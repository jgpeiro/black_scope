
test_g473_blink.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001d8  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00020fac  080001e0  080001e0  000101e0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00002e40  08021190  08021190  00031190  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08023fd0  08023fd0  00040358  2**0
                  CONTENTS
  4 .ARM          00000000  08023fd0  08023fd0  00040358  2**0
                  CONTENTS
  5 .preinit_array 00000000  08023fd0  08023fd0  00040358  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08023fd0  08023fd0  00033fd0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08023fd4  08023fd4  00033fd4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000358  20000000  08023fd8  00040000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00016720  20000358  08024330  00040358  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20016a78  08024330  00046a78  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00040358  2**0
                  CONTENTS, READONLY
 12 .comment      00000043  00000000  00000000  00040388  2**0
                  CONTENTS, READONLY
 13 .debug_info   000651c0  00000000  00000000  000403cb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 000096e5  00000000  00000000  000a558b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00002d38  00000000  00000000  000aec70  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 0000239b  00000000  00000000  000b19a8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00028bd3  00000000  00000000  000b3d43  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0003b4bc  00000000  00000000  000dc916  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    000ff80c  00000000  00000000  00117dd2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_frame  0000d084  00000000  00000000  002175e0  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 0000005a  00000000  00000000  00224664  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001e0 <__do_global_dtors_aux>:
 80001e0:	b510      	push	{r4, lr}
 80001e2:	4c05      	ldr	r4, [pc, #20]	; (80001f8 <__do_global_dtors_aux+0x18>)
 80001e4:	7823      	ldrb	r3, [r4, #0]
 80001e6:	b933      	cbnz	r3, 80001f6 <__do_global_dtors_aux+0x16>
 80001e8:	4b04      	ldr	r3, [pc, #16]	; (80001fc <__do_global_dtors_aux+0x1c>)
 80001ea:	b113      	cbz	r3, 80001f2 <__do_global_dtors_aux+0x12>
 80001ec:	4804      	ldr	r0, [pc, #16]	; (8000200 <__do_global_dtors_aux+0x20>)
 80001ee:	f3af 8000 	nop.w
 80001f2:	2301      	movs	r3, #1
 80001f4:	7023      	strb	r3, [r4, #0]
 80001f6:	bd10      	pop	{r4, pc}
 80001f8:	20000358 	.word	0x20000358
 80001fc:	00000000 	.word	0x00000000
 8000200:	08021174 	.word	0x08021174

08000204 <frame_dummy>:
 8000204:	b508      	push	{r3, lr}
 8000206:	4b03      	ldr	r3, [pc, #12]	; (8000214 <frame_dummy+0x10>)
 8000208:	b11b      	cbz	r3, 8000212 <frame_dummy+0xe>
 800020a:	4903      	ldr	r1, [pc, #12]	; (8000218 <frame_dummy+0x14>)
 800020c:	4803      	ldr	r0, [pc, #12]	; (800021c <frame_dummy+0x18>)
 800020e:	f3af 8000 	nop.w
 8000212:	bd08      	pop	{r3, pc}
 8000214:	00000000 	.word	0x00000000
 8000218:	2000035c 	.word	0x2000035c
 800021c:	08021174 	.word	0x08021174

08000220 <memchr>:
 8000220:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000224:	2a10      	cmp	r2, #16
 8000226:	db2b      	blt.n	8000280 <memchr+0x60>
 8000228:	f010 0f07 	tst.w	r0, #7
 800022c:	d008      	beq.n	8000240 <memchr+0x20>
 800022e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000232:	3a01      	subs	r2, #1
 8000234:	428b      	cmp	r3, r1
 8000236:	d02d      	beq.n	8000294 <memchr+0x74>
 8000238:	f010 0f07 	tst.w	r0, #7
 800023c:	b342      	cbz	r2, 8000290 <memchr+0x70>
 800023e:	d1f6      	bne.n	800022e <memchr+0xe>
 8000240:	b4f0      	push	{r4, r5, r6, r7}
 8000242:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000246:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800024a:	f022 0407 	bic.w	r4, r2, #7
 800024e:	f07f 0700 	mvns.w	r7, #0
 8000252:	2300      	movs	r3, #0
 8000254:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000258:	3c08      	subs	r4, #8
 800025a:	ea85 0501 	eor.w	r5, r5, r1
 800025e:	ea86 0601 	eor.w	r6, r6, r1
 8000262:	fa85 f547 	uadd8	r5, r5, r7
 8000266:	faa3 f587 	sel	r5, r3, r7
 800026a:	fa86 f647 	uadd8	r6, r6, r7
 800026e:	faa5 f687 	sel	r6, r5, r7
 8000272:	b98e      	cbnz	r6, 8000298 <memchr+0x78>
 8000274:	d1ee      	bne.n	8000254 <memchr+0x34>
 8000276:	bcf0      	pop	{r4, r5, r6, r7}
 8000278:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800027c:	f002 0207 	and.w	r2, r2, #7
 8000280:	b132      	cbz	r2, 8000290 <memchr+0x70>
 8000282:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000286:	3a01      	subs	r2, #1
 8000288:	ea83 0301 	eor.w	r3, r3, r1
 800028c:	b113      	cbz	r3, 8000294 <memchr+0x74>
 800028e:	d1f8      	bne.n	8000282 <memchr+0x62>
 8000290:	2000      	movs	r0, #0
 8000292:	4770      	bx	lr
 8000294:	3801      	subs	r0, #1
 8000296:	4770      	bx	lr
 8000298:	2d00      	cmp	r5, #0
 800029a:	bf06      	itte	eq
 800029c:	4635      	moveq	r5, r6
 800029e:	3803      	subeq	r0, #3
 80002a0:	3807      	subne	r0, #7
 80002a2:	f015 0f01 	tst.w	r5, #1
 80002a6:	d107      	bne.n	80002b8 <memchr+0x98>
 80002a8:	3001      	adds	r0, #1
 80002aa:	f415 7f80 	tst.w	r5, #256	; 0x100
 80002ae:	bf02      	ittt	eq
 80002b0:	3001      	addeq	r0, #1
 80002b2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 80002b6:	3001      	addeq	r0, #1
 80002b8:	bcf0      	pop	{r4, r5, r6, r7}
 80002ba:	3801      	subs	r0, #1
 80002bc:	4770      	bx	lr
 80002be:	bf00      	nop

080002c0 <strlen>:
 80002c0:	4603      	mov	r3, r0
 80002c2:	f813 2b01 	ldrb.w	r2, [r3], #1
 80002c6:	2a00      	cmp	r2, #0
 80002c8:	d1fb      	bne.n	80002c2 <strlen+0x2>
 80002ca:	1a18      	subs	r0, r3, r0
 80002cc:	3801      	subs	r0, #1
 80002ce:	4770      	bx	lr

080002d0 <__aeabi_drsub>:
 80002d0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80002d4:	e002      	b.n	80002dc <__adddf3>
 80002d6:	bf00      	nop

080002d8 <__aeabi_dsub>:
 80002d8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080002dc <__adddf3>:
 80002dc:	b530      	push	{r4, r5, lr}
 80002de:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002e2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002e6:	ea94 0f05 	teq	r4, r5
 80002ea:	bf08      	it	eq
 80002ec:	ea90 0f02 	teqeq	r0, r2
 80002f0:	bf1f      	itttt	ne
 80002f2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002f6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002fa:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002fe:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000302:	f000 80e2 	beq.w	80004ca <__adddf3+0x1ee>
 8000306:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800030a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800030e:	bfb8      	it	lt
 8000310:	426d      	neglt	r5, r5
 8000312:	dd0c      	ble.n	800032e <__adddf3+0x52>
 8000314:	442c      	add	r4, r5
 8000316:	ea80 0202 	eor.w	r2, r0, r2
 800031a:	ea81 0303 	eor.w	r3, r1, r3
 800031e:	ea82 0000 	eor.w	r0, r2, r0
 8000322:	ea83 0101 	eor.w	r1, r3, r1
 8000326:	ea80 0202 	eor.w	r2, r0, r2
 800032a:	ea81 0303 	eor.w	r3, r1, r3
 800032e:	2d36      	cmp	r5, #54	; 0x36
 8000330:	bf88      	it	hi
 8000332:	bd30      	pophi	{r4, r5, pc}
 8000334:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000338:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800033c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000340:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000344:	d002      	beq.n	800034c <__adddf3+0x70>
 8000346:	4240      	negs	r0, r0
 8000348:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800034c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000350:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000354:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000358:	d002      	beq.n	8000360 <__adddf3+0x84>
 800035a:	4252      	negs	r2, r2
 800035c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000360:	ea94 0f05 	teq	r4, r5
 8000364:	f000 80a7 	beq.w	80004b6 <__adddf3+0x1da>
 8000368:	f1a4 0401 	sub.w	r4, r4, #1
 800036c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000370:	db0d      	blt.n	800038e <__adddf3+0xb2>
 8000372:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000376:	fa22 f205 	lsr.w	r2, r2, r5
 800037a:	1880      	adds	r0, r0, r2
 800037c:	f141 0100 	adc.w	r1, r1, #0
 8000380:	fa03 f20e 	lsl.w	r2, r3, lr
 8000384:	1880      	adds	r0, r0, r2
 8000386:	fa43 f305 	asr.w	r3, r3, r5
 800038a:	4159      	adcs	r1, r3
 800038c:	e00e      	b.n	80003ac <__adddf3+0xd0>
 800038e:	f1a5 0520 	sub.w	r5, r5, #32
 8000392:	f10e 0e20 	add.w	lr, lr, #32
 8000396:	2a01      	cmp	r2, #1
 8000398:	fa03 fc0e 	lsl.w	ip, r3, lr
 800039c:	bf28      	it	cs
 800039e:	f04c 0c02 	orrcs.w	ip, ip, #2
 80003a2:	fa43 f305 	asr.w	r3, r3, r5
 80003a6:	18c0      	adds	r0, r0, r3
 80003a8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80003ac:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80003b0:	d507      	bpl.n	80003c2 <__adddf3+0xe6>
 80003b2:	f04f 0e00 	mov.w	lr, #0
 80003b6:	f1dc 0c00 	rsbs	ip, ip, #0
 80003ba:	eb7e 0000 	sbcs.w	r0, lr, r0
 80003be:	eb6e 0101 	sbc.w	r1, lr, r1
 80003c2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80003c6:	d31b      	bcc.n	8000400 <__adddf3+0x124>
 80003c8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80003cc:	d30c      	bcc.n	80003e8 <__adddf3+0x10c>
 80003ce:	0849      	lsrs	r1, r1, #1
 80003d0:	ea5f 0030 	movs.w	r0, r0, rrx
 80003d4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003d8:	f104 0401 	add.w	r4, r4, #1
 80003dc:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003e0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80003e4:	f080 809a 	bcs.w	800051c <__adddf3+0x240>
 80003e8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80003ec:	bf08      	it	eq
 80003ee:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003f2:	f150 0000 	adcs.w	r0, r0, #0
 80003f6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003fa:	ea41 0105 	orr.w	r1, r1, r5
 80003fe:	bd30      	pop	{r4, r5, pc}
 8000400:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000404:	4140      	adcs	r0, r0
 8000406:	eb41 0101 	adc.w	r1, r1, r1
 800040a:	3c01      	subs	r4, #1
 800040c:	bf28      	it	cs
 800040e:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 8000412:	d2e9      	bcs.n	80003e8 <__adddf3+0x10c>
 8000414:	f091 0f00 	teq	r1, #0
 8000418:	bf04      	itt	eq
 800041a:	4601      	moveq	r1, r0
 800041c:	2000      	moveq	r0, #0
 800041e:	fab1 f381 	clz	r3, r1
 8000422:	bf08      	it	eq
 8000424:	3320      	addeq	r3, #32
 8000426:	f1a3 030b 	sub.w	r3, r3, #11
 800042a:	f1b3 0220 	subs.w	r2, r3, #32
 800042e:	da0c      	bge.n	800044a <__adddf3+0x16e>
 8000430:	320c      	adds	r2, #12
 8000432:	dd08      	ble.n	8000446 <__adddf3+0x16a>
 8000434:	f102 0c14 	add.w	ip, r2, #20
 8000438:	f1c2 020c 	rsb	r2, r2, #12
 800043c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000440:	fa21 f102 	lsr.w	r1, r1, r2
 8000444:	e00c      	b.n	8000460 <__adddf3+0x184>
 8000446:	f102 0214 	add.w	r2, r2, #20
 800044a:	bfd8      	it	le
 800044c:	f1c2 0c20 	rsble	ip, r2, #32
 8000450:	fa01 f102 	lsl.w	r1, r1, r2
 8000454:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000458:	bfdc      	itt	le
 800045a:	ea41 010c 	orrle.w	r1, r1, ip
 800045e:	4090      	lslle	r0, r2
 8000460:	1ae4      	subs	r4, r4, r3
 8000462:	bfa2      	ittt	ge
 8000464:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000468:	4329      	orrge	r1, r5
 800046a:	bd30      	popge	{r4, r5, pc}
 800046c:	ea6f 0404 	mvn.w	r4, r4
 8000470:	3c1f      	subs	r4, #31
 8000472:	da1c      	bge.n	80004ae <__adddf3+0x1d2>
 8000474:	340c      	adds	r4, #12
 8000476:	dc0e      	bgt.n	8000496 <__adddf3+0x1ba>
 8000478:	f104 0414 	add.w	r4, r4, #20
 800047c:	f1c4 0220 	rsb	r2, r4, #32
 8000480:	fa20 f004 	lsr.w	r0, r0, r4
 8000484:	fa01 f302 	lsl.w	r3, r1, r2
 8000488:	ea40 0003 	orr.w	r0, r0, r3
 800048c:	fa21 f304 	lsr.w	r3, r1, r4
 8000490:	ea45 0103 	orr.w	r1, r5, r3
 8000494:	bd30      	pop	{r4, r5, pc}
 8000496:	f1c4 040c 	rsb	r4, r4, #12
 800049a:	f1c4 0220 	rsb	r2, r4, #32
 800049e:	fa20 f002 	lsr.w	r0, r0, r2
 80004a2:	fa01 f304 	lsl.w	r3, r1, r4
 80004a6:	ea40 0003 	orr.w	r0, r0, r3
 80004aa:	4629      	mov	r1, r5
 80004ac:	bd30      	pop	{r4, r5, pc}
 80004ae:	fa21 f004 	lsr.w	r0, r1, r4
 80004b2:	4629      	mov	r1, r5
 80004b4:	bd30      	pop	{r4, r5, pc}
 80004b6:	f094 0f00 	teq	r4, #0
 80004ba:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80004be:	bf06      	itte	eq
 80004c0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80004c4:	3401      	addeq	r4, #1
 80004c6:	3d01      	subne	r5, #1
 80004c8:	e74e      	b.n	8000368 <__adddf3+0x8c>
 80004ca:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004ce:	bf18      	it	ne
 80004d0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004d4:	d029      	beq.n	800052a <__adddf3+0x24e>
 80004d6:	ea94 0f05 	teq	r4, r5
 80004da:	bf08      	it	eq
 80004dc:	ea90 0f02 	teqeq	r0, r2
 80004e0:	d005      	beq.n	80004ee <__adddf3+0x212>
 80004e2:	ea54 0c00 	orrs.w	ip, r4, r0
 80004e6:	bf04      	itt	eq
 80004e8:	4619      	moveq	r1, r3
 80004ea:	4610      	moveq	r0, r2
 80004ec:	bd30      	pop	{r4, r5, pc}
 80004ee:	ea91 0f03 	teq	r1, r3
 80004f2:	bf1e      	ittt	ne
 80004f4:	2100      	movne	r1, #0
 80004f6:	2000      	movne	r0, #0
 80004f8:	bd30      	popne	{r4, r5, pc}
 80004fa:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004fe:	d105      	bne.n	800050c <__adddf3+0x230>
 8000500:	0040      	lsls	r0, r0, #1
 8000502:	4149      	adcs	r1, r1
 8000504:	bf28      	it	cs
 8000506:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800050a:	bd30      	pop	{r4, r5, pc}
 800050c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000510:	bf3c      	itt	cc
 8000512:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8000516:	bd30      	popcc	{r4, r5, pc}
 8000518:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800051c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000520:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000524:	f04f 0000 	mov.w	r0, #0
 8000528:	bd30      	pop	{r4, r5, pc}
 800052a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800052e:	bf1a      	itte	ne
 8000530:	4619      	movne	r1, r3
 8000532:	4610      	movne	r0, r2
 8000534:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000538:	bf1c      	itt	ne
 800053a:	460b      	movne	r3, r1
 800053c:	4602      	movne	r2, r0
 800053e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000542:	bf06      	itte	eq
 8000544:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000548:	ea91 0f03 	teqeq	r1, r3
 800054c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000550:	bd30      	pop	{r4, r5, pc}
 8000552:	bf00      	nop

08000554 <__aeabi_ui2d>:
 8000554:	f090 0f00 	teq	r0, #0
 8000558:	bf04      	itt	eq
 800055a:	2100      	moveq	r1, #0
 800055c:	4770      	bxeq	lr
 800055e:	b530      	push	{r4, r5, lr}
 8000560:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000564:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000568:	f04f 0500 	mov.w	r5, #0
 800056c:	f04f 0100 	mov.w	r1, #0
 8000570:	e750      	b.n	8000414 <__adddf3+0x138>
 8000572:	bf00      	nop

08000574 <__aeabi_i2d>:
 8000574:	f090 0f00 	teq	r0, #0
 8000578:	bf04      	itt	eq
 800057a:	2100      	moveq	r1, #0
 800057c:	4770      	bxeq	lr
 800057e:	b530      	push	{r4, r5, lr}
 8000580:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000584:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000588:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800058c:	bf48      	it	mi
 800058e:	4240      	negmi	r0, r0
 8000590:	f04f 0100 	mov.w	r1, #0
 8000594:	e73e      	b.n	8000414 <__adddf3+0x138>
 8000596:	bf00      	nop

08000598 <__aeabi_f2d>:
 8000598:	0042      	lsls	r2, r0, #1
 800059a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800059e:	ea4f 0131 	mov.w	r1, r1, rrx
 80005a2:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80005a6:	bf1f      	itttt	ne
 80005a8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80005ac:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005b0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80005b4:	4770      	bxne	lr
 80005b6:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 80005ba:	bf08      	it	eq
 80005bc:	4770      	bxeq	lr
 80005be:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 80005c2:	bf04      	itt	eq
 80005c4:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 80005c8:	4770      	bxeq	lr
 80005ca:	b530      	push	{r4, r5, lr}
 80005cc:	f44f 7460 	mov.w	r4, #896	; 0x380
 80005d0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80005d4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005d8:	e71c      	b.n	8000414 <__adddf3+0x138>
 80005da:	bf00      	nop

080005dc <__aeabi_ul2d>:
 80005dc:	ea50 0201 	orrs.w	r2, r0, r1
 80005e0:	bf08      	it	eq
 80005e2:	4770      	bxeq	lr
 80005e4:	b530      	push	{r4, r5, lr}
 80005e6:	f04f 0500 	mov.w	r5, #0
 80005ea:	e00a      	b.n	8000602 <__aeabi_l2d+0x16>

080005ec <__aeabi_l2d>:
 80005ec:	ea50 0201 	orrs.w	r2, r0, r1
 80005f0:	bf08      	it	eq
 80005f2:	4770      	bxeq	lr
 80005f4:	b530      	push	{r4, r5, lr}
 80005f6:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80005fa:	d502      	bpl.n	8000602 <__aeabi_l2d+0x16>
 80005fc:	4240      	negs	r0, r0
 80005fe:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000602:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000606:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800060a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800060e:	f43f aed8 	beq.w	80003c2 <__adddf3+0xe6>
 8000612:	f04f 0203 	mov.w	r2, #3
 8000616:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800061a:	bf18      	it	ne
 800061c:	3203      	addne	r2, #3
 800061e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000622:	bf18      	it	ne
 8000624:	3203      	addne	r2, #3
 8000626:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800062a:	f1c2 0320 	rsb	r3, r2, #32
 800062e:	fa00 fc03 	lsl.w	ip, r0, r3
 8000632:	fa20 f002 	lsr.w	r0, r0, r2
 8000636:	fa01 fe03 	lsl.w	lr, r1, r3
 800063a:	ea40 000e 	orr.w	r0, r0, lr
 800063e:	fa21 f102 	lsr.w	r1, r1, r2
 8000642:	4414      	add	r4, r2
 8000644:	e6bd      	b.n	80003c2 <__adddf3+0xe6>
 8000646:	bf00      	nop

08000648 <__aeabi_dmul>:
 8000648:	b570      	push	{r4, r5, r6, lr}
 800064a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800064e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000652:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000656:	bf1d      	ittte	ne
 8000658:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800065c:	ea94 0f0c 	teqne	r4, ip
 8000660:	ea95 0f0c 	teqne	r5, ip
 8000664:	f000 f8de 	bleq	8000824 <__aeabi_dmul+0x1dc>
 8000668:	442c      	add	r4, r5
 800066a:	ea81 0603 	eor.w	r6, r1, r3
 800066e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000672:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000676:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800067a:	bf18      	it	ne
 800067c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000680:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000684:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000688:	d038      	beq.n	80006fc <__aeabi_dmul+0xb4>
 800068a:	fba0 ce02 	umull	ip, lr, r0, r2
 800068e:	f04f 0500 	mov.w	r5, #0
 8000692:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000696:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800069a:	fbe0 e503 	umlal	lr, r5, r0, r3
 800069e:	f04f 0600 	mov.w	r6, #0
 80006a2:	fbe1 5603 	umlal	r5, r6, r1, r3
 80006a6:	f09c 0f00 	teq	ip, #0
 80006aa:	bf18      	it	ne
 80006ac:	f04e 0e01 	orrne.w	lr, lr, #1
 80006b0:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80006b4:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80006b8:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80006bc:	d204      	bcs.n	80006c8 <__aeabi_dmul+0x80>
 80006be:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80006c2:	416d      	adcs	r5, r5
 80006c4:	eb46 0606 	adc.w	r6, r6, r6
 80006c8:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80006cc:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80006d0:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80006d4:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80006d8:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80006dc:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80006e0:	bf88      	it	hi
 80006e2:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80006e6:	d81e      	bhi.n	8000726 <__aeabi_dmul+0xde>
 80006e8:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80006ec:	bf08      	it	eq
 80006ee:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80006f2:	f150 0000 	adcs.w	r0, r0, #0
 80006f6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80006fa:	bd70      	pop	{r4, r5, r6, pc}
 80006fc:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000700:	ea46 0101 	orr.w	r1, r6, r1
 8000704:	ea40 0002 	orr.w	r0, r0, r2
 8000708:	ea81 0103 	eor.w	r1, r1, r3
 800070c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000710:	bfc2      	ittt	gt
 8000712:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000716:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800071a:	bd70      	popgt	{r4, r5, r6, pc}
 800071c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000720:	f04f 0e00 	mov.w	lr, #0
 8000724:	3c01      	subs	r4, #1
 8000726:	f300 80ab 	bgt.w	8000880 <__aeabi_dmul+0x238>
 800072a:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800072e:	bfde      	ittt	le
 8000730:	2000      	movle	r0, #0
 8000732:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8000736:	bd70      	pople	{r4, r5, r6, pc}
 8000738:	f1c4 0400 	rsb	r4, r4, #0
 800073c:	3c20      	subs	r4, #32
 800073e:	da35      	bge.n	80007ac <__aeabi_dmul+0x164>
 8000740:	340c      	adds	r4, #12
 8000742:	dc1b      	bgt.n	800077c <__aeabi_dmul+0x134>
 8000744:	f104 0414 	add.w	r4, r4, #20
 8000748:	f1c4 0520 	rsb	r5, r4, #32
 800074c:	fa00 f305 	lsl.w	r3, r0, r5
 8000750:	fa20 f004 	lsr.w	r0, r0, r4
 8000754:	fa01 f205 	lsl.w	r2, r1, r5
 8000758:	ea40 0002 	orr.w	r0, r0, r2
 800075c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000760:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000764:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000768:	fa21 f604 	lsr.w	r6, r1, r4
 800076c:	eb42 0106 	adc.w	r1, r2, r6
 8000770:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000774:	bf08      	it	eq
 8000776:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800077a:	bd70      	pop	{r4, r5, r6, pc}
 800077c:	f1c4 040c 	rsb	r4, r4, #12
 8000780:	f1c4 0520 	rsb	r5, r4, #32
 8000784:	fa00 f304 	lsl.w	r3, r0, r4
 8000788:	fa20 f005 	lsr.w	r0, r0, r5
 800078c:	fa01 f204 	lsl.w	r2, r1, r4
 8000790:	ea40 0002 	orr.w	r0, r0, r2
 8000794:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000798:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800079c:	f141 0100 	adc.w	r1, r1, #0
 80007a0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007a4:	bf08      	it	eq
 80007a6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007aa:	bd70      	pop	{r4, r5, r6, pc}
 80007ac:	f1c4 0520 	rsb	r5, r4, #32
 80007b0:	fa00 f205 	lsl.w	r2, r0, r5
 80007b4:	ea4e 0e02 	orr.w	lr, lr, r2
 80007b8:	fa20 f304 	lsr.w	r3, r0, r4
 80007bc:	fa01 f205 	lsl.w	r2, r1, r5
 80007c0:	ea43 0302 	orr.w	r3, r3, r2
 80007c4:	fa21 f004 	lsr.w	r0, r1, r4
 80007c8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007cc:	fa21 f204 	lsr.w	r2, r1, r4
 80007d0:	ea20 0002 	bic.w	r0, r0, r2
 80007d4:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80007d8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007dc:	bf08      	it	eq
 80007de:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007e2:	bd70      	pop	{r4, r5, r6, pc}
 80007e4:	f094 0f00 	teq	r4, #0
 80007e8:	d10f      	bne.n	800080a <__aeabi_dmul+0x1c2>
 80007ea:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80007ee:	0040      	lsls	r0, r0, #1
 80007f0:	eb41 0101 	adc.w	r1, r1, r1
 80007f4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80007f8:	bf08      	it	eq
 80007fa:	3c01      	subeq	r4, #1
 80007fc:	d0f7      	beq.n	80007ee <__aeabi_dmul+0x1a6>
 80007fe:	ea41 0106 	orr.w	r1, r1, r6
 8000802:	f095 0f00 	teq	r5, #0
 8000806:	bf18      	it	ne
 8000808:	4770      	bxne	lr
 800080a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 800080e:	0052      	lsls	r2, r2, #1
 8000810:	eb43 0303 	adc.w	r3, r3, r3
 8000814:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8000818:	bf08      	it	eq
 800081a:	3d01      	subeq	r5, #1
 800081c:	d0f7      	beq.n	800080e <__aeabi_dmul+0x1c6>
 800081e:	ea43 0306 	orr.w	r3, r3, r6
 8000822:	4770      	bx	lr
 8000824:	ea94 0f0c 	teq	r4, ip
 8000828:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800082c:	bf18      	it	ne
 800082e:	ea95 0f0c 	teqne	r5, ip
 8000832:	d00c      	beq.n	800084e <__aeabi_dmul+0x206>
 8000834:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000838:	bf18      	it	ne
 800083a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800083e:	d1d1      	bne.n	80007e4 <__aeabi_dmul+0x19c>
 8000840:	ea81 0103 	eor.w	r1, r1, r3
 8000844:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000848:	f04f 0000 	mov.w	r0, #0
 800084c:	bd70      	pop	{r4, r5, r6, pc}
 800084e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000852:	bf06      	itte	eq
 8000854:	4610      	moveq	r0, r2
 8000856:	4619      	moveq	r1, r3
 8000858:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800085c:	d019      	beq.n	8000892 <__aeabi_dmul+0x24a>
 800085e:	ea94 0f0c 	teq	r4, ip
 8000862:	d102      	bne.n	800086a <__aeabi_dmul+0x222>
 8000864:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000868:	d113      	bne.n	8000892 <__aeabi_dmul+0x24a>
 800086a:	ea95 0f0c 	teq	r5, ip
 800086e:	d105      	bne.n	800087c <__aeabi_dmul+0x234>
 8000870:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000874:	bf1c      	itt	ne
 8000876:	4610      	movne	r0, r2
 8000878:	4619      	movne	r1, r3
 800087a:	d10a      	bne.n	8000892 <__aeabi_dmul+0x24a>
 800087c:	ea81 0103 	eor.w	r1, r1, r3
 8000880:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000884:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000888:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800088c:	f04f 0000 	mov.w	r0, #0
 8000890:	bd70      	pop	{r4, r5, r6, pc}
 8000892:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000896:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800089a:	bd70      	pop	{r4, r5, r6, pc}

0800089c <__aeabi_ddiv>:
 800089c:	b570      	push	{r4, r5, r6, lr}
 800089e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80008a2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80008a6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80008aa:	bf1d      	ittte	ne
 80008ac:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80008b0:	ea94 0f0c 	teqne	r4, ip
 80008b4:	ea95 0f0c 	teqne	r5, ip
 80008b8:	f000 f8a7 	bleq	8000a0a <__aeabi_ddiv+0x16e>
 80008bc:	eba4 0405 	sub.w	r4, r4, r5
 80008c0:	ea81 0e03 	eor.w	lr, r1, r3
 80008c4:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80008c8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80008cc:	f000 8088 	beq.w	80009e0 <__aeabi_ddiv+0x144>
 80008d0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80008d4:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80008d8:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80008dc:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80008e0:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80008e4:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80008e8:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80008ec:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80008f0:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80008f4:	429d      	cmp	r5, r3
 80008f6:	bf08      	it	eq
 80008f8:	4296      	cmpeq	r6, r2
 80008fa:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80008fe:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8000902:	d202      	bcs.n	800090a <__aeabi_ddiv+0x6e>
 8000904:	085b      	lsrs	r3, r3, #1
 8000906:	ea4f 0232 	mov.w	r2, r2, rrx
 800090a:	1ab6      	subs	r6, r6, r2
 800090c:	eb65 0503 	sbc.w	r5, r5, r3
 8000910:	085b      	lsrs	r3, r3, #1
 8000912:	ea4f 0232 	mov.w	r2, r2, rrx
 8000916:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800091a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800091e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000922:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000926:	bf22      	ittt	cs
 8000928:	1ab6      	subcs	r6, r6, r2
 800092a:	4675      	movcs	r5, lr
 800092c:	ea40 000c 	orrcs.w	r0, r0, ip
 8000930:	085b      	lsrs	r3, r3, #1
 8000932:	ea4f 0232 	mov.w	r2, r2, rrx
 8000936:	ebb6 0e02 	subs.w	lr, r6, r2
 800093a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800093e:	bf22      	ittt	cs
 8000940:	1ab6      	subcs	r6, r6, r2
 8000942:	4675      	movcs	r5, lr
 8000944:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000948:	085b      	lsrs	r3, r3, #1
 800094a:	ea4f 0232 	mov.w	r2, r2, rrx
 800094e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000952:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000956:	bf22      	ittt	cs
 8000958:	1ab6      	subcs	r6, r6, r2
 800095a:	4675      	movcs	r5, lr
 800095c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000960:	085b      	lsrs	r3, r3, #1
 8000962:	ea4f 0232 	mov.w	r2, r2, rrx
 8000966:	ebb6 0e02 	subs.w	lr, r6, r2
 800096a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800096e:	bf22      	ittt	cs
 8000970:	1ab6      	subcs	r6, r6, r2
 8000972:	4675      	movcs	r5, lr
 8000974:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000978:	ea55 0e06 	orrs.w	lr, r5, r6
 800097c:	d018      	beq.n	80009b0 <__aeabi_ddiv+0x114>
 800097e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000982:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000986:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800098a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800098e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000992:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000996:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800099a:	d1c0      	bne.n	800091e <__aeabi_ddiv+0x82>
 800099c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80009a0:	d10b      	bne.n	80009ba <__aeabi_ddiv+0x11e>
 80009a2:	ea41 0100 	orr.w	r1, r1, r0
 80009a6:	f04f 0000 	mov.w	r0, #0
 80009aa:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80009ae:	e7b6      	b.n	800091e <__aeabi_ddiv+0x82>
 80009b0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80009b4:	bf04      	itt	eq
 80009b6:	4301      	orreq	r1, r0
 80009b8:	2000      	moveq	r0, #0
 80009ba:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80009be:	bf88      	it	hi
 80009c0:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80009c4:	f63f aeaf 	bhi.w	8000726 <__aeabi_dmul+0xde>
 80009c8:	ebb5 0c03 	subs.w	ip, r5, r3
 80009cc:	bf04      	itt	eq
 80009ce:	ebb6 0c02 	subseq.w	ip, r6, r2
 80009d2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80009d6:	f150 0000 	adcs.w	r0, r0, #0
 80009da:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80009de:	bd70      	pop	{r4, r5, r6, pc}
 80009e0:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80009e4:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80009e8:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80009ec:	bfc2      	ittt	gt
 80009ee:	ebd4 050c 	rsbsgt	r5, r4, ip
 80009f2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80009f6:	bd70      	popgt	{r4, r5, r6, pc}
 80009f8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80009fc:	f04f 0e00 	mov.w	lr, #0
 8000a00:	3c01      	subs	r4, #1
 8000a02:	e690      	b.n	8000726 <__aeabi_dmul+0xde>
 8000a04:	ea45 0e06 	orr.w	lr, r5, r6
 8000a08:	e68d      	b.n	8000726 <__aeabi_dmul+0xde>
 8000a0a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000a0e:	ea94 0f0c 	teq	r4, ip
 8000a12:	bf08      	it	eq
 8000a14:	ea95 0f0c 	teqeq	r5, ip
 8000a18:	f43f af3b 	beq.w	8000892 <__aeabi_dmul+0x24a>
 8000a1c:	ea94 0f0c 	teq	r4, ip
 8000a20:	d10a      	bne.n	8000a38 <__aeabi_ddiv+0x19c>
 8000a22:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000a26:	f47f af34 	bne.w	8000892 <__aeabi_dmul+0x24a>
 8000a2a:	ea95 0f0c 	teq	r5, ip
 8000a2e:	f47f af25 	bne.w	800087c <__aeabi_dmul+0x234>
 8000a32:	4610      	mov	r0, r2
 8000a34:	4619      	mov	r1, r3
 8000a36:	e72c      	b.n	8000892 <__aeabi_dmul+0x24a>
 8000a38:	ea95 0f0c 	teq	r5, ip
 8000a3c:	d106      	bne.n	8000a4c <__aeabi_ddiv+0x1b0>
 8000a3e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a42:	f43f aefd 	beq.w	8000840 <__aeabi_dmul+0x1f8>
 8000a46:	4610      	mov	r0, r2
 8000a48:	4619      	mov	r1, r3
 8000a4a:	e722      	b.n	8000892 <__aeabi_dmul+0x24a>
 8000a4c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a50:	bf18      	it	ne
 8000a52:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a56:	f47f aec5 	bne.w	80007e4 <__aeabi_dmul+0x19c>
 8000a5a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a5e:	f47f af0d 	bne.w	800087c <__aeabi_dmul+0x234>
 8000a62:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a66:	f47f aeeb 	bne.w	8000840 <__aeabi_dmul+0x1f8>
 8000a6a:	e712      	b.n	8000892 <__aeabi_dmul+0x24a>

08000a6c <__gedf2>:
 8000a6c:	f04f 3cff 	mov.w	ip, #4294967295
 8000a70:	e006      	b.n	8000a80 <__cmpdf2+0x4>
 8000a72:	bf00      	nop

08000a74 <__ledf2>:
 8000a74:	f04f 0c01 	mov.w	ip, #1
 8000a78:	e002      	b.n	8000a80 <__cmpdf2+0x4>
 8000a7a:	bf00      	nop

08000a7c <__cmpdf2>:
 8000a7c:	f04f 0c01 	mov.w	ip, #1
 8000a80:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000a84:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000a88:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000a8c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000a90:	bf18      	it	ne
 8000a92:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000a96:	d01b      	beq.n	8000ad0 <__cmpdf2+0x54>
 8000a98:	b001      	add	sp, #4
 8000a9a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000a9e:	bf0c      	ite	eq
 8000aa0:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000aa4:	ea91 0f03 	teqne	r1, r3
 8000aa8:	bf02      	ittt	eq
 8000aaa:	ea90 0f02 	teqeq	r0, r2
 8000aae:	2000      	moveq	r0, #0
 8000ab0:	4770      	bxeq	lr
 8000ab2:	f110 0f00 	cmn.w	r0, #0
 8000ab6:	ea91 0f03 	teq	r1, r3
 8000aba:	bf58      	it	pl
 8000abc:	4299      	cmppl	r1, r3
 8000abe:	bf08      	it	eq
 8000ac0:	4290      	cmpeq	r0, r2
 8000ac2:	bf2c      	ite	cs
 8000ac4:	17d8      	asrcs	r0, r3, #31
 8000ac6:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000aca:	f040 0001 	orr.w	r0, r0, #1
 8000ace:	4770      	bx	lr
 8000ad0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000ad4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000ad8:	d102      	bne.n	8000ae0 <__cmpdf2+0x64>
 8000ada:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000ade:	d107      	bne.n	8000af0 <__cmpdf2+0x74>
 8000ae0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000ae4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000ae8:	d1d6      	bne.n	8000a98 <__cmpdf2+0x1c>
 8000aea:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000aee:	d0d3      	beq.n	8000a98 <__cmpdf2+0x1c>
 8000af0:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000af4:	4770      	bx	lr
 8000af6:	bf00      	nop

08000af8 <__aeabi_cdrcmple>:
 8000af8:	4684      	mov	ip, r0
 8000afa:	4610      	mov	r0, r2
 8000afc:	4662      	mov	r2, ip
 8000afe:	468c      	mov	ip, r1
 8000b00:	4619      	mov	r1, r3
 8000b02:	4663      	mov	r3, ip
 8000b04:	e000      	b.n	8000b08 <__aeabi_cdcmpeq>
 8000b06:	bf00      	nop

08000b08 <__aeabi_cdcmpeq>:
 8000b08:	b501      	push	{r0, lr}
 8000b0a:	f7ff ffb7 	bl	8000a7c <__cmpdf2>
 8000b0e:	2800      	cmp	r0, #0
 8000b10:	bf48      	it	mi
 8000b12:	f110 0f00 	cmnmi.w	r0, #0
 8000b16:	bd01      	pop	{r0, pc}

08000b18 <__aeabi_dcmpeq>:
 8000b18:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b1c:	f7ff fff4 	bl	8000b08 <__aeabi_cdcmpeq>
 8000b20:	bf0c      	ite	eq
 8000b22:	2001      	moveq	r0, #1
 8000b24:	2000      	movne	r0, #0
 8000b26:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b2a:	bf00      	nop

08000b2c <__aeabi_dcmplt>:
 8000b2c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b30:	f7ff ffea 	bl	8000b08 <__aeabi_cdcmpeq>
 8000b34:	bf34      	ite	cc
 8000b36:	2001      	movcc	r0, #1
 8000b38:	2000      	movcs	r0, #0
 8000b3a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b3e:	bf00      	nop

08000b40 <__aeabi_dcmple>:
 8000b40:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b44:	f7ff ffe0 	bl	8000b08 <__aeabi_cdcmpeq>
 8000b48:	bf94      	ite	ls
 8000b4a:	2001      	movls	r0, #1
 8000b4c:	2000      	movhi	r0, #0
 8000b4e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b52:	bf00      	nop

08000b54 <__aeabi_dcmpge>:
 8000b54:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b58:	f7ff ffce 	bl	8000af8 <__aeabi_cdrcmple>
 8000b5c:	bf94      	ite	ls
 8000b5e:	2001      	movls	r0, #1
 8000b60:	2000      	movhi	r0, #0
 8000b62:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b66:	bf00      	nop

08000b68 <__aeabi_dcmpgt>:
 8000b68:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b6c:	f7ff ffc4 	bl	8000af8 <__aeabi_cdrcmple>
 8000b70:	bf34      	ite	cc
 8000b72:	2001      	movcc	r0, #1
 8000b74:	2000      	movcs	r0, #0
 8000b76:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b7a:	bf00      	nop

08000b7c <__aeabi_dcmpun>:
 8000b7c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000b80:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b84:	d102      	bne.n	8000b8c <__aeabi_dcmpun+0x10>
 8000b86:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000b8a:	d10a      	bne.n	8000ba2 <__aeabi_dcmpun+0x26>
 8000b8c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000b90:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b94:	d102      	bne.n	8000b9c <__aeabi_dcmpun+0x20>
 8000b96:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000b9a:	d102      	bne.n	8000ba2 <__aeabi_dcmpun+0x26>
 8000b9c:	f04f 0000 	mov.w	r0, #0
 8000ba0:	4770      	bx	lr
 8000ba2:	f04f 0001 	mov.w	r0, #1
 8000ba6:	4770      	bx	lr

08000ba8 <__aeabi_d2iz>:
 8000ba8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000bac:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000bb0:	d215      	bcs.n	8000bde <__aeabi_d2iz+0x36>
 8000bb2:	d511      	bpl.n	8000bd8 <__aeabi_d2iz+0x30>
 8000bb4:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000bb8:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000bbc:	d912      	bls.n	8000be4 <__aeabi_d2iz+0x3c>
 8000bbe:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000bc2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000bc6:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000bca:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000bce:	fa23 f002 	lsr.w	r0, r3, r2
 8000bd2:	bf18      	it	ne
 8000bd4:	4240      	negne	r0, r0
 8000bd6:	4770      	bx	lr
 8000bd8:	f04f 0000 	mov.w	r0, #0
 8000bdc:	4770      	bx	lr
 8000bde:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000be2:	d105      	bne.n	8000bf0 <__aeabi_d2iz+0x48>
 8000be4:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8000be8:	bf08      	it	eq
 8000bea:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000bee:	4770      	bx	lr
 8000bf0:	f04f 0000 	mov.w	r0, #0
 8000bf4:	4770      	bx	lr
 8000bf6:	bf00      	nop

08000bf8 <__aeabi_d2uiz>:
 8000bf8:	004a      	lsls	r2, r1, #1
 8000bfa:	d211      	bcs.n	8000c20 <__aeabi_d2uiz+0x28>
 8000bfc:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000c00:	d211      	bcs.n	8000c26 <__aeabi_d2uiz+0x2e>
 8000c02:	d50d      	bpl.n	8000c20 <__aeabi_d2uiz+0x28>
 8000c04:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000c08:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000c0c:	d40e      	bmi.n	8000c2c <__aeabi_d2uiz+0x34>
 8000c0e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000c12:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000c16:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000c1a:	fa23 f002 	lsr.w	r0, r3, r2
 8000c1e:	4770      	bx	lr
 8000c20:	f04f 0000 	mov.w	r0, #0
 8000c24:	4770      	bx	lr
 8000c26:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000c2a:	d102      	bne.n	8000c32 <__aeabi_d2uiz+0x3a>
 8000c2c:	f04f 30ff 	mov.w	r0, #4294967295
 8000c30:	4770      	bx	lr
 8000c32:	f04f 0000 	mov.w	r0, #0
 8000c36:	4770      	bx	lr

08000c38 <__aeabi_d2f>:
 8000c38:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000c3c:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000c40:	bf24      	itt	cs
 8000c42:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000c46:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000c4a:	d90d      	bls.n	8000c68 <__aeabi_d2f+0x30>
 8000c4c:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000c50:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000c54:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000c58:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000c5c:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000c60:	bf08      	it	eq
 8000c62:	f020 0001 	biceq.w	r0, r0, #1
 8000c66:	4770      	bx	lr
 8000c68:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000c6c:	d121      	bne.n	8000cb2 <__aeabi_d2f+0x7a>
 8000c6e:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000c72:	bfbc      	itt	lt
 8000c74:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000c78:	4770      	bxlt	lr
 8000c7a:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000c7e:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000c82:	f1c2 0218 	rsb	r2, r2, #24
 8000c86:	f1c2 0c20 	rsb	ip, r2, #32
 8000c8a:	fa10 f30c 	lsls.w	r3, r0, ip
 8000c8e:	fa20 f002 	lsr.w	r0, r0, r2
 8000c92:	bf18      	it	ne
 8000c94:	f040 0001 	orrne.w	r0, r0, #1
 8000c98:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000c9c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000ca0:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000ca4:	ea40 000c 	orr.w	r0, r0, ip
 8000ca8:	fa23 f302 	lsr.w	r3, r3, r2
 8000cac:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000cb0:	e7cc      	b.n	8000c4c <__aeabi_d2f+0x14>
 8000cb2:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000cb6:	d107      	bne.n	8000cc8 <__aeabi_d2f+0x90>
 8000cb8:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000cbc:	bf1e      	ittt	ne
 8000cbe:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000cc2:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000cc6:	4770      	bxne	lr
 8000cc8:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000ccc:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000cd0:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000cd4:	4770      	bx	lr
 8000cd6:	bf00      	nop

08000cd8 <MX_ADC1_Init>:
DMA_HandleTypeDef hdma_adc4;
DMA_HandleTypeDef hdma_adc5;

/* ADC1 init function */
void MX_ADC1_Init(void)
{
 8000cd8:	b580      	push	{r7, lr}
 8000cda:	b092      	sub	sp, #72	; 0x48
 8000cdc:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_MultiModeTypeDef multimode = {0};
 8000cde:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 8000ce2:	2200      	movs	r2, #0
 8000ce4:	601a      	str	r2, [r3, #0]
 8000ce6:	605a      	str	r2, [r3, #4]
 8000ce8:	609a      	str	r2, [r3, #8]
  ADC_AnalogWDGConfTypeDef AnalogWDGConfig = {0};
 8000cea:	f107 0320 	add.w	r3, r7, #32
 8000cee:	2200      	movs	r2, #0
 8000cf0:	601a      	str	r2, [r3, #0]
 8000cf2:	605a      	str	r2, [r3, #4]
 8000cf4:	609a      	str	r2, [r3, #8]
 8000cf6:	60da      	str	r2, [r3, #12]
 8000cf8:	611a      	str	r2, [r3, #16]
 8000cfa:	615a      	str	r2, [r3, #20]
 8000cfc:	619a      	str	r2, [r3, #24]
  ADC_ChannelConfTypeDef sConfig = {0};
 8000cfe:	463b      	mov	r3, r7
 8000d00:	2220      	movs	r2, #32
 8000d02:	2100      	movs	r1, #0
 8000d04:	4618      	mov	r0, r3
 8000d06:	f01d fc30 	bl	801e56a <memset>

  /* USER CODE END ADC1_Init 1 */

  /** Common config
  */
  hadc1.Instance = ADC1;
 8000d0a:	4b4c      	ldr	r3, [pc, #304]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000d0c:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 8000d10:	601a      	str	r2, [r3, #0]
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 8000d12:	4b4a      	ldr	r3, [pc, #296]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000d14:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 8000d18:	605a      	str	r2, [r3, #4]
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 8000d1a:	4b48      	ldr	r3, [pc, #288]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000d1c:	2200      	movs	r2, #0
 8000d1e:	609a      	str	r2, [r3, #8]
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8000d20:	4b46      	ldr	r3, [pc, #280]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000d22:	2200      	movs	r2, #0
 8000d24:	60da      	str	r2, [r3, #12]
  hadc1.Init.GainCompensation = 0;
 8000d26:	4b45      	ldr	r3, [pc, #276]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000d28:	2200      	movs	r2, #0
 8000d2a:	611a      	str	r2, [r3, #16]
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
 8000d2c:	4b43      	ldr	r3, [pc, #268]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000d2e:	2200      	movs	r2, #0
 8000d30:	615a      	str	r2, [r3, #20]
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000d32:	4b42      	ldr	r3, [pc, #264]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000d34:	2204      	movs	r2, #4
 8000d36:	619a      	str	r2, [r3, #24]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 8000d38:	4b40      	ldr	r3, [pc, #256]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000d3a:	2200      	movs	r2, #0
 8000d3c:	771a      	strb	r2, [r3, #28]
  hadc1.Init.ContinuousConvMode = DISABLE;
 8000d3e:	4b3f      	ldr	r3, [pc, #252]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000d40:	2200      	movs	r2, #0
 8000d42:	775a      	strb	r2, [r3, #29]
  hadc1.Init.NbrOfConversion = 1;
 8000d44:	4b3d      	ldr	r3, [pc, #244]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000d46:	2201      	movs	r2, #1
 8000d48:	621a      	str	r2, [r3, #32]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8000d4a:	4b3c      	ldr	r3, [pc, #240]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000d4c:	2200      	movs	r2, #0
 8000d4e:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  hadc1.Init.ExternalTrigConv = ADC_EXTERNALTRIG_T1_TRGO;
 8000d52:	4b3a      	ldr	r3, [pc, #232]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000d54:	f44f 62a4 	mov.w	r2, #1312	; 0x520
 8000d58:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_RISING;
 8000d5a:	4b38      	ldr	r3, [pc, #224]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000d5c:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8000d60:	631a      	str	r2, [r3, #48]	; 0x30
  hadc1.Init.DMAContinuousRequests = ENABLE;
 8000d62:	4b36      	ldr	r3, [pc, #216]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000d64:	2201      	movs	r2, #1
 8000d66:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8000d6a:	4b34      	ldr	r3, [pc, #208]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000d6c:	2200      	movs	r2, #0
 8000d6e:	63da      	str	r2, [r3, #60]	; 0x3c
  hadc1.Init.OversamplingMode = DISABLE;
 8000d70:	4b32      	ldr	r3, [pc, #200]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000d72:	2200      	movs	r2, #0
 8000d74:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8000d78:	4830      	ldr	r0, [pc, #192]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000d7a:	f005 fba7 	bl	80064cc <HAL_ADC_Init>
 8000d7e:	4603      	mov	r3, r0
 8000d80:	2b00      	cmp	r3, #0
 8000d82:	d001      	beq.n	8000d88 <MX_ADC1_Init+0xb0>
  {
    Error_Handler();
 8000d84:	f003 fb23 	bl	80043ce <Error_Handler>
  }

  /** Configure the ADC multi-mode
  */
  multimode.Mode = ADC_MODE_INDEPENDENT;
 8000d88:	2300      	movs	r3, #0
 8000d8a:	63fb      	str	r3, [r7, #60]	; 0x3c
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
 8000d8c:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 8000d90:	4619      	mov	r1, r3
 8000d92:	482a      	ldr	r0, [pc, #168]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000d94:	f007 fa36 	bl	8008204 <HAL_ADCEx_MultiModeConfigChannel>
 8000d98:	4603      	mov	r3, r0
 8000d9a:	2b00      	cmp	r3, #0
 8000d9c:	d001      	beq.n	8000da2 <MX_ADC1_Init+0xca>
  {
    Error_Handler();
 8000d9e:	f003 fb16 	bl	80043ce <Error_Handler>
  }

  /** Configure Analog WatchDog 1
  */
  AnalogWDGConfig.WatchdogNumber = ADC_ANALOGWATCHDOG_1;
 8000da2:	4b27      	ldr	r3, [pc, #156]	; (8000e40 <MX_ADC1_Init+0x168>)
 8000da4:	623b      	str	r3, [r7, #32]
  AnalogWDGConfig.WatchdogMode = ADC_ANALOGWATCHDOG_SINGLE_REG;
 8000da6:	f44f 0340 	mov.w	r3, #12582912	; 0xc00000
 8000daa:	627b      	str	r3, [r7, #36]	; 0x24
  AnalogWDGConfig.Channel = ADC_CHANNEL_VOPAMP1;
 8000dac:	4b25      	ldr	r3, [pc, #148]	; (8000e44 <MX_ADC1_Init+0x16c>)
 8000dae:	62bb      	str	r3, [r7, #40]	; 0x28
  AnalogWDGConfig.ITMode = ENABLE;
 8000db0:	2301      	movs	r3, #1
 8000db2:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
  AnalogWDGConfig.HighThreshold = 4095;
 8000db6:	f640 73ff 	movw	r3, #4095	; 0xfff
 8000dba:	633b      	str	r3, [r7, #48]	; 0x30
  AnalogWDGConfig.LowThreshold = 2048+768;
 8000dbc:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8000dc0:	637b      	str	r3, [r7, #52]	; 0x34
  AnalogWDGConfig.FilteringConfig = ADC_AWD_FILTERING_NONE;
 8000dc2:	2300      	movs	r3, #0
 8000dc4:	63bb      	str	r3, [r7, #56]	; 0x38
  if (HAL_ADC_AnalogWDGConfig(&hadc1, &AnalogWDGConfig) != HAL_OK)
 8000dc6:	f107 0320 	add.w	r3, r7, #32
 8000dca:	4619      	mov	r1, r3
 8000dcc:	481b      	ldr	r0, [pc, #108]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000dce:	f006 fd1f 	bl	8007810 <HAL_ADC_AnalogWDGConfig>
 8000dd2:	4603      	mov	r3, r0
 8000dd4:	2b00      	cmp	r3, #0
 8000dd6:	d001      	beq.n	8000ddc <MX_ADC1_Init+0x104>
  {
    Error_Handler();
 8000dd8:	f003 faf9 	bl	80043ce <Error_Handler>
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_VOPAMP1;
 8000ddc:	4b19      	ldr	r3, [pc, #100]	; (8000e44 <MX_ADC1_Init+0x16c>)
 8000dde:	603b      	str	r3, [r7, #0]
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8000de0:	2306      	movs	r3, #6
 8000de2:	607b      	str	r3, [r7, #4]
  sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
 8000de4:	2300      	movs	r3, #0
 8000de6:	60bb      	str	r3, [r7, #8]
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 8000de8:	237f      	movs	r3, #127	; 0x7f
 8000dea:	60fb      	str	r3, [r7, #12]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 8000dec:	2304      	movs	r3, #4
 8000dee:	613b      	str	r3, [r7, #16]
  sConfig.Offset = 0;
 8000df0:	2300      	movs	r3, #0
 8000df2:	617b      	str	r3, [r7, #20]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000df4:	463b      	mov	r3, r7
 8000df6:	4619      	mov	r1, r3
 8000df8:	4810      	ldr	r0, [pc, #64]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000dfa:	f006 f8c9 	bl	8006f90 <HAL_ADC_ConfigChannel>
 8000dfe:	4603      	mov	r3, r0
 8000e00:	2b00      	cmp	r3, #0
 8000e02:	d001      	beq.n	8000e08 <MX_ADC1_Init+0x130>
  {
    Error_Handler();
 8000e04:	f003 fae3 	bl	80043ce <Error_Handler>
  }

  /** Configure the channel to be monitored by WatchDog 2
  */
  AnalogWDGConfig.WatchdogNumber = ADC_ANALOGWATCHDOG_2;
 8000e08:	4b0f      	ldr	r3, [pc, #60]	; (8000e48 <MX_ADC1_Init+0x170>)
 8000e0a:	623b      	str	r3, [r7, #32]
  AnalogWDGConfig.WatchdogMode = ADC_ANALOGWATCHDOG_SINGLE_REGINJEC;
 8000e0c:	f04f 73e0 	mov.w	r3, #29360128	; 0x1c00000
 8000e10:	627b      	str	r3, [r7, #36]	; 0x24
  AnalogWDGConfig.HighThreshold = 2816;
 8000e12:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8000e16:	633b      	str	r3, [r7, #48]	; 0x30
  AnalogWDGConfig.LowThreshold = 0;
 8000e18:	2300      	movs	r3, #0
 8000e1a:	637b      	str	r3, [r7, #52]	; 0x34
  if (HAL_ADC_AnalogWDGConfig(&hadc1, &AnalogWDGConfig) != HAL_OK)
 8000e1c:	f107 0320 	add.w	r3, r7, #32
 8000e20:	4619      	mov	r1, r3
 8000e22:	4806      	ldr	r0, [pc, #24]	; (8000e3c <MX_ADC1_Init+0x164>)
 8000e24:	f006 fcf4 	bl	8007810 <HAL_ADC_AnalogWDGConfig>
 8000e28:	4603      	mov	r3, r0
 8000e2a:	2b00      	cmp	r3, #0
 8000e2c:	d001      	beq.n	8000e32 <MX_ADC1_Init+0x15a>
  {
    Error_Handler();
 8000e2e:	f003 face 	bl	80043ce <Error_Handler>
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}
 8000e32:	bf00      	nop
 8000e34:	3748      	adds	r7, #72	; 0x48
 8000e36:	46bd      	mov	sp, r7
 8000e38:	bd80      	pop	{r7, pc}
 8000e3a:	bf00      	nop
 8000e3c:	20000374 	.word	0x20000374
 8000e40:	7dc00000 	.word	0x7dc00000
 8000e44:	b6902000 	.word	0xb6902000
 8000e48:	0017ffff 	.word	0x0017ffff

08000e4c <MX_ADC3_Init>:
/* ADC3 init function */
void MX_ADC3_Init(void)
{
 8000e4c:	b580      	push	{r7, lr}
 8000e4e:	b08c      	sub	sp, #48	; 0x30
 8000e50:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN ADC3_Init 0 */

  /* USER CODE END ADC3_Init 0 */

  ADC_MultiModeTypeDef multimode = {0};
 8000e52:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8000e56:	2200      	movs	r2, #0
 8000e58:	601a      	str	r2, [r3, #0]
 8000e5a:	605a      	str	r2, [r3, #4]
 8000e5c:	609a      	str	r2, [r3, #8]
  ADC_ChannelConfTypeDef sConfig = {0};
 8000e5e:	1d3b      	adds	r3, r7, #4
 8000e60:	2220      	movs	r2, #32
 8000e62:	2100      	movs	r1, #0
 8000e64:	4618      	mov	r0, r3
 8000e66:	f01d fb80 	bl	801e56a <memset>

  /* USER CODE END ADC3_Init 1 */

  /** Common config
  */
  hadc3.Instance = ADC3;
 8000e6a:	4b32      	ldr	r3, [pc, #200]	; (8000f34 <MX_ADC3_Init+0xe8>)
 8000e6c:	4a32      	ldr	r2, [pc, #200]	; (8000f38 <MX_ADC3_Init+0xec>)
 8000e6e:	601a      	str	r2, [r3, #0]
  hadc3.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 8000e70:	4b30      	ldr	r3, [pc, #192]	; (8000f34 <MX_ADC3_Init+0xe8>)
 8000e72:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 8000e76:	605a      	str	r2, [r3, #4]
  hadc3.Init.Resolution = ADC_RESOLUTION_12B;
 8000e78:	4b2e      	ldr	r3, [pc, #184]	; (8000f34 <MX_ADC3_Init+0xe8>)
 8000e7a:	2200      	movs	r2, #0
 8000e7c:	609a      	str	r2, [r3, #8]
  hadc3.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8000e7e:	4b2d      	ldr	r3, [pc, #180]	; (8000f34 <MX_ADC3_Init+0xe8>)
 8000e80:	2200      	movs	r2, #0
 8000e82:	60da      	str	r2, [r3, #12]
  hadc3.Init.GainCompensation = 0;
 8000e84:	4b2b      	ldr	r3, [pc, #172]	; (8000f34 <MX_ADC3_Init+0xe8>)
 8000e86:	2200      	movs	r2, #0
 8000e88:	611a      	str	r2, [r3, #16]
  hadc3.Init.ScanConvMode = ADC_SCAN_DISABLE;
 8000e8a:	4b2a      	ldr	r3, [pc, #168]	; (8000f34 <MX_ADC3_Init+0xe8>)
 8000e8c:	2200      	movs	r2, #0
 8000e8e:	615a      	str	r2, [r3, #20]
  hadc3.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000e90:	4b28      	ldr	r3, [pc, #160]	; (8000f34 <MX_ADC3_Init+0xe8>)
 8000e92:	2204      	movs	r2, #4
 8000e94:	619a      	str	r2, [r3, #24]
  hadc3.Init.LowPowerAutoWait = DISABLE;
 8000e96:	4b27      	ldr	r3, [pc, #156]	; (8000f34 <MX_ADC3_Init+0xe8>)
 8000e98:	2200      	movs	r2, #0
 8000e9a:	771a      	strb	r2, [r3, #28]
  hadc3.Init.ContinuousConvMode = DISABLE;
 8000e9c:	4b25      	ldr	r3, [pc, #148]	; (8000f34 <MX_ADC3_Init+0xe8>)
 8000e9e:	2200      	movs	r2, #0
 8000ea0:	775a      	strb	r2, [r3, #29]
  hadc3.Init.NbrOfConversion = 1;
 8000ea2:	4b24      	ldr	r3, [pc, #144]	; (8000f34 <MX_ADC3_Init+0xe8>)
 8000ea4:	2201      	movs	r2, #1
 8000ea6:	621a      	str	r2, [r3, #32]
  hadc3.Init.DiscontinuousConvMode = DISABLE;
 8000ea8:	4b22      	ldr	r3, [pc, #136]	; (8000f34 <MX_ADC3_Init+0xe8>)
 8000eaa:	2200      	movs	r2, #0
 8000eac:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  hadc3.Init.ExternalTrigConv = ADC_EXTERNALTRIG_T1_TRGO;
 8000eb0:	4b20      	ldr	r3, [pc, #128]	; (8000f34 <MX_ADC3_Init+0xe8>)
 8000eb2:	f44f 62a4 	mov.w	r2, #1312	; 0x520
 8000eb6:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc3.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_RISING;
 8000eb8:	4b1e      	ldr	r3, [pc, #120]	; (8000f34 <MX_ADC3_Init+0xe8>)
 8000eba:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8000ebe:	631a      	str	r2, [r3, #48]	; 0x30
  hadc3.Init.DMAContinuousRequests = ENABLE;
 8000ec0:	4b1c      	ldr	r3, [pc, #112]	; (8000f34 <MX_ADC3_Init+0xe8>)
 8000ec2:	2201      	movs	r2, #1
 8000ec4:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  hadc3.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8000ec8:	4b1a      	ldr	r3, [pc, #104]	; (8000f34 <MX_ADC3_Init+0xe8>)
 8000eca:	2200      	movs	r2, #0
 8000ecc:	63da      	str	r2, [r3, #60]	; 0x3c
  hadc3.Init.OversamplingMode = DISABLE;
 8000ece:	4b19      	ldr	r3, [pc, #100]	; (8000f34 <MX_ADC3_Init+0xe8>)
 8000ed0:	2200      	movs	r2, #0
 8000ed2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  if (HAL_ADC_Init(&hadc3) != HAL_OK)
 8000ed6:	4817      	ldr	r0, [pc, #92]	; (8000f34 <MX_ADC3_Init+0xe8>)
 8000ed8:	f005 faf8 	bl	80064cc <HAL_ADC_Init>
 8000edc:	4603      	mov	r3, r0
 8000ede:	2b00      	cmp	r3, #0
 8000ee0:	d001      	beq.n	8000ee6 <MX_ADC3_Init+0x9a>
  {
    Error_Handler();
 8000ee2:	f003 fa74 	bl	80043ce <Error_Handler>
  }

  /** Configure the ADC multi-mode
  */
  multimode.Mode = ADC_MODE_INDEPENDENT;
 8000ee6:	2300      	movs	r3, #0
 8000ee8:	627b      	str	r3, [r7, #36]	; 0x24
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc3, &multimode) != HAL_OK)
 8000eea:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8000eee:	4619      	mov	r1, r3
 8000ef0:	4810      	ldr	r0, [pc, #64]	; (8000f34 <MX_ADC3_Init+0xe8>)
 8000ef2:	f007 f987 	bl	8008204 <HAL_ADCEx_MultiModeConfigChannel>
 8000ef6:	4603      	mov	r3, r0
 8000ef8:	2b00      	cmp	r3, #0
 8000efa:	d001      	beq.n	8000f00 <MX_ADC3_Init+0xb4>
  {
    Error_Handler();
 8000efc:	f003 fa67 	bl	80043ce <Error_Handler>
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_VOPAMP3_ADC3;
 8000f00:	4b0e      	ldr	r3, [pc, #56]	; (8000f3c <MX_ADC3_Init+0xf0>)
 8000f02:	607b      	str	r3, [r7, #4]
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8000f04:	2306      	movs	r3, #6
 8000f06:	60bb      	str	r3, [r7, #8]
  sConfig.SamplingTime = ADC_SAMPLETIME_24CYCLES_5;
 8000f08:	2303      	movs	r3, #3
 8000f0a:	60fb      	str	r3, [r7, #12]
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 8000f0c:	237f      	movs	r3, #127	; 0x7f
 8000f0e:	613b      	str	r3, [r7, #16]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 8000f10:	2304      	movs	r3, #4
 8000f12:	617b      	str	r3, [r7, #20]
  sConfig.Offset = 0;
 8000f14:	2300      	movs	r3, #0
 8000f16:	61bb      	str	r3, [r7, #24]
  if (HAL_ADC_ConfigChannel(&hadc3, &sConfig) != HAL_OK)
 8000f18:	1d3b      	adds	r3, r7, #4
 8000f1a:	4619      	mov	r1, r3
 8000f1c:	4805      	ldr	r0, [pc, #20]	; (8000f34 <MX_ADC3_Init+0xe8>)
 8000f1e:	f006 f837 	bl	8006f90 <HAL_ADC_ConfigChannel>
 8000f22:	4603      	mov	r3, r0
 8000f24:	2b00      	cmp	r3, #0
 8000f26:	d001      	beq.n	8000f2c <MX_ADC3_Init+0xe0>
  {
    Error_Handler();
 8000f28:	f003 fa51 	bl	80043ce <Error_Handler>
  }
  /* USER CODE BEGIN ADC3_Init 2 */

  /* USER CODE END ADC3_Init 2 */

}
 8000f2c:	bf00      	nop
 8000f2e:	3730      	adds	r7, #48	; 0x30
 8000f30:	46bd      	mov	sp, r7
 8000f32:	bd80      	pop	{r7, pc}
 8000f34:	200003e0 	.word	0x200003e0
 8000f38:	50000400 	.word	0x50000400
 8000f3c:	b6982000 	.word	0xb6982000

08000f40 <MX_ADC4_Init>:
/* ADC4 init function */
void MX_ADC4_Init(void)
{
 8000f40:	b580      	push	{r7, lr}
 8000f42:	b088      	sub	sp, #32
 8000f44:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN ADC4_Init 0 */

  /* USER CODE END ADC4_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};
 8000f46:	463b      	mov	r3, r7
 8000f48:	2220      	movs	r2, #32
 8000f4a:	2100      	movs	r1, #0
 8000f4c:	4618      	mov	r0, r3
 8000f4e:	f01d fb0c 	bl	801e56a <memset>

  /* USER CODE END ADC4_Init 1 */

  /** Common config
  */
  hadc4.Instance = ADC4;
 8000f52:	4b2c      	ldr	r3, [pc, #176]	; (8001004 <MX_ADC4_Init+0xc4>)
 8000f54:	4a2c      	ldr	r2, [pc, #176]	; (8001008 <MX_ADC4_Init+0xc8>)
 8000f56:	601a      	str	r2, [r3, #0]
  hadc4.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 8000f58:	4b2a      	ldr	r3, [pc, #168]	; (8001004 <MX_ADC4_Init+0xc4>)
 8000f5a:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 8000f5e:	605a      	str	r2, [r3, #4]
  hadc4.Init.Resolution = ADC_RESOLUTION_12B;
 8000f60:	4b28      	ldr	r3, [pc, #160]	; (8001004 <MX_ADC4_Init+0xc4>)
 8000f62:	2200      	movs	r2, #0
 8000f64:	609a      	str	r2, [r3, #8]
  hadc4.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8000f66:	4b27      	ldr	r3, [pc, #156]	; (8001004 <MX_ADC4_Init+0xc4>)
 8000f68:	2200      	movs	r2, #0
 8000f6a:	60da      	str	r2, [r3, #12]
  hadc4.Init.GainCompensation = 0;
 8000f6c:	4b25      	ldr	r3, [pc, #148]	; (8001004 <MX_ADC4_Init+0xc4>)
 8000f6e:	2200      	movs	r2, #0
 8000f70:	611a      	str	r2, [r3, #16]
  hadc4.Init.ScanConvMode = ADC_SCAN_DISABLE;
 8000f72:	4b24      	ldr	r3, [pc, #144]	; (8001004 <MX_ADC4_Init+0xc4>)
 8000f74:	2200      	movs	r2, #0
 8000f76:	615a      	str	r2, [r3, #20]
  hadc4.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000f78:	4b22      	ldr	r3, [pc, #136]	; (8001004 <MX_ADC4_Init+0xc4>)
 8000f7a:	2204      	movs	r2, #4
 8000f7c:	619a      	str	r2, [r3, #24]
  hadc4.Init.LowPowerAutoWait = DISABLE;
 8000f7e:	4b21      	ldr	r3, [pc, #132]	; (8001004 <MX_ADC4_Init+0xc4>)
 8000f80:	2200      	movs	r2, #0
 8000f82:	771a      	strb	r2, [r3, #28]
  hadc4.Init.ContinuousConvMode = DISABLE;
 8000f84:	4b1f      	ldr	r3, [pc, #124]	; (8001004 <MX_ADC4_Init+0xc4>)
 8000f86:	2200      	movs	r2, #0
 8000f88:	775a      	strb	r2, [r3, #29]
  hadc4.Init.NbrOfConversion = 1;
 8000f8a:	4b1e      	ldr	r3, [pc, #120]	; (8001004 <MX_ADC4_Init+0xc4>)
 8000f8c:	2201      	movs	r2, #1
 8000f8e:	621a      	str	r2, [r3, #32]
  hadc4.Init.DiscontinuousConvMode = DISABLE;
 8000f90:	4b1c      	ldr	r3, [pc, #112]	; (8001004 <MX_ADC4_Init+0xc4>)
 8000f92:	2200      	movs	r2, #0
 8000f94:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  hadc4.Init.ExternalTrigConv = ADC_EXTERNALTRIG_T1_TRGO;
 8000f98:	4b1a      	ldr	r3, [pc, #104]	; (8001004 <MX_ADC4_Init+0xc4>)
 8000f9a:	f44f 62a4 	mov.w	r2, #1312	; 0x520
 8000f9e:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc4.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_RISING;
 8000fa0:	4b18      	ldr	r3, [pc, #96]	; (8001004 <MX_ADC4_Init+0xc4>)
 8000fa2:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8000fa6:	631a      	str	r2, [r3, #48]	; 0x30
  hadc4.Init.DMAContinuousRequests = ENABLE;
 8000fa8:	4b16      	ldr	r3, [pc, #88]	; (8001004 <MX_ADC4_Init+0xc4>)
 8000faa:	2201      	movs	r2, #1
 8000fac:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  hadc4.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8000fb0:	4b14      	ldr	r3, [pc, #80]	; (8001004 <MX_ADC4_Init+0xc4>)
 8000fb2:	2200      	movs	r2, #0
 8000fb4:	63da      	str	r2, [r3, #60]	; 0x3c
  hadc4.Init.OversamplingMode = DISABLE;
 8000fb6:	4b13      	ldr	r3, [pc, #76]	; (8001004 <MX_ADC4_Init+0xc4>)
 8000fb8:	2200      	movs	r2, #0
 8000fba:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  if (HAL_ADC_Init(&hadc4) != HAL_OK)
 8000fbe:	4811      	ldr	r0, [pc, #68]	; (8001004 <MX_ADC4_Init+0xc4>)
 8000fc0:	f005 fa84 	bl	80064cc <HAL_ADC_Init>
 8000fc4:	4603      	mov	r3, r0
 8000fc6:	2b00      	cmp	r3, #0
 8000fc8:	d001      	beq.n	8000fce <MX_ADC4_Init+0x8e>
  {
    Error_Handler();
 8000fca:	f003 fa00 	bl	80043ce <Error_Handler>
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_VOPAMP6;
 8000fce:	4b0f      	ldr	r3, [pc, #60]	; (800100c <MX_ADC4_Init+0xcc>)
 8000fd0:	603b      	str	r3, [r7, #0]
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8000fd2:	2306      	movs	r3, #6
 8000fd4:	607b      	str	r3, [r7, #4]
  sConfig.SamplingTime = ADC_SAMPLETIME_24CYCLES_5;
 8000fd6:	2303      	movs	r3, #3
 8000fd8:	60bb      	str	r3, [r7, #8]
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 8000fda:	237f      	movs	r3, #127	; 0x7f
 8000fdc:	60fb      	str	r3, [r7, #12]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 8000fde:	2304      	movs	r3, #4
 8000fe0:	613b      	str	r3, [r7, #16]
  sConfig.Offset = 0;
 8000fe2:	2300      	movs	r3, #0
 8000fe4:	617b      	str	r3, [r7, #20]
  if (HAL_ADC_ConfigChannel(&hadc4, &sConfig) != HAL_OK)
 8000fe6:	463b      	mov	r3, r7
 8000fe8:	4619      	mov	r1, r3
 8000fea:	4806      	ldr	r0, [pc, #24]	; (8001004 <MX_ADC4_Init+0xc4>)
 8000fec:	f005 ffd0 	bl	8006f90 <HAL_ADC_ConfigChannel>
 8000ff0:	4603      	mov	r3, r0
 8000ff2:	2b00      	cmp	r3, #0
 8000ff4:	d001      	beq.n	8000ffa <MX_ADC4_Init+0xba>
  {
    Error_Handler();
 8000ff6:	f003 f9ea 	bl	80043ce <Error_Handler>
  }
  /* USER CODE BEGIN ADC4_Init 2 */

  /* USER CODE END ADC4_Init 2 */

}
 8000ffa:	bf00      	nop
 8000ffc:	3720      	adds	r7, #32
 8000ffe:	46bd      	mov	sp, r7
 8001000:	bd80      	pop	{r7, pc}
 8001002:	bf00      	nop
 8001004:	2000044c 	.word	0x2000044c
 8001008:	50000500 	.word	0x50000500
 800100c:	c75a0000 	.word	0xc75a0000

08001010 <MX_ADC5_Init>:
/* ADC5 init function */
void MX_ADC5_Init(void)
{
 8001010:	b580      	push	{r7, lr}
 8001012:	b088      	sub	sp, #32
 8001014:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN ADC5_Init 0 */

  /* USER CODE END ADC5_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};
 8001016:	463b      	mov	r3, r7
 8001018:	2220      	movs	r2, #32
 800101a:	2100      	movs	r1, #0
 800101c:	4618      	mov	r0, r3
 800101e:	f01d faa4 	bl	801e56a <memset>

  /* USER CODE END ADC5_Init 1 */

  /** Common config
  */
  hadc5.Instance = ADC5;
 8001022:	4b2c      	ldr	r3, [pc, #176]	; (80010d4 <MX_ADC5_Init+0xc4>)
 8001024:	4a2c      	ldr	r2, [pc, #176]	; (80010d8 <MX_ADC5_Init+0xc8>)
 8001026:	601a      	str	r2, [r3, #0]
  hadc5.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 8001028:	4b2a      	ldr	r3, [pc, #168]	; (80010d4 <MX_ADC5_Init+0xc4>)
 800102a:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 800102e:	605a      	str	r2, [r3, #4]
  hadc5.Init.Resolution = ADC_RESOLUTION_12B;
 8001030:	4b28      	ldr	r3, [pc, #160]	; (80010d4 <MX_ADC5_Init+0xc4>)
 8001032:	2200      	movs	r2, #0
 8001034:	609a      	str	r2, [r3, #8]
  hadc5.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8001036:	4b27      	ldr	r3, [pc, #156]	; (80010d4 <MX_ADC5_Init+0xc4>)
 8001038:	2200      	movs	r2, #0
 800103a:	60da      	str	r2, [r3, #12]
  hadc5.Init.GainCompensation = 0;
 800103c:	4b25      	ldr	r3, [pc, #148]	; (80010d4 <MX_ADC5_Init+0xc4>)
 800103e:	2200      	movs	r2, #0
 8001040:	611a      	str	r2, [r3, #16]
  hadc5.Init.ScanConvMode = ADC_SCAN_DISABLE;
 8001042:	4b24      	ldr	r3, [pc, #144]	; (80010d4 <MX_ADC5_Init+0xc4>)
 8001044:	2200      	movs	r2, #0
 8001046:	615a      	str	r2, [r3, #20]
  hadc5.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8001048:	4b22      	ldr	r3, [pc, #136]	; (80010d4 <MX_ADC5_Init+0xc4>)
 800104a:	2204      	movs	r2, #4
 800104c:	619a      	str	r2, [r3, #24]
  hadc5.Init.LowPowerAutoWait = DISABLE;
 800104e:	4b21      	ldr	r3, [pc, #132]	; (80010d4 <MX_ADC5_Init+0xc4>)
 8001050:	2200      	movs	r2, #0
 8001052:	771a      	strb	r2, [r3, #28]
  hadc5.Init.ContinuousConvMode = DISABLE;
 8001054:	4b1f      	ldr	r3, [pc, #124]	; (80010d4 <MX_ADC5_Init+0xc4>)
 8001056:	2200      	movs	r2, #0
 8001058:	775a      	strb	r2, [r3, #29]
  hadc5.Init.NbrOfConversion = 1;
 800105a:	4b1e      	ldr	r3, [pc, #120]	; (80010d4 <MX_ADC5_Init+0xc4>)
 800105c:	2201      	movs	r2, #1
 800105e:	621a      	str	r2, [r3, #32]
  hadc5.Init.DiscontinuousConvMode = DISABLE;
 8001060:	4b1c      	ldr	r3, [pc, #112]	; (80010d4 <MX_ADC5_Init+0xc4>)
 8001062:	2200      	movs	r2, #0
 8001064:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  hadc5.Init.ExternalTrigConv = ADC_EXTERNALTRIG_T1_TRGO;
 8001068:	4b1a      	ldr	r3, [pc, #104]	; (80010d4 <MX_ADC5_Init+0xc4>)
 800106a:	f44f 62a4 	mov.w	r2, #1312	; 0x520
 800106e:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc5.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_RISING;
 8001070:	4b18      	ldr	r3, [pc, #96]	; (80010d4 <MX_ADC5_Init+0xc4>)
 8001072:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8001076:	631a      	str	r2, [r3, #48]	; 0x30
  hadc5.Init.DMAContinuousRequests = ENABLE;
 8001078:	4b16      	ldr	r3, [pc, #88]	; (80010d4 <MX_ADC5_Init+0xc4>)
 800107a:	2201      	movs	r2, #1
 800107c:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  hadc5.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8001080:	4b14      	ldr	r3, [pc, #80]	; (80010d4 <MX_ADC5_Init+0xc4>)
 8001082:	2200      	movs	r2, #0
 8001084:	63da      	str	r2, [r3, #60]	; 0x3c
  hadc5.Init.OversamplingMode = DISABLE;
 8001086:	4b13      	ldr	r3, [pc, #76]	; (80010d4 <MX_ADC5_Init+0xc4>)
 8001088:	2200      	movs	r2, #0
 800108a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  if (HAL_ADC_Init(&hadc5) != HAL_OK)
 800108e:	4811      	ldr	r0, [pc, #68]	; (80010d4 <MX_ADC5_Init+0xc4>)
 8001090:	f005 fa1c 	bl	80064cc <HAL_ADC_Init>
 8001094:	4603      	mov	r3, r0
 8001096:	2b00      	cmp	r3, #0
 8001098:	d001      	beq.n	800109e <MX_ADC5_Init+0x8e>
  {
    Error_Handler();
 800109a:	f003 f998 	bl	80043ce <Error_Handler>
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_VOPAMP5;
 800109e:	4b0f      	ldr	r3, [pc, #60]	; (80010dc <MX_ADC5_Init+0xcc>)
 80010a0:	603b      	str	r3, [r7, #0]
  sConfig.Rank = ADC_REGULAR_RANK_1;
 80010a2:	2306      	movs	r3, #6
 80010a4:	607b      	str	r3, [r7, #4]
  sConfig.SamplingTime = ADC_SAMPLETIME_24CYCLES_5;
 80010a6:	2303      	movs	r3, #3
 80010a8:	60bb      	str	r3, [r7, #8]
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 80010aa:	237f      	movs	r3, #127	; 0x7f
 80010ac:	60fb      	str	r3, [r7, #12]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 80010ae:	2304      	movs	r3, #4
 80010b0:	613b      	str	r3, [r7, #16]
  sConfig.Offset = 0;
 80010b2:	2300      	movs	r3, #0
 80010b4:	617b      	str	r3, [r7, #20]
  if (HAL_ADC_ConfigChannel(&hadc5, &sConfig) != HAL_OK)
 80010b6:	463b      	mov	r3, r7
 80010b8:	4619      	mov	r1, r3
 80010ba:	4806      	ldr	r0, [pc, #24]	; (80010d4 <MX_ADC5_Init+0xc4>)
 80010bc:	f005 ff68 	bl	8006f90 <HAL_ADC_ConfigChannel>
 80010c0:	4603      	mov	r3, r0
 80010c2:	2b00      	cmp	r3, #0
 80010c4:	d001      	beq.n	80010ca <MX_ADC5_Init+0xba>
  {
    Error_Handler();
 80010c6:	f003 f982 	bl	80043ce <Error_Handler>
  }
  /* USER CODE BEGIN ADC5_Init 2 */

  /* USER CODE END ADC5_Init 2 */

}
 80010ca:	bf00      	nop
 80010cc:	3720      	adds	r7, #32
 80010ce:	46bd      	mov	sp, r7
 80010d0:	bd80      	pop	{r7, pc}
 80010d2:	bf00      	nop
 80010d4:	200004b8 	.word	0x200004b8
 80010d8:	50000600 	.word	0x50000600
 80010dc:	8c900008 	.word	0x8c900008

080010e0 <HAL_ADC_MspInit>:

static uint32_t HAL_RCC_ADC345_CLK_ENABLED=0;

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{
 80010e0:	b580      	push	{r7, lr}
 80010e2:	b09c      	sub	sp, #112	; 0x70
 80010e4:	af00      	add	r7, sp, #0
 80010e6:	6078      	str	r0, [r7, #4]

  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 80010e8:	f107 031c 	add.w	r3, r7, #28
 80010ec:	2254      	movs	r2, #84	; 0x54
 80010ee:	2100      	movs	r1, #0
 80010f0:	4618      	mov	r0, r3
 80010f2:	f01d fa3a 	bl	801e56a <memset>
  if(adcHandle->Instance==ADC1)
 80010f6:	687b      	ldr	r3, [r7, #4]
 80010f8:	681b      	ldr	r3, [r3, #0]
 80010fa:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80010fe:	d14f      	bne.n	80011a0 <HAL_ADC_MspInit+0xc0>

  /* USER CODE END ADC1_MspInit 0 */

  /** Initializes the peripherals clocks
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC12;
 8001100:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8001104:	61fb      	str	r3, [r7, #28]
    PeriphClkInit.Adc12ClockSelection = RCC_ADC12CLKSOURCE_SYSCLK;
 8001106:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 800110a:	663b      	str	r3, [r7, #96]	; 0x60
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 800110c:	f107 031c 	add.w	r3, r7, #28
 8001110:	4618      	mov	r0, r3
 8001112:	f009 fcad 	bl	800aa70 <HAL_RCCEx_PeriphCLKConfig>
 8001116:	4603      	mov	r3, r0
 8001118:	2b00      	cmp	r3, #0
 800111a:	d001      	beq.n	8001120 <HAL_ADC_MspInit+0x40>
    {
      Error_Handler();
 800111c:	f003 f957 	bl	80043ce <Error_Handler>
    }

    /* ADC1 clock enable */
    __HAL_RCC_ADC12_CLK_ENABLE();
 8001120:	4b75      	ldr	r3, [pc, #468]	; (80012f8 <HAL_ADC_MspInit+0x218>)
 8001122:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001124:	4a74      	ldr	r2, [pc, #464]	; (80012f8 <HAL_ADC_MspInit+0x218>)
 8001126:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800112a:	64d3      	str	r3, [r2, #76]	; 0x4c
 800112c:	4b72      	ldr	r3, [pc, #456]	; (80012f8 <HAL_ADC_MspInit+0x218>)
 800112e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001130:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8001134:	61bb      	str	r3, [r7, #24]
 8001136:	69bb      	ldr	r3, [r7, #24]

    /* ADC1 DMA Init */
    /* ADC1 Init */
    hdma_adc1.Instance = DMA1_Channel2;
 8001138:	4b70      	ldr	r3, [pc, #448]	; (80012fc <HAL_ADC_MspInit+0x21c>)
 800113a:	4a71      	ldr	r2, [pc, #452]	; (8001300 <HAL_ADC_MspInit+0x220>)
 800113c:	601a      	str	r2, [r3, #0]
    hdma_adc1.Init.Request = DMA_REQUEST_ADC1;
 800113e:	4b6f      	ldr	r3, [pc, #444]	; (80012fc <HAL_ADC_MspInit+0x21c>)
 8001140:	2205      	movs	r2, #5
 8001142:	605a      	str	r2, [r3, #4]
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8001144:	4b6d      	ldr	r3, [pc, #436]	; (80012fc <HAL_ADC_MspInit+0x21c>)
 8001146:	2200      	movs	r2, #0
 8001148:	609a      	str	r2, [r3, #8]
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
 800114a:	4b6c      	ldr	r3, [pc, #432]	; (80012fc <HAL_ADC_MspInit+0x21c>)
 800114c:	2200      	movs	r2, #0
 800114e:	60da      	str	r2, [r3, #12]
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
 8001150:	4b6a      	ldr	r3, [pc, #424]	; (80012fc <HAL_ADC_MspInit+0x21c>)
 8001152:	2280      	movs	r2, #128	; 0x80
 8001154:	611a      	str	r2, [r3, #16]
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 8001156:	4b69      	ldr	r3, [pc, #420]	; (80012fc <HAL_ADC_MspInit+0x21c>)
 8001158:	f44f 7280 	mov.w	r2, #256	; 0x100
 800115c:	615a      	str	r2, [r3, #20]
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 800115e:	4b67      	ldr	r3, [pc, #412]	; (80012fc <HAL_ADC_MspInit+0x21c>)
 8001160:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8001164:	619a      	str	r2, [r3, #24]
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
 8001166:	4b65      	ldr	r3, [pc, #404]	; (80012fc <HAL_ADC_MspInit+0x21c>)
 8001168:	2220      	movs	r2, #32
 800116a:	61da      	str	r2, [r3, #28]
    hdma_adc1.Init.Priority = DMA_PRIORITY_LOW;
 800116c:	4b63      	ldr	r3, [pc, #396]	; (80012fc <HAL_ADC_MspInit+0x21c>)
 800116e:	2200      	movs	r2, #0
 8001170:	621a      	str	r2, [r3, #32]
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
 8001172:	4862      	ldr	r0, [pc, #392]	; (80012fc <HAL_ADC_MspInit+0x21c>)
 8001174:	f007 fe18 	bl	8008da8 <HAL_DMA_Init>
 8001178:	4603      	mov	r3, r0
 800117a:	2b00      	cmp	r3, #0
 800117c:	d001      	beq.n	8001182 <HAL_ADC_MspInit+0xa2>
    {
      Error_Handler();
 800117e:	f003 f926 	bl	80043ce <Error_Handler>
    }

    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc1);
 8001182:	687b      	ldr	r3, [r7, #4]
 8001184:	4a5d      	ldr	r2, [pc, #372]	; (80012fc <HAL_ADC_MspInit+0x21c>)
 8001186:	655a      	str	r2, [r3, #84]	; 0x54
 8001188:	4a5c      	ldr	r2, [pc, #368]	; (80012fc <HAL_ADC_MspInit+0x21c>)
 800118a:	687b      	ldr	r3, [r7, #4]
 800118c:	6293      	str	r3, [r2, #40]	; 0x28

    /* ADC1 interrupt Init */
    HAL_NVIC_SetPriority(ADC1_2_IRQn, 0, 0);
 800118e:	2200      	movs	r2, #0
 8001190:	2100      	movs	r1, #0
 8001192:	2012      	movs	r0, #18
 8001194:	f007 fa19 	bl	80085ca <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ADC1_2_IRQn);
 8001198:	2012      	movs	r0, #18
 800119a:	f007 fa30 	bl	80085fe <HAL_NVIC_EnableIRQ>

  /* USER CODE BEGIN ADC5_MspInit 1 */

  /* USER CODE END ADC5_MspInit 1 */
  }
}
 800119e:	e114      	b.n	80013ca <HAL_ADC_MspInit+0x2ea>
  else if(adcHandle->Instance==ADC3)
 80011a0:	687b      	ldr	r3, [r7, #4]
 80011a2:	681b      	ldr	r3, [r3, #0]
 80011a4:	4a57      	ldr	r2, [pc, #348]	; (8001304 <HAL_ADC_MspInit+0x224>)
 80011a6:	4293      	cmp	r3, r2
 80011a8:	d150      	bne.n	800124c <HAL_ADC_MspInit+0x16c>
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC345;
 80011aa:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80011ae:	61fb      	str	r3, [r7, #28]
    PeriphClkInit.Adc345ClockSelection = RCC_ADC345CLKSOURCE_SYSCLK;
 80011b0:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 80011b4:	667b      	str	r3, [r7, #100]	; 0x64
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 80011b6:	f107 031c 	add.w	r3, r7, #28
 80011ba:	4618      	mov	r0, r3
 80011bc:	f009 fc58 	bl	800aa70 <HAL_RCCEx_PeriphCLKConfig>
 80011c0:	4603      	mov	r3, r0
 80011c2:	2b00      	cmp	r3, #0
 80011c4:	d001      	beq.n	80011ca <HAL_ADC_MspInit+0xea>
      Error_Handler();
 80011c6:	f003 f902 	bl	80043ce <Error_Handler>
    HAL_RCC_ADC345_CLK_ENABLED++;
 80011ca:	4b4f      	ldr	r3, [pc, #316]	; (8001308 <HAL_ADC_MspInit+0x228>)
 80011cc:	681b      	ldr	r3, [r3, #0]
 80011ce:	3301      	adds	r3, #1
 80011d0:	4a4d      	ldr	r2, [pc, #308]	; (8001308 <HAL_ADC_MspInit+0x228>)
 80011d2:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_ADC345_CLK_ENABLED==1){
 80011d4:	4b4c      	ldr	r3, [pc, #304]	; (8001308 <HAL_ADC_MspInit+0x228>)
 80011d6:	681b      	ldr	r3, [r3, #0]
 80011d8:	2b01      	cmp	r3, #1
 80011da:	d10b      	bne.n	80011f4 <HAL_ADC_MspInit+0x114>
      __HAL_RCC_ADC345_CLK_ENABLE();
 80011dc:	4b46      	ldr	r3, [pc, #280]	; (80012f8 <HAL_ADC_MspInit+0x218>)
 80011de:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80011e0:	4a45      	ldr	r2, [pc, #276]	; (80012f8 <HAL_ADC_MspInit+0x218>)
 80011e2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80011e6:	64d3      	str	r3, [r2, #76]	; 0x4c
 80011e8:	4b43      	ldr	r3, [pc, #268]	; (80012f8 <HAL_ADC_MspInit+0x218>)
 80011ea:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80011ec:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80011f0:	617b      	str	r3, [r7, #20]
 80011f2:	697b      	ldr	r3, [r7, #20]
    hdma_adc3.Instance = DMA1_Channel5;
 80011f4:	4b45      	ldr	r3, [pc, #276]	; (800130c <HAL_ADC_MspInit+0x22c>)
 80011f6:	4a46      	ldr	r2, [pc, #280]	; (8001310 <HAL_ADC_MspInit+0x230>)
 80011f8:	601a      	str	r2, [r3, #0]
    hdma_adc3.Init.Request = DMA_REQUEST_ADC3;
 80011fa:	4b44      	ldr	r3, [pc, #272]	; (800130c <HAL_ADC_MspInit+0x22c>)
 80011fc:	2225      	movs	r2, #37	; 0x25
 80011fe:	605a      	str	r2, [r3, #4]
    hdma_adc3.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8001200:	4b42      	ldr	r3, [pc, #264]	; (800130c <HAL_ADC_MspInit+0x22c>)
 8001202:	2200      	movs	r2, #0
 8001204:	609a      	str	r2, [r3, #8]
    hdma_adc3.Init.PeriphInc = DMA_PINC_DISABLE;
 8001206:	4b41      	ldr	r3, [pc, #260]	; (800130c <HAL_ADC_MspInit+0x22c>)
 8001208:	2200      	movs	r2, #0
 800120a:	60da      	str	r2, [r3, #12]
    hdma_adc3.Init.MemInc = DMA_MINC_ENABLE;
 800120c:	4b3f      	ldr	r3, [pc, #252]	; (800130c <HAL_ADC_MspInit+0x22c>)
 800120e:	2280      	movs	r2, #128	; 0x80
 8001210:	611a      	str	r2, [r3, #16]
    hdma_adc3.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 8001212:	4b3e      	ldr	r3, [pc, #248]	; (800130c <HAL_ADC_MspInit+0x22c>)
 8001214:	f44f 7280 	mov.w	r2, #256	; 0x100
 8001218:	615a      	str	r2, [r3, #20]
    hdma_adc3.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 800121a:	4b3c      	ldr	r3, [pc, #240]	; (800130c <HAL_ADC_MspInit+0x22c>)
 800121c:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8001220:	619a      	str	r2, [r3, #24]
    hdma_adc3.Init.Mode = DMA_CIRCULAR;
 8001222:	4b3a      	ldr	r3, [pc, #232]	; (800130c <HAL_ADC_MspInit+0x22c>)
 8001224:	2220      	movs	r2, #32
 8001226:	61da      	str	r2, [r3, #28]
    hdma_adc3.Init.Priority = DMA_PRIORITY_LOW;
 8001228:	4b38      	ldr	r3, [pc, #224]	; (800130c <HAL_ADC_MspInit+0x22c>)
 800122a:	2200      	movs	r2, #0
 800122c:	621a      	str	r2, [r3, #32]
    if (HAL_DMA_Init(&hdma_adc3) != HAL_OK)
 800122e:	4837      	ldr	r0, [pc, #220]	; (800130c <HAL_ADC_MspInit+0x22c>)
 8001230:	f007 fdba 	bl	8008da8 <HAL_DMA_Init>
 8001234:	4603      	mov	r3, r0
 8001236:	2b00      	cmp	r3, #0
 8001238:	d001      	beq.n	800123e <HAL_ADC_MspInit+0x15e>
      Error_Handler();
 800123a:	f003 f8c8 	bl	80043ce <Error_Handler>
    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc3);
 800123e:	687b      	ldr	r3, [r7, #4]
 8001240:	4a32      	ldr	r2, [pc, #200]	; (800130c <HAL_ADC_MspInit+0x22c>)
 8001242:	655a      	str	r2, [r3, #84]	; 0x54
 8001244:	4a31      	ldr	r2, [pc, #196]	; (800130c <HAL_ADC_MspInit+0x22c>)
 8001246:	687b      	ldr	r3, [r7, #4]
 8001248:	6293      	str	r3, [r2, #40]	; 0x28
}
 800124a:	e0be      	b.n	80013ca <HAL_ADC_MspInit+0x2ea>
  else if(adcHandle->Instance==ADC4)
 800124c:	687b      	ldr	r3, [r7, #4]
 800124e:	681b      	ldr	r3, [r3, #0]
 8001250:	4a30      	ldr	r2, [pc, #192]	; (8001314 <HAL_ADC_MspInit+0x234>)
 8001252:	4293      	cmp	r3, r2
 8001254:	d164      	bne.n	8001320 <HAL_ADC_MspInit+0x240>
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC345;
 8001256:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800125a:	61fb      	str	r3, [r7, #28]
    PeriphClkInit.Adc345ClockSelection = RCC_ADC345CLKSOURCE_SYSCLK;
 800125c:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8001260:	667b      	str	r3, [r7, #100]	; 0x64
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8001262:	f107 031c 	add.w	r3, r7, #28
 8001266:	4618      	mov	r0, r3
 8001268:	f009 fc02 	bl	800aa70 <HAL_RCCEx_PeriphCLKConfig>
 800126c:	4603      	mov	r3, r0
 800126e:	2b00      	cmp	r3, #0
 8001270:	d001      	beq.n	8001276 <HAL_ADC_MspInit+0x196>
      Error_Handler();
 8001272:	f003 f8ac 	bl	80043ce <Error_Handler>
    HAL_RCC_ADC345_CLK_ENABLED++;
 8001276:	4b24      	ldr	r3, [pc, #144]	; (8001308 <HAL_ADC_MspInit+0x228>)
 8001278:	681b      	ldr	r3, [r3, #0]
 800127a:	3301      	adds	r3, #1
 800127c:	4a22      	ldr	r2, [pc, #136]	; (8001308 <HAL_ADC_MspInit+0x228>)
 800127e:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_ADC345_CLK_ENABLED==1){
 8001280:	4b21      	ldr	r3, [pc, #132]	; (8001308 <HAL_ADC_MspInit+0x228>)
 8001282:	681b      	ldr	r3, [r3, #0]
 8001284:	2b01      	cmp	r3, #1
 8001286:	d10b      	bne.n	80012a0 <HAL_ADC_MspInit+0x1c0>
      __HAL_RCC_ADC345_CLK_ENABLE();
 8001288:	4b1b      	ldr	r3, [pc, #108]	; (80012f8 <HAL_ADC_MspInit+0x218>)
 800128a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800128c:	4a1a      	ldr	r2, [pc, #104]	; (80012f8 <HAL_ADC_MspInit+0x218>)
 800128e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001292:	64d3      	str	r3, [r2, #76]	; 0x4c
 8001294:	4b18      	ldr	r3, [pc, #96]	; (80012f8 <HAL_ADC_MspInit+0x218>)
 8001296:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001298:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800129c:	613b      	str	r3, [r7, #16]
 800129e:	693b      	ldr	r3, [r7, #16]
    hdma_adc4.Instance = DMA1_Channel6;
 80012a0:	4b1d      	ldr	r3, [pc, #116]	; (8001318 <HAL_ADC_MspInit+0x238>)
 80012a2:	4a1e      	ldr	r2, [pc, #120]	; (800131c <HAL_ADC_MspInit+0x23c>)
 80012a4:	601a      	str	r2, [r3, #0]
    hdma_adc4.Init.Request = DMA_REQUEST_ADC4;
 80012a6:	4b1c      	ldr	r3, [pc, #112]	; (8001318 <HAL_ADC_MspInit+0x238>)
 80012a8:	2226      	movs	r2, #38	; 0x26
 80012aa:	605a      	str	r2, [r3, #4]
    hdma_adc4.Init.Direction = DMA_PERIPH_TO_MEMORY;
 80012ac:	4b1a      	ldr	r3, [pc, #104]	; (8001318 <HAL_ADC_MspInit+0x238>)
 80012ae:	2200      	movs	r2, #0
 80012b0:	609a      	str	r2, [r3, #8]
    hdma_adc4.Init.PeriphInc = DMA_PINC_DISABLE;
 80012b2:	4b19      	ldr	r3, [pc, #100]	; (8001318 <HAL_ADC_MspInit+0x238>)
 80012b4:	2200      	movs	r2, #0
 80012b6:	60da      	str	r2, [r3, #12]
    hdma_adc4.Init.MemInc = DMA_MINC_ENABLE;
 80012b8:	4b17      	ldr	r3, [pc, #92]	; (8001318 <HAL_ADC_MspInit+0x238>)
 80012ba:	2280      	movs	r2, #128	; 0x80
 80012bc:	611a      	str	r2, [r3, #16]
    hdma_adc4.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 80012be:	4b16      	ldr	r3, [pc, #88]	; (8001318 <HAL_ADC_MspInit+0x238>)
 80012c0:	f44f 7280 	mov.w	r2, #256	; 0x100
 80012c4:	615a      	str	r2, [r3, #20]
    hdma_adc4.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 80012c6:	4b14      	ldr	r3, [pc, #80]	; (8001318 <HAL_ADC_MspInit+0x238>)
 80012c8:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80012cc:	619a      	str	r2, [r3, #24]
    hdma_adc4.Init.Mode = DMA_CIRCULAR;
 80012ce:	4b12      	ldr	r3, [pc, #72]	; (8001318 <HAL_ADC_MspInit+0x238>)
 80012d0:	2220      	movs	r2, #32
 80012d2:	61da      	str	r2, [r3, #28]
    hdma_adc4.Init.Priority = DMA_PRIORITY_LOW;
 80012d4:	4b10      	ldr	r3, [pc, #64]	; (8001318 <HAL_ADC_MspInit+0x238>)
 80012d6:	2200      	movs	r2, #0
 80012d8:	621a      	str	r2, [r3, #32]
    if (HAL_DMA_Init(&hdma_adc4) != HAL_OK)
 80012da:	480f      	ldr	r0, [pc, #60]	; (8001318 <HAL_ADC_MspInit+0x238>)
 80012dc:	f007 fd64 	bl	8008da8 <HAL_DMA_Init>
 80012e0:	4603      	mov	r3, r0
 80012e2:	2b00      	cmp	r3, #0
 80012e4:	d001      	beq.n	80012ea <HAL_ADC_MspInit+0x20a>
      Error_Handler();
 80012e6:	f003 f872 	bl	80043ce <Error_Handler>
    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc4);
 80012ea:	687b      	ldr	r3, [r7, #4]
 80012ec:	4a0a      	ldr	r2, [pc, #40]	; (8001318 <HAL_ADC_MspInit+0x238>)
 80012ee:	655a      	str	r2, [r3, #84]	; 0x54
 80012f0:	4a09      	ldr	r2, [pc, #36]	; (8001318 <HAL_ADC_MspInit+0x238>)
 80012f2:	687b      	ldr	r3, [r7, #4]
 80012f4:	6293      	str	r3, [r2, #40]	; 0x28
}
 80012f6:	e068      	b.n	80013ca <HAL_ADC_MspInit+0x2ea>
 80012f8:	40021000 	.word	0x40021000
 80012fc:	20000524 	.word	0x20000524
 8001300:	4002001c 	.word	0x4002001c
 8001304:	50000400 	.word	0x50000400
 8001308:	200006a4 	.word	0x200006a4
 800130c:	20000584 	.word	0x20000584
 8001310:	40020058 	.word	0x40020058
 8001314:	50000500 	.word	0x50000500
 8001318:	200005e4 	.word	0x200005e4
 800131c:	4002006c 	.word	0x4002006c
  else if(adcHandle->Instance==ADC5)
 8001320:	687b      	ldr	r3, [r7, #4]
 8001322:	681b      	ldr	r3, [r3, #0]
 8001324:	4a2b      	ldr	r2, [pc, #172]	; (80013d4 <HAL_ADC_MspInit+0x2f4>)
 8001326:	4293      	cmp	r3, r2
 8001328:	d14f      	bne.n	80013ca <HAL_ADC_MspInit+0x2ea>
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC345;
 800132a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800132e:	61fb      	str	r3, [r7, #28]
    PeriphClkInit.Adc345ClockSelection = RCC_ADC345CLKSOURCE_SYSCLK;
 8001330:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8001334:	667b      	str	r3, [r7, #100]	; 0x64
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8001336:	f107 031c 	add.w	r3, r7, #28
 800133a:	4618      	mov	r0, r3
 800133c:	f009 fb98 	bl	800aa70 <HAL_RCCEx_PeriphCLKConfig>
 8001340:	4603      	mov	r3, r0
 8001342:	2b00      	cmp	r3, #0
 8001344:	d001      	beq.n	800134a <HAL_ADC_MspInit+0x26a>
      Error_Handler();
 8001346:	f003 f842 	bl	80043ce <Error_Handler>
    HAL_RCC_ADC345_CLK_ENABLED++;
 800134a:	4b23      	ldr	r3, [pc, #140]	; (80013d8 <HAL_ADC_MspInit+0x2f8>)
 800134c:	681b      	ldr	r3, [r3, #0]
 800134e:	3301      	adds	r3, #1
 8001350:	4a21      	ldr	r2, [pc, #132]	; (80013d8 <HAL_ADC_MspInit+0x2f8>)
 8001352:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_ADC345_CLK_ENABLED==1){
 8001354:	4b20      	ldr	r3, [pc, #128]	; (80013d8 <HAL_ADC_MspInit+0x2f8>)
 8001356:	681b      	ldr	r3, [r3, #0]
 8001358:	2b01      	cmp	r3, #1
 800135a:	d10b      	bne.n	8001374 <HAL_ADC_MspInit+0x294>
      __HAL_RCC_ADC345_CLK_ENABLE();
 800135c:	4b1f      	ldr	r3, [pc, #124]	; (80013dc <HAL_ADC_MspInit+0x2fc>)
 800135e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001360:	4a1e      	ldr	r2, [pc, #120]	; (80013dc <HAL_ADC_MspInit+0x2fc>)
 8001362:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001366:	64d3      	str	r3, [r2, #76]	; 0x4c
 8001368:	4b1c      	ldr	r3, [pc, #112]	; (80013dc <HAL_ADC_MspInit+0x2fc>)
 800136a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800136c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8001370:	60fb      	str	r3, [r7, #12]
 8001372:	68fb      	ldr	r3, [r7, #12]
    hdma_adc5.Instance = DMA1_Channel7;
 8001374:	4b1a      	ldr	r3, [pc, #104]	; (80013e0 <HAL_ADC_MspInit+0x300>)
 8001376:	4a1b      	ldr	r2, [pc, #108]	; (80013e4 <HAL_ADC_MspInit+0x304>)
 8001378:	601a      	str	r2, [r3, #0]
    hdma_adc5.Init.Request = DMA_REQUEST_ADC5;
 800137a:	4b19      	ldr	r3, [pc, #100]	; (80013e0 <HAL_ADC_MspInit+0x300>)
 800137c:	2227      	movs	r2, #39	; 0x27
 800137e:	605a      	str	r2, [r3, #4]
    hdma_adc5.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8001380:	4b17      	ldr	r3, [pc, #92]	; (80013e0 <HAL_ADC_MspInit+0x300>)
 8001382:	2200      	movs	r2, #0
 8001384:	609a      	str	r2, [r3, #8]
    hdma_adc5.Init.PeriphInc = DMA_PINC_DISABLE;
 8001386:	4b16      	ldr	r3, [pc, #88]	; (80013e0 <HAL_ADC_MspInit+0x300>)
 8001388:	2200      	movs	r2, #0
 800138a:	60da      	str	r2, [r3, #12]
    hdma_adc5.Init.MemInc = DMA_MINC_ENABLE;
 800138c:	4b14      	ldr	r3, [pc, #80]	; (80013e0 <HAL_ADC_MspInit+0x300>)
 800138e:	2280      	movs	r2, #128	; 0x80
 8001390:	611a      	str	r2, [r3, #16]
    hdma_adc5.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 8001392:	4b13      	ldr	r3, [pc, #76]	; (80013e0 <HAL_ADC_MspInit+0x300>)
 8001394:	f44f 7280 	mov.w	r2, #256	; 0x100
 8001398:	615a      	str	r2, [r3, #20]
    hdma_adc5.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 800139a:	4b11      	ldr	r3, [pc, #68]	; (80013e0 <HAL_ADC_MspInit+0x300>)
 800139c:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80013a0:	619a      	str	r2, [r3, #24]
    hdma_adc5.Init.Mode = DMA_CIRCULAR;
 80013a2:	4b0f      	ldr	r3, [pc, #60]	; (80013e0 <HAL_ADC_MspInit+0x300>)
 80013a4:	2220      	movs	r2, #32
 80013a6:	61da      	str	r2, [r3, #28]
    hdma_adc5.Init.Priority = DMA_PRIORITY_LOW;
 80013a8:	4b0d      	ldr	r3, [pc, #52]	; (80013e0 <HAL_ADC_MspInit+0x300>)
 80013aa:	2200      	movs	r2, #0
 80013ac:	621a      	str	r2, [r3, #32]
    if (HAL_DMA_Init(&hdma_adc5) != HAL_OK)
 80013ae:	480c      	ldr	r0, [pc, #48]	; (80013e0 <HAL_ADC_MspInit+0x300>)
 80013b0:	f007 fcfa 	bl	8008da8 <HAL_DMA_Init>
 80013b4:	4603      	mov	r3, r0
 80013b6:	2b00      	cmp	r3, #0
 80013b8:	d001      	beq.n	80013be <HAL_ADC_MspInit+0x2de>
      Error_Handler();
 80013ba:	f003 f808 	bl	80043ce <Error_Handler>
    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc5);
 80013be:	687b      	ldr	r3, [r7, #4]
 80013c0:	4a07      	ldr	r2, [pc, #28]	; (80013e0 <HAL_ADC_MspInit+0x300>)
 80013c2:	655a      	str	r2, [r3, #84]	; 0x54
 80013c4:	4a06      	ldr	r2, [pc, #24]	; (80013e0 <HAL_ADC_MspInit+0x300>)
 80013c6:	687b      	ldr	r3, [r7, #4]
 80013c8:	6293      	str	r3, [r2, #40]	; 0x28
}
 80013ca:	bf00      	nop
 80013cc:	3770      	adds	r7, #112	; 0x70
 80013ce:	46bd      	mov	sp, r7
 80013d0:	bd80      	pop	{r7, pc}
 80013d2:	bf00      	nop
 80013d4:	50000600 	.word	0x50000600
 80013d8:	200006a4 	.word	0x200006a4
 80013dc:	40021000 	.word	0x40021000
 80013e0:	20000644 	.word	0x20000644
 80013e4:	40020080 	.word	0x40020080

080013e8 <MX_DAC1_Init>:
DMA_HandleTypeDef hdma_dac1_ch1;
DMA_HandleTypeDef hdma_dac1_ch2;

/* DAC1 init function */
void MX_DAC1_Init(void)
{
 80013e8:	b580      	push	{r7, lr}
 80013ea:	b08c      	sub	sp, #48	; 0x30
 80013ec:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN DAC1_Init 0 */

  /* USER CODE END DAC1_Init 0 */

  DAC_ChannelConfTypeDef sConfig = {0};
 80013ee:	463b      	mov	r3, r7
 80013f0:	2230      	movs	r2, #48	; 0x30
 80013f2:	2100      	movs	r1, #0
 80013f4:	4618      	mov	r0, r3
 80013f6:	f01d f8b8 	bl	801e56a <memset>

  /* USER CODE END DAC1_Init 1 */

  /** DAC Initialization
  */
  hdac1.Instance = DAC1;
 80013fa:	4b1b      	ldr	r3, [pc, #108]	; (8001468 <MX_DAC1_Init+0x80>)
 80013fc:	4a1b      	ldr	r2, [pc, #108]	; (800146c <MX_DAC1_Init+0x84>)
 80013fe:	601a      	str	r2, [r3, #0]
  if (HAL_DAC_Init(&hdac1) != HAL_OK)
 8001400:	4819      	ldr	r0, [pc, #100]	; (8001468 <MX_DAC1_Init+0x80>)
 8001402:	f007 f916 	bl	8008632 <HAL_DAC_Init>
 8001406:	4603      	mov	r3, r0
 8001408:	2b00      	cmp	r3, #0
 800140a:	d001      	beq.n	8001410 <MX_DAC1_Init+0x28>
  {
    Error_Handler();
 800140c:	f002 ffdf 	bl	80043ce <Error_Handler>
  }

  /** DAC channel OUT1 config
  */
  sConfig.DAC_HighFrequency = DAC_HIGH_FREQUENCY_INTERFACE_MODE_AUTOMATIC;
 8001410:	2302      	movs	r3, #2
 8001412:	603b      	str	r3, [r7, #0]
  sConfig.DAC_DMADoubleDataMode = DISABLE;
 8001414:	2300      	movs	r3, #0
 8001416:	713b      	strb	r3, [r7, #4]
  sConfig.DAC_SignedFormat = DISABLE;
 8001418:	2300      	movs	r3, #0
 800141a:	717b      	strb	r3, [r7, #5]
  sConfig.DAC_SampleAndHold = DAC_SAMPLEANDHOLD_DISABLE;
 800141c:	2300      	movs	r3, #0
 800141e:	60bb      	str	r3, [r7, #8]
  sConfig.DAC_Trigger = DAC_TRIGGER_T3_TRGO;
 8001420:	2322      	movs	r3, #34	; 0x22
 8001422:	60fb      	str	r3, [r7, #12]
  sConfig.DAC_Trigger2 = DAC_TRIGGER_NONE;
 8001424:	2300      	movs	r3, #0
 8001426:	613b      	str	r3, [r7, #16]
  sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
 8001428:	2300      	movs	r3, #0
 800142a:	617b      	str	r3, [r7, #20]
  sConfig.DAC_ConnectOnChipPeripheral = DAC_CHIPCONNECT_EXTERNAL;
 800142c:	2301      	movs	r3, #1
 800142e:	61bb      	str	r3, [r7, #24]
  sConfig.DAC_UserTrimming = DAC_TRIMMING_FACTORY;
 8001430:	2300      	movs	r3, #0
 8001432:	61fb      	str	r3, [r7, #28]
  if (HAL_DAC_ConfigChannel(&hdac1, &sConfig, DAC_CHANNEL_1) != HAL_OK)
 8001434:	463b      	mov	r3, r7
 8001436:	2200      	movs	r2, #0
 8001438:	4619      	mov	r1, r3
 800143a:	480b      	ldr	r0, [pc, #44]	; (8001468 <MX_DAC1_Init+0x80>)
 800143c:	f007 fa82 	bl	8008944 <HAL_DAC_ConfigChannel>
 8001440:	4603      	mov	r3, r0
 8001442:	2b00      	cmp	r3, #0
 8001444:	d001      	beq.n	800144a <MX_DAC1_Init+0x62>
  {
    Error_Handler();
 8001446:	f002 ffc2 	bl	80043ce <Error_Handler>
  }

  /** DAC channel OUT2 config
  */
  if (HAL_DAC_ConfigChannel(&hdac1, &sConfig, DAC_CHANNEL_2) != HAL_OK)
 800144a:	463b      	mov	r3, r7
 800144c:	2210      	movs	r2, #16
 800144e:	4619      	mov	r1, r3
 8001450:	4805      	ldr	r0, [pc, #20]	; (8001468 <MX_DAC1_Init+0x80>)
 8001452:	f007 fa77 	bl	8008944 <HAL_DAC_ConfigChannel>
 8001456:	4603      	mov	r3, r0
 8001458:	2b00      	cmp	r3, #0
 800145a:	d001      	beq.n	8001460 <MX_DAC1_Init+0x78>
  {
    Error_Handler();
 800145c:	f002 ffb7 	bl	80043ce <Error_Handler>
  }
  /* USER CODE BEGIN DAC1_Init 2 */

  /* USER CODE END DAC1_Init 2 */

}
 8001460:	bf00      	nop
 8001462:	3730      	adds	r7, #48	; 0x30
 8001464:	46bd      	mov	sp, r7
 8001466:	bd80      	pop	{r7, pc}
 8001468:	200006a8 	.word	0x200006a8
 800146c:	50000800 	.word	0x50000800

08001470 <MX_DAC2_Init>:
/* DAC2 init function */
void MX_DAC2_Init(void)
{
 8001470:	b580      	push	{r7, lr}
 8001472:	b08c      	sub	sp, #48	; 0x30
 8001474:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN DAC2_Init 0 */

  /* USER CODE END DAC2_Init 0 */

  DAC_ChannelConfTypeDef sConfig = {0};
 8001476:	463b      	mov	r3, r7
 8001478:	2230      	movs	r2, #48	; 0x30
 800147a:	2100      	movs	r1, #0
 800147c:	4618      	mov	r0, r3
 800147e:	f01d f874 	bl	801e56a <memset>

  /* USER CODE END DAC2_Init 1 */

  /** DAC Initialization
  */
  hdac2.Instance = DAC2;
 8001482:	4b16      	ldr	r3, [pc, #88]	; (80014dc <MX_DAC2_Init+0x6c>)
 8001484:	4a16      	ldr	r2, [pc, #88]	; (80014e0 <MX_DAC2_Init+0x70>)
 8001486:	601a      	str	r2, [r3, #0]
  if (HAL_DAC_Init(&hdac2) != HAL_OK)
 8001488:	4814      	ldr	r0, [pc, #80]	; (80014dc <MX_DAC2_Init+0x6c>)
 800148a:	f007 f8d2 	bl	8008632 <HAL_DAC_Init>
 800148e:	4603      	mov	r3, r0
 8001490:	2b00      	cmp	r3, #0
 8001492:	d001      	beq.n	8001498 <MX_DAC2_Init+0x28>
  {
    Error_Handler();
 8001494:	f002 ff9b 	bl	80043ce <Error_Handler>
  }

  /** DAC channel OUT1 config
  */
  sConfig.DAC_HighFrequency = DAC_HIGH_FREQUENCY_INTERFACE_MODE_AUTOMATIC;
 8001498:	2302      	movs	r3, #2
 800149a:	603b      	str	r3, [r7, #0]
  sConfig.DAC_DMADoubleDataMode = DISABLE;
 800149c:	2300      	movs	r3, #0
 800149e:	713b      	strb	r3, [r7, #4]
  sConfig.DAC_SignedFormat = DISABLE;
 80014a0:	2300      	movs	r3, #0
 80014a2:	717b      	strb	r3, [r7, #5]
  sConfig.DAC_SampleAndHold = DAC_SAMPLEANDHOLD_DISABLE;
 80014a4:	2300      	movs	r3, #0
 80014a6:	60bb      	str	r3, [r7, #8]
  sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
 80014a8:	2300      	movs	r3, #0
 80014aa:	60fb      	str	r3, [r7, #12]
  sConfig.DAC_Trigger2 = DAC_TRIGGER_NONE;
 80014ac:	2300      	movs	r3, #0
 80014ae:	613b      	str	r3, [r7, #16]
  sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
 80014b0:	2300      	movs	r3, #0
 80014b2:	617b      	str	r3, [r7, #20]
  sConfig.DAC_ConnectOnChipPeripheral = DAC_CHIPCONNECT_EXTERNAL;
 80014b4:	2301      	movs	r3, #1
 80014b6:	61bb      	str	r3, [r7, #24]
  sConfig.DAC_UserTrimming = DAC_TRIMMING_FACTORY;
 80014b8:	2300      	movs	r3, #0
 80014ba:	61fb      	str	r3, [r7, #28]
  if (HAL_DAC_ConfigChannel(&hdac2, &sConfig, DAC_CHANNEL_1) != HAL_OK)
 80014bc:	463b      	mov	r3, r7
 80014be:	2200      	movs	r2, #0
 80014c0:	4619      	mov	r1, r3
 80014c2:	4806      	ldr	r0, [pc, #24]	; (80014dc <MX_DAC2_Init+0x6c>)
 80014c4:	f007 fa3e 	bl	8008944 <HAL_DAC_ConfigChannel>
 80014c8:	4603      	mov	r3, r0
 80014ca:	2b00      	cmp	r3, #0
 80014cc:	d001      	beq.n	80014d2 <MX_DAC2_Init+0x62>
  {
    Error_Handler();
 80014ce:	f002 ff7e 	bl	80043ce <Error_Handler>
  }
  /* USER CODE BEGIN DAC2_Init 2 */

  /* USER CODE END DAC2_Init 2 */

}
 80014d2:	bf00      	nop
 80014d4:	3730      	adds	r7, #48	; 0x30
 80014d6:	46bd      	mov	sp, r7
 80014d8:	bd80      	pop	{r7, pc}
 80014da:	bf00      	nop
 80014dc:	200006bc 	.word	0x200006bc
 80014e0:	50000c00 	.word	0x50000c00

080014e4 <HAL_DAC_MspInit>:

void HAL_DAC_MspInit(DAC_HandleTypeDef* dacHandle)
{
 80014e4:	b580      	push	{r7, lr}
 80014e6:	b08c      	sub	sp, #48	; 0x30
 80014e8:	af00      	add	r7, sp, #0
 80014ea:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80014ec:	f107 031c 	add.w	r3, r7, #28
 80014f0:	2200      	movs	r2, #0
 80014f2:	601a      	str	r2, [r3, #0]
 80014f4:	605a      	str	r2, [r3, #4]
 80014f6:	609a      	str	r2, [r3, #8]
 80014f8:	60da      	str	r2, [r3, #12]
 80014fa:	611a      	str	r2, [r3, #16]
  if(dacHandle->Instance==DAC1)
 80014fc:	687b      	ldr	r3, [r7, #4]
 80014fe:	681b      	ldr	r3, [r3, #0]
 8001500:	4a56      	ldr	r2, [pc, #344]	; (800165c <HAL_DAC_MspInit+0x178>)
 8001502:	4293      	cmp	r3, r2
 8001504:	d17b      	bne.n	80015fe <HAL_DAC_MspInit+0x11a>
  {
  /* USER CODE BEGIN DAC1_MspInit 0 */

  /* USER CODE END DAC1_MspInit 0 */
    /* DAC1 clock enable */
    __HAL_RCC_DAC1_CLK_ENABLE();
 8001506:	4b56      	ldr	r3, [pc, #344]	; (8001660 <HAL_DAC_MspInit+0x17c>)
 8001508:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800150a:	4a55      	ldr	r2, [pc, #340]	; (8001660 <HAL_DAC_MspInit+0x17c>)
 800150c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001510:	64d3      	str	r3, [r2, #76]	; 0x4c
 8001512:	4b53      	ldr	r3, [pc, #332]	; (8001660 <HAL_DAC_MspInit+0x17c>)
 8001514:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001516:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800151a:	61bb      	str	r3, [r7, #24]
 800151c:	69bb      	ldr	r3, [r7, #24]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 800151e:	4b50      	ldr	r3, [pc, #320]	; (8001660 <HAL_DAC_MspInit+0x17c>)
 8001520:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001522:	4a4f      	ldr	r2, [pc, #316]	; (8001660 <HAL_DAC_MspInit+0x17c>)
 8001524:	f043 0301 	orr.w	r3, r3, #1
 8001528:	64d3      	str	r3, [r2, #76]	; 0x4c
 800152a:	4b4d      	ldr	r3, [pc, #308]	; (8001660 <HAL_DAC_MspInit+0x17c>)
 800152c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800152e:	f003 0301 	and.w	r3, r3, #1
 8001532:	617b      	str	r3, [r7, #20]
 8001534:	697b      	ldr	r3, [r7, #20]
    /**DAC1 GPIO Configuration
    PA4     ------> DAC1_OUT1
    PA5     ------> DAC1_OUT2
    */
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5;
 8001536:	2330      	movs	r3, #48	; 0x30
 8001538:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800153a:	2303      	movs	r3, #3
 800153c:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800153e:	2300      	movs	r3, #0
 8001540:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001542:	f107 031c 	add.w	r3, r7, #28
 8001546:	4619      	mov	r1, r3
 8001548:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800154c:	f007 ff5e 	bl	800940c <HAL_GPIO_Init>

    /* DAC1 DMA Init */
    /* DAC1_CH1 Init */
    hdma_dac1_ch1.Instance = DMA1_Channel3;
 8001550:	4b44      	ldr	r3, [pc, #272]	; (8001664 <HAL_DAC_MspInit+0x180>)
 8001552:	4a45      	ldr	r2, [pc, #276]	; (8001668 <HAL_DAC_MspInit+0x184>)
 8001554:	601a      	str	r2, [r3, #0]
    hdma_dac1_ch1.Init.Request = DMA_REQUEST_DAC1_CHANNEL1;
 8001556:	4b43      	ldr	r3, [pc, #268]	; (8001664 <HAL_DAC_MspInit+0x180>)
 8001558:	2206      	movs	r2, #6
 800155a:	605a      	str	r2, [r3, #4]
    hdma_dac1_ch1.Init.Direction = DMA_MEMORY_TO_PERIPH;
 800155c:	4b41      	ldr	r3, [pc, #260]	; (8001664 <HAL_DAC_MspInit+0x180>)
 800155e:	2210      	movs	r2, #16
 8001560:	609a      	str	r2, [r3, #8]
    hdma_dac1_ch1.Init.PeriphInc = DMA_PINC_DISABLE;
 8001562:	4b40      	ldr	r3, [pc, #256]	; (8001664 <HAL_DAC_MspInit+0x180>)
 8001564:	2200      	movs	r2, #0
 8001566:	60da      	str	r2, [r3, #12]
    hdma_dac1_ch1.Init.MemInc = DMA_MINC_ENABLE;
 8001568:	4b3e      	ldr	r3, [pc, #248]	; (8001664 <HAL_DAC_MspInit+0x180>)
 800156a:	2280      	movs	r2, #128	; 0x80
 800156c:	611a      	str	r2, [r3, #16]
    hdma_dac1_ch1.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 800156e:	4b3d      	ldr	r3, [pc, #244]	; (8001664 <HAL_DAC_MspInit+0x180>)
 8001570:	f44f 7200 	mov.w	r2, #512	; 0x200
 8001574:	615a      	str	r2, [r3, #20]
    hdma_dac1_ch1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 8001576:	4b3b      	ldr	r3, [pc, #236]	; (8001664 <HAL_DAC_MspInit+0x180>)
 8001578:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800157c:	619a      	str	r2, [r3, #24]
    hdma_dac1_ch1.Init.Mode = DMA_CIRCULAR;
 800157e:	4b39      	ldr	r3, [pc, #228]	; (8001664 <HAL_DAC_MspInit+0x180>)
 8001580:	2220      	movs	r2, #32
 8001582:	61da      	str	r2, [r3, #28]
    hdma_dac1_ch1.Init.Priority = DMA_PRIORITY_LOW;
 8001584:	4b37      	ldr	r3, [pc, #220]	; (8001664 <HAL_DAC_MspInit+0x180>)
 8001586:	2200      	movs	r2, #0
 8001588:	621a      	str	r2, [r3, #32]
    if (HAL_DMA_Init(&hdma_dac1_ch1) != HAL_OK)
 800158a:	4836      	ldr	r0, [pc, #216]	; (8001664 <HAL_DAC_MspInit+0x180>)
 800158c:	f007 fc0c 	bl	8008da8 <HAL_DMA_Init>
 8001590:	4603      	mov	r3, r0
 8001592:	2b00      	cmp	r3, #0
 8001594:	d001      	beq.n	800159a <HAL_DAC_MspInit+0xb6>
    {
      Error_Handler();
 8001596:	f002 ff1a 	bl	80043ce <Error_Handler>
    }

    __HAL_LINKDMA(dacHandle,DMA_Handle1,hdma_dac1_ch1);
 800159a:	687b      	ldr	r3, [r7, #4]
 800159c:	4a31      	ldr	r2, [pc, #196]	; (8001664 <HAL_DAC_MspInit+0x180>)
 800159e:	609a      	str	r2, [r3, #8]
 80015a0:	4a30      	ldr	r2, [pc, #192]	; (8001664 <HAL_DAC_MspInit+0x180>)
 80015a2:	687b      	ldr	r3, [r7, #4]
 80015a4:	6293      	str	r3, [r2, #40]	; 0x28

    /* DAC1_CH2 Init */
    hdma_dac1_ch2.Instance = DMA1_Channel4;
 80015a6:	4b31      	ldr	r3, [pc, #196]	; (800166c <HAL_DAC_MspInit+0x188>)
 80015a8:	4a31      	ldr	r2, [pc, #196]	; (8001670 <HAL_DAC_MspInit+0x18c>)
 80015aa:	601a      	str	r2, [r3, #0]
    hdma_dac1_ch2.Init.Request = DMA_REQUEST_DAC1_CHANNEL2;
 80015ac:	4b2f      	ldr	r3, [pc, #188]	; (800166c <HAL_DAC_MspInit+0x188>)
 80015ae:	2207      	movs	r2, #7
 80015b0:	605a      	str	r2, [r3, #4]
    hdma_dac1_ch2.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80015b2:	4b2e      	ldr	r3, [pc, #184]	; (800166c <HAL_DAC_MspInit+0x188>)
 80015b4:	2210      	movs	r2, #16
 80015b6:	609a      	str	r2, [r3, #8]
    hdma_dac1_ch2.Init.PeriphInc = DMA_PINC_DISABLE;
 80015b8:	4b2c      	ldr	r3, [pc, #176]	; (800166c <HAL_DAC_MspInit+0x188>)
 80015ba:	2200      	movs	r2, #0
 80015bc:	60da      	str	r2, [r3, #12]
    hdma_dac1_ch2.Init.MemInc = DMA_MINC_ENABLE;
 80015be:	4b2b      	ldr	r3, [pc, #172]	; (800166c <HAL_DAC_MspInit+0x188>)
 80015c0:	2280      	movs	r2, #128	; 0x80
 80015c2:	611a      	str	r2, [r3, #16]
    hdma_dac1_ch2.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 80015c4:	4b29      	ldr	r3, [pc, #164]	; (800166c <HAL_DAC_MspInit+0x188>)
 80015c6:	f44f 7200 	mov.w	r2, #512	; 0x200
 80015ca:	615a      	str	r2, [r3, #20]
    hdma_dac1_ch2.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 80015cc:	4b27      	ldr	r3, [pc, #156]	; (800166c <HAL_DAC_MspInit+0x188>)
 80015ce:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80015d2:	619a      	str	r2, [r3, #24]
    hdma_dac1_ch2.Init.Mode = DMA_CIRCULAR;
 80015d4:	4b25      	ldr	r3, [pc, #148]	; (800166c <HAL_DAC_MspInit+0x188>)
 80015d6:	2220      	movs	r2, #32
 80015d8:	61da      	str	r2, [r3, #28]
    hdma_dac1_ch2.Init.Priority = DMA_PRIORITY_LOW;
 80015da:	4b24      	ldr	r3, [pc, #144]	; (800166c <HAL_DAC_MspInit+0x188>)
 80015dc:	2200      	movs	r2, #0
 80015de:	621a      	str	r2, [r3, #32]
    if (HAL_DMA_Init(&hdma_dac1_ch2) != HAL_OK)
 80015e0:	4822      	ldr	r0, [pc, #136]	; (800166c <HAL_DAC_MspInit+0x188>)
 80015e2:	f007 fbe1 	bl	8008da8 <HAL_DMA_Init>
 80015e6:	4603      	mov	r3, r0
 80015e8:	2b00      	cmp	r3, #0
 80015ea:	d001      	beq.n	80015f0 <HAL_DAC_MspInit+0x10c>
    {
      Error_Handler();
 80015ec:	f002 feef 	bl	80043ce <Error_Handler>
    }

    __HAL_LINKDMA(dacHandle,DMA_Handle2,hdma_dac1_ch2);
 80015f0:	687b      	ldr	r3, [r7, #4]
 80015f2:	4a1e      	ldr	r2, [pc, #120]	; (800166c <HAL_DAC_MspInit+0x188>)
 80015f4:	60da      	str	r2, [r3, #12]
 80015f6:	4a1d      	ldr	r2, [pc, #116]	; (800166c <HAL_DAC_MspInit+0x188>)
 80015f8:	687b      	ldr	r3, [r7, #4]
 80015fa:	6293      	str	r3, [r2, #40]	; 0x28

  /* USER CODE BEGIN DAC2_MspInit 1 */

  /* USER CODE END DAC2_MspInit 1 */
  }
}
 80015fc:	e029      	b.n	8001652 <HAL_DAC_MspInit+0x16e>
  else if(dacHandle->Instance==DAC2)
 80015fe:	687b      	ldr	r3, [r7, #4]
 8001600:	681b      	ldr	r3, [r3, #0]
 8001602:	4a1c      	ldr	r2, [pc, #112]	; (8001674 <HAL_DAC_MspInit+0x190>)
 8001604:	4293      	cmp	r3, r2
 8001606:	d124      	bne.n	8001652 <HAL_DAC_MspInit+0x16e>
    __HAL_RCC_DAC2_CLK_ENABLE();
 8001608:	4b15      	ldr	r3, [pc, #84]	; (8001660 <HAL_DAC_MspInit+0x17c>)
 800160a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800160c:	4a14      	ldr	r2, [pc, #80]	; (8001660 <HAL_DAC_MspInit+0x17c>)
 800160e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001612:	64d3      	str	r3, [r2, #76]	; 0x4c
 8001614:	4b12      	ldr	r3, [pc, #72]	; (8001660 <HAL_DAC_MspInit+0x17c>)
 8001616:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001618:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800161c:	613b      	str	r3, [r7, #16]
 800161e:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001620:	4b0f      	ldr	r3, [pc, #60]	; (8001660 <HAL_DAC_MspInit+0x17c>)
 8001622:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001624:	4a0e      	ldr	r2, [pc, #56]	; (8001660 <HAL_DAC_MspInit+0x17c>)
 8001626:	f043 0301 	orr.w	r3, r3, #1
 800162a:	64d3      	str	r3, [r2, #76]	; 0x4c
 800162c:	4b0c      	ldr	r3, [pc, #48]	; (8001660 <HAL_DAC_MspInit+0x17c>)
 800162e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001630:	f003 0301 	and.w	r3, r3, #1
 8001634:	60fb      	str	r3, [r7, #12]
 8001636:	68fb      	ldr	r3, [r7, #12]
    GPIO_InitStruct.Pin = GPIO_PIN_6;
 8001638:	2340      	movs	r3, #64	; 0x40
 800163a:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800163c:	2303      	movs	r3, #3
 800163e:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001640:	2300      	movs	r3, #0
 8001642:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001644:	f107 031c 	add.w	r3, r7, #28
 8001648:	4619      	mov	r1, r3
 800164a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800164e:	f007 fedd 	bl	800940c <HAL_GPIO_Init>
}
 8001652:	bf00      	nop
 8001654:	3730      	adds	r7, #48	; 0x30
 8001656:	46bd      	mov	sp, r7
 8001658:	bd80      	pop	{r7, pc}
 800165a:	bf00      	nop
 800165c:	50000800 	.word	0x50000800
 8001660:	40021000 	.word	0x40021000
 8001664:	200006d0 	.word	0x200006d0
 8001668:	40020030 	.word	0x40020030
 800166c:	20000730 	.word	0x20000730
 8001670:	40020044 	.word	0x40020044
 8001674:	50000c00 	.word	0x50000c00

08001678 <MX_DMA_Init>:

/**
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
 8001678:	b580      	push	{r7, lr}
 800167a:	b082      	sub	sp, #8
 800167c:	af00      	add	r7, sp, #0

  /* DMA controller clock enable */
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
 800167e:	4b2a      	ldr	r3, [pc, #168]	; (8001728 <MX_DMA_Init+0xb0>)
 8001680:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001682:	4a29      	ldr	r2, [pc, #164]	; (8001728 <MX_DMA_Init+0xb0>)
 8001684:	f043 0304 	orr.w	r3, r3, #4
 8001688:	6493      	str	r3, [r2, #72]	; 0x48
 800168a:	4b27      	ldr	r3, [pc, #156]	; (8001728 <MX_DMA_Init+0xb0>)
 800168c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800168e:	f003 0304 	and.w	r3, r3, #4
 8001692:	607b      	str	r3, [r7, #4]
 8001694:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_DMA1_CLK_ENABLE();
 8001696:	4b24      	ldr	r3, [pc, #144]	; (8001728 <MX_DMA_Init+0xb0>)
 8001698:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800169a:	4a23      	ldr	r2, [pc, #140]	; (8001728 <MX_DMA_Init+0xb0>)
 800169c:	f043 0301 	orr.w	r3, r3, #1
 80016a0:	6493      	str	r3, [r2, #72]	; 0x48
 80016a2:	4b21      	ldr	r3, [pc, #132]	; (8001728 <MX_DMA_Init+0xb0>)
 80016a4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80016a6:	f003 0301 	and.w	r3, r3, #1
 80016aa:	603b      	str	r3, [r7, #0]
 80016ac:	683b      	ldr	r3, [r7, #0]

  /* DMA interrupt init */
  /* DMA1_Channel1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
 80016ae:	2200      	movs	r2, #0
 80016b0:	2100      	movs	r1, #0
 80016b2:	200b      	movs	r0, #11
 80016b4:	f006 ff89 	bl	80085ca <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 80016b8:	200b      	movs	r0, #11
 80016ba:	f006 ffa0 	bl	80085fe <HAL_NVIC_EnableIRQ>
  /* DMA1_Channel2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 0, 0);
 80016be:	2200      	movs	r2, #0
 80016c0:	2100      	movs	r1, #0
 80016c2:	200c      	movs	r0, #12
 80016c4:	f006 ff81 	bl	80085ca <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
 80016c8:	200c      	movs	r0, #12
 80016ca:	f006 ff98 	bl	80085fe <HAL_NVIC_EnableIRQ>
  /* DMA1_Channel3_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel3_IRQn, 0, 0);
 80016ce:	2200      	movs	r2, #0
 80016d0:	2100      	movs	r1, #0
 80016d2:	200d      	movs	r0, #13
 80016d4:	f006 ff79 	bl	80085ca <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel3_IRQn);
 80016d8:	200d      	movs	r0, #13
 80016da:	f006 ff90 	bl	80085fe <HAL_NVIC_EnableIRQ>
  /* DMA1_Channel4_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel4_IRQn, 0, 0);
 80016de:	2200      	movs	r2, #0
 80016e0:	2100      	movs	r1, #0
 80016e2:	200e      	movs	r0, #14
 80016e4:	f006 ff71 	bl	80085ca <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel4_IRQn);
 80016e8:	200e      	movs	r0, #14
 80016ea:	f006 ff88 	bl	80085fe <HAL_NVIC_EnableIRQ>
  /* DMA1_Channel5_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel5_IRQn, 0, 0);
 80016ee:	2200      	movs	r2, #0
 80016f0:	2100      	movs	r1, #0
 80016f2:	200f      	movs	r0, #15
 80016f4:	f006 ff69 	bl	80085ca <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
 80016f8:	200f      	movs	r0, #15
 80016fa:	f006 ff80 	bl	80085fe <HAL_NVIC_EnableIRQ>
  /* DMA1_Channel6_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel6_IRQn, 0, 0);
 80016fe:	2200      	movs	r2, #0
 8001700:	2100      	movs	r1, #0
 8001702:	2010      	movs	r0, #16
 8001704:	f006 ff61 	bl	80085ca <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel6_IRQn);
 8001708:	2010      	movs	r0, #16
 800170a:	f006 ff78 	bl	80085fe <HAL_NVIC_EnableIRQ>
  /* DMA1_Channel7_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel7_IRQn, 0, 0);
 800170e:	2200      	movs	r2, #0
 8001710:	2100      	movs	r1, #0
 8001712:	2011      	movs	r0, #17
 8001714:	f006 ff59 	bl	80085ca <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel7_IRQn);
 8001718:	2011      	movs	r0, #17
 800171a:	f006 ff70 	bl	80085fe <HAL_NVIC_EnableIRQ>

}
 800171e:	bf00      	nop
 8001720:	3708      	adds	r7, #8
 8001722:	46bd      	mov	sp, r7
 8001724:	bd80      	pop	{r7, pc}
 8001726:	bf00      	nop
 8001728:	40021000 	.word	0x40021000

0800172c <MX_FMC_Init>:

SRAM_HandleTypeDef hsram1;

/* FMC initialization function */
void MX_FMC_Init(void)
{
 800172c:	b580      	push	{r7, lr}
 800172e:	b088      	sub	sp, #32
 8001730:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN FMC_Init 0 */

  /* USER CODE END FMC_Init 0 */

  FMC_NORSRAM_TimingTypeDef Timing = {0};
 8001732:	463b      	mov	r3, r7
 8001734:	2220      	movs	r2, #32
 8001736:	2100      	movs	r1, #0
 8001738:	4618      	mov	r0, r3
 800173a:	f01c ff16 	bl	801e56a <memset>

  /* USER CODE END FMC_Init 1 */

  /** Perform the SRAM1 memory initialization sequence
  */
  hsram1.Instance = FMC_NORSRAM_DEVICE;
 800173e:	4b2e      	ldr	r3, [pc, #184]	; (80017f8 <MX_FMC_Init+0xcc>)
 8001740:	f04f 4220 	mov.w	r2, #2684354560	; 0xa0000000
 8001744:	601a      	str	r2, [r3, #0]
  hsram1.Extended = FMC_NORSRAM_EXTENDED_DEVICE;
 8001746:	4b2c      	ldr	r3, [pc, #176]	; (80017f8 <MX_FMC_Init+0xcc>)
 8001748:	4a2c      	ldr	r2, [pc, #176]	; (80017fc <MX_FMC_Init+0xd0>)
 800174a:	605a      	str	r2, [r3, #4]
  /* hsram1.Init */
  hsram1.Init.NSBank = FMC_NORSRAM_BANK1;
 800174c:	4b2a      	ldr	r3, [pc, #168]	; (80017f8 <MX_FMC_Init+0xcc>)
 800174e:	2200      	movs	r2, #0
 8001750:	609a      	str	r2, [r3, #8]
  hsram1.Init.DataAddressMux = FMC_DATA_ADDRESS_MUX_DISABLE;
 8001752:	4b29      	ldr	r3, [pc, #164]	; (80017f8 <MX_FMC_Init+0xcc>)
 8001754:	2200      	movs	r2, #0
 8001756:	60da      	str	r2, [r3, #12]
  hsram1.Init.MemoryType = FMC_MEMORY_TYPE_SRAM;
 8001758:	4b27      	ldr	r3, [pc, #156]	; (80017f8 <MX_FMC_Init+0xcc>)
 800175a:	2200      	movs	r2, #0
 800175c:	611a      	str	r2, [r3, #16]
  hsram1.Init.MemoryDataWidth = FMC_NORSRAM_MEM_BUS_WIDTH_16;
 800175e:	4b26      	ldr	r3, [pc, #152]	; (80017f8 <MX_FMC_Init+0xcc>)
 8001760:	2210      	movs	r2, #16
 8001762:	615a      	str	r2, [r3, #20]
  hsram1.Init.BurstAccessMode = FMC_BURST_ACCESS_MODE_DISABLE;
 8001764:	4b24      	ldr	r3, [pc, #144]	; (80017f8 <MX_FMC_Init+0xcc>)
 8001766:	2200      	movs	r2, #0
 8001768:	619a      	str	r2, [r3, #24]
  hsram1.Init.WaitSignalPolarity = FMC_WAIT_SIGNAL_POLARITY_LOW;
 800176a:	4b23      	ldr	r3, [pc, #140]	; (80017f8 <MX_FMC_Init+0xcc>)
 800176c:	2200      	movs	r2, #0
 800176e:	61da      	str	r2, [r3, #28]
  hsram1.Init.WaitSignalActive = FMC_WAIT_TIMING_BEFORE_WS;
 8001770:	4b21      	ldr	r3, [pc, #132]	; (80017f8 <MX_FMC_Init+0xcc>)
 8001772:	2200      	movs	r2, #0
 8001774:	621a      	str	r2, [r3, #32]
  hsram1.Init.WriteOperation = FMC_WRITE_OPERATION_ENABLE;
 8001776:	4b20      	ldr	r3, [pc, #128]	; (80017f8 <MX_FMC_Init+0xcc>)
 8001778:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800177c:	625a      	str	r2, [r3, #36]	; 0x24
  hsram1.Init.WaitSignal = FMC_WAIT_SIGNAL_DISABLE;
 800177e:	4b1e      	ldr	r3, [pc, #120]	; (80017f8 <MX_FMC_Init+0xcc>)
 8001780:	2200      	movs	r2, #0
 8001782:	629a      	str	r2, [r3, #40]	; 0x28
  hsram1.Init.ExtendedMode = FMC_EXTENDED_MODE_DISABLE;
 8001784:	4b1c      	ldr	r3, [pc, #112]	; (80017f8 <MX_FMC_Init+0xcc>)
 8001786:	2200      	movs	r2, #0
 8001788:	62da      	str	r2, [r3, #44]	; 0x2c
  hsram1.Init.AsynchronousWait = FMC_ASYNCHRONOUS_WAIT_DISABLE;
 800178a:	4b1b      	ldr	r3, [pc, #108]	; (80017f8 <MX_FMC_Init+0xcc>)
 800178c:	2200      	movs	r2, #0
 800178e:	631a      	str	r2, [r3, #48]	; 0x30
  hsram1.Init.WriteBurst = FMC_WRITE_BURST_DISABLE;
 8001790:	4b19      	ldr	r3, [pc, #100]	; (80017f8 <MX_FMC_Init+0xcc>)
 8001792:	2200      	movs	r2, #0
 8001794:	635a      	str	r2, [r3, #52]	; 0x34
  hsram1.Init.ContinuousClock = FMC_CONTINUOUS_CLOCK_SYNC_ONLY;
 8001796:	4b18      	ldr	r3, [pc, #96]	; (80017f8 <MX_FMC_Init+0xcc>)
 8001798:	2200      	movs	r2, #0
 800179a:	639a      	str	r2, [r3, #56]	; 0x38
  hsram1.Init.WriteFifo = FMC_WRITE_FIFO_DISABLE;
 800179c:	4b16      	ldr	r3, [pc, #88]	; (80017f8 <MX_FMC_Init+0xcc>)
 800179e:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 80017a2:	63da      	str	r2, [r3, #60]	; 0x3c
  hsram1.Init.NBLSetupTime = 0;
 80017a4:	4b14      	ldr	r3, [pc, #80]	; (80017f8 <MX_FMC_Init+0xcc>)
 80017a6:	2200      	movs	r2, #0
 80017a8:	645a      	str	r2, [r3, #68]	; 0x44
  hsram1.Init.PageSize = FMC_PAGE_SIZE_NONE;
 80017aa:	4b13      	ldr	r3, [pc, #76]	; (80017f8 <MX_FMC_Init+0xcc>)
 80017ac:	2200      	movs	r2, #0
 80017ae:	641a      	str	r2, [r3, #64]	; 0x40
  hsram1.Init.MaxChipSelectPulse = DISABLE;
 80017b0:	4b11      	ldr	r3, [pc, #68]	; (80017f8 <MX_FMC_Init+0xcc>)
 80017b2:	2200      	movs	r2, #0
 80017b4:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
  /* Timing */
  Timing.AddressSetupTime = 15;
 80017b8:	230f      	movs	r3, #15
 80017ba:	603b      	str	r3, [r7, #0]
  Timing.AddressHoldTime = 15;
 80017bc:	230f      	movs	r3, #15
 80017be:	607b      	str	r3, [r7, #4]
  Timing.DataSetupTime = 15;
 80017c0:	230f      	movs	r3, #15
 80017c2:	60bb      	str	r3, [r7, #8]
  Timing.DataHoldTime = 0;
 80017c4:	2300      	movs	r3, #0
 80017c6:	60fb      	str	r3, [r7, #12]
  Timing.BusTurnAroundDuration = 15;
 80017c8:	230f      	movs	r3, #15
 80017ca:	613b      	str	r3, [r7, #16]
  Timing.CLKDivision = 16;
 80017cc:	2310      	movs	r3, #16
 80017ce:	617b      	str	r3, [r7, #20]
  Timing.DataLatency = 17;
 80017d0:	2311      	movs	r3, #17
 80017d2:	61bb      	str	r3, [r7, #24]
  Timing.AccessMode = FMC_ACCESS_MODE_A;
 80017d4:	2300      	movs	r3, #0
 80017d6:	61fb      	str	r3, [r7, #28]
  /* ExtTiming */

  if (HAL_SRAM_Init(&hsram1, &Timing, NULL) != HAL_OK)
 80017d8:	463b      	mov	r3, r7
 80017da:	2200      	movs	r2, #0
 80017dc:	4619      	mov	r1, r3
 80017de:	4806      	ldr	r0, [pc, #24]	; (80017f8 <MX_FMC_Init+0xcc>)
 80017e0:	f009 ffb6 	bl	800b750 <HAL_SRAM_Init>
 80017e4:	4603      	mov	r3, r0
 80017e6:	2b00      	cmp	r3, #0
 80017e8:	d001      	beq.n	80017ee <MX_FMC_Init+0xc2>
  {
    Error_Handler( );
 80017ea:	f002 fdf0 	bl	80043ce <Error_Handler>
  }

  /* USER CODE BEGIN FMC_Init 2 */

  /* USER CODE END FMC_Init 2 */
}
 80017ee:	bf00      	nop
 80017f0:	3720      	adds	r7, #32
 80017f2:	46bd      	mov	sp, r7
 80017f4:	bd80      	pop	{r7, pc}
 80017f6:	bf00      	nop
 80017f8:	20000790 	.word	0x20000790
 80017fc:	a0000104 	.word	0xa0000104

08001800 <HAL_FMC_MspInit>:

static uint32_t FMC_Initialized = 0;

static void HAL_FMC_MspInit(void){
 8001800:	b580      	push	{r7, lr}
 8001802:	b086      	sub	sp, #24
 8001804:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN FMC_MspInit 0 */

  /* USER CODE END FMC_MspInit 0 */
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001806:	1d3b      	adds	r3, r7, #4
 8001808:	2200      	movs	r2, #0
 800180a:	601a      	str	r2, [r3, #0]
 800180c:	605a      	str	r2, [r3, #4]
 800180e:	609a      	str	r2, [r3, #8]
 8001810:	60da      	str	r2, [r3, #12]
 8001812:	611a      	str	r2, [r3, #16]
  if (FMC_Initialized) {
 8001814:	4b23      	ldr	r3, [pc, #140]	; (80018a4 <HAL_FMC_MspInit+0xa4>)
 8001816:	681b      	ldr	r3, [r3, #0]
 8001818:	2b00      	cmp	r3, #0
 800181a:	d13f      	bne.n	800189c <HAL_FMC_MspInit+0x9c>
    return;
  }
  FMC_Initialized = 1;
 800181c:	4b21      	ldr	r3, [pc, #132]	; (80018a4 <HAL_FMC_MspInit+0xa4>)
 800181e:	2201      	movs	r2, #1
 8001820:	601a      	str	r2, [r3, #0]

  /* Peripheral clock enable */
  __HAL_RCC_FMC_CLK_ENABLE();
 8001822:	4b21      	ldr	r3, [pc, #132]	; (80018a8 <HAL_FMC_MspInit+0xa8>)
 8001824:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001826:	4a20      	ldr	r2, [pc, #128]	; (80018a8 <HAL_FMC_MspInit+0xa8>)
 8001828:	f043 0301 	orr.w	r3, r3, #1
 800182c:	6513      	str	r3, [r2, #80]	; 0x50
 800182e:	4b1e      	ldr	r3, [pc, #120]	; (80018a8 <HAL_FMC_MspInit+0xa8>)
 8001830:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001832:	f003 0301 	and.w	r3, r3, #1
 8001836:	603b      	str	r3, [r7, #0]
 8001838:	683b      	ldr	r3, [r7, #0]
  PD4   ------> FMC_NOE
  PD5   ------> FMC_NWE
  PD7   ------> FMC_NE1
  */
  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_10;
 800183a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800183e:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001840:	2302      	movs	r3, #2
 8001842:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001844:	2300      	movs	r3, #0
 8001846:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001848:	2303      	movs	r3, #3
 800184a:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 800184c:	230c      	movs	r3, #12
 800184e:	617b      	str	r3, [r7, #20]

  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8001850:	1d3b      	adds	r3, r7, #4
 8001852:	4619      	mov	r1, r3
 8001854:	4815      	ldr	r0, [pc, #84]	; (80018ac <HAL_FMC_MspInit+0xac>)
 8001856:	f007 fdd9 	bl	800940c <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10
 800185a:	f64f 7380 	movw	r3, #65408	; 0xff80
 800185e:	607b      	str	r3, [r7, #4]
                          |GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14
                          |GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001860:	2302      	movs	r3, #2
 8001862:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001864:	2300      	movs	r3, #0
 8001866:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001868:	2303      	movs	r3, #3
 800186a:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 800186c:	230c      	movs	r3, #12
 800186e:	617b      	str	r3, [r7, #20]

  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8001870:	1d3b      	adds	r3, r7, #4
 8001872:	4619      	mov	r1, r3
 8001874:	480e      	ldr	r0, [pc, #56]	; (80018b0 <HAL_FMC_MspInit+0xb0>)
 8001876:	f007 fdc9 	bl	800940c <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14
 800187a:	f24c 73b3 	movw	r3, #51123	; 0xc7b3
 800187e:	607b      	str	r3, [r7, #4]
                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4
                          |GPIO_PIN_5|GPIO_PIN_7;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001880:	2302      	movs	r3, #2
 8001882:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001884:	2300      	movs	r3, #0
 8001886:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001888:	2303      	movs	r3, #3
 800188a:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 800188c:	230c      	movs	r3, #12
 800188e:	617b      	str	r3, [r7, #20]

  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8001890:	1d3b      	adds	r3, r7, #4
 8001892:	4619      	mov	r1, r3
 8001894:	4807      	ldr	r0, [pc, #28]	; (80018b4 <HAL_FMC_MspInit+0xb4>)
 8001896:	f007 fdb9 	bl	800940c <HAL_GPIO_Init>
 800189a:	e000      	b.n	800189e <HAL_FMC_MspInit+0x9e>
    return;
 800189c:	bf00      	nop

  /* USER CODE BEGIN FMC_MspInit 1 */

  /* USER CODE END FMC_MspInit 1 */
}
 800189e:	3718      	adds	r7, #24
 80018a0:	46bd      	mov	sp, r7
 80018a2:	bd80      	pop	{r7, pc}
 80018a4:	200007e8 	.word	0x200007e8
 80018a8:	40021000 	.word	0x40021000
 80018ac:	48001400 	.word	0x48001400
 80018b0:	48001000 	.word	0x48001000
 80018b4:	48000c00 	.word	0x48000c00

080018b8 <HAL_SRAM_MspInit>:

void HAL_SRAM_MspInit(SRAM_HandleTypeDef* sramHandle){
 80018b8:	b580      	push	{r7, lr}
 80018ba:	b082      	sub	sp, #8
 80018bc:	af00      	add	r7, sp, #0
 80018be:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN SRAM_MspInit 0 */

  /* USER CODE END SRAM_MspInit 0 */
  HAL_FMC_MspInit();
 80018c0:	f7ff ff9e 	bl	8001800 <HAL_FMC_MspInit>
  /* USER CODE BEGIN SRAM_MspInit 1 */

  /* USER CODE END SRAM_MspInit 1 */
}
 80018c4:	bf00      	nop
 80018c6:	3708      	adds	r7, #8
 80018c8:	46bd      	mov	sp, r7
 80018ca:	bd80      	pop	{r7, pc}

080018cc <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 80018cc:	b580      	push	{r7, lr}
 80018ce:	b08c      	sub	sp, #48	; 0x30
 80018d0:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80018d2:	f107 031c 	add.w	r3, r7, #28
 80018d6:	2200      	movs	r2, #0
 80018d8:	601a      	str	r2, [r3, #0]
 80018da:	605a      	str	r2, [r3, #4]
 80018dc:	609a      	str	r2, [r3, #8]
 80018de:	60da      	str	r2, [r3, #12]
 80018e0:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOF_CLK_ENABLE();
 80018e2:	4b31      	ldr	r3, [pc, #196]	; (80019a8 <MX_GPIO_Init+0xdc>)
 80018e4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80018e6:	4a30      	ldr	r2, [pc, #192]	; (80019a8 <MX_GPIO_Init+0xdc>)
 80018e8:	f043 0320 	orr.w	r3, r3, #32
 80018ec:	64d3      	str	r3, [r2, #76]	; 0x4c
 80018ee:	4b2e      	ldr	r3, [pc, #184]	; (80019a8 <MX_GPIO_Init+0xdc>)
 80018f0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80018f2:	f003 0320 	and.w	r3, r3, #32
 80018f6:	61bb      	str	r3, [r7, #24]
 80018f8:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80018fa:	4b2b      	ldr	r3, [pc, #172]	; (80019a8 <MX_GPIO_Init+0xdc>)
 80018fc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80018fe:	4a2a      	ldr	r2, [pc, #168]	; (80019a8 <MX_GPIO_Init+0xdc>)
 8001900:	f043 0304 	orr.w	r3, r3, #4
 8001904:	64d3      	str	r3, [r2, #76]	; 0x4c
 8001906:	4b28      	ldr	r3, [pc, #160]	; (80019a8 <MX_GPIO_Init+0xdc>)
 8001908:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800190a:	f003 0304 	and.w	r3, r3, #4
 800190e:	617b      	str	r3, [r7, #20]
 8001910:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001912:	4b25      	ldr	r3, [pc, #148]	; (80019a8 <MX_GPIO_Init+0xdc>)
 8001914:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001916:	4a24      	ldr	r2, [pc, #144]	; (80019a8 <MX_GPIO_Init+0xdc>)
 8001918:	f043 0301 	orr.w	r3, r3, #1
 800191c:	64d3      	str	r3, [r2, #76]	; 0x4c
 800191e:	4b22      	ldr	r3, [pc, #136]	; (80019a8 <MX_GPIO_Init+0xdc>)
 8001920:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001922:	f003 0301 	and.w	r3, r3, #1
 8001926:	613b      	str	r3, [r7, #16]
 8001928:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800192a:	4b1f      	ldr	r3, [pc, #124]	; (80019a8 <MX_GPIO_Init+0xdc>)
 800192c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800192e:	4a1e      	ldr	r2, [pc, #120]	; (80019a8 <MX_GPIO_Init+0xdc>)
 8001930:	f043 0302 	orr.w	r3, r3, #2
 8001934:	64d3      	str	r3, [r2, #76]	; 0x4c
 8001936:	4b1c      	ldr	r3, [pc, #112]	; (80019a8 <MX_GPIO_Init+0xdc>)
 8001938:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800193a:	f003 0302 	and.w	r3, r3, #2
 800193e:	60fb      	str	r3, [r7, #12]
 8001940:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8001942:	4b19      	ldr	r3, [pc, #100]	; (80019a8 <MX_GPIO_Init+0xdc>)
 8001944:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001946:	4a18      	ldr	r2, [pc, #96]	; (80019a8 <MX_GPIO_Init+0xdc>)
 8001948:	f043 0310 	orr.w	r3, r3, #16
 800194c:	64d3      	str	r3, [r2, #76]	; 0x4c
 800194e:	4b16      	ldr	r3, [pc, #88]	; (80019a8 <MX_GPIO_Init+0xdc>)
 8001950:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001952:	f003 0310 	and.w	r3, r3, #16
 8001956:	60bb      	str	r3, [r7, #8]
 8001958:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 800195a:	4b13      	ldr	r3, [pc, #76]	; (80019a8 <MX_GPIO_Init+0xdc>)
 800195c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800195e:	4a12      	ldr	r2, [pc, #72]	; (80019a8 <MX_GPIO_Init+0xdc>)
 8001960:	f043 0308 	orr.w	r3, r3, #8
 8001964:	64d3      	str	r3, [r2, #76]	; 0x4c
 8001966:	4b10      	ldr	r3, [pc, #64]	; (80019a8 <MX_GPIO_Init+0xdc>)
 8001968:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800196a:	f003 0308 	and.w	r3, r3, #8
 800196e:	607b      	str	r3, [r7, #4]
 8001970:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_2|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_15, GPIO_PIN_RESET);
 8001972:	2200      	movs	r2, #0
 8001974:	f248 3104 	movw	r1, #33540	; 0x8304
 8001978:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800197c:	f007 fec8 	bl	8009710 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PA2 PA8 PA9 PA15 */
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_15;
 8001980:	f248 3304 	movw	r3, #33540	; 0x8304
 8001984:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001986:	2301      	movs	r3, #1
 8001988:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800198a:	2300      	movs	r3, #0
 800198c:	627b      	str	r3, [r7, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800198e:	2300      	movs	r3, #0
 8001990:	62bb      	str	r3, [r7, #40]	; 0x28
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001992:	f107 031c 	add.w	r3, r7, #28
 8001996:	4619      	mov	r1, r3
 8001998:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800199c:	f007 fd36 	bl	800940c <HAL_GPIO_Init>

}
 80019a0:	bf00      	nop
 80019a2:	3730      	adds	r7, #48	; 0x30
 80019a4:	46bd      	mov	sp, r7
 80019a6:	bd80      	pop	{r7, pc}
 80019a8:	40021000 	.word	0x40021000

080019ac <ITM_SendChar>:
           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
  \param [in]     ch  Character to transmit.
  \returns            Character to transmit.
 */
__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
{
 80019ac:	b480      	push	{r7}
 80019ae:	b083      	sub	sp, #12
 80019b0:	af00      	add	r7, sp, #0
 80019b2:	6078      	str	r0, [r7, #4]
  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
 80019b4:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
 80019b8:	f8d3 3e80 	ldr.w	r3, [r3, #3712]	; 0xe80
 80019bc:	f003 0301 	and.w	r3, r3, #1
 80019c0:	2b00      	cmp	r3, #0
 80019c2:	d013      	beq.n	80019ec <ITM_SendChar+0x40>
      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
 80019c4:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
 80019c8:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 80019cc:	f003 0301 	and.w	r3, r3, #1
  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
 80019d0:	2b00      	cmp	r3, #0
 80019d2:	d00b      	beq.n	80019ec <ITM_SendChar+0x40>
  {
    while (ITM->PORT[0U].u32 == 0UL)
 80019d4:	e000      	b.n	80019d8 <ITM_SendChar+0x2c>
    {
      __NOP();
 80019d6:	bf00      	nop
    while (ITM->PORT[0U].u32 == 0UL)
 80019d8:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
 80019dc:	681b      	ldr	r3, [r3, #0]
 80019de:	2b00      	cmp	r3, #0
 80019e0:	d0f9      	beq.n	80019d6 <ITM_SendChar+0x2a>
    }
    ITM->PORT[0U].u8 = (uint8_t)ch;
 80019e2:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
 80019e6:	687a      	ldr	r2, [r7, #4]
 80019e8:	b2d2      	uxtb	r2, r2
 80019ea:	701a      	strb	r2, [r3, #0]
  }
  return (ch);
 80019ec:	687b      	ldr	r3, [r7, #4]
}
 80019ee:	4618      	mov	r0, r3
 80019f0:	370c      	adds	r7, #12
 80019f2:	46bd      	mov	sp, r7
 80019f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80019f8:	4770      	bx	lr

080019fa <_write>:
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
int _write(int file, char *ptr, int len)
{
 80019fa:	b580      	push	{r7, lr}
 80019fc:	b086      	sub	sp, #24
 80019fe:	af00      	add	r7, sp, #0
 8001a00:	60f8      	str	r0, [r7, #12]
 8001a02:	60b9      	str	r1, [r7, #8]
 8001a04:	607a      	str	r2, [r7, #4]
	int DataIdx;
	for(DataIdx = 0; DataIdx < len; DataIdx++)
 8001a06:	2300      	movs	r3, #0
 8001a08:	617b      	str	r3, [r7, #20]
 8001a0a:	e009      	b.n	8001a20 <_write+0x26>
	{
		ITM_SendChar(*ptr++);
 8001a0c:	68bb      	ldr	r3, [r7, #8]
 8001a0e:	1c5a      	adds	r2, r3, #1
 8001a10:	60ba      	str	r2, [r7, #8]
 8001a12:	781b      	ldrb	r3, [r3, #0]
 8001a14:	4618      	mov	r0, r3
 8001a16:	f7ff ffc9 	bl	80019ac <ITM_SendChar>
	for(DataIdx = 0; DataIdx < len; DataIdx++)
 8001a1a:	697b      	ldr	r3, [r7, #20]
 8001a1c:	3301      	adds	r3, #1
 8001a1e:	617b      	str	r3, [r7, #20]
 8001a20:	697a      	ldr	r2, [r7, #20]
 8001a22:	687b      	ldr	r3, [r7, #4]
 8001a24:	429a      	cmp	r2, r3
 8001a26:	dbf1      	blt.n	8001a0c <_write+0x12>
	}
    return len;
 8001a28:	687b      	ldr	r3, [r7, #4]
}
 8001a2a:	4618      	mov	r0, r3
 8001a2c:	3718      	adds	r7, #24
 8001a2e:	46bd      	mov	sp, r7
 8001a30:	bd80      	pop	{r7, pc}
	...

08001a34 <get_systick>:

int32_t get_systick()
{
 8001a34:	b480      	push	{r7}
 8001a36:	af00      	add	r7, sp, #0
	return SysTick->VAL;
 8001a38:	4b03      	ldr	r3, [pc, #12]	; (8001a48 <get_systick+0x14>)
 8001a3a:	689b      	ldr	r3, [r3, #8]
}
 8001a3c:	4618      	mov	r0, r3
 8001a3e:	46bd      	mov	sp, r7
 8001a40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a44:	4770      	bx	lr
 8001a46:	bf00      	nop
 8001a48:	e000e010 	.word	0xe000e010

08001a4c <diff_systick>:

int32_t diff_systick( int32_t b, int32_t a )
{
 8001a4c:	b480      	push	{r7}
 8001a4e:	b085      	sub	sp, #20
 8001a50:	af00      	add	r7, sp, #0
 8001a52:	6078      	str	r0, [r7, #4]
 8001a54:	6039      	str	r1, [r7, #0]
	int d = 0;
 8001a56:	2300      	movs	r3, #0
 8001a58:	60fb      	str	r3, [r7, #12]
	if( b < a )
 8001a5a:	687a      	ldr	r2, [r7, #4]
 8001a5c:	683b      	ldr	r3, [r7, #0]
 8001a5e:	429a      	cmp	r2, r3
 8001a60:	da04      	bge.n	8001a6c <diff_systick+0x20>
	{
	  d = a-b;
 8001a62:	683a      	ldr	r2, [r7, #0]
 8001a64:	687b      	ldr	r3, [r7, #4]
 8001a66:	1ad3      	subs	r3, r2, r3
 8001a68:	60fb      	str	r3, [r7, #12]
 8001a6a:	e006      	b.n	8001a7a <diff_systick+0x2e>
	}
	else
	{
	  d = a+(SysTick->LOAD-b);
 8001a6c:	4b06      	ldr	r3, [pc, #24]	; (8001a88 <diff_systick+0x3c>)
 8001a6e:	685a      	ldr	r2, [r3, #4]
 8001a70:	687b      	ldr	r3, [r7, #4]
 8001a72:	1ad2      	subs	r2, r2, r3
 8001a74:	683b      	ldr	r3, [r7, #0]
 8001a76:	4413      	add	r3, r2
 8001a78:	60fb      	str	r3, [r7, #12]
	}
	return d;
 8001a7a:	68fb      	ldr	r3, [r7, #12]
}
 8001a7c:	4618      	mov	r0, r3
 8001a7e:	3714      	adds	r7, #20
 8001a80:	46bd      	mov	sp, r7
 8001a82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a86:	4770      	bx	lr
 8001a88:	e000e010 	.word	0xe000e010

08001a8c <text_width_f>:
void draw_char( const tFramebuf *fb, const tFont *pFont, int16_t x0, int16_t y0, uint8_t c, uint32_t color );
tRectangle get_char_rect( const tFont *pFont, uint8_t c );
tRectangle get_text_rect( const tFont *pFont, char *pString );

float text_width_f( nk_handle handle, float h, const char* t, int len )
{
 8001a8c:	b580      	push	{r7, lr}
 8001a8e:	b086      	sub	sp, #24
 8001a90:	af00      	add	r7, sp, #0
 8001a92:	60f8      	str	r0, [r7, #12]
 8001a94:	ed87 0a02 	vstr	s0, [r7, #8]
 8001a98:	6079      	str	r1, [r7, #4]
 8001a9a:	603a      	str	r2, [r7, #0]

	return get_text_rect( &fontUbuntuBookRNormal16, t ).width;
 8001a9c:	f107 0310 	add.w	r3, r7, #16
 8001aa0:	687a      	ldr	r2, [r7, #4]
 8001aa2:	4907      	ldr	r1, [pc, #28]	; (8001ac0 <text_width_f+0x34>)
 8001aa4:	4618      	mov	r0, r3
 8001aa6:	f000 fc30 	bl	800230a <get_text_rect>
 8001aaa:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8001aae:	ee07 3a90 	vmov	s15, r3
 8001ab2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
}
 8001ab6:	eeb0 0a67 	vmov.f32	s0, s15
 8001aba:	3718      	adds	r7, #24
 8001abc:	46bd      	mov	sp, r7
 8001abe:	bd80      	pop	{r7, pc}
 8001ac0:	08023160 	.word	0x08023160

08001ac4 <lcd_config>:

void lcd_config( void );
void lcd_rect( int16_t x, int16_t y, int16_t w, int16_t h, uint32_t color );

void lcd_config( void )
{
 8001ac4:	b580      	push	{r7, lr}
 8001ac6:	b082      	sub	sp, #8
 8001ac8:	af02      	add	r7, sp, #8
	HAL_GPIO_WritePin( GPIOA, GPIO_PIN_8, GPIO_PIN_SET );
 8001aca:	2201      	movs	r2, #1
 8001acc:	f44f 7180 	mov.w	r1, #256	; 0x100
 8001ad0:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001ad4:	f007 fe1c 	bl	8009710 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin( GPIOA, GPIO_PIN_9, GPIO_PIN_RESET );
 8001ad8:	2200      	movs	r2, #0
 8001ada:	f44f 7100 	mov.w	r1, #512	; 0x200
 8001ade:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001ae2:	f007 fe15 	bl	8009710 <HAL_GPIO_WritePin>
	HAL_Delay( 10 );
 8001ae6:	200a      	movs	r0, #10
 8001ae8:	f004 f940 	bl	8005d6c <HAL_Delay>
	HAL_GPIO_WritePin( GPIOA, GPIO_PIN_9, GPIO_PIN_SET );
 8001aec:	2201      	movs	r2, #1
 8001aee:	f44f 7100 	mov.w	r1, #512	; 0x200
 8001af2:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001af6:	f007 fe0b 	bl	8009710 <HAL_GPIO_WritePin>
	HAL_Delay( 100 );
 8001afa:	2064      	movs	r0, #100	; 0x64
 8001afc:	f004 f936 	bl	8005d6c <HAL_Delay>

	*addr_cmd = 0x01;
 8001b00:	4b18      	ldr	r3, [pc, #96]	; (8001b64 <lcd_config+0xa0>)
 8001b02:	681b      	ldr	r3, [r3, #0]
 8001b04:	2201      	movs	r2, #1
 8001b06:	801a      	strh	r2, [r3, #0]
	HAL_Delay( 100 );
 8001b08:	2064      	movs	r0, #100	; 0x64
 8001b0a:	f004 f92f 	bl	8005d6c <HAL_Delay>
	*addr_cmd = 0x11;
 8001b0e:	4b15      	ldr	r3, [pc, #84]	; (8001b64 <lcd_config+0xa0>)
 8001b10:	681b      	ldr	r3, [r3, #0]
 8001b12:	2211      	movs	r2, #17
 8001b14:	801a      	strh	r2, [r3, #0]
	HAL_Delay( 10 );
 8001b16:	200a      	movs	r0, #10
 8001b18:	f004 f928 	bl	8005d6c <HAL_Delay>
	*addr_cmd = 0x3A;
 8001b1c:	4b11      	ldr	r3, [pc, #68]	; (8001b64 <lcd_config+0xa0>)
 8001b1e:	681b      	ldr	r3, [r3, #0]
 8001b20:	223a      	movs	r2, #58	; 0x3a
 8001b22:	801a      	strh	r2, [r3, #0]
	*addr_data = 0x06;//0x05;
 8001b24:	4b10      	ldr	r3, [pc, #64]	; (8001b68 <lcd_config+0xa4>)
 8001b26:	681b      	ldr	r3, [r3, #0]
 8001b28:	2206      	movs	r2, #6
 8001b2a:	801a      	strh	r2, [r3, #0]
	*addr_cmd = 0x36;
 8001b2c:	4b0d      	ldr	r3, [pc, #52]	; (8001b64 <lcd_config+0xa0>)
 8001b2e:	681b      	ldr	r3, [r3, #0]
 8001b30:	2236      	movs	r2, #54	; 0x36
 8001b32:	801a      	strh	r2, [r3, #0]
	*addr_data = (0x01<<5)|(0x01<<6)|(0x01<<7);
 8001b34:	4b0c      	ldr	r3, [pc, #48]	; (8001b68 <lcd_config+0xa4>)
 8001b36:	681b      	ldr	r3, [r3, #0]
 8001b38:	22e0      	movs	r2, #224	; 0xe0
 8001b3a:	801a      	strh	r2, [r3, #0]
	*addr_cmd = 0x29;
 8001b3c:	4b09      	ldr	r3, [pc, #36]	; (8001b64 <lcd_config+0xa0>)
 8001b3e:	681b      	ldr	r3, [r3, #0]
 8001b40:	2229      	movs	r2, #41	; 0x29
 8001b42:	801a      	strh	r2, [r3, #0]
	HAL_Delay( 10 );
 8001b44:	200a      	movs	r0, #10
 8001b46:	f004 f911 	bl	8005d6c <HAL_Delay>

	lcd_rect( 0, 0, 480, 320, 0x0000 );
 8001b4a:	2300      	movs	r3, #0
 8001b4c:	9300      	str	r3, [sp, #0]
 8001b4e:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8001b52:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 8001b56:	2100      	movs	r1, #0
 8001b58:	2000      	movs	r0, #0
 8001b5a:	f000 f867 	bl	8001c2c <lcd_rect>
}
 8001b5e:	bf00      	nop
 8001b60:	46bd      	mov	sp, r7
 8001b62:	bd80      	pop	{r7, pc}
 8001b64:	20000000 	.word	0x20000000
 8001b68:	20000004 	.word	0x20000004

08001b6c <nk_colot_to_rgb666>:

uint32_t nk_colot_to_rgb666( struct nk_color color )
{
 8001b6c:	b580      	push	{r7, lr}
 8001b6e:	b084      	sub	sp, #16
 8001b70:	af00      	add	r7, sp, #0
 8001b72:	6078      	str	r0, [r7, #4]
	uint32_t rgb666 = 0;
 8001b74:	2300      	movs	r3, #0
 8001b76:	60fb      	str	r3, [r7, #12]

	color.r = (color.r*color.a)/256.0;
 8001b78:	793b      	ldrb	r3, [r7, #4]
 8001b7a:	79fa      	ldrb	r2, [r7, #7]
 8001b7c:	fb02 f303 	mul.w	r3, r2, r3
 8001b80:	4618      	mov	r0, r3
 8001b82:	f7fe fcf7 	bl	8000574 <__aeabi_i2d>
 8001b86:	f04f 0200 	mov.w	r2, #0
 8001b8a:	4b27      	ldr	r3, [pc, #156]	; (8001c28 <nk_colot_to_rgb666+0xbc>)
 8001b8c:	f7fe fe86 	bl	800089c <__aeabi_ddiv>
 8001b90:	4602      	mov	r2, r0
 8001b92:	460b      	mov	r3, r1
 8001b94:	4610      	mov	r0, r2
 8001b96:	4619      	mov	r1, r3
 8001b98:	f7ff f82e 	bl	8000bf8 <__aeabi_d2uiz>
 8001b9c:	4603      	mov	r3, r0
 8001b9e:	b2db      	uxtb	r3, r3
 8001ba0:	713b      	strb	r3, [r7, #4]
	color.g = (color.g*color.a)/256.0;
 8001ba2:	797b      	ldrb	r3, [r7, #5]
 8001ba4:	79fa      	ldrb	r2, [r7, #7]
 8001ba6:	fb02 f303 	mul.w	r3, r2, r3
 8001baa:	4618      	mov	r0, r3
 8001bac:	f7fe fce2 	bl	8000574 <__aeabi_i2d>
 8001bb0:	f04f 0200 	mov.w	r2, #0
 8001bb4:	4b1c      	ldr	r3, [pc, #112]	; (8001c28 <nk_colot_to_rgb666+0xbc>)
 8001bb6:	f7fe fe71 	bl	800089c <__aeabi_ddiv>
 8001bba:	4602      	mov	r2, r0
 8001bbc:	460b      	mov	r3, r1
 8001bbe:	4610      	mov	r0, r2
 8001bc0:	4619      	mov	r1, r3
 8001bc2:	f7ff f819 	bl	8000bf8 <__aeabi_d2uiz>
 8001bc6:	4603      	mov	r3, r0
 8001bc8:	b2db      	uxtb	r3, r3
 8001bca:	717b      	strb	r3, [r7, #5]
	color.b = (color.b*color.a)/256.0;
 8001bcc:	79bb      	ldrb	r3, [r7, #6]
 8001bce:	79fa      	ldrb	r2, [r7, #7]
 8001bd0:	fb02 f303 	mul.w	r3, r2, r3
 8001bd4:	4618      	mov	r0, r3
 8001bd6:	f7fe fccd 	bl	8000574 <__aeabi_i2d>
 8001bda:	f04f 0200 	mov.w	r2, #0
 8001bde:	4b12      	ldr	r3, [pc, #72]	; (8001c28 <nk_colot_to_rgb666+0xbc>)
 8001be0:	f7fe fe5c 	bl	800089c <__aeabi_ddiv>
 8001be4:	4602      	mov	r2, r0
 8001be6:	460b      	mov	r3, r1
 8001be8:	4610      	mov	r0, r2
 8001bea:	4619      	mov	r1, r3
 8001bec:	f7ff f804 	bl	8000bf8 <__aeabi_d2uiz>
 8001bf0:	4603      	mov	r3, r0
 8001bf2:	b2db      	uxtb	r3, r3
 8001bf4:	71bb      	strb	r3, [r7, #6]

	color.r >>= 2;
 8001bf6:	793b      	ldrb	r3, [r7, #4]
 8001bf8:	089b      	lsrs	r3, r3, #2
 8001bfa:	b2db      	uxtb	r3, r3
 8001bfc:	713b      	strb	r3, [r7, #4]
	color.g >>= 2;
 8001bfe:	797b      	ldrb	r3, [r7, #5]
 8001c00:	089b      	lsrs	r3, r3, #2
 8001c02:	b2db      	uxtb	r3, r3
 8001c04:	717b      	strb	r3, [r7, #5]
	color.b >>= 2;
 8001c06:	79bb      	ldrb	r3, [r7, #6]
 8001c08:	089b      	lsrs	r3, r3, #2
 8001c0a:	b2db      	uxtb	r3, r3
 8001c0c:	71bb      	strb	r3, [r7, #6]
	rgb666 = (color.r<<12) | (color.g<<6) | (color.b<<0);
 8001c0e:	793b      	ldrb	r3, [r7, #4]
 8001c10:	031a      	lsls	r2, r3, #12
 8001c12:	797b      	ldrb	r3, [r7, #5]
 8001c14:	019b      	lsls	r3, r3, #6
 8001c16:	4313      	orrs	r3, r2
 8001c18:	79ba      	ldrb	r2, [r7, #6]
 8001c1a:	4313      	orrs	r3, r2
 8001c1c:	60fb      	str	r3, [r7, #12]
	return rgb666;
 8001c1e:	68fb      	ldr	r3, [r7, #12]
}
 8001c20:	4618      	mov	r0, r3
 8001c22:	3710      	adds	r7, #16
 8001c24:	46bd      	mov	sp, r7
 8001c26:	bd80      	pop	{r7, pc}
 8001c28:	40700000 	.word	0x40700000

08001c2c <lcd_rect>:

void lcd_rect( int16_t x, int16_t y, int16_t w, int16_t h, uint32_t color )
{
 8001c2c:	b490      	push	{r4, r7}
 8001c2e:	b08a      	sub	sp, #40	; 0x28
 8001c30:	af00      	add	r7, sp, #0
 8001c32:	4604      	mov	r4, r0
 8001c34:	4608      	mov	r0, r1
 8001c36:	4611      	mov	r1, r2
 8001c38:	461a      	mov	r2, r3
 8001c3a:	4623      	mov	r3, r4
 8001c3c:	80fb      	strh	r3, [r7, #6]
 8001c3e:	4603      	mov	r3, r0
 8001c40:	80bb      	strh	r3, [r7, #4]
 8001c42:	460b      	mov	r3, r1
 8001c44:	807b      	strh	r3, [r7, #2]
 8001c46:	4613      	mov	r3, r2
 8001c48:	803b      	strh	r3, [r7, #0]
	int16_t x0 = x;
 8001c4a:	88fb      	ldrh	r3, [r7, #6]
 8001c4c:	84fb      	strh	r3, [r7, #38]	; 0x26
	int16_t y0 = y;
 8001c4e:	88bb      	ldrh	r3, [r7, #4]
 8001c50:	84bb      	strh	r3, [r7, #36]	; 0x24
	int16_t x1 = x + w - 1;
 8001c52:	88fa      	ldrh	r2, [r7, #6]
 8001c54:	887b      	ldrh	r3, [r7, #2]
 8001c56:	4413      	add	r3, r2
 8001c58:	b29b      	uxth	r3, r3
 8001c5a:	3b01      	subs	r3, #1
 8001c5c:	b29b      	uxth	r3, r3
 8001c5e:	847b      	strh	r3, [r7, #34]	; 0x22
	int16_t y1 = y + h - 1;
 8001c60:	88ba      	ldrh	r2, [r7, #4]
 8001c62:	883b      	ldrh	r3, [r7, #0]
 8001c64:	4413      	add	r3, r2
 8001c66:	b29b      	uxth	r3, r3
 8001c68:	3b01      	subs	r3, #1
 8001c6a:	b29b      	uxth	r3, r3
 8001c6c:	843b      	strh	r3, [r7, #32]

	if( x0 < 0 )
 8001c6e:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8001c72:	2b00      	cmp	r3, #0
 8001c74:	da02      	bge.n	8001c7c <lcd_rect+0x50>
	{
		x0 = 0;
 8001c76:	2300      	movs	r3, #0
 8001c78:	84fb      	strh	r3, [r7, #38]	; 0x26
 8001c7a:	e007      	b.n	8001c8c <lcd_rect+0x60>
	}
	else if( x0 > 480 - 1 )
 8001c7c:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8001c80:	f5b3 7ff0 	cmp.w	r3, #480	; 0x1e0
 8001c84:	db02      	blt.n	8001c8c <lcd_rect+0x60>
	{
		x0 = 480 - 1;
 8001c86:	f240 13df 	movw	r3, #479	; 0x1df
 8001c8a:	84fb      	strh	r3, [r7, #38]	; 0x26
	}

	if( x1 < 0 )
 8001c8c:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8001c90:	2b00      	cmp	r3, #0
 8001c92:	da02      	bge.n	8001c9a <lcd_rect+0x6e>
	{
		x1 = 0;
 8001c94:	2300      	movs	r3, #0
 8001c96:	847b      	strh	r3, [r7, #34]	; 0x22
 8001c98:	e007      	b.n	8001caa <lcd_rect+0x7e>
	}
	else if( x1 > 480 - 1 )
 8001c9a:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8001c9e:	f5b3 7ff0 	cmp.w	r3, #480	; 0x1e0
 8001ca2:	db02      	blt.n	8001caa <lcd_rect+0x7e>
	{
		x1 = 480 - 1;
 8001ca4:	f240 13df 	movw	r3, #479	; 0x1df
 8001ca8:	847b      	strh	r3, [r7, #34]	; 0x22
	}

	if( y0 < 0 )
 8001caa:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8001cae:	2b00      	cmp	r3, #0
 8001cb0:	da02      	bge.n	8001cb8 <lcd_rect+0x8c>
	{
		y0 = 0;
 8001cb2:	2300      	movs	r3, #0
 8001cb4:	84bb      	strh	r3, [r7, #36]	; 0x24
 8001cb6:	e007      	b.n	8001cc8 <lcd_rect+0x9c>
	}
	else if( y0 > 320 - 1 )
 8001cb8:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8001cbc:	f5b3 7fa0 	cmp.w	r3, #320	; 0x140
 8001cc0:	db02      	blt.n	8001cc8 <lcd_rect+0x9c>
	{
		y0 = 320 - 1;
 8001cc2:	f240 133f 	movw	r3, #319	; 0x13f
 8001cc6:	84bb      	strh	r3, [r7, #36]	; 0x24
	}

	if( y1 < 0 )
 8001cc8:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8001ccc:	2b00      	cmp	r3, #0
 8001cce:	da02      	bge.n	8001cd6 <lcd_rect+0xaa>
	{
		y1 = 0;
 8001cd0:	2300      	movs	r3, #0
 8001cd2:	843b      	strh	r3, [r7, #32]
 8001cd4:	e007      	b.n	8001ce6 <lcd_rect+0xba>
	}
	else if( y1 > 320 - 1 )
 8001cd6:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8001cda:	f5b3 7fa0 	cmp.w	r3, #320	; 0x140
 8001cde:	db02      	blt.n	8001ce6 <lcd_rect+0xba>
	{
		y1 = 320 - 1;
 8001ce0:	f240 133f 	movw	r3, #319	; 0x13f
 8001ce4:	843b      	strh	r3, [r7, #32]
	}

	if( x0 > x1 )
 8001ce6:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8001cea:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8001cee:	429a      	cmp	r2, r3
 8001cf0:	dd06      	ble.n	8001d00 <lcd_rect+0xd4>
	{
		int tmp = x0;
 8001cf2:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8001cf6:	61bb      	str	r3, [r7, #24]
		x0 = x1;
 8001cf8:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001cfa:	84fb      	strh	r3, [r7, #38]	; 0x26
		x1 = tmp;
 8001cfc:	69bb      	ldr	r3, [r7, #24]
 8001cfe:	847b      	strh	r3, [r7, #34]	; 0x22
	}

	if( y0 > y1 )
 8001d00:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 8001d04:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8001d08:	429a      	cmp	r2, r3
 8001d0a:	dd06      	ble.n	8001d1a <lcd_rect+0xee>
	{
		int tmp = y0;
 8001d0c:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8001d10:	617b      	str	r3, [r7, #20]
		y0 = y1;
 8001d12:	8c3b      	ldrh	r3, [r7, #32]
 8001d14:	84bb      	strh	r3, [r7, #36]	; 0x24
		y1 = tmp;
 8001d16:	697b      	ldr	r3, [r7, #20]
 8001d18:	843b      	strh	r3, [r7, #32]
	}

	w = x1 - x0 + 1;
 8001d1a:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 8001d1c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8001d1e:	1ad3      	subs	r3, r2, r3
 8001d20:	b29b      	uxth	r3, r3
 8001d22:	3301      	adds	r3, #1
 8001d24:	b29b      	uxth	r3, r3
 8001d26:	807b      	strh	r3, [r7, #2]
	h = y1 - y0 + 1;
 8001d28:	8c3a      	ldrh	r2, [r7, #32]
 8001d2a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8001d2c:	1ad3      	subs	r3, r2, r3
 8001d2e:	b29b      	uxth	r3, r3
 8001d30:	3301      	adds	r3, #1
 8001d32:	b29b      	uxth	r3, r3
 8001d34:	803b      	strh	r3, [r7, #0]

	uint32_t i = 0;
 8001d36:	2300      	movs	r3, #0
 8001d38:	61fb      	str	r3, [r7, #28]
	uint32_t n = w*h;
 8001d3a:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8001d3e:	f9b7 2000 	ldrsh.w	r2, [r7]
 8001d42:	fb02 f303 	mul.w	r3, r2, r3
 8001d46:	613b      	str	r3, [r7, #16]

	uint16_t color_l = (color>>0)&0x1FF;
 8001d48:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001d4a:	b29b      	uxth	r3, r3
 8001d4c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8001d50:	81fb      	strh	r3, [r7, #14]
	uint16_t color_h = (color>>9)&0x1FF;
 8001d52:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001d54:	0a5b      	lsrs	r3, r3, #9
 8001d56:	b29b      	uxth	r3, r3
 8001d58:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8001d5c:	81bb      	strh	r3, [r7, #12]

	*addr_cmd = 0x2A;
 8001d5e:	4b2a      	ldr	r3, [pc, #168]	; (8001e08 <lcd_rect+0x1dc>)
 8001d60:	681b      	ldr	r3, [r3, #0]
 8001d62:	222a      	movs	r2, #42	; 0x2a
 8001d64:	801a      	strh	r2, [r3, #0]
	*addr_data = (x0>>8)&0xFF;
 8001d66:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8001d68:	4b28      	ldr	r3, [pc, #160]	; (8001e0c <lcd_rect+0x1e0>)
 8001d6a:	681b      	ldr	r3, [r3, #0]
 8001d6c:	0a12      	lsrs	r2, r2, #8
 8001d6e:	b292      	uxth	r2, r2
 8001d70:	801a      	strh	r2, [r3, #0]
	*addr_data = (x0>>0)&0xFF;
 8001d72:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8001d74:	4b25      	ldr	r3, [pc, #148]	; (8001e0c <lcd_rect+0x1e0>)
 8001d76:	681b      	ldr	r3, [r3, #0]
 8001d78:	b2d2      	uxtb	r2, r2
 8001d7a:	b292      	uxth	r2, r2
 8001d7c:	801a      	strh	r2, [r3, #0]
	*addr_data = (x1>>8)&0xFF;
 8001d7e:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 8001d80:	4b22      	ldr	r3, [pc, #136]	; (8001e0c <lcd_rect+0x1e0>)
 8001d82:	681b      	ldr	r3, [r3, #0]
 8001d84:	0a12      	lsrs	r2, r2, #8
 8001d86:	b292      	uxth	r2, r2
 8001d88:	801a      	strh	r2, [r3, #0]
	*addr_data = (x1>>0)&0xFF;
 8001d8a:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 8001d8c:	4b1f      	ldr	r3, [pc, #124]	; (8001e0c <lcd_rect+0x1e0>)
 8001d8e:	681b      	ldr	r3, [r3, #0]
 8001d90:	b2d2      	uxtb	r2, r2
 8001d92:	b292      	uxth	r2, r2
 8001d94:	801a      	strh	r2, [r3, #0]

	*addr_cmd = 0x2B;
 8001d96:	4b1c      	ldr	r3, [pc, #112]	; (8001e08 <lcd_rect+0x1dc>)
 8001d98:	681b      	ldr	r3, [r3, #0]
 8001d9a:	222b      	movs	r2, #43	; 0x2b
 8001d9c:	801a      	strh	r2, [r3, #0]
	*addr_data = (y0>>8)&0xFF;
 8001d9e:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8001da0:	4b1a      	ldr	r3, [pc, #104]	; (8001e0c <lcd_rect+0x1e0>)
 8001da2:	681b      	ldr	r3, [r3, #0]
 8001da4:	0a12      	lsrs	r2, r2, #8
 8001da6:	b292      	uxth	r2, r2
 8001da8:	801a      	strh	r2, [r3, #0]
	*addr_data = (y0>>0)&0xFF;
 8001daa:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8001dac:	4b17      	ldr	r3, [pc, #92]	; (8001e0c <lcd_rect+0x1e0>)
 8001dae:	681b      	ldr	r3, [r3, #0]
 8001db0:	b2d2      	uxtb	r2, r2
 8001db2:	b292      	uxth	r2, r2
 8001db4:	801a      	strh	r2, [r3, #0]
	*addr_data = (y1>>8)&0xFF;
 8001db6:	8c3a      	ldrh	r2, [r7, #32]
 8001db8:	4b14      	ldr	r3, [pc, #80]	; (8001e0c <lcd_rect+0x1e0>)
 8001dba:	681b      	ldr	r3, [r3, #0]
 8001dbc:	0a12      	lsrs	r2, r2, #8
 8001dbe:	b292      	uxth	r2, r2
 8001dc0:	801a      	strh	r2, [r3, #0]
	*addr_data = (y1>>0)&0xFF;
 8001dc2:	8c3a      	ldrh	r2, [r7, #32]
 8001dc4:	4b11      	ldr	r3, [pc, #68]	; (8001e0c <lcd_rect+0x1e0>)
 8001dc6:	681b      	ldr	r3, [r3, #0]
 8001dc8:	b2d2      	uxtb	r2, r2
 8001dca:	b292      	uxth	r2, r2
 8001dcc:	801a      	strh	r2, [r3, #0]

	*addr_cmd = 0x2C;
 8001dce:	4b0e      	ldr	r3, [pc, #56]	; (8001e08 <lcd_rect+0x1dc>)
 8001dd0:	681b      	ldr	r3, [r3, #0]
 8001dd2:	222c      	movs	r2, #44	; 0x2c
 8001dd4:	801a      	strh	r2, [r3, #0]
	for( i = 0 ; i < n ; i++ )
 8001dd6:	2300      	movs	r3, #0
 8001dd8:	61fb      	str	r3, [r7, #28]
 8001dda:	e00a      	b.n	8001df2 <lcd_rect+0x1c6>
	{
		*addr_data = color_l;
 8001ddc:	4b0b      	ldr	r3, [pc, #44]	; (8001e0c <lcd_rect+0x1e0>)
 8001dde:	681b      	ldr	r3, [r3, #0]
 8001de0:	89fa      	ldrh	r2, [r7, #14]
 8001de2:	801a      	strh	r2, [r3, #0]
		*addr_data = color_h;
 8001de4:	4b09      	ldr	r3, [pc, #36]	; (8001e0c <lcd_rect+0x1e0>)
 8001de6:	681b      	ldr	r3, [r3, #0]
 8001de8:	89ba      	ldrh	r2, [r7, #12]
 8001dea:	801a      	strh	r2, [r3, #0]
	for( i = 0 ; i < n ; i++ )
 8001dec:	69fb      	ldr	r3, [r7, #28]
 8001dee:	3301      	adds	r3, #1
 8001df0:	61fb      	str	r3, [r7, #28]
 8001df2:	69fa      	ldr	r2, [r7, #28]
 8001df4:	693b      	ldr	r3, [r7, #16]
 8001df6:	429a      	cmp	r2, r3
 8001df8:	d3f0      	bcc.n	8001ddc <lcd_rect+0x1b0>
	}
}
 8001dfa:	bf00      	nop
 8001dfc:	bf00      	nop
 8001dfe:	3728      	adds	r7, #40	; 0x28
 8001e00:	46bd      	mov	sp, r7
 8001e02:	bc90      	pop	{r4, r7}
 8001e04:	4770      	bx	lr
 8001e06:	bf00      	nop
 8001e08:	20000000 	.word	0x20000000
 8001e0c:	20000004 	.word	0x20000004

08001e10 <lcd_set_pixel>:

void lcd_set_pixel( int16_t x, int16_t y, uint32_t color )
{
 8001e10:	b480      	push	{r7}
 8001e12:	b087      	sub	sp, #28
 8001e14:	af00      	add	r7, sp, #0
 8001e16:	4603      	mov	r3, r0
 8001e18:	603a      	str	r2, [r7, #0]
 8001e1a:	80fb      	strh	r3, [r7, #6]
 8001e1c:	460b      	mov	r3, r1
 8001e1e:	80bb      	strh	r3, [r7, #4]
	int16_t x0 = x;
 8001e20:	88fb      	ldrh	r3, [r7, #6]
 8001e22:	82fb      	strh	r3, [r7, #22]
	int16_t y0 = y;
 8001e24:	88bb      	ldrh	r3, [r7, #4]
 8001e26:	82bb      	strh	r3, [r7, #20]
	int16_t x1 = x + 1;
 8001e28:	88fb      	ldrh	r3, [r7, #6]
 8001e2a:	3301      	adds	r3, #1
 8001e2c:	b29b      	uxth	r3, r3
 8001e2e:	827b      	strh	r3, [r7, #18]
	int16_t y1 = y + 1;
 8001e30:	88bb      	ldrh	r3, [r7, #4]
 8001e32:	3301      	adds	r3, #1
 8001e34:	b29b      	uxth	r3, r3
 8001e36:	823b      	strh	r3, [r7, #16]
	uint16_t color_l = (color>>0)&0x1FF;
 8001e38:	683b      	ldr	r3, [r7, #0]
 8001e3a:	b29b      	uxth	r3, r3
 8001e3c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8001e40:	81fb      	strh	r3, [r7, #14]
	uint16_t color_h = (color>>9)&0x1FF;
 8001e42:	683b      	ldr	r3, [r7, #0]
 8001e44:	0a5b      	lsrs	r3, r3, #9
 8001e46:	b29b      	uxth	r3, r3
 8001e48:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8001e4c:	81bb      	strh	r3, [r7, #12]

	*addr_cmd = 0x2A;
 8001e4e:	4b25      	ldr	r3, [pc, #148]	; (8001ee4 <lcd_set_pixel+0xd4>)
 8001e50:	681b      	ldr	r3, [r3, #0]
 8001e52:	222a      	movs	r2, #42	; 0x2a
 8001e54:	801a      	strh	r2, [r3, #0]
	*addr_data = (x0>>8)&0xFF;
 8001e56:	8afa      	ldrh	r2, [r7, #22]
 8001e58:	4b23      	ldr	r3, [pc, #140]	; (8001ee8 <lcd_set_pixel+0xd8>)
 8001e5a:	681b      	ldr	r3, [r3, #0]
 8001e5c:	0a12      	lsrs	r2, r2, #8
 8001e5e:	b292      	uxth	r2, r2
 8001e60:	801a      	strh	r2, [r3, #0]
	*addr_data = (x0>>0)&0xFF;
 8001e62:	8afa      	ldrh	r2, [r7, #22]
 8001e64:	4b20      	ldr	r3, [pc, #128]	; (8001ee8 <lcd_set_pixel+0xd8>)
 8001e66:	681b      	ldr	r3, [r3, #0]
 8001e68:	b2d2      	uxtb	r2, r2
 8001e6a:	b292      	uxth	r2, r2
 8001e6c:	801a      	strh	r2, [r3, #0]
	*addr_data = (x1>>8)&0xFF;
 8001e6e:	8a7a      	ldrh	r2, [r7, #18]
 8001e70:	4b1d      	ldr	r3, [pc, #116]	; (8001ee8 <lcd_set_pixel+0xd8>)
 8001e72:	681b      	ldr	r3, [r3, #0]
 8001e74:	0a12      	lsrs	r2, r2, #8
 8001e76:	b292      	uxth	r2, r2
 8001e78:	801a      	strh	r2, [r3, #0]
	*addr_data = (x1>>0)&0xFF;
 8001e7a:	8a7a      	ldrh	r2, [r7, #18]
 8001e7c:	4b1a      	ldr	r3, [pc, #104]	; (8001ee8 <lcd_set_pixel+0xd8>)
 8001e7e:	681b      	ldr	r3, [r3, #0]
 8001e80:	b2d2      	uxtb	r2, r2
 8001e82:	b292      	uxth	r2, r2
 8001e84:	801a      	strh	r2, [r3, #0]

	*addr_cmd = 0x2B;
 8001e86:	4b17      	ldr	r3, [pc, #92]	; (8001ee4 <lcd_set_pixel+0xd4>)
 8001e88:	681b      	ldr	r3, [r3, #0]
 8001e8a:	222b      	movs	r2, #43	; 0x2b
 8001e8c:	801a      	strh	r2, [r3, #0]
	*addr_data = (y0>>8)&0xFF;
 8001e8e:	8aba      	ldrh	r2, [r7, #20]
 8001e90:	4b15      	ldr	r3, [pc, #84]	; (8001ee8 <lcd_set_pixel+0xd8>)
 8001e92:	681b      	ldr	r3, [r3, #0]
 8001e94:	0a12      	lsrs	r2, r2, #8
 8001e96:	b292      	uxth	r2, r2
 8001e98:	801a      	strh	r2, [r3, #0]
	*addr_data = (y0>>0)&0xFF;
 8001e9a:	8aba      	ldrh	r2, [r7, #20]
 8001e9c:	4b12      	ldr	r3, [pc, #72]	; (8001ee8 <lcd_set_pixel+0xd8>)
 8001e9e:	681b      	ldr	r3, [r3, #0]
 8001ea0:	b2d2      	uxtb	r2, r2
 8001ea2:	b292      	uxth	r2, r2
 8001ea4:	801a      	strh	r2, [r3, #0]
	*addr_data = (y1>>8)&0xFF;
 8001ea6:	8a3a      	ldrh	r2, [r7, #16]
 8001ea8:	4b0f      	ldr	r3, [pc, #60]	; (8001ee8 <lcd_set_pixel+0xd8>)
 8001eaa:	681b      	ldr	r3, [r3, #0]
 8001eac:	0a12      	lsrs	r2, r2, #8
 8001eae:	b292      	uxth	r2, r2
 8001eb0:	801a      	strh	r2, [r3, #0]
	*addr_data = (y1>>0)&0xFF;
 8001eb2:	8a3a      	ldrh	r2, [r7, #16]
 8001eb4:	4b0c      	ldr	r3, [pc, #48]	; (8001ee8 <lcd_set_pixel+0xd8>)
 8001eb6:	681b      	ldr	r3, [r3, #0]
 8001eb8:	b2d2      	uxtb	r2, r2
 8001eba:	b292      	uxth	r2, r2
 8001ebc:	801a      	strh	r2, [r3, #0]

	*addr_cmd = 0x2C;
 8001ebe:	4b09      	ldr	r3, [pc, #36]	; (8001ee4 <lcd_set_pixel+0xd4>)
 8001ec0:	681b      	ldr	r3, [r3, #0]
 8001ec2:	222c      	movs	r2, #44	; 0x2c
 8001ec4:	801a      	strh	r2, [r3, #0]
	*addr_data = color_l;
 8001ec6:	4b08      	ldr	r3, [pc, #32]	; (8001ee8 <lcd_set_pixel+0xd8>)
 8001ec8:	681b      	ldr	r3, [r3, #0]
 8001eca:	89fa      	ldrh	r2, [r7, #14]
 8001ecc:	801a      	strh	r2, [r3, #0]
	*addr_data = color_h;
 8001ece:	4b06      	ldr	r3, [pc, #24]	; (8001ee8 <lcd_set_pixel+0xd8>)
 8001ed0:	681b      	ldr	r3, [r3, #0]
 8001ed2:	89ba      	ldrh	r2, [r7, #12]
 8001ed4:	801a      	strh	r2, [r3, #0]
}
 8001ed6:	bf00      	nop
 8001ed8:	371c      	adds	r7, #28
 8001eda:	46bd      	mov	sp, r7
 8001edc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001ee0:	4770      	bx	lr
 8001ee2:	bf00      	nop
 8001ee4:	20000000 	.word	0x20000000
 8001ee8:	20000004 	.word	0x20000004

08001eec <lcd_set_pixel_bench>:


int32_t lcd_set_pixel_bench( int16_t x, int16_t y, uint32_t color )
{
 8001eec:	b580      	push	{r7, lr}
 8001eee:	b088      	sub	sp, #32
 8001ef0:	af00      	add	r7, sp, #0
 8001ef2:	4603      	mov	r3, r0
 8001ef4:	603a      	str	r2, [r7, #0]
 8001ef6:	80fb      	strh	r3, [r7, #6]
 8001ef8:	460b      	mov	r3, r1
 8001efa:	80bb      	strh	r3, [r7, #4]
	int32_t a, b, d;
	int16_t x0 = x;
 8001efc:	88fb      	ldrh	r3, [r7, #6]
 8001efe:	83fb      	strh	r3, [r7, #30]
	int16_t y0 = y;
 8001f00:	88bb      	ldrh	r3, [r7, #4]
 8001f02:	83bb      	strh	r3, [r7, #28]
	int16_t x1 = x + 4;
 8001f04:	88fb      	ldrh	r3, [r7, #6]
 8001f06:	3304      	adds	r3, #4
 8001f08:	b29b      	uxth	r3, r3
 8001f0a:	837b      	strh	r3, [r7, #26]
	int16_t y1 = y + 4;
 8001f0c:	88bb      	ldrh	r3, [r7, #4]
 8001f0e:	3304      	adds	r3, #4
 8001f10:	b29b      	uxth	r3, r3
 8001f12:	833b      	strh	r3, [r7, #24]
	uint16_t color_l = (color>>0)&0x1FF;
 8001f14:	683b      	ldr	r3, [r7, #0]
 8001f16:	b29b      	uxth	r3, r3
 8001f18:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8001f1c:	82fb      	strh	r3, [r7, #22]
	uint16_t color_h = (color>>9)&0x1FF;
 8001f1e:	683b      	ldr	r3, [r7, #0]
 8001f20:	0a5b      	lsrs	r3, r3, #9
 8001f22:	b29b      	uxth	r3, r3
 8001f24:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8001f28:	82bb      	strh	r3, [r7, #20]

	*addr_cmd = 0x2A;
 8001f2a:	4b66      	ldr	r3, [pc, #408]	; (80020c4 <lcd_set_pixel_bench+0x1d8>)
 8001f2c:	681b      	ldr	r3, [r3, #0]
 8001f2e:	222a      	movs	r2, #42	; 0x2a
 8001f30:	801a      	strh	r2, [r3, #0]
	*addr_data = (x0>>8)&0xFF;
 8001f32:	8bfa      	ldrh	r2, [r7, #30]
 8001f34:	4b64      	ldr	r3, [pc, #400]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8001f36:	681b      	ldr	r3, [r3, #0]
 8001f38:	0a12      	lsrs	r2, r2, #8
 8001f3a:	b292      	uxth	r2, r2
 8001f3c:	801a      	strh	r2, [r3, #0]
	*addr_data = (x0>>0)&0xFF;
 8001f3e:	8bfa      	ldrh	r2, [r7, #30]
 8001f40:	4b61      	ldr	r3, [pc, #388]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8001f42:	681b      	ldr	r3, [r3, #0]
 8001f44:	b2d2      	uxtb	r2, r2
 8001f46:	b292      	uxth	r2, r2
 8001f48:	801a      	strh	r2, [r3, #0]
	*addr_data = (x1>>8)&0xFF;
 8001f4a:	8b7a      	ldrh	r2, [r7, #26]
 8001f4c:	4b5e      	ldr	r3, [pc, #376]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8001f4e:	681b      	ldr	r3, [r3, #0]
 8001f50:	0a12      	lsrs	r2, r2, #8
 8001f52:	b292      	uxth	r2, r2
 8001f54:	801a      	strh	r2, [r3, #0]
	*addr_data = (x1>>0)&0xFF;
 8001f56:	8b7a      	ldrh	r2, [r7, #26]
 8001f58:	4b5b      	ldr	r3, [pc, #364]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8001f5a:	681b      	ldr	r3, [r3, #0]
 8001f5c:	b2d2      	uxtb	r2, r2
 8001f5e:	b292      	uxth	r2, r2
 8001f60:	801a      	strh	r2, [r3, #0]

	*addr_cmd = 0x2B;
 8001f62:	4b58      	ldr	r3, [pc, #352]	; (80020c4 <lcd_set_pixel_bench+0x1d8>)
 8001f64:	681b      	ldr	r3, [r3, #0]
 8001f66:	222b      	movs	r2, #43	; 0x2b
 8001f68:	801a      	strh	r2, [r3, #0]
	*addr_data = (y0>>8)&0xFF;
 8001f6a:	8bba      	ldrh	r2, [r7, #28]
 8001f6c:	4b56      	ldr	r3, [pc, #344]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8001f6e:	681b      	ldr	r3, [r3, #0]
 8001f70:	0a12      	lsrs	r2, r2, #8
 8001f72:	b292      	uxth	r2, r2
 8001f74:	801a      	strh	r2, [r3, #0]
	*addr_data = (y0>>0)&0xFF;
 8001f76:	8bba      	ldrh	r2, [r7, #28]
 8001f78:	4b53      	ldr	r3, [pc, #332]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8001f7a:	681b      	ldr	r3, [r3, #0]
 8001f7c:	b2d2      	uxtb	r2, r2
 8001f7e:	b292      	uxth	r2, r2
 8001f80:	801a      	strh	r2, [r3, #0]
	*addr_data = (y1>>8)&0xFF;
 8001f82:	8b3a      	ldrh	r2, [r7, #24]
 8001f84:	4b50      	ldr	r3, [pc, #320]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8001f86:	681b      	ldr	r3, [r3, #0]
 8001f88:	0a12      	lsrs	r2, r2, #8
 8001f8a:	b292      	uxth	r2, r2
 8001f8c:	801a      	strh	r2, [r3, #0]
	*addr_data = (y1>>0)&0xFF;
 8001f8e:	8b3a      	ldrh	r2, [r7, #24]
 8001f90:	4b4d      	ldr	r3, [pc, #308]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8001f92:	681b      	ldr	r3, [r3, #0]
 8001f94:	b2d2      	uxtb	r2, r2
 8001f96:	b292      	uxth	r2, r2
 8001f98:	801a      	strh	r2, [r3, #0]

	a = get_systick();
 8001f9a:	f7ff fd4b 	bl	8001a34 <get_systick>
 8001f9e:	6138      	str	r0, [r7, #16]
	*addr_cmd = 0x2C;
 8001fa0:	4b48      	ldr	r3, [pc, #288]	; (80020c4 <lcd_set_pixel_bench+0x1d8>)
 8001fa2:	681b      	ldr	r3, [r3, #0]
 8001fa4:	222c      	movs	r2, #44	; 0x2c
 8001fa6:	801a      	strh	r2, [r3, #0]
	*addr_data = color_l;
 8001fa8:	4b47      	ldr	r3, [pc, #284]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8001faa:	681b      	ldr	r3, [r3, #0]
 8001fac:	8afa      	ldrh	r2, [r7, #22]
 8001fae:	801a      	strh	r2, [r3, #0]
	*addr_data = color_h;
 8001fb0:	4b45      	ldr	r3, [pc, #276]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8001fb2:	681b      	ldr	r3, [r3, #0]
 8001fb4:	8aba      	ldrh	r2, [r7, #20]
 8001fb6:	801a      	strh	r2, [r3, #0]
	*addr_data = color_l;
 8001fb8:	4b43      	ldr	r3, [pc, #268]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8001fba:	681b      	ldr	r3, [r3, #0]
 8001fbc:	8afa      	ldrh	r2, [r7, #22]
 8001fbe:	801a      	strh	r2, [r3, #0]
	*addr_data = color_h;
 8001fc0:	4b41      	ldr	r3, [pc, #260]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8001fc2:	681b      	ldr	r3, [r3, #0]
 8001fc4:	8aba      	ldrh	r2, [r7, #20]
 8001fc6:	801a      	strh	r2, [r3, #0]
	*addr_data = color_l;
 8001fc8:	4b3f      	ldr	r3, [pc, #252]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8001fca:	681b      	ldr	r3, [r3, #0]
 8001fcc:	8afa      	ldrh	r2, [r7, #22]
 8001fce:	801a      	strh	r2, [r3, #0]
	*addr_data = color_h;
 8001fd0:	4b3d      	ldr	r3, [pc, #244]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8001fd2:	681b      	ldr	r3, [r3, #0]
 8001fd4:	8aba      	ldrh	r2, [r7, #20]
 8001fd6:	801a      	strh	r2, [r3, #0]
	*addr_data = color_l;
 8001fd8:	4b3b      	ldr	r3, [pc, #236]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8001fda:	681b      	ldr	r3, [r3, #0]
 8001fdc:	8afa      	ldrh	r2, [r7, #22]
 8001fde:	801a      	strh	r2, [r3, #0]
	*addr_data = color_h;
 8001fe0:	4b39      	ldr	r3, [pc, #228]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8001fe2:	681b      	ldr	r3, [r3, #0]
 8001fe4:	8aba      	ldrh	r2, [r7, #20]
 8001fe6:	801a      	strh	r2, [r3, #0]

	*addr_data = color_l;
 8001fe8:	4b37      	ldr	r3, [pc, #220]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8001fea:	681b      	ldr	r3, [r3, #0]
 8001fec:	8afa      	ldrh	r2, [r7, #22]
 8001fee:	801a      	strh	r2, [r3, #0]
	*addr_data = color_h;
 8001ff0:	4b35      	ldr	r3, [pc, #212]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8001ff2:	681b      	ldr	r3, [r3, #0]
 8001ff4:	8aba      	ldrh	r2, [r7, #20]
 8001ff6:	801a      	strh	r2, [r3, #0]
	*addr_data = color_l;
 8001ff8:	4b33      	ldr	r3, [pc, #204]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8001ffa:	681b      	ldr	r3, [r3, #0]
 8001ffc:	8afa      	ldrh	r2, [r7, #22]
 8001ffe:	801a      	strh	r2, [r3, #0]
	*addr_data = color_h;
 8002000:	4b31      	ldr	r3, [pc, #196]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8002002:	681b      	ldr	r3, [r3, #0]
 8002004:	8aba      	ldrh	r2, [r7, #20]
 8002006:	801a      	strh	r2, [r3, #0]
	*addr_data = color_l;
 8002008:	4b2f      	ldr	r3, [pc, #188]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 800200a:	681b      	ldr	r3, [r3, #0]
 800200c:	8afa      	ldrh	r2, [r7, #22]
 800200e:	801a      	strh	r2, [r3, #0]
	*addr_data = color_h;
 8002010:	4b2d      	ldr	r3, [pc, #180]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8002012:	681b      	ldr	r3, [r3, #0]
 8002014:	8aba      	ldrh	r2, [r7, #20]
 8002016:	801a      	strh	r2, [r3, #0]
	*addr_data = color_l;
 8002018:	4b2b      	ldr	r3, [pc, #172]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 800201a:	681b      	ldr	r3, [r3, #0]
 800201c:	8afa      	ldrh	r2, [r7, #22]
 800201e:	801a      	strh	r2, [r3, #0]
	*addr_data = color_h;
 8002020:	4b29      	ldr	r3, [pc, #164]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8002022:	681b      	ldr	r3, [r3, #0]
 8002024:	8aba      	ldrh	r2, [r7, #20]
 8002026:	801a      	strh	r2, [r3, #0]

	*addr_data = color_l;
 8002028:	4b27      	ldr	r3, [pc, #156]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 800202a:	681b      	ldr	r3, [r3, #0]
 800202c:	8afa      	ldrh	r2, [r7, #22]
 800202e:	801a      	strh	r2, [r3, #0]
	*addr_data = color_h;
 8002030:	4b25      	ldr	r3, [pc, #148]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8002032:	681b      	ldr	r3, [r3, #0]
 8002034:	8aba      	ldrh	r2, [r7, #20]
 8002036:	801a      	strh	r2, [r3, #0]
	*addr_data = color_l;
 8002038:	4b23      	ldr	r3, [pc, #140]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 800203a:	681b      	ldr	r3, [r3, #0]
 800203c:	8afa      	ldrh	r2, [r7, #22]
 800203e:	801a      	strh	r2, [r3, #0]
	*addr_data = color_h;
 8002040:	4b21      	ldr	r3, [pc, #132]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8002042:	681b      	ldr	r3, [r3, #0]
 8002044:	8aba      	ldrh	r2, [r7, #20]
 8002046:	801a      	strh	r2, [r3, #0]
	*addr_data = color_l;
 8002048:	4b1f      	ldr	r3, [pc, #124]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 800204a:	681b      	ldr	r3, [r3, #0]
 800204c:	8afa      	ldrh	r2, [r7, #22]
 800204e:	801a      	strh	r2, [r3, #0]
	*addr_data = color_h;
 8002050:	4b1d      	ldr	r3, [pc, #116]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8002052:	681b      	ldr	r3, [r3, #0]
 8002054:	8aba      	ldrh	r2, [r7, #20]
 8002056:	801a      	strh	r2, [r3, #0]
	*addr_data = color_l;
 8002058:	4b1b      	ldr	r3, [pc, #108]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 800205a:	681b      	ldr	r3, [r3, #0]
 800205c:	8afa      	ldrh	r2, [r7, #22]
 800205e:	801a      	strh	r2, [r3, #0]
	*addr_data = color_h;
 8002060:	4b19      	ldr	r3, [pc, #100]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8002062:	681b      	ldr	r3, [r3, #0]
 8002064:	8aba      	ldrh	r2, [r7, #20]
 8002066:	801a      	strh	r2, [r3, #0]

	*addr_data = color_l;
 8002068:	4b17      	ldr	r3, [pc, #92]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 800206a:	681b      	ldr	r3, [r3, #0]
 800206c:	8afa      	ldrh	r2, [r7, #22]
 800206e:	801a      	strh	r2, [r3, #0]
	*addr_data = color_h;
 8002070:	4b15      	ldr	r3, [pc, #84]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8002072:	681b      	ldr	r3, [r3, #0]
 8002074:	8aba      	ldrh	r2, [r7, #20]
 8002076:	801a      	strh	r2, [r3, #0]
	*addr_data = color_l;
 8002078:	4b13      	ldr	r3, [pc, #76]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 800207a:	681b      	ldr	r3, [r3, #0]
 800207c:	8afa      	ldrh	r2, [r7, #22]
 800207e:	801a      	strh	r2, [r3, #0]
	*addr_data = color_h;
 8002080:	4b11      	ldr	r3, [pc, #68]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8002082:	681b      	ldr	r3, [r3, #0]
 8002084:	8aba      	ldrh	r2, [r7, #20]
 8002086:	801a      	strh	r2, [r3, #0]
	*addr_data = color_l;
 8002088:	4b0f      	ldr	r3, [pc, #60]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 800208a:	681b      	ldr	r3, [r3, #0]
 800208c:	8afa      	ldrh	r2, [r7, #22]
 800208e:	801a      	strh	r2, [r3, #0]
	*addr_data = color_h;
 8002090:	4b0d      	ldr	r3, [pc, #52]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 8002092:	681b      	ldr	r3, [r3, #0]
 8002094:	8aba      	ldrh	r2, [r7, #20]
 8002096:	801a      	strh	r2, [r3, #0]
	*addr_data = color_l;
 8002098:	4b0b      	ldr	r3, [pc, #44]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 800209a:	681b      	ldr	r3, [r3, #0]
 800209c:	8afa      	ldrh	r2, [r7, #22]
 800209e:	801a      	strh	r2, [r3, #0]
	*addr_data = color_h;
 80020a0:	4b09      	ldr	r3, [pc, #36]	; (80020c8 <lcd_set_pixel_bench+0x1dc>)
 80020a2:	681b      	ldr	r3, [r3, #0]
 80020a4:	8aba      	ldrh	r2, [r7, #20]
 80020a6:	801a      	strh	r2, [r3, #0]
	b = get_systick();
 80020a8:	f7ff fcc4 	bl	8001a34 <get_systick>
 80020ac:	60f8      	str	r0, [r7, #12]
	d = diff_systick(b,a);
 80020ae:	6939      	ldr	r1, [r7, #16]
 80020b0:	68f8      	ldr	r0, [r7, #12]
 80020b2:	f7ff fccb 	bl	8001a4c <diff_systick>
 80020b6:	60b8      	str	r0, [r7, #8]
	return d;
 80020b8:	68bb      	ldr	r3, [r7, #8]
}
 80020ba:	4618      	mov	r0, r3
 80020bc:	3720      	adds	r7, #32
 80020be:	46bd      	mov	sp, r7
 80020c0:	bd80      	pop	{r7, pc}
 80020c2:	bf00      	nop
 80020c4:	20000000 	.word	0x20000000
 80020c8:	20000004 	.word	0x20000004

080020cc <lcd_text>:
void lcd_text( const tFramebuf *fb, uint16_t x0, uint16_t y0, char *str, uint32_t color )
{
 80020cc:	b580      	push	{r7, lr}
 80020ce:	b08a      	sub	sp, #40	; 0x28
 80020d0:	af02      	add	r7, sp, #8
 80020d2:	60f8      	str	r0, [r7, #12]
 80020d4:	607b      	str	r3, [r7, #4]
 80020d6:	460b      	mov	r3, r1
 80020d8:	817b      	strh	r3, [r7, #10]
 80020da:	4613      	mov	r3, r2
 80020dc:	813b      	strh	r3, [r7, #8]
	for(; *str; ++str) {
 80020de:	e02a      	b.n	8002136 <lcd_text+0x6a>
	        // get char and make sure its in range of font
	        int chr = *(uint8_t *)str;
 80020e0:	687b      	ldr	r3, [r7, #4]
 80020e2:	781b      	ldrb	r3, [r3, #0]
 80020e4:	61fb      	str	r3, [r7, #28]
	        if (chr < 32 || chr > 127) {
 80020e6:	69fb      	ldr	r3, [r7, #28]
 80020e8:	2b1f      	cmp	r3, #31
 80020ea:	dd02      	ble.n	80020f2 <lcd_text+0x26>
 80020ec:	69fb      	ldr	r3, [r7, #28]
 80020ee:	2b7f      	cmp	r3, #127	; 0x7f
 80020f0:	dd01      	ble.n	80020f6 <lcd_text+0x2a>
	            chr = 127;
 80020f2:	237f      	movs	r3, #127	; 0x7f
 80020f4:	61fb      	str	r3, [r7, #28]
	        }
	        draw_char( fb, &fontUbuntuBookRNormal16, x0, y0, chr, color );
 80020f6:	f9b7 100a 	ldrsh.w	r1, [r7, #10]
 80020fa:	f9b7 0008 	ldrsh.w	r0, [r7, #8]
 80020fe:	69fb      	ldr	r3, [r7, #28]
 8002100:	b2db      	uxtb	r3, r3
 8002102:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8002104:	9201      	str	r2, [sp, #4]
 8002106:	9300      	str	r3, [sp, #0]
 8002108:	4603      	mov	r3, r0
 800210a:	460a      	mov	r2, r1
 800210c:	490e      	ldr	r1, [pc, #56]	; (8002148 <lcd_text+0x7c>)
 800210e:	68f8      	ldr	r0, [r7, #12]
 8002110:	f000 f81c 	bl	800214c <draw_char>
	        x0 += get_char_rect( &fontUbuntuBookRNormal16, chr ).width;
 8002114:	69fb      	ldr	r3, [r7, #28]
 8002116:	b2da      	uxtb	r2, r3
 8002118:	f107 0314 	add.w	r3, r7, #20
 800211c:	490a      	ldr	r1, [pc, #40]	; (8002148 <lcd_text+0x7c>)
 800211e:	4618      	mov	r0, r3
 8002120:	f000 f8c9 	bl	80022b6 <get_char_rect>
 8002124:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8002128:	b29a      	uxth	r2, r3
 800212a:	897b      	ldrh	r3, [r7, #10]
 800212c:	4413      	add	r3, r2
 800212e:	817b      	strh	r3, [r7, #10]
	for(; *str; ++str) {
 8002130:	687b      	ldr	r3, [r7, #4]
 8002132:	3301      	adds	r3, #1
 8002134:	607b      	str	r3, [r7, #4]
 8002136:	687b      	ldr	r3, [r7, #4]
 8002138:	781b      	ldrb	r3, [r3, #0]
 800213a:	2b00      	cmp	r3, #0
 800213c:	d1d0      	bne.n	80020e0 <lcd_text+0x14>
	}
}
 800213e:	bf00      	nop
 8002140:	bf00      	nop
 8002142:	3720      	adds	r7, #32
 8002144:	46bd      	mov	sp, r7
 8002146:	bd80      	pop	{r7, pc}
 8002148:	08023160 	.word	0x08023160

0800214c <draw_char>:
void draw_char( const tFramebuf *fb, const tFont *pFont, int16_t x0, int16_t y0, uint8_t c, uint32_t color )
{
 800214c:	b580      	push	{r7, lr}
 800214e:	b08c      	sub	sp, #48	; 0x30
 8002150:	af02      	add	r7, sp, #8
 8002152:	60f8      	str	r0, [r7, #12]
 8002154:	60b9      	str	r1, [r7, #8]
 8002156:	4611      	mov	r1, r2
 8002158:	461a      	mov	r2, r3
 800215a:	460b      	mov	r3, r1
 800215c:	80fb      	strh	r3, [r7, #6]
 800215e:	4613      	mov	r3, r2
 8002160:	80bb      	strh	r3, [r7, #4]
    int16_t x, y, w, bitmap, b;
    int16_t px, py;
    const tGlyph *pGlyph;

    pGlyph = pFont->pGlyphs[c-32];
 8002162:	68bb      	ldr	r3, [r7, #8]
 8002164:	68da      	ldr	r2, [r3, #12]
 8002166:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 800216a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800216e:	3b20      	subs	r3, #32
 8002170:	009b      	lsls	r3, r3, #2
 8002172:	4413      	add	r3, r2
 8002174:	681b      	ldr	r3, [r3, #0]
 8002176:	61fb      	str	r3, [r7, #28]

    y0 += pFont->bbxh;
 8002178:	68bb      	ldr	r3, [r7, #8]
 800217a:	f993 3009 	ldrsb.w	r3, [r3, #9]
 800217e:	b29a      	uxth	r2, r3
 8002180:	88bb      	ldrh	r3, [r7, #4]
 8002182:	4413      	add	r3, r2
 8002184:	b29b      	uxth	r3, r3
 8002186:	80bb      	strh	r3, [r7, #4]
    y0 -= pFont->descent;
 8002188:	88ba      	ldrh	r2, [r7, #4]
 800218a:	68bb      	ldr	r3, [r7, #8]
 800218c:	79db      	ldrb	r3, [r3, #7]
 800218e:	b29b      	uxth	r3, r3
 8002190:	1ad3      	subs	r3, r2, r3
 8002192:	b29b      	uxth	r3, r3
 8002194:	80bb      	strh	r3, [r7, #4]
    y0 -= pGlyph->bbxh;
 8002196:	88ba      	ldrh	r2, [r7, #4]
 8002198:	69fb      	ldr	r3, [r7, #28]
 800219a:	f993 300a 	ldrsb.w	r3, [r3, #10]
 800219e:	b29b      	uxth	r3, r3
 80021a0:	1ad3      	subs	r3, r2, r3
 80021a2:	b29b      	uxth	r3, r3
 80021a4:	80bb      	strh	r3, [r7, #4]
    y0 -= pGlyph->bbxy;
 80021a6:	88ba      	ldrh	r2, [r7, #4]
 80021a8:	69fb      	ldr	r3, [r7, #28]
 80021aa:	f993 300c 	ldrsb.w	r3, [r3, #12]
 80021ae:	b29b      	uxth	r3, r3
 80021b0:	1ad3      	subs	r3, r2, r3
 80021b2:	b29b      	uxth	r3, r3
 80021b4:	80bb      	strh	r3, [r7, #4]

    for( y = 0 ; y < pGlyph->bbxh ; y++ )
 80021b6:	2300      	movs	r3, #0
 80021b8:	84bb      	strh	r3, [r7, #36]	; 0x24
 80021ba:	e06f      	b.n	800229c <draw_char+0x150>
    {
        py = y0+y;
 80021bc:	88ba      	ldrh	r2, [r7, #4]
 80021be:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80021c0:	4413      	add	r3, r2
 80021c2:	b29b      	uxth	r3, r3
 80021c4:	837b      	strh	r3, [r7, #26]

        w = (pGlyph->bbxw-1)/8+1;
 80021c6:	69fb      	ldr	r3, [r7, #28]
 80021c8:	f993 3009 	ldrsb.w	r3, [r3, #9]
 80021cc:	3b01      	subs	r3, #1
 80021ce:	2b00      	cmp	r3, #0
 80021d0:	da00      	bge.n	80021d4 <draw_char+0x88>
 80021d2:	3307      	adds	r3, #7
 80021d4:	10db      	asrs	r3, r3, #3
 80021d6:	b29b      	uxth	r3, r3
 80021d8:	3301      	adds	r3, #1
 80021da:	b29b      	uxth	r3, r3
 80021dc:	833b      	strh	r3, [r7, #24]

        int16_t yw = y*w;
 80021de:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 80021e0:	8b3b      	ldrh	r3, [r7, #24]
 80021e2:	fb12 f303 	smulbb	r3, r2, r3
 80021e6:	b29b      	uxth	r3, r3
 80021e8:	82fb      	strh	r3, [r7, #22]
        for( x = 0 ; x < pGlyph->bbxw ; x+=8 )
 80021ea:	2300      	movs	r3, #0
 80021ec:	84fb      	strh	r3, [r7, #38]	; 0x26
 80021ee:	e047      	b.n	8002280 <draw_char+0x134>
        {
            bitmap = pGlyph->pBitmap[yw+x/8];
 80021f0:	69fb      	ldr	r3, [r7, #28]
 80021f2:	691a      	ldr	r2, [r3, #16]
 80021f4:	f9b7 1016 	ldrsh.w	r1, [r7, #22]
 80021f8:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 80021fc:	2b00      	cmp	r3, #0
 80021fe:	da00      	bge.n	8002202 <draw_char+0xb6>
 8002200:	3307      	adds	r3, #7
 8002202:	10db      	asrs	r3, r3, #3
 8002204:	b21b      	sxth	r3, r3
 8002206:	440b      	add	r3, r1
 8002208:	4413      	add	r3, r2
 800220a:	781b      	ldrb	r3, [r3, #0]
 800220c:	82bb      	strh	r3, [r7, #20]

            for( b = 0 ; b < 8 ; b++ )
 800220e:	2300      	movs	r3, #0
 8002210:	847b      	strh	r3, [r7, #34]	; 0x22
 8002212:	e02b      	b.n	800226c <draw_char+0x120>
            {
                if( x+b >= pGlyph->bbxw )
 8002214:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8002218:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 800221c:	4413      	add	r3, r2
 800221e:	69fa      	ldr	r2, [r7, #28]
 8002220:	f992 2009 	ldrsb.w	r2, [r2, #9]
 8002224:	4293      	cmp	r3, r2
 8002226:	da26      	bge.n	8002276 <draw_char+0x12a>
                {
                    break;
                }

                px = x0+x+b;
 8002228:	88fa      	ldrh	r2, [r7, #6]
 800222a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800222c:	4413      	add	r3, r2
 800222e:	b29a      	uxth	r2, r3
 8002230:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8002232:	4413      	add	r3, r2
 8002234:	b29b      	uxth	r3, r3
 8002236:	827b      	strh	r3, [r7, #18]

                if( bitmap & (0x80>>b) )
 8002238:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 800223c:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8002240:	2180      	movs	r1, #128	; 0x80
 8002242:	fa41 f303 	asr.w	r3, r1, r3
 8002246:	4013      	ands	r3, r2
 8002248:	2b00      	cmp	r3, #0
 800224a:	d009      	beq.n	8002260 <draw_char+0x114>
                {
                    //set_pixel( px, py, color );
                    //lcd_rect( px, py, 1, 1, color);
                	setpixel_checked(fb, px, py, color, 1);
 800224c:	f9b7 1012 	ldrsh.w	r1, [r7, #18]
 8002250:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 8002254:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002256:	2001      	movs	r0, #1
 8002258:	9000      	str	r0, [sp, #0]
 800225a:	68f8      	ldr	r0, [r7, #12]
 800225c:	f00a ff4a 	bl	800d0f4 <setpixel_checked>
            for( b = 0 ; b < 8 ; b++ )
 8002260:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8002264:	b29b      	uxth	r3, r3
 8002266:	3301      	adds	r3, #1
 8002268:	b29b      	uxth	r3, r3
 800226a:	847b      	strh	r3, [r7, #34]	; 0x22
 800226c:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8002270:	2b07      	cmp	r3, #7
 8002272:	ddcf      	ble.n	8002214 <draw_char+0xc8>
 8002274:	e000      	b.n	8002278 <draw_char+0x12c>
                    break;
 8002276:	bf00      	nop
        for( x = 0 ; x < pGlyph->bbxw ; x+=8 )
 8002278:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800227a:	3308      	adds	r3, #8
 800227c:	b29b      	uxth	r3, r3
 800227e:	84fb      	strh	r3, [r7, #38]	; 0x26
 8002280:	69fb      	ldr	r3, [r7, #28]
 8002282:	f993 3009 	ldrsb.w	r3, [r3, #9]
 8002286:	b21b      	sxth	r3, r3
 8002288:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 800228c:	429a      	cmp	r2, r3
 800228e:	dbaf      	blt.n	80021f0 <draw_char+0xa4>
    for( y = 0 ; y < pGlyph->bbxh ; y++ )
 8002290:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8002294:	b29b      	uxth	r3, r3
 8002296:	3301      	adds	r3, #1
 8002298:	b29b      	uxth	r3, r3
 800229a:	84bb      	strh	r3, [r7, #36]	; 0x24
 800229c:	69fb      	ldr	r3, [r7, #28]
 800229e:	f993 300a 	ldrsb.w	r3, [r3, #10]
 80022a2:	b21b      	sxth	r3, r3
 80022a4:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 80022a8:	429a      	cmp	r2, r3
 80022aa:	db87      	blt.n	80021bc <draw_char+0x70>
                }
            }
        }
    }
}
 80022ac:	bf00      	nop
 80022ae:	bf00      	nop
 80022b0:	3728      	adds	r7, #40	; 0x28
 80022b2:	46bd      	mov	sp, r7
 80022b4:	bd80      	pop	{r7, pc}

080022b6 <get_char_rect>:


tRectangle get_char_rect( const tFont *pFont, uint8_t c )
{
 80022b6:	b480      	push	{r7}
 80022b8:	b087      	sub	sp, #28
 80022ba:	af00      	add	r7, sp, #0
 80022bc:	60f8      	str	r0, [r7, #12]
 80022be:	60b9      	str	r1, [r7, #8]
 80022c0:	4613      	mov	r3, r2
 80022c2:	71fb      	strb	r3, [r7, #7]
    tRectangle rect = {0};
 80022c4:	f107 0310 	add.w	r3, r7, #16
 80022c8:	2200      	movs	r2, #0
 80022ca:	601a      	str	r2, [r3, #0]
 80022cc:	605a      	str	r2, [r3, #4]

    rect.width = pFont->pGlyphs[c-32]->dwidthx;
 80022ce:	68bb      	ldr	r3, [r7, #8]
 80022d0:	68da      	ldr	r2, [r3, #12]
 80022d2:	79fb      	ldrb	r3, [r7, #7]
 80022d4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80022d8:	3b20      	subs	r3, #32
 80022da:	009b      	lsls	r3, r3, #2
 80022dc:	4413      	add	r3, r2
 80022de:	681b      	ldr	r3, [r3, #0]
 80022e0:	79db      	ldrb	r3, [r3, #7]
 80022e2:	b21b      	sxth	r3, r3
 80022e4:	82bb      	strh	r3, [r7, #20]
    rect.height = pFont->bbxh;
 80022e6:	68bb      	ldr	r3, [r7, #8]
 80022e8:	f993 3009 	ldrsb.w	r3, [r3, #9]
 80022ec:	b21b      	sxth	r3, r3
 80022ee:	82fb      	strh	r3, [r7, #22]
    return rect;
 80022f0:	68fb      	ldr	r3, [r7, #12]
 80022f2:	461a      	mov	r2, r3
 80022f4:	f107 0310 	add.w	r3, r7, #16
 80022f8:	cb03      	ldmia	r3!, {r0, r1}
 80022fa:	6010      	str	r0, [r2, #0]
 80022fc:	6051      	str	r1, [r2, #4]
}
 80022fe:	68f8      	ldr	r0, [r7, #12]
 8002300:	371c      	adds	r7, #28
 8002302:	46bd      	mov	sp, r7
 8002304:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002308:	4770      	bx	lr

0800230a <get_text_rect>:

tRectangle get_text_rect( const tFont *pFont, char *pString )
{
 800230a:	b580      	push	{r7, lr}
 800230c:	b08a      	sub	sp, #40	; 0x28
 800230e:	af00      	add	r7, sp, #0
 8002310:	60f8      	str	r0, [r7, #12]
 8002312:	60b9      	str	r1, [r7, #8]
 8002314:	607a      	str	r2, [r7, #4]
	uint8_t i;
	tRectangle rect = {0};
 8002316:	f107 0314 	add.w	r3, r7, #20
 800231a:	2200      	movs	r2, #0
 800231c:	601a      	str	r2, [r3, #0]
 800231e:	605a      	str	r2, [r3, #4]

	rect.height = pFont->bbxh;
 8002320:	68bb      	ldr	r3, [r7, #8]
 8002322:	f993 3009 	ldrsb.w	r3, [r3, #9]
 8002326:	b21b      	sxth	r3, r3
 8002328:	837b      	strh	r3, [r7, #26]
	for( i = 0 ; pString[i] != '\0' ; i++ )
 800232a:	2300      	movs	r3, #0
 800232c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8002330:	e019      	b.n	8002366 <get_text_rect+0x5c>
	{
		rect.width += get_char_rect( pFont, pString[i] ).width;
 8002332:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8002336:	687a      	ldr	r2, [r7, #4]
 8002338:	4413      	add	r3, r2
 800233a:	781a      	ldrb	r2, [r3, #0]
 800233c:	f107 031c 	add.w	r3, r7, #28
 8002340:	68b9      	ldr	r1, [r7, #8]
 8002342:	4618      	mov	r0, r3
 8002344:	f7ff ffb7 	bl	80022b6 <get_char_rect>
 8002348:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 800234c:	f9b7 2018 	ldrsh.w	r2, [r7, #24]
 8002350:	b292      	uxth	r2, r2
 8002352:	b29b      	uxth	r3, r3
 8002354:	4413      	add	r3, r2
 8002356:	b29b      	uxth	r3, r3
 8002358:	b21b      	sxth	r3, r3
 800235a:	833b      	strh	r3, [r7, #24]
	for( i = 0 ; pString[i] != '\0' ; i++ )
 800235c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8002360:	3301      	adds	r3, #1
 8002362:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8002366:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800236a:	687a      	ldr	r2, [r7, #4]
 800236c:	4413      	add	r3, r2
 800236e:	781b      	ldrb	r3, [r3, #0]
 8002370:	2b00      	cmp	r3, #0
 8002372:	d1de      	bne.n	8002332 <get_text_rect+0x28>
    }

    return rect;
 8002374:	68fb      	ldr	r3, [r7, #12]
 8002376:	461a      	mov	r2, r3
 8002378:	f107 0314 	add.w	r3, r7, #20
 800237c:	cb03      	ldmia	r3!, {r0, r1}
 800237e:	6010      	str	r0, [r2, #0]
 8002380:	6051      	str	r1, [r2, #4]
}
 8002382:	68f8      	ldr	r0, [r7, #12]
 8002384:	3728      	adds	r7, #40	; 0x28
 8002386:	46bd      	mov	sp, r7
 8002388:	bd80      	pop	{r7, pc}
	...

0800238c <lcd_bmp>:
	        }
	    }
}

void lcd_bmp( int16_t x, int16_t y, int16_t w, int16_t h, uint8_t *buf )
{
 800238c:	b490      	push	{r4, r7}
 800238e:	b088      	sub	sp, #32
 8002390:	af00      	add	r7, sp, #0
 8002392:	4604      	mov	r4, r0
 8002394:	4608      	mov	r0, r1
 8002396:	4611      	mov	r1, r2
 8002398:	461a      	mov	r2, r3
 800239a:	4623      	mov	r3, r4
 800239c:	80fb      	strh	r3, [r7, #6]
 800239e:	4603      	mov	r3, r0
 80023a0:	80bb      	strh	r3, [r7, #4]
 80023a2:	460b      	mov	r3, r1
 80023a4:	807b      	strh	r3, [r7, #2]
 80023a6:	4613      	mov	r3, r2
 80023a8:	803b      	strh	r3, [r7, #0]
	int16_t x0 = x;
 80023aa:	88fb      	ldrh	r3, [r7, #6]
 80023ac:	83fb      	strh	r3, [r7, #30]
	int16_t y0 = y;
 80023ae:	88bb      	ldrh	r3, [r7, #4]
 80023b0:	83bb      	strh	r3, [r7, #28]
	int16_t x1 = x + w - 1;
 80023b2:	88fa      	ldrh	r2, [r7, #6]
 80023b4:	887b      	ldrh	r3, [r7, #2]
 80023b6:	4413      	add	r3, r2
 80023b8:	b29b      	uxth	r3, r3
 80023ba:	3b01      	subs	r3, #1
 80023bc:	b29b      	uxth	r3, r3
 80023be:	837b      	strh	r3, [r7, #26]
	int16_t y1 = y + h - 1;
 80023c0:	88ba      	ldrh	r2, [r7, #4]
 80023c2:	883b      	ldrh	r3, [r7, #0]
 80023c4:	4413      	add	r3, r2
 80023c6:	b29b      	uxth	r3, r3
 80023c8:	3b01      	subs	r3, #1
 80023ca:	b29b      	uxth	r3, r3
 80023cc:	833b      	strh	r3, [r7, #24]

	if( x0 < 0 )
 80023ce:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80023d2:	2b00      	cmp	r3, #0
 80023d4:	da02      	bge.n	80023dc <lcd_bmp+0x50>
	{
		x0 = 0;
 80023d6:	2300      	movs	r3, #0
 80023d8:	83fb      	strh	r3, [r7, #30]
 80023da:	e007      	b.n	80023ec <lcd_bmp+0x60>
	}
	else if( x0 > 480 - 1 )
 80023dc:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80023e0:	f5b3 7ff0 	cmp.w	r3, #480	; 0x1e0
 80023e4:	db02      	blt.n	80023ec <lcd_bmp+0x60>
	{
		x0 = 480 - 1;
 80023e6:	f240 13df 	movw	r3, #479	; 0x1df
 80023ea:	83fb      	strh	r3, [r7, #30]
	}

	if( x1 < 0 )
 80023ec:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80023f0:	2b00      	cmp	r3, #0
 80023f2:	da02      	bge.n	80023fa <lcd_bmp+0x6e>
	{
		x1 = 0;
 80023f4:	2300      	movs	r3, #0
 80023f6:	837b      	strh	r3, [r7, #26]
 80023f8:	e007      	b.n	800240a <lcd_bmp+0x7e>
	}
	else if( x1 > 480 - 1 )
 80023fa:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80023fe:	f5b3 7ff0 	cmp.w	r3, #480	; 0x1e0
 8002402:	db02      	blt.n	800240a <lcd_bmp+0x7e>
	{
		x1 = 480 - 1;
 8002404:	f240 13df 	movw	r3, #479	; 0x1df
 8002408:	837b      	strh	r3, [r7, #26]
	}

	if( y0 < 0 )
 800240a:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 800240e:	2b00      	cmp	r3, #0
 8002410:	da02      	bge.n	8002418 <lcd_bmp+0x8c>
	{
		y0 = 0;
 8002412:	2300      	movs	r3, #0
 8002414:	83bb      	strh	r3, [r7, #28]
 8002416:	e007      	b.n	8002428 <lcd_bmp+0x9c>
	}
	else if( y0 > 320 - 1 )
 8002418:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 800241c:	f5b3 7fa0 	cmp.w	r3, #320	; 0x140
 8002420:	db02      	blt.n	8002428 <lcd_bmp+0x9c>
	{
		y0 = 320 - 1;
 8002422:	f240 133f 	movw	r3, #319	; 0x13f
 8002426:	83bb      	strh	r3, [r7, #28]
	}

	if( y1 < 0 )
 8002428:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 800242c:	2b00      	cmp	r3, #0
 800242e:	da02      	bge.n	8002436 <lcd_bmp+0xaa>
	{
		y1 = 0;
 8002430:	2300      	movs	r3, #0
 8002432:	833b      	strh	r3, [r7, #24]
 8002434:	e007      	b.n	8002446 <lcd_bmp+0xba>
	}
	else if( y1 > 320 - 1 )
 8002436:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 800243a:	f5b3 7fa0 	cmp.w	r3, #320	; 0x140
 800243e:	db02      	blt.n	8002446 <lcd_bmp+0xba>
	{
		y1 = 320 - 1;
 8002440:	f240 133f 	movw	r3, #319	; 0x13f
 8002444:	833b      	strh	r3, [r7, #24]
	}

	if( x0 > x1 )
 8002446:	f9b7 201e 	ldrsh.w	r2, [r7, #30]
 800244a:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 800244e:	429a      	cmp	r2, r3
 8002450:	dd06      	ble.n	8002460 <lcd_bmp+0xd4>
	{
		int tmp = x0;
 8002452:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8002456:	613b      	str	r3, [r7, #16]
		x0 = x1;
 8002458:	8b7b      	ldrh	r3, [r7, #26]
 800245a:	83fb      	strh	r3, [r7, #30]
		x1 = tmp;
 800245c:	693b      	ldr	r3, [r7, #16]
 800245e:	837b      	strh	r3, [r7, #26]
	}

	if( y0 > y1 )
 8002460:	f9b7 201c 	ldrsh.w	r2, [r7, #28]
 8002464:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8002468:	429a      	cmp	r2, r3
 800246a:	dd06      	ble.n	800247a <lcd_bmp+0xee>
	{
		int tmp = y0;
 800246c:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8002470:	60fb      	str	r3, [r7, #12]
		y0 = y1;
 8002472:	8b3b      	ldrh	r3, [r7, #24]
 8002474:	83bb      	strh	r3, [r7, #28]
		y1 = tmp;
 8002476:	68fb      	ldr	r3, [r7, #12]
 8002478:	833b      	strh	r3, [r7, #24]
	}

	w = x1 - x0 + 1;
 800247a:	8b7a      	ldrh	r2, [r7, #26]
 800247c:	8bfb      	ldrh	r3, [r7, #30]
 800247e:	1ad3      	subs	r3, r2, r3
 8002480:	b29b      	uxth	r3, r3
 8002482:	3301      	adds	r3, #1
 8002484:	b29b      	uxth	r3, r3
 8002486:	807b      	strh	r3, [r7, #2]
	h = y1 - y0 + 1;
 8002488:	8b3a      	ldrh	r2, [r7, #24]
 800248a:	8bbb      	ldrh	r3, [r7, #28]
 800248c:	1ad3      	subs	r3, r2, r3
 800248e:	b29b      	uxth	r3, r3
 8002490:	3301      	adds	r3, #1
 8002492:	b29b      	uxth	r3, r3
 8002494:	803b      	strh	r3, [r7, #0]

	uint32_t i = 0;
 8002496:	2300      	movs	r3, #0
 8002498:	617b      	str	r3, [r7, #20]
	uint32_t n = w*h;
 800249a:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800249e:	f9b7 2000 	ldrsh.w	r2, [r7]
 80024a2:	fb02 f303 	mul.w	r3, r2, r3
 80024a6:	60bb      	str	r3, [r7, #8]

	//uint16_t color_l = (color>>0)&0x1FF;
	//uint16_t color_h = (color>>9)&0x1FF;

	*addr_cmd = 0x2A;
 80024a8:	4b2e      	ldr	r3, [pc, #184]	; (8002564 <lcd_bmp+0x1d8>)
 80024aa:	681b      	ldr	r3, [r3, #0]
 80024ac:	222a      	movs	r2, #42	; 0x2a
 80024ae:	801a      	strh	r2, [r3, #0]
	*addr_data = (x0>>8)&0xFF;
 80024b0:	8bfa      	ldrh	r2, [r7, #30]
 80024b2:	4b2d      	ldr	r3, [pc, #180]	; (8002568 <lcd_bmp+0x1dc>)
 80024b4:	681b      	ldr	r3, [r3, #0]
 80024b6:	0a12      	lsrs	r2, r2, #8
 80024b8:	b292      	uxth	r2, r2
 80024ba:	801a      	strh	r2, [r3, #0]
	*addr_data = (x0>>0)&0xFF;
 80024bc:	8bfa      	ldrh	r2, [r7, #30]
 80024be:	4b2a      	ldr	r3, [pc, #168]	; (8002568 <lcd_bmp+0x1dc>)
 80024c0:	681b      	ldr	r3, [r3, #0]
 80024c2:	b2d2      	uxtb	r2, r2
 80024c4:	b292      	uxth	r2, r2
 80024c6:	801a      	strh	r2, [r3, #0]
	*addr_data = (x1>>8)&0xFF;
 80024c8:	8b7a      	ldrh	r2, [r7, #26]
 80024ca:	4b27      	ldr	r3, [pc, #156]	; (8002568 <lcd_bmp+0x1dc>)
 80024cc:	681b      	ldr	r3, [r3, #0]
 80024ce:	0a12      	lsrs	r2, r2, #8
 80024d0:	b292      	uxth	r2, r2
 80024d2:	801a      	strh	r2, [r3, #0]
	*addr_data = (x1>>0)&0xFF;
 80024d4:	8b7a      	ldrh	r2, [r7, #26]
 80024d6:	4b24      	ldr	r3, [pc, #144]	; (8002568 <lcd_bmp+0x1dc>)
 80024d8:	681b      	ldr	r3, [r3, #0]
 80024da:	b2d2      	uxtb	r2, r2
 80024dc:	b292      	uxth	r2, r2
 80024de:	801a      	strh	r2, [r3, #0]

	*addr_cmd = 0x2B;
 80024e0:	4b20      	ldr	r3, [pc, #128]	; (8002564 <lcd_bmp+0x1d8>)
 80024e2:	681b      	ldr	r3, [r3, #0]
 80024e4:	222b      	movs	r2, #43	; 0x2b
 80024e6:	801a      	strh	r2, [r3, #0]
	*addr_data = (y0>>8)&0xFF;
 80024e8:	8bba      	ldrh	r2, [r7, #28]
 80024ea:	4b1f      	ldr	r3, [pc, #124]	; (8002568 <lcd_bmp+0x1dc>)
 80024ec:	681b      	ldr	r3, [r3, #0]
 80024ee:	0a12      	lsrs	r2, r2, #8
 80024f0:	b292      	uxth	r2, r2
 80024f2:	801a      	strh	r2, [r3, #0]
	*addr_data = (y0>>0)&0xFF;
 80024f4:	8bba      	ldrh	r2, [r7, #28]
 80024f6:	4b1c      	ldr	r3, [pc, #112]	; (8002568 <lcd_bmp+0x1dc>)
 80024f8:	681b      	ldr	r3, [r3, #0]
 80024fa:	b2d2      	uxtb	r2, r2
 80024fc:	b292      	uxth	r2, r2
 80024fe:	801a      	strh	r2, [r3, #0]
	*addr_data = (y1>>8)&0xFF;
 8002500:	8b3a      	ldrh	r2, [r7, #24]
 8002502:	4b19      	ldr	r3, [pc, #100]	; (8002568 <lcd_bmp+0x1dc>)
 8002504:	681b      	ldr	r3, [r3, #0]
 8002506:	0a12      	lsrs	r2, r2, #8
 8002508:	b292      	uxth	r2, r2
 800250a:	801a      	strh	r2, [r3, #0]
	*addr_data = (y1>>0)&0xFF;
 800250c:	8b3a      	ldrh	r2, [r7, #24]
 800250e:	4b16      	ldr	r3, [pc, #88]	; (8002568 <lcd_bmp+0x1dc>)
 8002510:	681b      	ldr	r3, [r3, #0]
 8002512:	b2d2      	uxtb	r2, r2
 8002514:	b292      	uxth	r2, r2
 8002516:	801a      	strh	r2, [r3, #0]

	*addr_cmd = 0x2C;
 8002518:	4b12      	ldr	r3, [pc, #72]	; (8002564 <lcd_bmp+0x1d8>)
 800251a:	681b      	ldr	r3, [r3, #0]
 800251c:	222c      	movs	r2, #44	; 0x2c
 800251e:	801a      	strh	r2, [r3, #0]
	for( i = 0 ; i < n ; i++ )
 8002520:	2300      	movs	r3, #0
 8002522:	617b      	str	r3, [r7, #20]
 8002524:	e014      	b.n	8002550 <lcd_bmp+0x1c4>
	{
		*addr_data = *buf;
 8002526:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002528:	781a      	ldrb	r2, [r3, #0]
 800252a:	4b0f      	ldr	r3, [pc, #60]	; (8002568 <lcd_bmp+0x1dc>)
 800252c:	681b      	ldr	r3, [r3, #0]
 800252e:	b292      	uxth	r2, r2
 8002530:	801a      	strh	r2, [r3, #0]
		buf++;
 8002532:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002534:	3301      	adds	r3, #1
 8002536:	62bb      	str	r3, [r7, #40]	; 0x28
		*addr_data = *buf;
 8002538:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800253a:	781a      	ldrb	r2, [r3, #0]
 800253c:	4b0a      	ldr	r3, [pc, #40]	; (8002568 <lcd_bmp+0x1dc>)
 800253e:	681b      	ldr	r3, [r3, #0]
 8002540:	b292      	uxth	r2, r2
 8002542:	801a      	strh	r2, [r3, #0]
		buf++;
 8002544:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002546:	3301      	adds	r3, #1
 8002548:	62bb      	str	r3, [r7, #40]	; 0x28
	for( i = 0 ; i < n ; i++ )
 800254a:	697b      	ldr	r3, [r7, #20]
 800254c:	3301      	adds	r3, #1
 800254e:	617b      	str	r3, [r7, #20]
 8002550:	697a      	ldr	r2, [r7, #20]
 8002552:	68bb      	ldr	r3, [r7, #8]
 8002554:	429a      	cmp	r2, r3
 8002556:	d3e6      	bcc.n	8002526 <lcd_bmp+0x19a>
	}
}
 8002558:	bf00      	nop
 800255a:	bf00      	nop
 800255c:	3720      	adds	r7, #32
 800255e:	46bd      	mov	sp, r7
 8002560:	bc90      	pop	{r4, r7}
 8002562:	4770      	bx	lr
 8002564:	20000000 	.word	0x20000000
 8002568:	20000004 	.word	0x20000004

0800256c <oscilloscope_process>:
    nk_bool draw_bg;
    int draw_signals;
};
int visible = 0;
void oscilloscope_process(struct Oscilloscope *osc, struct nk_context *ctx)
{
 800256c:	b5b0      	push	{r4, r5, r7, lr}
 800256e:	b0e6      	sub	sp, #408	; 0x198
 8002570:	af04      	add	r7, sp, #16
 8002572:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002576:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 800257a:	6018      	str	r0, [r3, #0]
 800257c:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002580:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002584:	6019      	str	r1, [r3, #0]
	visible = 0;
 8002586:	4b6d      	ldr	r3, [pc, #436]	; (800273c <oscilloscope_process+0x1d0>)
 8002588:	2200      	movs	r2, #0
 800258a:	601a      	str	r2, [r3, #0]
	if( nk_begin(ctx, "STM32G4 Scope", nk_rect(0, 0, 480, 320), NK_WINDOW_MINIMIZABLE ) )
 800258c:	eddf 1a6c 	vldr	s3, [pc, #432]	; 8002740 <oscilloscope_process+0x1d4>
 8002590:	ed9f 1a6c 	vldr	s2, [pc, #432]	; 8002744 <oscilloscope_process+0x1d8>
 8002594:	eddf 0a6c 	vldr	s1, [pc, #432]	; 8002748 <oscilloscope_process+0x1dc>
 8002598:	ed9f 0a6b 	vldr	s0, [pc, #428]	; 8002748 <oscilloscope_process+0x1dc>
 800259c:	f011 f8da 	bl	8013754 <nk_rect>
 80025a0:	eeb0 6a40 	vmov.f32	s12, s0
 80025a4:	eef0 6a60 	vmov.f32	s13, s1
 80025a8:	eeb0 7a41 	vmov.f32	s14, s2
 80025ac:	eef0 7a61 	vmov.f32	s15, s3
 80025b0:	ed87 6a44 	vstr	s12, [r7, #272]	; 0x110
 80025b4:	edc7 6a45 	vstr	s13, [r7, #276]	; 0x114
 80025b8:	ed87 7a46 	vstr	s14, [r7, #280]	; 0x118
 80025bc:	edc7 7a47 	vstr	s15, [r7, #284]	; 0x11c
 80025c0:	ed97 6a44 	vldr	s12, [r7, #272]	; 0x110
 80025c4:	edd7 6a45 	vldr	s13, [r7, #276]	; 0x114
 80025c8:	ed97 7a46 	vldr	s14, [r7, #280]	; 0x118
 80025cc:	edd7 7a47 	vldr	s15, [r7, #284]	; 0x11c
 80025d0:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80025d4:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 80025d8:	2210      	movs	r2, #16
 80025da:	eeb0 0a46 	vmov.f32	s0, s12
 80025de:	eef0 0a66 	vmov.f32	s1, s13
 80025e2:	eeb0 1a47 	vmov.f32	s2, s14
 80025e6:	eef0 1a67 	vmov.f32	s3, s15
 80025ea:	4958      	ldr	r1, [pc, #352]	; (800274c <oscilloscope_process+0x1e0>)
 80025ec:	6818      	ldr	r0, [r3, #0]
 80025ee:	f01a fb7c 	bl	801ccea <nk_begin>
 80025f2:	4603      	mov	r3, r0
 80025f4:	2b00      	cmp	r3, #0
 80025f6:	f001 8172 	beq.w	80038de <oscilloscope_process+0x1372>
	{
		visible = 1;
 80025fa:	4b50      	ldr	r3, [pc, #320]	; (800273c <oscilloscope_process+0x1d0>)
 80025fc:	2201      	movs	r2, #1
 80025fe:	601a      	str	r2, [r3, #0]
        osc->draw_bg = nk_true;
 8002600:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002604:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002608:	681b      	ldr	r3, [r3, #0]
 800260a:	2201      	movs	r2, #1
 800260c:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
        if( nk_tree_push( ctx, NK_TREE_TAB, "Acquire", NK_MAXIMIZED) ){
 8002610:	484f      	ldr	r0, [pc, #316]	; (8002750 <oscilloscope_process+0x1e4>)
 8002612:	f019 fd27 	bl	801c064 <nk_strlen>
 8002616:	4603      	mov	r3, r0
 8002618:	f507 72c4 	add.w	r2, r7, #392	; 0x188
 800261c:	f5a2 70c4 	sub.w	r0, r2, #392	; 0x188
 8002620:	f240 2267 	movw	r2, #615	; 0x267
 8002624:	9202      	str	r2, [sp, #8]
 8002626:	9301      	str	r3, [sp, #4]
 8002628:	4b49      	ldr	r3, [pc, #292]	; (8002750 <oscilloscope_process+0x1e4>)
 800262a:	9300      	str	r3, [sp, #0]
 800262c:	2301      	movs	r3, #1
 800262e:	4a49      	ldr	r2, [pc, #292]	; (8002754 <oscilloscope_process+0x1e8>)
 8002630:	2101      	movs	r1, #1
 8002632:	6800      	ldr	r0, [r0, #0]
 8002634:	f019 fa68 	bl	801bb08 <nk_tree_push_hashed>
 8002638:	4603      	mov	r3, r0
 800263a:	2b00      	cmp	r3, #0
 800263c:	f000 80a5 	beq.w	800278a <oscilloscope_process+0x21e>
            osc->draw_bg = nk_false;
 8002640:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002644:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002648:	681b      	ldr	r3, [r3, #0]
 800264a:	2200      	movs	r2, #0
 800264c:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
            nk_layout_row(ctx, NK_STATIC, 30, 4, (float[]){60, 60, 60, 60});
 8002650:	4b41      	ldr	r3, [pc, #260]	; (8002758 <oscilloscope_process+0x1ec>)
 8002652:	f507 7480 	add.w	r4, r7, #256	; 0x100
 8002656:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8002658:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 800265c:	f507 7380 	add.w	r3, r7, #256	; 0x100
 8002660:	f507 72c4 	add.w	r2, r7, #392	; 0x188
 8002664:	f5a2 70c4 	sub.w	r0, r2, #392	; 0x188
 8002668:	2204      	movs	r2, #4
 800266a:	eeb3 0a0e 	vmov.f32	s0, #62	; 0x41f00000  30.0
 800266e:	2101      	movs	r1, #1
 8002670:	6800      	ldr	r0, [r0, #0]
 8002672:	f010 fb1b 	bl	8012cac <nk_layout_row>
            if (osc->acquire_run) {
 8002676:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800267a:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 800267e:	681b      	ldr	r3, [r3, #0]
 8002680:	681b      	ldr	r3, [r3, #0]
 8002682:	2b00      	cmp	r3, #0
 8002684:	d012      	beq.n	80026ac <oscilloscope_process+0x140>
                if (nk_button_label(ctx, "Stop")) {
 8002686:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800268a:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 800268e:	4933      	ldr	r1, [pc, #204]	; (800275c <oscilloscope_process+0x1f0>)
 8002690:	6818      	ldr	r0, [r3, #0]
 8002692:	f00c fb17 	bl	800ecc4 <nk_button_label>
 8002696:	4603      	mov	r3, r0
 8002698:	2b00      	cmp	r3, #0
 800269a:	d019      	beq.n	80026d0 <oscilloscope_process+0x164>
                    osc->acquire_run = nk_false;
 800269c:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80026a0:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 80026a4:	681b      	ldr	r3, [r3, #0]
 80026a6:	2200      	movs	r2, #0
 80026a8:	601a      	str	r2, [r3, #0]
 80026aa:	e011      	b.n	80026d0 <oscilloscope_process+0x164>
                }
            } else {
                if (nk_button_label(ctx, "Run")) {
 80026ac:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80026b0:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 80026b4:	492a      	ldr	r1, [pc, #168]	; (8002760 <oscilloscope_process+0x1f4>)
 80026b6:	6818      	ldr	r0, [r3, #0]
 80026b8:	f00c fb04 	bl	800ecc4 <nk_button_label>
 80026bc:	4603      	mov	r3, r0
 80026be:	2b00      	cmp	r3, #0
 80026c0:	d006      	beq.n	80026d0 <oscilloscope_process+0x164>
                    osc->acquire_run = nk_true;
 80026c2:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80026c6:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 80026ca:	681b      	ldr	r3, [r3, #0]
 80026cc:	2201      	movs	r2, #1
 80026ce:	601a      	str	r2, [r3, #0]
                }
            }

            if (nk_button_label(ctx, "Single")) {
 80026d0:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80026d4:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 80026d8:	4922      	ldr	r1, [pc, #136]	; (8002764 <oscilloscope_process+0x1f8>)
 80026da:	6818      	ldr	r0, [r3, #0]
 80026dc:	f00c faf2 	bl	800ecc4 <nk_button_label>
 80026e0:	4603      	mov	r3, r0
 80026e2:	2b00      	cmp	r3, #0
 80026e4:	d006      	beq.n	80026f4 <oscilloscope_process+0x188>
                osc->acquire_single = nk_true;
 80026e6:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80026ea:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 80026ee:	681b      	ldr	r3, [r3, #0]
 80026f0:	2201      	movs	r2, #1
 80026f2:	605a      	str	r2, [r3, #4]
            }

            if (nk_button_label(ctx, "Draw")) {
 80026f4:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80026f8:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 80026fc:	491a      	ldr	r1, [pc, #104]	; (8002768 <oscilloscope_process+0x1fc>)
 80026fe:	6818      	ldr	r0, [r3, #0]
 8002700:	f00c fae0 	bl	800ecc4 <nk_button_label>
 8002704:	4603      	mov	r3, r0
 8002706:	2b00      	cmp	r3, #0
 8002708:	d038      	beq.n	800277c <oscilloscope_process+0x210>
                if (osc->draw_signals + 1 < 3) {
 800270a:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800270e:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002712:	681b      	ldr	r3, [r3, #0]
 8002714:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 8002718:	2b01      	cmp	r3, #1
 800271a:	dc27      	bgt.n	800276c <oscilloscope_process+0x200>
                    osc->draw_signals += 1;
 800271c:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002720:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002724:	681b      	ldr	r3, [r3, #0]
 8002726:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 800272a:	1c5a      	adds	r2, r3, #1
 800272c:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002730:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002734:	681b      	ldr	r3, [r3, #0]
 8002736:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
 800273a:	e01f      	b.n	800277c <oscilloscope_process+0x210>
 800273c:	200007ec 	.word	0x200007ec
 8002740:	43a00000 	.word	0x43a00000
 8002744:	43f00000 	.word	0x43f00000
 8002748:	00000000 	.word	0x00000000
 800274c:	08021190 	.word	0x08021190
 8002750:	080211a0 	.word	0x080211a0
 8002754:	080211b8 	.word	0x080211b8
 8002758:	0802130c 	.word	0x0802130c
 800275c:	080211c0 	.word	0x080211c0
 8002760:	080211c8 	.word	0x080211c8
 8002764:	080211cc 	.word	0x080211cc
 8002768:	080211d4 	.word	0x080211d4
                } else {
                    osc->draw_signals = 0;
 800276c:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002770:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002774:	681b      	ldr	r3, [r3, #0]
 8002776:	2200      	movs	r2, #0
 8002778:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
                }
            }
            nk_tree_pop(ctx);
 800277c:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002780:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002784:	6818      	ldr	r0, [r3, #0]
 8002786:	f019 f9dc 	bl	801bb42 <nk_tree_pop>
        }

        {
        	if( nk_tree_push( ctx, NK_TREE_TAB, "Horizontal", NK_MINIMIZED) ){
 800278a:	48d8      	ldr	r0, [pc, #864]	; (8002aec <oscilloscope_process+0x580>)
 800278c:	f019 fc6a 	bl	801c064 <nk_strlen>
 8002790:	4603      	mov	r3, r0
 8002792:	f507 72c4 	add.w	r2, r7, #392	; 0x188
 8002796:	f5a2 70c4 	sub.w	r0, r2, #392	; 0x188
 800279a:	f240 2283 	movw	r2, #643	; 0x283
 800279e:	9202      	str	r2, [sp, #8]
 80027a0:	9301      	str	r3, [sp, #4]
 80027a2:	4bd2      	ldr	r3, [pc, #840]	; (8002aec <oscilloscope_process+0x580>)
 80027a4:	9300      	str	r3, [sp, #0]
 80027a6:	2300      	movs	r3, #0
 80027a8:	4ad1      	ldr	r2, [pc, #836]	; (8002af0 <oscilloscope_process+0x584>)
 80027aa:	2101      	movs	r1, #1
 80027ac:	6800      	ldr	r0, [r0, #0]
 80027ae:	f019 f9ab 	bl	801bb08 <nk_tree_push_hashed>
 80027b2:	4603      	mov	r3, r0
 80027b4:	2b00      	cmp	r3, #0
 80027b6:	f000 80f4 	beq.w	80029a2 <oscilloscope_process+0x436>
        		nk_layout_row(ctx, NK_STATIC, 30, 4, (float[]){60, 30, 60, 30});
 80027ba:	4bce      	ldr	r3, [pc, #824]	; (8002af4 <oscilloscope_process+0x588>)
 80027bc:	f107 04f0 	add.w	r4, r7, #240	; 0xf0
 80027c0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80027c2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 80027c6:	f107 03f0 	add.w	r3, r7, #240	; 0xf0
 80027ca:	f507 72c4 	add.w	r2, r7, #392	; 0x188
 80027ce:	f5a2 70c4 	sub.w	r0, r2, #392	; 0x188
 80027d2:	2204      	movs	r2, #4
 80027d4:	eeb3 0a0e 	vmov.f32	s0, #62	; 0x41f00000  30.0
 80027d8:	2101      	movs	r1, #1
 80027da:	6800      	ldr	r0, [r0, #0]
 80027dc:	f010 fa66 	bl	8012cac <nk_layout_row>
        		nk_label( ctx, "Offset", NK_TEXT_ALIGN_LEFT );
 80027e0:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80027e4:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 80027e8:	2201      	movs	r2, #1
 80027ea:	49c3      	ldr	r1, [pc, #780]	; (8002af8 <oscilloscope_process+0x58c>)
 80027ec:	6818      	ldr	r0, [r3, #0]
 80027ee:	f018 fd45 	bl	801b27c <nk_label>
        		nk_button_set_behavior(ctx, NK_BUTTON_REPEATER);
 80027f2:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80027f6:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 80027fa:	2101      	movs	r1, #1
 80027fc:	6818      	ldr	r0, [r3, #0]
 80027fe:	f00c f95d 	bl	800eabc <nk_button_set_behavior>
        		if( nk_button_symbol(ctx, NK_SYMBOL_TRIANGLE_LEFT) )
 8002802:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002806:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 800280a:	2109      	movs	r1, #9
 800280c:	6818      	ldr	r0, [r3, #0]
 800280e:	f00c fb0f 	bl	800ee30 <nk_button_symbol>
 8002812:	4603      	mov	r3, r0
 8002814:	2b00      	cmp	r3, #0
 8002816:	d011      	beq.n	800283c <oscilloscope_process+0x2d0>
        		{
        			osc->horizontal_offset -= 1;
 8002818:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800281c:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002820:	681b      	ldr	r3, [r3, #0]
 8002822:	edd3 7a02 	vldr	s15, [r3, #8]
 8002826:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 800282a:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800282e:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002832:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002836:	681b      	ldr	r3, [r3, #0]
 8002838:	edc3 7a02 	vstr	s15, [r3, #8]
        		}
        		char combo_buffer[32];
        		sprintf(combo_buffer, "%.2f", osc->horizontal_offset);
 800283c:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002840:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002844:	681b      	ldr	r3, [r3, #0]
 8002846:	689b      	ldr	r3, [r3, #8]
 8002848:	4618      	mov	r0, r3
 800284a:	f7fd fea5 	bl	8000598 <__aeabi_f2d>
 800284e:	4602      	mov	r2, r0
 8002850:	460b      	mov	r3, r1
 8002852:	f107 000c 	add.w	r0, r7, #12
 8002856:	49a9      	ldr	r1, [pc, #676]	; (8002afc <oscilloscope_process+0x590>)
 8002858:	f01b fe24 	bl	801e4a4 <siprintf>
        		nk_label( ctx, combo_buffer, NK_TEXT_ALIGN_CENTERED );
 800285c:	f107 010c 	add.w	r1, r7, #12
 8002860:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002864:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002868:	2202      	movs	r2, #2
 800286a:	6818      	ldr	r0, [r3, #0]
 800286c:	f018 fd06 	bl	801b27c <nk_label>
        		nk_button_set_behavior(ctx, NK_BUTTON_REPEATER);
 8002870:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002874:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002878:	2101      	movs	r1, #1
 800287a:	6818      	ldr	r0, [r3, #0]
 800287c:	f00c f91e 	bl	800eabc <nk_button_set_behavior>
        		if( nk_button_symbol(ctx, NK_SYMBOL_TRIANGLE_RIGHT) )
 8002880:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002884:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002888:	210a      	movs	r1, #10
 800288a:	6818      	ldr	r0, [r3, #0]
 800288c:	f00c fad0 	bl	800ee30 <nk_button_symbol>
 8002890:	4603      	mov	r3, r0
 8002892:	2b00      	cmp	r3, #0
 8002894:	d011      	beq.n	80028ba <oscilloscope_process+0x34e>
        		{
        			osc->horizontal_offset += 1;
 8002896:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800289a:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 800289e:	681b      	ldr	r3, [r3, #0]
 80028a0:	edd3 7a02 	vldr	s15, [r3, #8]
 80028a4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80028a8:	ee77 7a87 	vadd.f32	s15, s15, s14
 80028ac:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80028b0:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 80028b4:	681b      	ldr	r3, [r3, #0]
 80028b6:	edc3 7a02 	vstr	s15, [r3, #8]
        		}

        		nk_label( ctx, "Scale", NK_TEXT_ALIGN_LEFT );
 80028ba:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80028be:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 80028c2:	2201      	movs	r2, #1
 80028c4:	498e      	ldr	r1, [pc, #568]	; (8002b00 <oscilloscope_process+0x594>)
 80028c6:	6818      	ldr	r0, [r3, #0]
 80028c8:	f018 fcd8 	bl	801b27c <nk_label>
				nk_button_set_behavior(ctx, NK_BUTTON_REPEATER);
 80028cc:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80028d0:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 80028d4:	2101      	movs	r1, #1
 80028d6:	6818      	ldr	r0, [r3, #0]
 80028d8:	f00c f8f0 	bl	800eabc <nk_button_set_behavior>
				if( nk_button_symbol(ctx, NK_SYMBOL_TRIANGLE_LEFT) )
 80028dc:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80028e0:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 80028e4:	2109      	movs	r1, #9
 80028e6:	6818      	ldr	r0, [r3, #0]
 80028e8:	f00c faa2 	bl	800ee30 <nk_button_symbol>
 80028ec:	4603      	mov	r3, r0
 80028ee:	2b00      	cmp	r3, #0
 80028f0:	d011      	beq.n	8002916 <oscilloscope_process+0x3aa>
				{
					osc->horizontal_scale -= 1;
 80028f2:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80028f6:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 80028fa:	681b      	ldr	r3, [r3, #0]
 80028fc:	edd3 7a03 	vldr	s15, [r3, #12]
 8002900:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8002904:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8002908:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800290c:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002910:	681b      	ldr	r3, [r3, #0]
 8002912:	edc3 7a03 	vstr	s15, [r3, #12]
				}
				//char combo_buffer[32];
				sprintf(combo_buffer, "%.2f", osc->horizontal_scale);
 8002916:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800291a:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 800291e:	681b      	ldr	r3, [r3, #0]
 8002920:	68db      	ldr	r3, [r3, #12]
 8002922:	4618      	mov	r0, r3
 8002924:	f7fd fe38 	bl	8000598 <__aeabi_f2d>
 8002928:	4602      	mov	r2, r0
 800292a:	460b      	mov	r3, r1
 800292c:	f107 000c 	add.w	r0, r7, #12
 8002930:	4972      	ldr	r1, [pc, #456]	; (8002afc <oscilloscope_process+0x590>)
 8002932:	f01b fdb7 	bl	801e4a4 <siprintf>
				nk_label( ctx, combo_buffer, NK_TEXT_ALIGN_CENTERED );
 8002936:	f107 010c 	add.w	r1, r7, #12
 800293a:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800293e:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002942:	2202      	movs	r2, #2
 8002944:	6818      	ldr	r0, [r3, #0]
 8002946:	f018 fc99 	bl	801b27c <nk_label>
				nk_button_set_behavior(ctx, NK_BUTTON_REPEATER);
 800294a:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800294e:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002952:	2101      	movs	r1, #1
 8002954:	6818      	ldr	r0, [r3, #0]
 8002956:	f00c f8b1 	bl	800eabc <nk_button_set_behavior>
				if( nk_button_symbol(ctx, NK_SYMBOL_TRIANGLE_RIGHT) )
 800295a:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800295e:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002962:	210a      	movs	r1, #10
 8002964:	6818      	ldr	r0, [r3, #0]
 8002966:	f00c fa63 	bl	800ee30 <nk_button_symbol>
 800296a:	4603      	mov	r3, r0
 800296c:	2b00      	cmp	r3, #0
 800296e:	d011      	beq.n	8002994 <oscilloscope_process+0x428>
				{
					osc->horizontal_scale += 1;
 8002970:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002974:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002978:	681b      	ldr	r3, [r3, #0]
 800297a:	edd3 7a03 	vldr	s15, [r3, #12]
 800297e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8002982:	ee77 7a87 	vadd.f32	s15, s15, s14
 8002986:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800298a:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 800298e:	681b      	ldr	r3, [r3, #0]
 8002990:	edc3 7a03 	vstr	s15, [r3, #12]
				}
                nk_tree_pop(ctx);
 8002994:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002998:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 800299c:	6818      	ldr	r0, [r3, #0]
 800299e:	f019 f8d0 	bl	801bb42 <nk_tree_pop>
            }

        	if( nk_tree_push( ctx, NK_TREE_TAB, "Vertical", NK_MINIMIZED) ){
 80029a2:	4858      	ldr	r0, [pc, #352]	; (8002b04 <oscilloscope_process+0x598>)
 80029a4:	f019 fb5e 	bl	801c064 <nk_strlen>
 80029a8:	4603      	mov	r3, r0
 80029aa:	f507 72c4 	add.w	r2, r7, #392	; 0x188
 80029ae:	f5a2 70c4 	sub.w	r0, r2, #392	; 0x188
 80029b2:	f240 22a5 	movw	r2, #677	; 0x2a5
 80029b6:	9202      	str	r2, [sp, #8]
 80029b8:	9301      	str	r3, [sp, #4]
 80029ba:	4b52      	ldr	r3, [pc, #328]	; (8002b04 <oscilloscope_process+0x598>)
 80029bc:	9300      	str	r3, [sp, #0]
 80029be:	2300      	movs	r3, #0
 80029c0:	4a51      	ldr	r2, [pc, #324]	; (8002b08 <oscilloscope_process+0x59c>)
 80029c2:	2101      	movs	r1, #1
 80029c4:	6800      	ldr	r0, [r0, #0]
 80029c6:	f019 f89f 	bl	801bb08 <nk_tree_push_hashed>
 80029ca:	4603      	mov	r3, r0
 80029cc:	2b00      	cmp	r3, #0
 80029ce:	f000 8292 	beq.w	8002ef6 <oscilloscope_process+0x98a>
        		nk_layout_row(ctx, NK_STATIC, 30, 1, (float[]){100});
 80029d2:	4b4e      	ldr	r3, [pc, #312]	; (8002b0c <oscilloscope_process+0x5a0>)
 80029d4:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 80029d8:	f107 03ec 	add.w	r3, r7, #236	; 0xec
 80029dc:	f507 72c4 	add.w	r2, r7, #392	; 0x188
 80029e0:	f5a2 70c4 	sub.w	r0, r2, #392	; 0x188
 80029e4:	2201      	movs	r2, #1
 80029e6:	eeb3 0a0e 	vmov.f32	s0, #62	; 0x41f00000  30.0
 80029ea:	2101      	movs	r1, #1
 80029ec:	6800      	ldr	r0, [r0, #0]
 80029ee:	f010 f95d 	bl	8012cac <nk_layout_row>
        		//nk_style_push_style_item(&ctx, &ctx->style.combo.button.text_background, nk_style_item_color(nk_rgb(255,0,0)));
        		osc->channel_selected = nk_combo(ctx, (const char*[]){"Ch1", "Ch2", "Ch3", "Ch4"}, CHANNEL_COUNT, osc->channel_selected, 20, nk_vec2(100, 100));
 80029f2:	4b47      	ldr	r3, [pc, #284]	; (8002b10 <oscilloscope_process+0x5a4>)
 80029f4:	f107 04dc 	add.w	r4, r7, #220	; 0xdc
 80029f8:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80029fa:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 80029fe:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002a02:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002a06:	681b      	ldr	r3, [r3, #0]
 8002a08:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8002a0a:	eddf 0a42 	vldr	s1, [pc, #264]	; 8002b14 <oscilloscope_process+0x5a8>
 8002a0e:	ed9f 0a41 	vldr	s0, [pc, #260]	; 8002b14 <oscilloscope_process+0x5a8>
 8002a12:	f010 ff51 	bl	80138b8 <nk_vec2>
 8002a16:	eeb0 7a40 	vmov.f32	s14, s0
 8002a1a:	eef0 7a60 	vmov.f32	s15, s1
 8002a1e:	ed87 7a48 	vstr	s14, [r7, #288]	; 0x120
 8002a22:	edc7 7a49 	vstr	s15, [r7, #292]	; 0x124
 8002a26:	ed97 7a48 	vldr	s14, [r7, #288]	; 0x120
 8002a2a:	edd7 7a49 	vldr	s15, [r7, #292]	; 0x124
 8002a2e:	f107 01dc 	add.w	r1, r7, #220	; 0xdc
 8002a32:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002a36:	f5a3 70c4 	sub.w	r0, r3, #392	; 0x188
 8002a3a:	2314      	movs	r3, #20
 8002a3c:	9300      	str	r3, [sp, #0]
 8002a3e:	eeb0 0a47 	vmov.f32	s0, s14
 8002a42:	eef0 0a67 	vmov.f32	s1, s15
 8002a46:	4623      	mov	r3, r4
 8002a48:	2204      	movs	r2, #4
 8002a4a:	6800      	ldr	r0, [r0, #0]
 8002a4c:	f00c fef2 	bl	800f834 <nk_combo>
 8002a50:	4602      	mov	r2, r0
 8002a52:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002a56:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002a5a:	681b      	ldr	r3, [r3, #0]
 8002a5c:	625a      	str	r2, [r3, #36]	; 0x24
        		//nk_style_pop_style_item(&ctx);
        		nk_layout_row(ctx, NK_STATIC, 30, 2, (float[]){100, 100});
 8002a5e:	4a2e      	ldr	r2, [pc, #184]	; (8002b18 <oscilloscope_process+0x5ac>)
 8002a60:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
 8002a64:	e892 0003 	ldmia.w	r2, {r0, r1}
 8002a68:	e883 0003 	stmia.w	r3, {r0, r1}
 8002a6c:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
 8002a70:	f507 72c4 	add.w	r2, r7, #392	; 0x188
 8002a74:	f5a2 70c4 	sub.w	r0, r2, #392	; 0x188
 8002a78:	2202      	movs	r2, #2
 8002a7a:	eeb3 0a0e 	vmov.f32	s0, #62	; 0x41f00000  30.0
 8002a7e:	2101      	movs	r1, #1
 8002a80:	6800      	ldr	r0, [r0, #0]
 8002a82:	f010 f913 	bl	8012cac <nk_layout_row>
                osc->channels[osc->channel_selected].enabled = nk_combo(ctx, (const char*[]){"Off", "On"}, 2, osc->channels[osc->channel_selected].enabled, 20, nk_vec2(60, 200));
 8002a86:	4a25      	ldr	r2, [pc, #148]	; (8002b1c <oscilloscope_process+0x5b0>)
 8002a88:	f107 03cc 	add.w	r3, r7, #204	; 0xcc
 8002a8c:	e892 0003 	ldmia.w	r2, {r0, r1}
 8002a90:	e883 0003 	stmia.w	r3, {r0, r1}
 8002a94:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002a98:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002a9c:	681b      	ldr	r3, [r3, #0]
 8002a9e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002aa0:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002aa4:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002aa8:	6819      	ldr	r1, [r3, #0]
 8002aaa:	4613      	mov	r3, r2
 8002aac:	009b      	lsls	r3, r3, #2
 8002aae:	4413      	add	r3, r2
 8002ab0:	009b      	lsls	r3, r3, #2
 8002ab2:	440b      	add	r3, r1
 8002ab4:	3328      	adds	r3, #40	; 0x28
 8002ab6:	681d      	ldr	r5, [r3, #0]
 8002ab8:	eddf 0a19 	vldr	s1, [pc, #100]	; 8002b20 <oscilloscope_process+0x5b4>
 8002abc:	ed9f 0a19 	vldr	s0, [pc, #100]	; 8002b24 <oscilloscope_process+0x5b8>
 8002ac0:	f010 fefa 	bl	80138b8 <nk_vec2>
 8002ac4:	eeb0 7a40 	vmov.f32	s14, s0
 8002ac8:	eef0 7a60 	vmov.f32	s15, s1
 8002acc:	ed87 7a4a 	vstr	s14, [r7, #296]	; 0x128
 8002ad0:	edc7 7a4b 	vstr	s15, [r7, #300]	; 0x12c
 8002ad4:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002ad8:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002adc:	681b      	ldr	r3, [r3, #0]
 8002ade:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8002ae0:	ed97 7a4a 	vldr	s14, [r7, #296]	; 0x128
 8002ae4:	edd7 7a4b 	vldr	s15, [r7, #300]	; 0x12c
 8002ae8:	e01e      	b.n	8002b28 <oscilloscope_process+0x5bc>
 8002aea:	bf00      	nop
 8002aec:	080211dc 	.word	0x080211dc
 8002af0:	080211f4 	.word	0x080211f4
 8002af4:	0802131c 	.word	0x0802131c
 8002af8:	08021200 	.word	0x08021200
 8002afc:	08021208 	.word	0x08021208
 8002b00:	08021210 	.word	0x08021210
 8002b04:	08021218 	.word	0x08021218
 8002b08:	08021230 	.word	0x08021230
 8002b0c:	42c80000 	.word	0x42c80000
 8002b10:	0802133c 	.word	0x0802133c
 8002b14:	42c80000 	.word	0x42c80000
 8002b18:	0802134c 	.word	0x0802134c
 8002b1c:	0802135c 	.word	0x0802135c
 8002b20:	43480000 	.word	0x43480000
 8002b24:	42700000 	.word	0x42700000
 8002b28:	f107 01cc 	add.w	r1, r7, #204	; 0xcc
 8002b2c:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002b30:	f5a3 70c4 	sub.w	r0, r3, #392	; 0x188
 8002b34:	2314      	movs	r3, #20
 8002b36:	9300      	str	r3, [sp, #0]
 8002b38:	eeb0 0a47 	vmov.f32	s0, s14
 8002b3c:	eef0 0a67 	vmov.f32	s1, s15
 8002b40:	462b      	mov	r3, r5
 8002b42:	2202      	movs	r2, #2
 8002b44:	6800      	ldr	r0, [r0, #0]
 8002b46:	f00c fe75 	bl	800f834 <nk_combo>
 8002b4a:	4601      	mov	r1, r0
 8002b4c:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002b50:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002b54:	681a      	ldr	r2, [r3, #0]
 8002b56:	4623      	mov	r3, r4
 8002b58:	009b      	lsls	r3, r3, #2
 8002b5a:	4423      	add	r3, r4
 8002b5c:	009b      	lsls	r3, r3, #2
 8002b5e:	4413      	add	r3, r2
 8002b60:	3328      	adds	r3, #40	; 0x28
 8002b62:	6019      	str	r1, [r3, #0]
                osc->channels[osc->channel_selected].coupling = nk_combo(ctx, (const char*[]){"DC", "AC", "Gnd"}, 3, osc->channels[osc->channel_selected].coupling, 20, nk_vec2(60, 200));
 8002b64:	4ad9      	ldr	r2, [pc, #868]	; (8002ecc <oscilloscope_process+0x960>)
 8002b66:	f107 03c0 	add.w	r3, r7, #192	; 0xc0
 8002b6a:	ca07      	ldmia	r2, {r0, r1, r2}
 8002b6c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 8002b70:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002b74:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002b78:	681b      	ldr	r3, [r3, #0]
 8002b7a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002b7c:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002b80:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002b84:	6819      	ldr	r1, [r3, #0]
 8002b86:	4613      	mov	r3, r2
 8002b88:	009b      	lsls	r3, r3, #2
 8002b8a:	4413      	add	r3, r2
 8002b8c:	009b      	lsls	r3, r3, #2
 8002b8e:	440b      	add	r3, r1
 8002b90:	332c      	adds	r3, #44	; 0x2c
 8002b92:	681d      	ldr	r5, [r3, #0]
 8002b94:	eddf 0ace 	vldr	s1, [pc, #824]	; 8002ed0 <oscilloscope_process+0x964>
 8002b98:	ed9f 0ace 	vldr	s0, [pc, #824]	; 8002ed4 <oscilloscope_process+0x968>
 8002b9c:	f010 fe8c 	bl	80138b8 <nk_vec2>
 8002ba0:	eeb0 7a40 	vmov.f32	s14, s0
 8002ba4:	eef0 7a60 	vmov.f32	s15, s1
 8002ba8:	ed87 7a4c 	vstr	s14, [r7, #304]	; 0x130
 8002bac:	edc7 7a4d 	vstr	s15, [r7, #308]	; 0x134
 8002bb0:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002bb4:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002bb8:	681b      	ldr	r3, [r3, #0]
 8002bba:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8002bbc:	ed97 7a4c 	vldr	s14, [r7, #304]	; 0x130
 8002bc0:	edd7 7a4d 	vldr	s15, [r7, #308]	; 0x134
 8002bc4:	f107 01c0 	add.w	r1, r7, #192	; 0xc0
 8002bc8:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002bcc:	f5a3 70c4 	sub.w	r0, r3, #392	; 0x188
 8002bd0:	2314      	movs	r3, #20
 8002bd2:	9300      	str	r3, [sp, #0]
 8002bd4:	eeb0 0a47 	vmov.f32	s0, s14
 8002bd8:	eef0 0a67 	vmov.f32	s1, s15
 8002bdc:	462b      	mov	r3, r5
 8002bde:	2203      	movs	r2, #3
 8002be0:	6800      	ldr	r0, [r0, #0]
 8002be2:	f00c fe27 	bl	800f834 <nk_combo>
 8002be6:	4601      	mov	r1, r0
 8002be8:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002bec:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002bf0:	681a      	ldr	r2, [r3, #0]
 8002bf2:	4623      	mov	r3, r4
 8002bf4:	009b      	lsls	r3, r3, #2
 8002bf6:	4423      	add	r3, r4
 8002bf8:	009b      	lsls	r3, r3, #2
 8002bfa:	4413      	add	r3, r2
 8002bfc:	332c      	adds	r3, #44	; 0x2c
 8002bfe:	6019      	str	r1, [r3, #0]
                //osc->channels[osc->channel_selected].offset = nk_slider_float(ctx, -10.0f, &osc->channels[osc->channel_selected].offset, 10.0f, 1.0f);
                //osc->channels[osc->channel_selected].scale = nk_slider_float(ctx, -10.0f, &osc->channels[osc->channel_selected].scale, 10.0f, 1.0f);

                nk_layout_row(ctx, NK_STATIC, 30, 4, (float[]){60, 30, 60, 30});
 8002c00:	4bb5      	ldr	r3, [pc, #724]	; (8002ed8 <oscilloscope_process+0x96c>)
 8002c02:	f107 04b0 	add.w	r4, r7, #176	; 0xb0
 8002c06:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8002c08:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 8002c0c:	f107 03b0 	add.w	r3, r7, #176	; 0xb0
 8002c10:	f507 72c4 	add.w	r2, r7, #392	; 0x188
 8002c14:	f5a2 70c4 	sub.w	r0, r2, #392	; 0x188
 8002c18:	2204      	movs	r2, #4
 8002c1a:	eeb3 0a0e 	vmov.f32	s0, #62	; 0x41f00000  30.0
 8002c1e:	2101      	movs	r1, #1
 8002c20:	6800      	ldr	r0, [r0, #0]
 8002c22:	f010 f843 	bl	8012cac <nk_layout_row>
        		nk_label( ctx, "Offset", NK_TEXT_ALIGN_LEFT );
 8002c26:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002c2a:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002c2e:	2201      	movs	r2, #1
 8002c30:	49aa      	ldr	r1, [pc, #680]	; (8002edc <oscilloscope_process+0x970>)
 8002c32:	6818      	ldr	r0, [r3, #0]
 8002c34:	f018 fb22 	bl	801b27c <nk_label>
        		nk_button_set_behavior(ctx, NK_BUTTON_REPEATER);
 8002c38:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002c3c:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002c40:	2101      	movs	r1, #1
 8002c42:	6818      	ldr	r0, [r3, #0]
 8002c44:	f00b ff3a 	bl	800eabc <nk_button_set_behavior>
        		if( nk_button_symbol(ctx, NK_SYMBOL_TRIANGLE_LEFT) )
 8002c48:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002c4c:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002c50:	2109      	movs	r1, #9
 8002c52:	6818      	ldr	r0, [r3, #0]
 8002c54:	f00c f8ec 	bl	800ee30 <nk_button_symbol>
 8002c58:	4603      	mov	r3, r0
 8002c5a:	2b00      	cmp	r3, #0
 8002c5c:	d029      	beq.n	8002cb2 <oscilloscope_process+0x746>
        		{
        			osc->channels[osc->channel_selected].offset -= 1;
 8002c5e:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002c62:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002c66:	681b      	ldr	r3, [r3, #0]
 8002c68:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002c6a:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002c6e:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002c72:	6819      	ldr	r1, [r3, #0]
 8002c74:	4613      	mov	r3, r2
 8002c76:	009b      	lsls	r3, r3, #2
 8002c78:	4413      	add	r3, r2
 8002c7a:	009b      	lsls	r3, r3, #2
 8002c7c:	440b      	add	r3, r1
 8002c7e:	3330      	adds	r3, #48	; 0x30
 8002c80:	edd3 7a00 	vldr	s15, [r3]
 8002c84:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002c88:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002c8c:	681b      	ldr	r3, [r3, #0]
 8002c8e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002c90:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8002c94:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8002c98:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002c9c:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002ca0:	6819      	ldr	r1, [r3, #0]
 8002ca2:	4613      	mov	r3, r2
 8002ca4:	009b      	lsls	r3, r3, #2
 8002ca6:	4413      	add	r3, r2
 8002ca8:	009b      	lsls	r3, r3, #2
 8002caa:	440b      	add	r3, r1
 8002cac:	3330      	adds	r3, #48	; 0x30
 8002cae:	edc3 7a00 	vstr	s15, [r3]
        		}
        		char combo_buffer[32];
        		sprintf(combo_buffer, "%.2f", osc->channels[osc->channel_selected].offset);
 8002cb2:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002cb6:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002cba:	681b      	ldr	r3, [r3, #0]
 8002cbc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002cbe:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002cc2:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002cc6:	6819      	ldr	r1, [r3, #0]
 8002cc8:	4613      	mov	r3, r2
 8002cca:	009b      	lsls	r3, r3, #2
 8002ccc:	4413      	add	r3, r2
 8002cce:	009b      	lsls	r3, r3, #2
 8002cd0:	440b      	add	r3, r1
 8002cd2:	3330      	adds	r3, #48	; 0x30
 8002cd4:	681b      	ldr	r3, [r3, #0]
 8002cd6:	4618      	mov	r0, r3
 8002cd8:	f7fd fc5e 	bl	8000598 <__aeabi_f2d>
 8002cdc:	4602      	mov	r2, r0
 8002cde:	460b      	mov	r3, r1
 8002ce0:	f107 000c 	add.w	r0, r7, #12
 8002ce4:	497e      	ldr	r1, [pc, #504]	; (8002ee0 <oscilloscope_process+0x974>)
 8002ce6:	f01b fbdd 	bl	801e4a4 <siprintf>
        		nk_label( ctx, combo_buffer, NK_TEXT_ALIGN_CENTERED );
 8002cea:	f107 010c 	add.w	r1, r7, #12
 8002cee:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002cf2:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002cf6:	2202      	movs	r2, #2
 8002cf8:	6818      	ldr	r0, [r3, #0]
 8002cfa:	f018 fabf 	bl	801b27c <nk_label>
        		nk_button_set_behavior(ctx, NK_BUTTON_REPEATER);
 8002cfe:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002d02:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002d06:	2101      	movs	r1, #1
 8002d08:	6818      	ldr	r0, [r3, #0]
 8002d0a:	f00b fed7 	bl	800eabc <nk_button_set_behavior>
        		if( nk_button_symbol(ctx, NK_SYMBOL_TRIANGLE_RIGHT) )
 8002d0e:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002d12:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002d16:	210a      	movs	r1, #10
 8002d18:	6818      	ldr	r0, [r3, #0]
 8002d1a:	f00c f889 	bl	800ee30 <nk_button_symbol>
 8002d1e:	4603      	mov	r3, r0
 8002d20:	2b00      	cmp	r3, #0
 8002d22:	d029      	beq.n	8002d78 <oscilloscope_process+0x80c>
        		{
        			osc->channels[osc->channel_selected].offset += 1;
 8002d24:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002d28:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002d2c:	681b      	ldr	r3, [r3, #0]
 8002d2e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002d30:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002d34:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002d38:	6819      	ldr	r1, [r3, #0]
 8002d3a:	4613      	mov	r3, r2
 8002d3c:	009b      	lsls	r3, r3, #2
 8002d3e:	4413      	add	r3, r2
 8002d40:	009b      	lsls	r3, r3, #2
 8002d42:	440b      	add	r3, r1
 8002d44:	3330      	adds	r3, #48	; 0x30
 8002d46:	edd3 7a00 	vldr	s15, [r3]
 8002d4a:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002d4e:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002d52:	681b      	ldr	r3, [r3, #0]
 8002d54:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002d56:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8002d5a:	ee77 7a87 	vadd.f32	s15, s15, s14
 8002d5e:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002d62:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002d66:	6819      	ldr	r1, [r3, #0]
 8002d68:	4613      	mov	r3, r2
 8002d6a:	009b      	lsls	r3, r3, #2
 8002d6c:	4413      	add	r3, r2
 8002d6e:	009b      	lsls	r3, r3, #2
 8002d70:	440b      	add	r3, r1
 8002d72:	3330      	adds	r3, #48	; 0x30
 8002d74:	edc3 7a00 	vstr	s15, [r3]
        		}

        		nk_label( ctx, "Scale", NK_TEXT_ALIGN_LEFT );
 8002d78:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002d7c:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002d80:	2201      	movs	r2, #1
 8002d82:	4958      	ldr	r1, [pc, #352]	; (8002ee4 <oscilloscope_process+0x978>)
 8002d84:	6818      	ldr	r0, [r3, #0]
 8002d86:	f018 fa79 	bl	801b27c <nk_label>
				nk_button_set_behavior(ctx, NK_BUTTON_REPEATER);
 8002d8a:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002d8e:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002d92:	2101      	movs	r1, #1
 8002d94:	6818      	ldr	r0, [r3, #0]
 8002d96:	f00b fe91 	bl	800eabc <nk_button_set_behavior>
				if( nk_button_symbol(ctx, NK_SYMBOL_TRIANGLE_LEFT) )
 8002d9a:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002d9e:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002da2:	2109      	movs	r1, #9
 8002da4:	6818      	ldr	r0, [r3, #0]
 8002da6:	f00c f843 	bl	800ee30 <nk_button_symbol>
 8002daa:	4603      	mov	r3, r0
 8002dac:	2b00      	cmp	r3, #0
 8002dae:	d029      	beq.n	8002e04 <oscilloscope_process+0x898>
				{
					osc->channels[osc->channel_selected].scale -= 1;
 8002db0:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002db4:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002db8:	681b      	ldr	r3, [r3, #0]
 8002dba:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002dbc:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002dc0:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002dc4:	6819      	ldr	r1, [r3, #0]
 8002dc6:	4613      	mov	r3, r2
 8002dc8:	009b      	lsls	r3, r3, #2
 8002dca:	4413      	add	r3, r2
 8002dcc:	009b      	lsls	r3, r3, #2
 8002dce:	440b      	add	r3, r1
 8002dd0:	3334      	adds	r3, #52	; 0x34
 8002dd2:	edd3 7a00 	vldr	s15, [r3]
 8002dd6:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002dda:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002dde:	681b      	ldr	r3, [r3, #0]
 8002de0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002de2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8002de6:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8002dea:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002dee:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002df2:	6819      	ldr	r1, [r3, #0]
 8002df4:	4613      	mov	r3, r2
 8002df6:	009b      	lsls	r3, r3, #2
 8002df8:	4413      	add	r3, r2
 8002dfa:	009b      	lsls	r3, r3, #2
 8002dfc:	440b      	add	r3, r1
 8002dfe:	3334      	adds	r3, #52	; 0x34
 8002e00:	edc3 7a00 	vstr	s15, [r3]
				}
				//char combo_buffer[32];
				sprintf(combo_buffer, "%.2f", osc->channels[osc->channel_selected].scale);
 8002e04:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002e08:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002e0c:	681b      	ldr	r3, [r3, #0]
 8002e0e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002e10:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002e14:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002e18:	6819      	ldr	r1, [r3, #0]
 8002e1a:	4613      	mov	r3, r2
 8002e1c:	009b      	lsls	r3, r3, #2
 8002e1e:	4413      	add	r3, r2
 8002e20:	009b      	lsls	r3, r3, #2
 8002e22:	440b      	add	r3, r1
 8002e24:	3334      	adds	r3, #52	; 0x34
 8002e26:	681b      	ldr	r3, [r3, #0]
 8002e28:	4618      	mov	r0, r3
 8002e2a:	f7fd fbb5 	bl	8000598 <__aeabi_f2d>
 8002e2e:	4602      	mov	r2, r0
 8002e30:	460b      	mov	r3, r1
 8002e32:	f107 000c 	add.w	r0, r7, #12
 8002e36:	492a      	ldr	r1, [pc, #168]	; (8002ee0 <oscilloscope_process+0x974>)
 8002e38:	f01b fb34 	bl	801e4a4 <siprintf>
				nk_label( ctx, combo_buffer, NK_TEXT_ALIGN_CENTERED );
 8002e3c:	f107 010c 	add.w	r1, r7, #12
 8002e40:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002e44:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002e48:	2202      	movs	r2, #2
 8002e4a:	6818      	ldr	r0, [r3, #0]
 8002e4c:	f018 fa16 	bl	801b27c <nk_label>
				nk_button_set_behavior(ctx, NK_BUTTON_REPEATER);
 8002e50:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002e54:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002e58:	2101      	movs	r1, #1
 8002e5a:	6818      	ldr	r0, [r3, #0]
 8002e5c:	f00b fe2e 	bl	800eabc <nk_button_set_behavior>
				if( nk_button_symbol(ctx, NK_SYMBOL_TRIANGLE_RIGHT) )
 8002e60:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002e64:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002e68:	210a      	movs	r1, #10
 8002e6a:	6818      	ldr	r0, [r3, #0]
 8002e6c:	f00b ffe0 	bl	800ee30 <nk_button_symbol>
 8002e70:	4603      	mov	r3, r0
 8002e72:	2b00      	cmp	r3, #0
 8002e74:	d038      	beq.n	8002ee8 <oscilloscope_process+0x97c>
				{
					osc->channels[osc->channel_selected].scale += 1;
 8002e76:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002e7a:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002e7e:	681b      	ldr	r3, [r3, #0]
 8002e80:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002e82:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002e86:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002e8a:	6819      	ldr	r1, [r3, #0]
 8002e8c:	4613      	mov	r3, r2
 8002e8e:	009b      	lsls	r3, r3, #2
 8002e90:	4413      	add	r3, r2
 8002e92:	009b      	lsls	r3, r3, #2
 8002e94:	440b      	add	r3, r1
 8002e96:	3334      	adds	r3, #52	; 0x34
 8002e98:	edd3 7a00 	vldr	s15, [r3]
 8002e9c:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002ea0:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002ea4:	681b      	ldr	r3, [r3, #0]
 8002ea6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002ea8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8002eac:	ee77 7a87 	vadd.f32	s15, s15, s14
 8002eb0:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002eb4:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002eb8:	6819      	ldr	r1, [r3, #0]
 8002eba:	4613      	mov	r3, r2
 8002ebc:	009b      	lsls	r3, r3, #2
 8002ebe:	4413      	add	r3, r2
 8002ec0:	009b      	lsls	r3, r3, #2
 8002ec2:	440b      	add	r3, r1
 8002ec4:	3334      	adds	r3, #52	; 0x34
 8002ec6:	edc3 7a00 	vstr	s15, [r3]
 8002eca:	e00d      	b.n	8002ee8 <oscilloscope_process+0x97c>
 8002ecc:	08021370 	.word	0x08021370
 8002ed0:	43480000 	.word	0x43480000
 8002ed4:	42700000 	.word	0x42700000
 8002ed8:	0802131c 	.word	0x0802131c
 8002edc:	08021200 	.word	0x08021200
 8002ee0:	08021208 	.word	0x08021208
 8002ee4:	08021210 	.word	0x08021210
				}




                nk_tree_pop(ctx);
 8002ee8:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002eec:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8002ef0:	6818      	ldr	r0, [r3, #0]
 8002ef2:	f018 fe26 	bl	801bb42 <nk_tree_pop>
            }

            if( nk_tree_push( ctx, NK_TREE_TAB, "Trigger", NK_MINIMIZED) ){
 8002ef6:	48dc      	ldr	r0, [pc, #880]	; (8003268 <oscilloscope_process+0xcfc>)
 8002ef8:	f019 f8b4 	bl	801c064 <nk_strlen>
 8002efc:	4603      	mov	r3, r0
 8002efe:	f507 72c4 	add.w	r2, r7, #392	; 0x188
 8002f02:	f5a2 70c4 	sub.w	r0, r2, #392	; 0x188
 8002f06:	f240 22d5 	movw	r2, #725	; 0x2d5
 8002f0a:	9202      	str	r2, [sp, #8]
 8002f0c:	9301      	str	r3, [sp, #4]
 8002f0e:	4bd6      	ldr	r3, [pc, #856]	; (8003268 <oscilloscope_process+0xcfc>)
 8002f10:	9300      	str	r3, [sp, #0]
 8002f12:	2300      	movs	r3, #0
 8002f14:	4ad5      	ldr	r2, [pc, #852]	; (800326c <oscilloscope_process+0xd00>)
 8002f16:	2101      	movs	r1, #1
 8002f18:	6800      	ldr	r0, [r0, #0]
 8002f1a:	f018 fdf5 	bl	801bb08 <nk_tree_push_hashed>
 8002f1e:	4603      	mov	r3, r0
 8002f20:	2b00      	cmp	r3, #0
 8002f22:	f000 80e0 	beq.w	80030e6 <oscilloscope_process+0xb7a>
                osc->trigger_source = nk_combo(ctx, (const char*[]){"Ch1", "Ch2", "Ch3", "Ch4"}, CHANNEL_COUNT, osc->trigger_source, 20, nk_vec2(60, 200));
 8002f26:	4bd2      	ldr	r3, [pc, #840]	; (8003270 <oscilloscope_process+0xd04>)
 8002f28:	f107 04a0 	add.w	r4, r7, #160	; 0xa0
 8002f2c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8002f2e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 8002f32:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002f36:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002f3a:	681b      	ldr	r3, [r3, #0]
 8002f3c:	69dc      	ldr	r4, [r3, #28]
 8002f3e:	eddf 0ad5 	vldr	s1, [pc, #852]	; 8003294 <oscilloscope_process+0xd28>
 8002f42:	ed9f 0ad5 	vldr	s0, [pc, #852]	; 8003298 <oscilloscope_process+0xd2c>
 8002f46:	f010 fcb7 	bl	80138b8 <nk_vec2>
 8002f4a:	eeb0 7a40 	vmov.f32	s14, s0
 8002f4e:	eef0 7a60 	vmov.f32	s15, s1
 8002f52:	ed87 7a4e 	vstr	s14, [r7, #312]	; 0x138
 8002f56:	edc7 7a4f 	vstr	s15, [r7, #316]	; 0x13c
 8002f5a:	ed97 7a4e 	vldr	s14, [r7, #312]	; 0x138
 8002f5e:	edd7 7a4f 	vldr	s15, [r7, #316]	; 0x13c
 8002f62:	f107 01a0 	add.w	r1, r7, #160	; 0xa0
 8002f66:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002f6a:	f5a3 70c4 	sub.w	r0, r3, #392	; 0x188
 8002f6e:	2314      	movs	r3, #20
 8002f70:	9300      	str	r3, [sp, #0]
 8002f72:	eeb0 0a47 	vmov.f32	s0, s14
 8002f76:	eef0 0a67 	vmov.f32	s1, s15
 8002f7a:	4623      	mov	r3, r4
 8002f7c:	2204      	movs	r2, #4
 8002f7e:	6800      	ldr	r0, [r0, #0]
 8002f80:	f00c fc58 	bl	800f834 <nk_combo>
 8002f84:	4602      	mov	r2, r0
 8002f86:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002f8a:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002f8e:	681b      	ldr	r3, [r3, #0]
 8002f90:	61da      	str	r2, [r3, #28]
                nk_layout_row(ctx, NK_STATIC, 30, 2, (float[]){60, 60});
 8002f92:	4ab8      	ldr	r2, [pc, #736]	; (8003274 <oscilloscope_process+0xd08>)
 8002f94:	f107 0398 	add.w	r3, r7, #152	; 0x98
 8002f98:	e892 0003 	ldmia.w	r2, {r0, r1}
 8002f9c:	e883 0003 	stmia.w	r3, {r0, r1}
 8002fa0:	f107 0398 	add.w	r3, r7, #152	; 0x98
 8002fa4:	f507 72c4 	add.w	r2, r7, #392	; 0x188
 8002fa8:	f5a2 70c4 	sub.w	r0, r2, #392	; 0x188
 8002fac:	2202      	movs	r2, #2
 8002fae:	eeb3 0a0e 	vmov.f32	s0, #62	; 0x41f00000  30.0
 8002fb2:	2101      	movs	r1, #1
 8002fb4:	6800      	ldr	r0, [r0, #0]
 8002fb6:	f00f fe79 	bl	8012cac <nk_layout_row>
                osc->trigger_mode = nk_combo(ctx, (const char*[]){"Normal", "Auto"}, 2, osc->trigger_mode, 20, nk_vec2(60, 200));
 8002fba:	4aaf      	ldr	r2, [pc, #700]	; (8003278 <oscilloscope_process+0xd0c>)
 8002fbc:	f107 0390 	add.w	r3, r7, #144	; 0x90
 8002fc0:	e892 0003 	ldmia.w	r2, {r0, r1}
 8002fc4:	e883 0003 	stmia.w	r3, {r0, r1}
 8002fc8:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8002fcc:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8002fd0:	681b      	ldr	r3, [r3, #0]
 8002fd2:	695c      	ldr	r4, [r3, #20]
 8002fd4:	eddf 0aaf 	vldr	s1, [pc, #700]	; 8003294 <oscilloscope_process+0xd28>
 8002fd8:	ed9f 0aaf 	vldr	s0, [pc, #700]	; 8003298 <oscilloscope_process+0xd2c>
 8002fdc:	f010 fc6c 	bl	80138b8 <nk_vec2>
 8002fe0:	eeb0 7a40 	vmov.f32	s14, s0
 8002fe4:	eef0 7a60 	vmov.f32	s15, s1
 8002fe8:	ed87 7a50 	vstr	s14, [r7, #320]	; 0x140
 8002fec:	edc7 7a51 	vstr	s15, [r7, #324]	; 0x144
 8002ff0:	ed97 7a50 	vldr	s14, [r7, #320]	; 0x140
 8002ff4:	edd7 7a51 	vldr	s15, [r7, #324]	; 0x144
 8002ff8:	f107 0190 	add.w	r1, r7, #144	; 0x90
 8002ffc:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003000:	f5a3 70c4 	sub.w	r0, r3, #392	; 0x188
 8003004:	2314      	movs	r3, #20
 8003006:	9300      	str	r3, [sp, #0]
 8003008:	eeb0 0a47 	vmov.f32	s0, s14
 800300c:	eef0 0a67 	vmov.f32	s1, s15
 8003010:	4623      	mov	r3, r4
 8003012:	2202      	movs	r2, #2
 8003014:	6800      	ldr	r0, [r0, #0]
 8003016:	f00c fc0d 	bl	800f834 <nk_combo>
 800301a:	4602      	mov	r2, r0
 800301c:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003020:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8003024:	681b      	ldr	r3, [r3, #0]
 8003026:	615a      	str	r2, [r3, #20]
                osc->trigger_slope = nk_combo(ctx, (const char*[]){"Rising", "Falling", "Both"}, 3, osc->trigger_slope, 20, nk_vec2(60, 200));
 8003028:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800302c:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8003030:	4a92      	ldr	r2, [pc, #584]	; (800327c <oscilloscope_process+0xd10>)
 8003032:	ca07      	ldmia	r2, {r0, r1, r2}
 8003034:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 8003038:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800303c:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8003040:	681b      	ldr	r3, [r3, #0]
 8003042:	699c      	ldr	r4, [r3, #24]
 8003044:	eddf 0a93 	vldr	s1, [pc, #588]	; 8003294 <oscilloscope_process+0xd28>
 8003048:	ed9f 0a93 	vldr	s0, [pc, #588]	; 8003298 <oscilloscope_process+0xd2c>
 800304c:	f010 fc34 	bl	80138b8 <nk_vec2>
 8003050:	eeb0 7a40 	vmov.f32	s14, s0
 8003054:	eef0 7a60 	vmov.f32	s15, s1
 8003058:	ed87 7a52 	vstr	s14, [r7, #328]	; 0x148
 800305c:	edc7 7a53 	vstr	s15, [r7, #332]	; 0x14c
 8003060:	ed97 7a52 	vldr	s14, [r7, #328]	; 0x148
 8003064:	edd7 7a53 	vldr	s15, [r7, #332]	; 0x14c
 8003068:	f107 0184 	add.w	r1, r7, #132	; 0x84
 800306c:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003070:	f5a3 70c4 	sub.w	r0, r3, #392	; 0x188
 8003074:	2314      	movs	r3, #20
 8003076:	9300      	str	r3, [sp, #0]
 8003078:	eeb0 0a47 	vmov.f32	s0, s14
 800307c:	eef0 0a67 	vmov.f32	s1, s15
 8003080:	4623      	mov	r3, r4
 8003082:	2203      	movs	r2, #3
 8003084:	6800      	ldr	r0, [r0, #0]
 8003086:	f00c fbd5 	bl	800f834 <nk_combo>
 800308a:	4602      	mov	r2, r0
 800308c:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003090:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8003094:	681b      	ldr	r3, [r3, #0]
 8003096:	619a      	str	r2, [r3, #24]
                osc->trigger_offset = nk_slider_float(ctx, -10.0f, &osc->trigger_offset, 10.0f, 1.0f);
 8003098:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800309c:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 80030a0:	681b      	ldr	r3, [r3, #0]
 80030a2:	f103 0210 	add.w	r2, r3, #16
 80030a6:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80030aa:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 80030ae:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 80030b2:	eef2 0a04 	vmov.f32	s1, #36	; 0x41200000  10.0
 80030b6:	4611      	mov	r1, r2
 80030b8:	eeba 0a04 	vmov.f32	s0, #164	; 0xc1200000 -10.0
 80030bc:	6818      	ldr	r0, [r3, #0]
 80030be:	f015 fafd 	bl	80186bc <nk_slider_float>
 80030c2:	ee07 0a90 	vmov	s15, r0
 80030c6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80030ca:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80030ce:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 80030d2:	681b      	ldr	r3, [r3, #0]
 80030d4:	edc3 7a04 	vstr	s15, [r3, #16]
                nk_tree_pop(ctx);
 80030d8:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80030dc:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 80030e0:	6818      	ldr	r0, [r3, #0]
 80030e2:	f018 fd2e 	bl	801bb42 <nk_tree_pop>
            }

            if( nk_tree_push( ctx, NK_TREE_TAB, "Waveform", NK_MINIMIZED) ){
 80030e6:	4866      	ldr	r0, [pc, #408]	; (8003280 <oscilloscope_process+0xd14>)
 80030e8:	f018 ffbc 	bl	801c064 <nk_strlen>
 80030ec:	4603      	mov	r3, r0
 80030ee:	f507 72c4 	add.w	r2, r7, #392	; 0x188
 80030f2:	f5a2 70c4 	sub.w	r0, r2, #392	; 0x188
 80030f6:	f240 22de 	movw	r2, #734	; 0x2de
 80030fa:	9202      	str	r2, [sp, #8]
 80030fc:	9301      	str	r3, [sp, #4]
 80030fe:	4b60      	ldr	r3, [pc, #384]	; (8003280 <oscilloscope_process+0xd14>)
 8003100:	9300      	str	r3, [sp, #0]
 8003102:	2300      	movs	r3, #0
 8003104:	4a5f      	ldr	r2, [pc, #380]	; (8003284 <oscilloscope_process+0xd18>)
 8003106:	2101      	movs	r1, #1
 8003108:	6800      	ldr	r0, [r0, #0]
 800310a:	f018 fcfd 	bl	801bb08 <nk_tree_push_hashed>
 800310e:	4603      	mov	r3, r0
 8003110:	2b00      	cmp	r3, #0
 8003112:	f000 81bd 	beq.w	8003490 <oscilloscope_process+0xf24>
                osc->waveform_selected = nk_combo(ctx, (const char*[]){"Wf1", "Wf2"}, WAVEFORM_COUNT, osc->waveform_selected, 20, nk_vec2(60, 200));
 8003116:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800311a:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 800311e:	4a5a      	ldr	r2, [pc, #360]	; (8003288 <oscilloscope_process+0xd1c>)
 8003120:	e892 0003 	ldmia.w	r2, {r0, r1}
 8003124:	e883 0003 	stmia.w	r3, {r0, r1}
 8003128:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800312c:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8003130:	681b      	ldr	r3, [r3, #0]
 8003132:	6f9c      	ldr	r4, [r3, #120]	; 0x78
 8003134:	eddf 0a57 	vldr	s1, [pc, #348]	; 8003294 <oscilloscope_process+0xd28>
 8003138:	ed9f 0a57 	vldr	s0, [pc, #348]	; 8003298 <oscilloscope_process+0xd2c>
 800313c:	f010 fbbc 	bl	80138b8 <nk_vec2>
 8003140:	eeb0 7a40 	vmov.f32	s14, s0
 8003144:	eef0 7a60 	vmov.f32	s15, s1
 8003148:	ed87 7a54 	vstr	s14, [r7, #336]	; 0x150
 800314c:	edc7 7a55 	vstr	s15, [r7, #340]	; 0x154
 8003150:	ed97 7a54 	vldr	s14, [r7, #336]	; 0x150
 8003154:	edd7 7a55 	vldr	s15, [r7, #340]	; 0x154
 8003158:	f107 017c 	add.w	r1, r7, #124	; 0x7c
 800315c:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003160:	f5a3 70c4 	sub.w	r0, r3, #392	; 0x188
 8003164:	2314      	movs	r3, #20
 8003166:	9300      	str	r3, [sp, #0]
 8003168:	eeb0 0a47 	vmov.f32	s0, s14
 800316c:	eef0 0a67 	vmov.f32	s1, s15
 8003170:	4623      	mov	r3, r4
 8003172:	2202      	movs	r2, #2
 8003174:	6800      	ldr	r0, [r0, #0]
 8003176:	f00c fb5d 	bl	800f834 <nk_combo>
 800317a:	4602      	mov	r2, r0
 800317c:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003180:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8003184:	681b      	ldr	r3, [r3, #0]
 8003186:	679a      	str	r2, [r3, #120]	; 0x78
                nk_layout_row(ctx, NK_STATIC, 30, 2, (float[]){60, 60});
 8003188:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800318c:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8003190:	4a38      	ldr	r2, [pc, #224]	; (8003274 <oscilloscope_process+0xd08>)
 8003192:	e892 0003 	ldmia.w	r2, {r0, r1}
 8003196:	e883 0003 	stmia.w	r3, {r0, r1}
 800319a:	f107 0374 	add.w	r3, r7, #116	; 0x74
 800319e:	f507 72c4 	add.w	r2, r7, #392	; 0x188
 80031a2:	f5a2 70c4 	sub.w	r0, r2, #392	; 0x188
 80031a6:	2202      	movs	r2, #2
 80031a8:	eeb3 0a0e 	vmov.f32	s0, #62	; 0x41f00000  30.0
 80031ac:	2101      	movs	r1, #1
 80031ae:	6800      	ldr	r0, [r0, #0]
 80031b0:	f00f fd7c 	bl	8012cac <nk_layout_row>
                osc->waveforms[osc->waveform_selected].enabled = nk_combo(ctx, (const char*[]){"Off", "On"}, 2, osc->waveforms[osc->waveform_selected].enabled, 20, nk_vec2(60, 200));
 80031b4:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80031b8:	f5a3 738e 	sub.w	r3, r3, #284	; 0x11c
 80031bc:	4a33      	ldr	r2, [pc, #204]	; (800328c <oscilloscope_process+0xd20>)
 80031be:	e892 0003 	ldmia.w	r2, {r0, r1}
 80031c2:	e883 0003 	stmia.w	r3, {r0, r1}
 80031c6:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80031ca:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 80031ce:	681b      	ldr	r3, [r3, #0]
 80031d0:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 80031d2:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80031d6:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 80031da:	6819      	ldr	r1, [r3, #0]
 80031dc:	4613      	mov	r3, r2
 80031de:	005b      	lsls	r3, r3, #1
 80031e0:	4413      	add	r3, r2
 80031e2:	00db      	lsls	r3, r3, #3
 80031e4:	440b      	add	r3, r1
 80031e6:	337c      	adds	r3, #124	; 0x7c
 80031e8:	681d      	ldr	r5, [r3, #0]
 80031ea:	eddf 0a2a 	vldr	s1, [pc, #168]	; 8003294 <oscilloscope_process+0xd28>
 80031ee:	ed9f 0a2a 	vldr	s0, [pc, #168]	; 8003298 <oscilloscope_process+0xd2c>
 80031f2:	f010 fb61 	bl	80138b8 <nk_vec2>
 80031f6:	eeb0 7a40 	vmov.f32	s14, s0
 80031fa:	eef0 7a60 	vmov.f32	s15, s1
 80031fe:	ed87 7a56 	vstr	s14, [r7, #344]	; 0x158
 8003202:	edc7 7a57 	vstr	s15, [r7, #348]	; 0x15c
 8003206:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800320a:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 800320e:	681b      	ldr	r3, [r3, #0]
 8003210:	6f9c      	ldr	r4, [r3, #120]	; 0x78
 8003212:	ed97 7a56 	vldr	s14, [r7, #344]	; 0x158
 8003216:	edd7 7a57 	vldr	s15, [r7, #348]	; 0x15c
 800321a:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 800321e:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003222:	f5a3 70c4 	sub.w	r0, r3, #392	; 0x188
 8003226:	2314      	movs	r3, #20
 8003228:	9300      	str	r3, [sp, #0]
 800322a:	eeb0 0a47 	vmov.f32	s0, s14
 800322e:	eef0 0a67 	vmov.f32	s1, s15
 8003232:	462b      	mov	r3, r5
 8003234:	2202      	movs	r2, #2
 8003236:	6800      	ldr	r0, [r0, #0]
 8003238:	f00c fafc 	bl	800f834 <nk_combo>
 800323c:	4601      	mov	r1, r0
 800323e:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003242:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8003246:	681a      	ldr	r2, [r3, #0]
 8003248:	4623      	mov	r3, r4
 800324a:	005b      	lsls	r3, r3, #1
 800324c:	4423      	add	r3, r4
 800324e:	00db      	lsls	r3, r3, #3
 8003250:	4413      	add	r3, r2
 8003252:	337c      	adds	r3, #124	; 0x7c
 8003254:	6019      	str	r1, [r3, #0]
                osc->waveforms[osc->waveform_selected].type = nk_combo(ctx, (const char*[]){"DC", "PWM", "Sine", "Tria", "Saw", "Noise"}, 6, osc->waveforms[osc->waveform_selected].type, 20, nk_vec2(60, 200));
 8003256:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800325a:	f5a3 739a 	sub.w	r3, r3, #308	; 0x134
 800325e:	4a0c      	ldr	r2, [pc, #48]	; (8003290 <oscilloscope_process+0xd24>)
 8003260:	461c      	mov	r4, r3
 8003262:	4615      	mov	r5, r2
 8003264:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8003266:	e019      	b.n	800329c <oscilloscope_process+0xd30>
 8003268:	0802123c 	.word	0x0802123c
 800326c:	08021254 	.word	0x08021254
 8003270:	0802133c 	.word	0x0802133c
 8003274:	0802137c 	.word	0x0802137c
 8003278:	08021394 	.word	0x08021394
 800327c:	080213b4 	.word	0x080213b4
 8003280:	0802125c 	.word	0x0802125c
 8003284:	08021274 	.word	0x08021274
 8003288:	080213c8 	.word	0x080213c8
 800328c:	0802135c 	.word	0x0802135c
 8003290:	080213f0 	.word	0x080213f0
 8003294:	43480000 	.word	0x43480000
 8003298:	42700000 	.word	0x42700000
 800329c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800329e:	e895 0003 	ldmia.w	r5, {r0, r1}
 80032a2:	e884 0003 	stmia.w	r4, {r0, r1}
 80032a6:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80032aa:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 80032ae:	681b      	ldr	r3, [r3, #0]
 80032b0:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 80032b2:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80032b6:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 80032ba:	6819      	ldr	r1, [r3, #0]
 80032bc:	4613      	mov	r3, r2
 80032be:	005b      	lsls	r3, r3, #1
 80032c0:	4413      	add	r3, r2
 80032c2:	00db      	lsls	r3, r3, #3
 80032c4:	440b      	add	r3, r1
 80032c6:	3380      	adds	r3, #128	; 0x80
 80032c8:	681d      	ldr	r5, [r3, #0]
 80032ca:	ed5f 0a0e 	vldr	s1, [pc, #-56]	; 8003294 <oscilloscope_process+0xd28>
 80032ce:	ed1f 0a0e 	vldr	s0, [pc, #-56]	; 8003298 <oscilloscope_process+0xd2c>
 80032d2:	f010 faf1 	bl	80138b8 <nk_vec2>
 80032d6:	eeb0 7a40 	vmov.f32	s14, s0
 80032da:	eef0 7a60 	vmov.f32	s15, s1
 80032de:	ed87 7a58 	vstr	s14, [r7, #352]	; 0x160
 80032e2:	edc7 7a59 	vstr	s15, [r7, #356]	; 0x164
 80032e6:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80032ea:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 80032ee:	681b      	ldr	r3, [r3, #0]
 80032f0:	6f9c      	ldr	r4, [r3, #120]	; 0x78
 80032f2:	ed97 7a58 	vldr	s14, [r7, #352]	; 0x160
 80032f6:	edd7 7a59 	vldr	s15, [r7, #356]	; 0x164
 80032fa:	f107 0154 	add.w	r1, r7, #84	; 0x54
 80032fe:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003302:	f5a3 70c4 	sub.w	r0, r3, #392	; 0x188
 8003306:	2314      	movs	r3, #20
 8003308:	9300      	str	r3, [sp, #0]
 800330a:	eeb0 0a47 	vmov.f32	s0, s14
 800330e:	eef0 0a67 	vmov.f32	s1, s15
 8003312:	462b      	mov	r3, r5
 8003314:	2206      	movs	r2, #6
 8003316:	6800      	ldr	r0, [r0, #0]
 8003318:	f00c fa8c 	bl	800f834 <nk_combo>
 800331c:	4601      	mov	r1, r0
 800331e:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003322:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8003326:	681a      	ldr	r2, [r3, #0]
 8003328:	4623      	mov	r3, r4
 800332a:	005b      	lsls	r3, r3, #1
 800332c:	4423      	add	r3, r4
 800332e:	00db      	lsls	r3, r3, #3
 8003330:	4413      	add	r3, r2
 8003332:	3380      	adds	r3, #128	; 0x80
 8003334:	6019      	str	r1, [r3, #0]
                osc->waveforms[osc->waveform_selected].offset = nk_slider_float(ctx, -10.0f, &osc->waveforms[osc->waveform_selected].offset, 10.0f, 1.0f);
 8003336:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800333a:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 800333e:	681b      	ldr	r3, [r3, #0]
 8003340:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8003342:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003346:	f5a3 71c2 	sub.w	r1, r3, #388	; 0x184
 800334a:	4613      	mov	r3, r2
 800334c:	005b      	lsls	r3, r3, #1
 800334e:	4413      	add	r3, r2
 8003350:	00db      	lsls	r3, r3, #3
 8003352:	3380      	adds	r3, #128	; 0x80
 8003354:	680a      	ldr	r2, [r1, #0]
 8003356:	4413      	add	r3, r2
 8003358:	1d1a      	adds	r2, r3, #4
 800335a:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800335e:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8003362:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 8003366:	eef2 0a04 	vmov.f32	s1, #36	; 0x41200000  10.0
 800336a:	4611      	mov	r1, r2
 800336c:	eeba 0a04 	vmov.f32	s0, #164	; 0xc1200000 -10.0
 8003370:	6818      	ldr	r0, [r3, #0]
 8003372:	f015 f9a3 	bl	80186bc <nk_slider_float>
 8003376:	ee07 0a90 	vmov	s15, r0
 800337a:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800337e:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8003382:	681b      	ldr	r3, [r3, #0]
 8003384:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8003386:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800338a:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800338e:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8003392:	6819      	ldr	r1, [r3, #0]
 8003394:	4613      	mov	r3, r2
 8003396:	005b      	lsls	r3, r3, #1
 8003398:	4413      	add	r3, r2
 800339a:	00db      	lsls	r3, r3, #3
 800339c:	440b      	add	r3, r1
 800339e:	3384      	adds	r3, #132	; 0x84
 80033a0:	edc3 7a00 	vstr	s15, [r3]
                osc->waveforms[osc->waveform_selected].scale = nk_slider_float(ctx, -10.0f, &osc->waveforms[osc->waveform_selected].scale, 10.0f, 1.0f);
 80033a4:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80033a8:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 80033ac:	681b      	ldr	r3, [r3, #0]
 80033ae:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 80033b0:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80033b4:	f5a3 71c2 	sub.w	r1, r3, #388	; 0x184
 80033b8:	4613      	mov	r3, r2
 80033ba:	005b      	lsls	r3, r3, #1
 80033bc:	4413      	add	r3, r2
 80033be:	00db      	lsls	r3, r3, #3
 80033c0:	3380      	adds	r3, #128	; 0x80
 80033c2:	680a      	ldr	r2, [r1, #0]
 80033c4:	4413      	add	r3, r2
 80033c6:	f103 0208 	add.w	r2, r3, #8
 80033ca:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80033ce:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 80033d2:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 80033d6:	eef2 0a04 	vmov.f32	s1, #36	; 0x41200000  10.0
 80033da:	4611      	mov	r1, r2
 80033dc:	eeba 0a04 	vmov.f32	s0, #164	; 0xc1200000 -10.0
 80033e0:	6818      	ldr	r0, [r3, #0]
 80033e2:	f015 f96b 	bl	80186bc <nk_slider_float>
 80033e6:	ee07 0a90 	vmov	s15, r0
 80033ea:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80033ee:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 80033f2:	681b      	ldr	r3, [r3, #0]
 80033f4:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 80033f6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80033fa:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80033fe:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8003402:	6819      	ldr	r1, [r3, #0]
 8003404:	4613      	mov	r3, r2
 8003406:	005b      	lsls	r3, r3, #1
 8003408:	4413      	add	r3, r2
 800340a:	00db      	lsls	r3, r3, #3
 800340c:	440b      	add	r3, r1
 800340e:	3388      	adds	r3, #136	; 0x88
 8003410:	edc3 7a00 	vstr	s15, [r3]
                osc->waveforms[osc->waveform_selected].duty_cycle = nk_slider_float(ctx, -10.0f, &osc->waveforms[osc->waveform_selected].duty_cycle, 10.0f, 1.0f);
 8003414:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003418:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 800341c:	681b      	ldr	r3, [r3, #0]
 800341e:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8003420:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003424:	f5a3 71c2 	sub.w	r1, r3, #388	; 0x184
 8003428:	4613      	mov	r3, r2
 800342a:	005b      	lsls	r3, r3, #1
 800342c:	4413      	add	r3, r2
 800342e:	00db      	lsls	r3, r3, #3
 8003430:	3388      	adds	r3, #136	; 0x88
 8003432:	680a      	ldr	r2, [r1, #0]
 8003434:	4413      	add	r3, r2
 8003436:	1d1a      	adds	r2, r3, #4
 8003438:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800343c:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8003440:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 8003444:	eef2 0a04 	vmov.f32	s1, #36	; 0x41200000  10.0
 8003448:	4611      	mov	r1, r2
 800344a:	eeba 0a04 	vmov.f32	s0, #164	; 0xc1200000 -10.0
 800344e:	6818      	ldr	r0, [r3, #0]
 8003450:	f015 f934 	bl	80186bc <nk_slider_float>
 8003454:	ee07 0a90 	vmov	s15, r0
 8003458:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800345c:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8003460:	681b      	ldr	r3, [r3, #0]
 8003462:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8003464:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8003468:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800346c:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8003470:	6819      	ldr	r1, [r3, #0]
 8003472:	4613      	mov	r3, r2
 8003474:	005b      	lsls	r3, r3, #1
 8003476:	4413      	add	r3, r2
 8003478:	00db      	lsls	r3, r3, #3
 800347a:	440b      	add	r3, r1
 800347c:	338c      	adds	r3, #140	; 0x8c
 800347e:	edc3 7a00 	vstr	s15, [r3]
                nk_tree_pop(ctx);
 8003482:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003486:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 800348a:	6818      	ldr	r0, [r3, #0]
 800348c:	f018 fb59 	bl	801bb42 <nk_tree_pop>
            }

			if( nk_tree_push( ctx, NK_TREE_TAB, "Cursor", NK_MINIMIZED) ){
 8003490:	48de      	ldr	r0, [pc, #888]	; (800380c <oscilloscope_process+0x12a0>)
 8003492:	f018 fde7 	bl	801c064 <nk_strlen>
 8003496:	4603      	mov	r3, r0
 8003498:	f507 72c4 	add.w	r2, r7, #392	; 0x188
 800349c:	f5a2 70c4 	sub.w	r0, r2, #392	; 0x188
 80034a0:	f240 22e9 	movw	r2, #745	; 0x2e9
 80034a4:	9202      	str	r2, [sp, #8]
 80034a6:	9301      	str	r3, [sp, #4]
 80034a8:	4bd8      	ldr	r3, [pc, #864]	; (800380c <oscilloscope_process+0x12a0>)
 80034aa:	9300      	str	r3, [sp, #0]
 80034ac:	2300      	movs	r3, #0
 80034ae:	4ad8      	ldr	r2, [pc, #864]	; (8003810 <oscilloscope_process+0x12a4>)
 80034b0:	2101      	movs	r1, #1
 80034b2:	6800      	ldr	r0, [r0, #0]
 80034b4:	f018 fb28 	bl	801bb08 <nk_tree_push_hashed>
 80034b8:	4603      	mov	r3, r0
 80034ba:	2b00      	cmp	r3, #0
 80034bc:	f000 816f 	beq.w	800379e <oscilloscope_process+0x1232>
                osc->cursor_selected = nk_combo(ctx, (const char*[]){"C1", "C2"}, CURSOR_COUNT, osc->cursor_selected, 20, nk_vec2(60, 200));
 80034c0:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80034c4:	f5a3 739e 	sub.w	r3, r3, #316	; 0x13c
 80034c8:	4ad2      	ldr	r2, [pc, #840]	; (8003814 <oscilloscope_process+0x12a8>)
 80034ca:	e892 0003 	ldmia.w	r2, {r0, r1}
 80034ce:	e883 0003 	stmia.w	r3, {r0, r1}
 80034d2:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80034d6:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 80034da:	681b      	ldr	r3, [r3, #0]
 80034dc:	f8d3 40ac 	ldr.w	r4, [r3, #172]	; 0xac
 80034e0:	eddf 0acd 	vldr	s1, [pc, #820]	; 8003818 <oscilloscope_process+0x12ac>
 80034e4:	ed9f 0acd 	vldr	s0, [pc, #820]	; 800381c <oscilloscope_process+0x12b0>
 80034e8:	f010 f9e6 	bl	80138b8 <nk_vec2>
 80034ec:	eeb0 7a40 	vmov.f32	s14, s0
 80034f0:	eef0 7a60 	vmov.f32	s15, s1
 80034f4:	ed87 7a5a 	vstr	s14, [r7, #360]	; 0x168
 80034f8:	edc7 7a5b 	vstr	s15, [r7, #364]	; 0x16c
 80034fc:	ed97 7a5a 	vldr	s14, [r7, #360]	; 0x168
 8003500:	edd7 7a5b 	vldr	s15, [r7, #364]	; 0x16c
 8003504:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 8003508:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800350c:	f5a3 70c4 	sub.w	r0, r3, #392	; 0x188
 8003510:	2314      	movs	r3, #20
 8003512:	9300      	str	r3, [sp, #0]
 8003514:	eeb0 0a47 	vmov.f32	s0, s14
 8003518:	eef0 0a67 	vmov.f32	s1, s15
 800351c:	4623      	mov	r3, r4
 800351e:	2202      	movs	r2, #2
 8003520:	6800      	ldr	r0, [r0, #0]
 8003522:	f00c f987 	bl	800f834 <nk_combo>
 8003526:	4602      	mov	r2, r0
 8003528:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800352c:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8003530:	681b      	ldr	r3, [r3, #0]
 8003532:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
                nk_layout_row(ctx, NK_STATIC, 30, 2, (float[]){60, 60});
 8003536:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800353a:	f5a3 73a2 	sub.w	r3, r3, #324	; 0x144
 800353e:	4ab8      	ldr	r2, [pc, #736]	; (8003820 <oscilloscope_process+0x12b4>)
 8003540:	e892 0003 	ldmia.w	r2, {r0, r1}
 8003544:	e883 0003 	stmia.w	r3, {r0, r1}
 8003548:	f107 0344 	add.w	r3, r7, #68	; 0x44
 800354c:	f507 72c4 	add.w	r2, r7, #392	; 0x188
 8003550:	f5a2 70c4 	sub.w	r0, r2, #392	; 0x188
 8003554:	2202      	movs	r2, #2
 8003556:	eeb3 0a0e 	vmov.f32	s0, #62	; 0x41f00000  30.0
 800355a:	2101      	movs	r1, #1
 800355c:	6800      	ldr	r0, [r0, #0]
 800355e:	f00f fba5 	bl	8012cac <nk_layout_row>
                osc->cursors[osc->cursor_selected].enabled = nk_combo(ctx, (const char*[]){"Off", "On"}, 2, osc->cursors[osc->cursor_selected].enabled, 20, nk_vec2(60, 200));
 8003562:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003566:	f5a3 73a6 	sub.w	r3, r3, #332	; 0x14c
 800356a:	4aae      	ldr	r2, [pc, #696]	; (8003824 <oscilloscope_process+0x12b8>)
 800356c:	e892 0003 	ldmia.w	r2, {r0, r1}
 8003570:	e883 0003 	stmia.w	r3, {r0, r1}
 8003574:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003578:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 800357c:	681b      	ldr	r3, [r3, #0]
 800357e:	f8d3 20ac 	ldr.w	r2, [r3, #172]	; 0xac
 8003582:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003586:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 800358a:	6819      	ldr	r1, [r3, #0]
 800358c:	4613      	mov	r3, r2
 800358e:	009b      	lsls	r3, r3, #2
 8003590:	4413      	add	r3, r2
 8003592:	009b      	lsls	r3, r3, #2
 8003594:	440b      	add	r3, r1
 8003596:	33b0      	adds	r3, #176	; 0xb0
 8003598:	681d      	ldr	r5, [r3, #0]
 800359a:	eddf 0a9f 	vldr	s1, [pc, #636]	; 8003818 <oscilloscope_process+0x12ac>
 800359e:	ed9f 0a9f 	vldr	s0, [pc, #636]	; 800381c <oscilloscope_process+0x12b0>
 80035a2:	f010 f989 	bl	80138b8 <nk_vec2>
 80035a6:	eeb0 7a40 	vmov.f32	s14, s0
 80035aa:	eef0 7a60 	vmov.f32	s15, s1
 80035ae:	ed87 7a5c 	vstr	s14, [r7, #368]	; 0x170
 80035b2:	edc7 7a5d 	vstr	s15, [r7, #372]	; 0x174
 80035b6:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80035ba:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 80035be:	681b      	ldr	r3, [r3, #0]
 80035c0:	f8d3 40ac 	ldr.w	r4, [r3, #172]	; 0xac
 80035c4:	ed97 7a5c 	vldr	s14, [r7, #368]	; 0x170
 80035c8:	edd7 7a5d 	vldr	s15, [r7, #372]	; 0x174
 80035cc:	f107 013c 	add.w	r1, r7, #60	; 0x3c
 80035d0:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80035d4:	f5a3 70c4 	sub.w	r0, r3, #392	; 0x188
 80035d8:	2314      	movs	r3, #20
 80035da:	9300      	str	r3, [sp, #0]
 80035dc:	eeb0 0a47 	vmov.f32	s0, s14
 80035e0:	eef0 0a67 	vmov.f32	s1, s15
 80035e4:	462b      	mov	r3, r5
 80035e6:	2202      	movs	r2, #2
 80035e8:	6800      	ldr	r0, [r0, #0]
 80035ea:	f00c f923 	bl	800f834 <nk_combo>
 80035ee:	4601      	mov	r1, r0
 80035f0:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80035f4:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 80035f8:	681a      	ldr	r2, [r3, #0]
 80035fa:	4623      	mov	r3, r4
 80035fc:	009b      	lsls	r3, r3, #2
 80035fe:	4423      	add	r3, r4
 8003600:	009b      	lsls	r3, r3, #2
 8003602:	4413      	add	r3, r2
 8003604:	33b0      	adds	r3, #176	; 0xb0
 8003606:	6019      	str	r1, [r3, #0]
                osc->cursors[osc->cursor_selected].horizontal = nk_combo(ctx, (const char*[]){"Track", "Free"}, 2, osc->cursors[osc->cursor_selected].horizontal, 20, nk_vec2(60, 200));
 8003608:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800360c:	f5a3 73aa 	sub.w	r3, r3, #340	; 0x154
 8003610:	4a85      	ldr	r2, [pc, #532]	; (8003828 <oscilloscope_process+0x12bc>)
 8003612:	e892 0003 	ldmia.w	r2, {r0, r1}
 8003616:	e883 0003 	stmia.w	r3, {r0, r1}
 800361a:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800361e:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8003622:	681b      	ldr	r3, [r3, #0]
 8003624:	f8d3 20ac 	ldr.w	r2, [r3, #172]	; 0xac
 8003628:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800362c:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8003630:	6819      	ldr	r1, [r3, #0]
 8003632:	4613      	mov	r3, r2
 8003634:	009b      	lsls	r3, r3, #2
 8003636:	4413      	add	r3, r2
 8003638:	009b      	lsls	r3, r3, #2
 800363a:	440b      	add	r3, r1
 800363c:	33b4      	adds	r3, #180	; 0xb4
 800363e:	681d      	ldr	r5, [r3, #0]
 8003640:	eddf 0a75 	vldr	s1, [pc, #468]	; 8003818 <oscilloscope_process+0x12ac>
 8003644:	ed9f 0a75 	vldr	s0, [pc, #468]	; 800381c <oscilloscope_process+0x12b0>
 8003648:	f010 f936 	bl	80138b8 <nk_vec2>
 800364c:	eeb0 7a40 	vmov.f32	s14, s0
 8003650:	eef0 7a60 	vmov.f32	s15, s1
 8003654:	ed87 7a5e 	vstr	s14, [r7, #376]	; 0x178
 8003658:	edc7 7a5f 	vstr	s15, [r7, #380]	; 0x17c
 800365c:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003660:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8003664:	681b      	ldr	r3, [r3, #0]
 8003666:	f8d3 40ac 	ldr.w	r4, [r3, #172]	; 0xac
 800366a:	ed97 7a5e 	vldr	s14, [r7, #376]	; 0x178
 800366e:	edd7 7a5f 	vldr	s15, [r7, #380]	; 0x17c
 8003672:	f107 0134 	add.w	r1, r7, #52	; 0x34
 8003676:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800367a:	f5a3 70c4 	sub.w	r0, r3, #392	; 0x188
 800367e:	2314      	movs	r3, #20
 8003680:	9300      	str	r3, [sp, #0]
 8003682:	eeb0 0a47 	vmov.f32	s0, s14
 8003686:	eef0 0a67 	vmov.f32	s1, s15
 800368a:	462b      	mov	r3, r5
 800368c:	2202      	movs	r2, #2
 800368e:	6800      	ldr	r0, [r0, #0]
 8003690:	f00c f8d0 	bl	800f834 <nk_combo>
 8003694:	4601      	mov	r1, r0
 8003696:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800369a:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 800369e:	681a      	ldr	r2, [r3, #0]
 80036a0:	4623      	mov	r3, r4
 80036a2:	009b      	lsls	r3, r3, #2
 80036a4:	4423      	add	r3, r4
 80036a6:	009b      	lsls	r3, r3, #2
 80036a8:	4413      	add	r3, r2
 80036aa:	33b4      	adds	r3, #180	; 0xb4
 80036ac:	6019      	str	r1, [r3, #0]
                osc->cursors[osc->cursor_selected].offset = nk_slider_float(ctx, -10.0f, &osc->cursors[osc->cursor_selected].offset, 10.0f, 1.0f);
 80036ae:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80036b2:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 80036b6:	681b      	ldr	r3, [r3, #0]
 80036b8:	f8d3 20ac 	ldr.w	r2, [r3, #172]	; 0xac
 80036bc:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80036c0:	f5a3 71c2 	sub.w	r1, r3, #388	; 0x184
 80036c4:	4613      	mov	r3, r2
 80036c6:	009b      	lsls	r3, r3, #2
 80036c8:	4413      	add	r3, r2
 80036ca:	009b      	lsls	r3, r3, #2
 80036cc:	33b8      	adds	r3, #184	; 0xb8
 80036ce:	680a      	ldr	r2, [r1, #0]
 80036d0:	441a      	add	r2, r3
 80036d2:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80036d6:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 80036da:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 80036de:	eef2 0a04 	vmov.f32	s1, #36	; 0x41200000  10.0
 80036e2:	4611      	mov	r1, r2
 80036e4:	eeba 0a04 	vmov.f32	s0, #164	; 0xc1200000 -10.0
 80036e8:	6818      	ldr	r0, [r3, #0]
 80036ea:	f014 ffe7 	bl	80186bc <nk_slider_float>
 80036ee:	ee07 0a90 	vmov	s15, r0
 80036f2:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80036f6:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 80036fa:	681b      	ldr	r3, [r3, #0]
 80036fc:	f8d3 20ac 	ldr.w	r2, [r3, #172]	; 0xac
 8003700:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8003704:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003708:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 800370c:	6819      	ldr	r1, [r3, #0]
 800370e:	4613      	mov	r3, r2
 8003710:	009b      	lsls	r3, r3, #2
 8003712:	4413      	add	r3, r2
 8003714:	009b      	lsls	r3, r3, #2
 8003716:	440b      	add	r3, r1
 8003718:	33b8      	adds	r3, #184	; 0xb8
 800371a:	edc3 7a00 	vstr	s15, [r3]
                osc->cursors[osc->cursor_selected].track = nk_slider_float(ctx, -10.0f, &osc->cursors[osc->cursor_selected].track, 10.0f, 1.0f);
 800371e:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003722:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 8003726:	681b      	ldr	r3, [r3, #0]
 8003728:	f8d3 20ac 	ldr.w	r2, [r3, #172]	; 0xac
 800372c:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003730:	f5a3 71c2 	sub.w	r1, r3, #388	; 0x184
 8003734:	4613      	mov	r3, r2
 8003736:	009b      	lsls	r3, r3, #2
 8003738:	4413      	add	r3, r2
 800373a:	009b      	lsls	r3, r3, #2
 800373c:	33b8      	adds	r3, #184	; 0xb8
 800373e:	680a      	ldr	r2, [r1, #0]
 8003740:	4413      	add	r3, r2
 8003742:	1d1a      	adds	r2, r3, #4
 8003744:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003748:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 800374c:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 8003750:	eef2 0a04 	vmov.f32	s1, #36	; 0x41200000  10.0
 8003754:	4611      	mov	r1, r2
 8003756:	eeba 0a04 	vmov.f32	s0, #164	; 0xc1200000 -10.0
 800375a:	6818      	ldr	r0, [r3, #0]
 800375c:	f014 ffae 	bl	80186bc <nk_slider_float>
 8003760:	ee07 0a90 	vmov	s15, r0
 8003764:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003768:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 800376c:	681b      	ldr	r3, [r3, #0]
 800376e:	f8d3 20ac 	ldr.w	r2, [r3, #172]	; 0xac
 8003772:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8003776:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 800377a:	f5a3 73c2 	sub.w	r3, r3, #388	; 0x184
 800377e:	6819      	ldr	r1, [r3, #0]
 8003780:	4613      	mov	r3, r2
 8003782:	009b      	lsls	r3, r3, #2
 8003784:	4413      	add	r3, r2
 8003786:	009b      	lsls	r3, r3, #2
 8003788:	440b      	add	r3, r1
 800378a:	33bc      	adds	r3, #188	; 0xbc
 800378c:	edc3 7a00 	vstr	s15, [r3]
                nk_tree_pop(ctx);
 8003790:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003794:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8003798:	6818      	ldr	r0, [r3, #0]
 800379a:	f018 f9d2 	bl	801bb42 <nk_tree_pop>
            }

			if( nk_tree_push( ctx, NK_TREE_TAB, "Measurements", NK_MINIMIZED) ){
 800379e:	4823      	ldr	r0, [pc, #140]	; (800382c <oscilloscope_process+0x12c0>)
 80037a0:	f018 fc60 	bl	801c064 <nk_strlen>
 80037a4:	4603      	mov	r3, r0
 80037a6:	f507 72c4 	add.w	r2, r7, #392	; 0x188
 80037aa:	f5a2 70c4 	sub.w	r0, r2, #392	; 0x188
 80037ae:	f240 22f3 	movw	r2, #755	; 0x2f3
 80037b2:	9202      	str	r2, [sp, #8]
 80037b4:	9301      	str	r3, [sp, #4]
 80037b6:	4b1d      	ldr	r3, [pc, #116]	; (800382c <oscilloscope_process+0x12c0>)
 80037b8:	9300      	str	r3, [sp, #0]
 80037ba:	2300      	movs	r3, #0
 80037bc:	4a1c      	ldr	r2, [pc, #112]	; (8003830 <oscilloscope_process+0x12c4>)
 80037be:	2101      	movs	r1, #1
 80037c0:	6800      	ldr	r0, [r0, #0]
 80037c2:	f018 f9a1 	bl	801bb08 <nk_tree_push_hashed>
 80037c6:	4603      	mov	r3, r0
 80037c8:	2b00      	cmp	r3, #0
 80037ca:	d00f      	beq.n	80037ec <oscilloscope_process+0x1280>
                nk_label(ctx, "Todo", NK_TEXT_LEFT);
 80037cc:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80037d0:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 80037d4:	2211      	movs	r2, #17
 80037d6:	4917      	ldr	r1, [pc, #92]	; (8003834 <oscilloscope_process+0x12c8>)
 80037d8:	6818      	ldr	r0, [r3, #0]
 80037da:	f017 fd4f 	bl	801b27c <nk_label>
                nk_tree_pop(ctx);
 80037de:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80037e2:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 80037e6:	6818      	ldr	r0, [r3, #0]
 80037e8:	f018 f9ab 	bl	801bb42 <nk_tree_pop>
            }

			if( nk_tree_push( ctx, NK_TREE_TAB, "Info", NK_MINIMIZED) ){
 80037ec:	4812      	ldr	r0, [pc, #72]	; (8003838 <oscilloscope_process+0x12cc>)
 80037ee:	f018 fc39 	bl	801c064 <nk_strlen>
 80037f2:	4603      	mov	r3, r0
 80037f4:	f507 72c4 	add.w	r2, r7, #392	; 0x188
 80037f8:	f5a2 70c4 	sub.w	r0, r2, #392	; 0x188
 80037fc:	f44f 723e 	mov.w	r2, #760	; 0x2f8
 8003800:	9202      	str	r2, [sp, #8]
 8003802:	9301      	str	r3, [sp, #4]
 8003804:	4b0c      	ldr	r3, [pc, #48]	; (8003838 <oscilloscope_process+0x12cc>)
 8003806:	9300      	str	r3, [sp, #0]
 8003808:	2300      	movs	r3, #0
 800380a:	e017      	b.n	800383c <oscilloscope_process+0x12d0>
 800380c:	08021280 	.word	0x08021280
 8003810:	08021298 	.word	0x08021298
 8003814:	08021410 	.word	0x08021410
 8003818:	43480000 	.word	0x43480000
 800381c:	42700000 	.word	0x42700000
 8003820:	0802137c 	.word	0x0802137c
 8003824:	0802135c 	.word	0x0802135c
 8003828:	08021428 	.word	0x08021428
 800382c:	080212a0 	.word	0x080212a0
 8003830:	080212b8 	.word	0x080212b8
 8003834:	080212c8 	.word	0x080212c8
 8003838:	080212d0 	.word	0x080212d0
 800383c:	4a2e      	ldr	r2, [pc, #184]	; (80038f8 <oscilloscope_process+0x138c>)
 800383e:	2101      	movs	r1, #1
 8003840:	6800      	ldr	r0, [r0, #0]
 8003842:	f018 f961 	bl	801bb08 <nk_tree_push_hashed>
 8003846:	4603      	mov	r3, r0
 8003848:	2b00      	cmp	r3, #0
 800384a:	d048      	beq.n	80038de <oscilloscope_process+0x1372>
                nk_layout_row(ctx, NK_STATIC, 30, 2, (float[]){60, 60});
 800384c:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003850:	f5a3 73ae 	sub.w	r3, r3, #348	; 0x15c
 8003854:	4a29      	ldr	r2, [pc, #164]	; (80038fc <oscilloscope_process+0x1390>)
 8003856:	e892 0003 	ldmia.w	r2, {r0, r1}
 800385a:	e883 0003 	stmia.w	r3, {r0, r1}
 800385e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8003862:	f507 72c4 	add.w	r2, r7, #392	; 0x188
 8003866:	f5a2 70c4 	sub.w	r0, r2, #392	; 0x188
 800386a:	2202      	movs	r2, #2
 800386c:	eeb3 0a0e 	vmov.f32	s0, #62	; 0x41f00000  30.0
 8003870:	2101      	movs	r1, #1
 8003872:	6800      	ldr	r0, [r0, #0]
 8003874:	f00f fa1a 	bl	8012cac <nk_layout_row>

                float fps = 0.0f; // Calculate fps here
 8003878:	f04f 0300 	mov.w	r3, #0
 800387c:	f8c7 3184 	str.w	r3, [r7, #388]	; 0x184
                nk_label(ctx, "FPS", NK_TEXT_LEFT);
 8003880:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003884:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 8003888:	2211      	movs	r2, #17
 800388a:	491d      	ldr	r1, [pc, #116]	; (8003900 <oscilloscope_process+0x1394>)
 800388c:	6818      	ldr	r0, [r3, #0]
 800388e:	f017 fcf5 	bl	801b27c <nk_label>
                nk_label(ctx, "0.0000", NK_TEXT_LEFT); // Replace with actual fps
 8003892:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 8003896:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 800389a:	2211      	movs	r2, #17
 800389c:	4919      	ldr	r1, [pc, #100]	; (8003904 <oscilloscope_process+0x1398>)
 800389e:	6818      	ldr	r0, [r3, #0]
 80038a0:	f017 fcec 	bl	801b27c <nk_label>

                float ratio = 0.0f; // Calculate memory ratio here
 80038a4:	f04f 0300 	mov.w	r3, #0
 80038a8:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
                nk_label(ctx, "Memory", NK_TEXT_LEFT);
 80038ac:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80038b0:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 80038b4:	2211      	movs	r2, #17
 80038b6:	4914      	ldr	r1, [pc, #80]	; (8003908 <oscilloscope_process+0x139c>)
 80038b8:	6818      	ldr	r0, [r3, #0]
 80038ba:	f017 fcdf 	bl	801b27c <nk_label>
                nk_label(ctx, "0.0000%", NK_TEXT_LEFT); // Replace with actual memory ratio
 80038be:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80038c2:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 80038c6:	2211      	movs	r2, #17
 80038c8:	4910      	ldr	r1, [pc, #64]	; (800390c <oscilloscope_process+0x13a0>)
 80038ca:	6818      	ldr	r0, [r3, #0]
 80038cc:	f017 fcd6 	bl	801b27c <nk_label>

                nk_tree_pop(ctx);
 80038d0:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80038d4:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 80038d8:	6818      	ldr	r0, [r3, #0]
 80038da:	f018 f932 	bl	801bb42 <nk_tree_pop>
            }
        }
        //nk_end(ctx);
    }
	nk_end(ctx);
 80038de:	f507 73c4 	add.w	r3, r7, #392	; 0x188
 80038e2:	f5a3 73c4 	sub.w	r3, r3, #392	; 0x188
 80038e6:	6818      	ldr	r0, [r3, #0]
 80038e8:	f019 fe70 	bl	801d5cc <nk_end>
}
 80038ec:	bf00      	nop
 80038ee:	f507 77c4 	add.w	r7, r7, #392	; 0x188
 80038f2:	46bd      	mov	sp, r7
 80038f4:	bdb0      	pop	{r4, r5, r7, pc}
 80038f6:	bf00      	nop
 80038f8:	080212e8 	.word	0x080212e8
 80038fc:	0802137c 	.word	0x0802137c
 8003900:	080212f0 	.word	0x080212f0
 8003904:	080212f4 	.word	0x080212f4
 8003908:	080212fc 	.word	0x080212fc
 800390c:	08021304 	.word	0x08021304

08003910 <nk_draw_fb>:



int quadrant = 0x01;
void nk_draw_fb( struct nk_context *ctx, const tFramebuf *pfb )
{
 8003910:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003914:	b096      	sub	sp, #88	; 0x58
 8003916:	af02      	add	r7, sp, #8
 8003918:	60f8      	str	r0, [r7, #12]
 800391a:	60b9      	str	r1, [r7, #8]
	  for( int y0 = 0 ; y0 < 320 ; y0 += 40 )
 800391c:	2300      	movs	r3, #0
 800391e:	64fb      	str	r3, [r7, #76]	; 0x4c
 8003920:	e3b0      	b.n	8004084 <nk_draw_fb+0x774>
	  {
	   framebuf_fill( pfb, 0x00000000 );
 8003922:	2100      	movs	r1, #0
 8003924:	68b8      	ldr	r0, [r7, #8]
 8003926:	f009 fc9e 	bl	800d266 <framebuf_fill>

	  {
		  const struct nk_command *cmd = NULL;
 800392a:	2300      	movs	r3, #0
 800392c:	64bb      	str	r3, [r7, #72]	; 0x48
		  nk_foreach(cmd, ctx)
 800392e:	68f8      	ldr	r0, [r7, #12]
 8003930:	f00c fcbc 	bl	80102ac <nk__begin>
 8003934:	64b8      	str	r0, [r7, #72]	; 0x48
 8003936:	e393      	b.n	8004060 <nk_draw_fb+0x750>
		  {
			  //printf( "cmd->type = %d\n", cmd->type );
			  switch (cmd->type) {
 8003938:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800393a:	781b      	ldrb	r3, [r3, #0]
 800393c:	2b11      	cmp	r3, #17
 800393e:	f200 8389 	bhi.w	8004054 <nk_draw_fb+0x744>
 8003942:	a201      	add	r2, pc, #4	; (adr r2, 8003948 <nk_draw_fb+0x38>)
 8003944:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003948:	08004055 	.word	0x08004055
 800394c:	08003991 	.word	0x08003991
 8003950:	08003997 	.word	0x08003997
 8003954:	08004055 	.word	0x08004055
 8003958:	08003a8d 	.word	0x08003a8d
 800395c:	08003c93 	.word	0x08003c93
 8003960:	08004055 	.word	0x08004055
 8003964:	08003e39 	.word	0x08003e39
 8003968:	08003eb3 	.word	0x08003eb3
 800396c:	08004055 	.word	0x08004055
 8003970:	08004055 	.word	0x08004055
 8003974:	08004055 	.word	0x08004055
 8003978:	08003f8b 	.word	0x08003f8b
 800397c:	08004055 	.word	0x08004055
 8003980:	08004055 	.word	0x08004055
 8003984:	08004055 	.word	0x08004055
 8003988:	08003f27 	.word	0x08003f27
 800398c:	08003f55 	.word	0x08003f55
			  case NK_COMMAND_NOP: break;
			  case NK_COMMAND_SCISSOR: {
				  const struct nk_command_scissor *s = (const struct nk_command_scissor*)cmd;
 8003990:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8003992:	61fb      	str	r3, [r7, #28]
			  } break;
 8003994:	e35f      	b.n	8004056 <nk_draw_fb+0x746>
			  case NK_COMMAND_LINE: {
				  const struct nk_command_line *l = (const struct nk_command_line*)cmd;
 8003996:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8003998:	623b      	str	r3, [r7, #32]
				  if( l->begin.y == l->end.y )
 800399a:	6a3b      	ldr	r3, [r7, #32]
 800399c:	f9b3 200c 	ldrsh.w	r2, [r3, #12]
 80039a0:	6a3b      	ldr	r3, [r7, #32]
 80039a2:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80039a6:	429a      	cmp	r2, r3
 80039a8:	d121      	bne.n	80039ee <nk_draw_fb+0xde>
				  {
					  framebuf_hline( pfb, l->begin.x, l->begin.y-y0, l->end.x-l->begin.x, nk_colot_to_rgb666( l->color ) );
 80039aa:	6a3b      	ldr	r3, [r7, #32]
 80039ac:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 80039b0:	461e      	mov	r6, r3
 80039b2:	6a3b      	ldr	r3, [r7, #32]
 80039b4:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 80039b8:	461a      	mov	r2, r3
 80039ba:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80039bc:	1ad4      	subs	r4, r2, r3
 80039be:	6a3b      	ldr	r3, [r7, #32]
 80039c0:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 80039c4:	461a      	mov	r2, r3
 80039c6:	6a3b      	ldr	r3, [r7, #32]
 80039c8:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 80039cc:	1ad5      	subs	r5, r2, r3
 80039ce:	6a3b      	ldr	r3, [r7, #32]
 80039d0:	f8d3 2012 	ldr.w	r2, [r3, #18]
 80039d4:	4613      	mov	r3, r2
 80039d6:	4618      	mov	r0, r3
 80039d8:	f7fe f8c8 	bl	8001b6c <nk_colot_to_rgb666>
 80039dc:	4603      	mov	r3, r0
 80039de:	9300      	str	r3, [sp, #0]
 80039e0:	462b      	mov	r3, r5
 80039e2:	4622      	mov	r2, r4
 80039e4:	4631      	mov	r1, r6
 80039e6:	68b8      	ldr	r0, [r7, #8]
 80039e8:	f009 fc8d 	bl	800d306 <framebuf_hline>
				  }
				  else
				  {
					  framebuf_line( pfb, l->begin.x, l->begin.y-y0, l->end.x, l->end.y-y0, nk_colot_to_rgb666( l->color ) );
				  }
			  } break;
 80039ec:	e333      	b.n	8004056 <nk_draw_fb+0x746>
				  else if( l->begin.x == l->end.x )
 80039ee:	6a3b      	ldr	r3, [r7, #32]
 80039f0:	f9b3 200a 	ldrsh.w	r2, [r3, #10]
 80039f4:	6a3b      	ldr	r3, [r7, #32]
 80039f6:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 80039fa:	429a      	cmp	r2, r3
 80039fc:	d121      	bne.n	8003a42 <nk_draw_fb+0x132>
					  framebuf_vline( pfb, l->begin.x, l->begin.y-y0, l->end.y-l->begin.y, nk_colot_to_rgb666( l->color ) );
 80039fe:	6a3b      	ldr	r3, [r7, #32]
 8003a00:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8003a04:	461e      	mov	r6, r3
 8003a06:	6a3b      	ldr	r3, [r7, #32]
 8003a08:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8003a0c:	461a      	mov	r2, r3
 8003a0e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003a10:	1ad4      	subs	r4, r2, r3
 8003a12:	6a3b      	ldr	r3, [r7, #32]
 8003a14:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8003a18:	461a      	mov	r2, r3
 8003a1a:	6a3b      	ldr	r3, [r7, #32]
 8003a1c:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8003a20:	1ad5      	subs	r5, r2, r3
 8003a22:	6a3b      	ldr	r3, [r7, #32]
 8003a24:	f8d3 2012 	ldr.w	r2, [r3, #18]
 8003a28:	4613      	mov	r3, r2
 8003a2a:	4618      	mov	r0, r3
 8003a2c:	f7fe f89e 	bl	8001b6c <nk_colot_to_rgb666>
 8003a30:	4603      	mov	r3, r0
 8003a32:	9300      	str	r3, [sp, #0]
 8003a34:	462b      	mov	r3, r5
 8003a36:	4622      	mov	r2, r4
 8003a38:	4631      	mov	r1, r6
 8003a3a:	68b8      	ldr	r0, [r7, #8]
 8003a3c:	f009 fc78 	bl	800d330 <framebuf_vline>
			  } break;
 8003a40:	e309      	b.n	8004056 <nk_draw_fb+0x746>
					  framebuf_line( pfb, l->begin.x, l->begin.y-y0, l->end.x, l->end.y-y0, nk_colot_to_rgb666( l->color ) );
 8003a42:	6a3b      	ldr	r3, [r7, #32]
 8003a44:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8003a48:	461e      	mov	r6, r3
 8003a4a:	6a3b      	ldr	r3, [r7, #32]
 8003a4c:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8003a50:	461a      	mov	r2, r3
 8003a52:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003a54:	1ad5      	subs	r5, r2, r3
 8003a56:	6a3b      	ldr	r3, [r7, #32]
 8003a58:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 8003a5c:	4698      	mov	r8, r3
 8003a5e:	6a3b      	ldr	r3, [r7, #32]
 8003a60:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8003a64:	461a      	mov	r2, r3
 8003a66:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003a68:	1ad4      	subs	r4, r2, r3
 8003a6a:	6a3b      	ldr	r3, [r7, #32]
 8003a6c:	f8d3 2012 	ldr.w	r2, [r3, #18]
 8003a70:	4613      	mov	r3, r2
 8003a72:	4618      	mov	r0, r3
 8003a74:	f7fe f87a 	bl	8001b6c <nk_colot_to_rgb666>
 8003a78:	4603      	mov	r3, r0
 8003a7a:	9301      	str	r3, [sp, #4]
 8003a7c:	9400      	str	r4, [sp, #0]
 8003a7e:	4643      	mov	r3, r8
 8003a80:	462a      	mov	r2, r5
 8003a82:	4631      	mov	r1, r6
 8003a84:	68b8      	ldr	r0, [r7, #8]
 8003a86:	f009 fd1f 	bl	800d4c8 <framebuf_line>
			  } break;
 8003a8a:	e2e4      	b.n	8004056 <nk_draw_fb+0x746>
			  case NK_COMMAND_RECT: {
				  const struct nk_command_rect *r = (const struct nk_command_rect*)cmd;
 8003a8c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8003a8e:	62bb      	str	r3, [r7, #40]	; 0x28
				  //printf( "NK_COMMAND_RECT x: %d, y: %d, width: %d, height: %d, rounding: %d, thickness: %d\n", r->x, r->y, r->w, r->h, r->rounding, r->line_thickness );
				  //framebuf_rect( pfb, r->x, r->y-y0, r->w, r->h, nk_colot_to_rgb666( r->color ) );
				  int rad = 4;//r->rounding;
 8003a90:	2304      	movs	r3, #4
 8003a92:	627b      	str	r3, [r7, #36]	; 0x24
                    framebuf_circle_quadrant( pfb, r->x+r->w-rad, r->y-y0+r->h-rad, rad, nk_colot_to_rgb666( r->color ), QUADRANT_0 );
 8003a94:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003a96:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8003a9a:	461a      	mov	r2, r3
 8003a9c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003a9e:	8a1b      	ldrh	r3, [r3, #16]
 8003aa0:	441a      	add	r2, r3
 8003aa2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003aa4:	1ad4      	subs	r4, r2, r3
 8003aa6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003aa8:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 8003aac:	461a      	mov	r2, r3
 8003aae:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003ab0:	1ad3      	subs	r3, r2, r3
 8003ab2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8003ab4:	8a52      	ldrh	r2, [r2, #18]
 8003ab6:	441a      	add	r2, r3
 8003ab8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003aba:	1ad5      	subs	r5, r2, r3
 8003abc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003abe:	6958      	ldr	r0, [r3, #20]
 8003ac0:	f7fe f854 	bl	8001b6c <nk_colot_to_rgb666>
 8003ac4:	4603      	mov	r3, r0
 8003ac6:	2201      	movs	r2, #1
 8003ac8:	9201      	str	r2, [sp, #4]
 8003aca:	9300      	str	r3, [sp, #0]
 8003acc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003ace:	462a      	mov	r2, r5
 8003ad0:	4621      	mov	r1, r4
 8003ad2:	68b8      	ldr	r0, [r7, #8]
 8003ad4:	f009 fd8f 	bl	800d5f6 <framebuf_circle_quadrant>
                    framebuf_circle_quadrant( pfb, r->x+rad, r->y-y0+r->h-rad, rad, nk_colot_to_rgb666( r->color ), QUADRANT_90 );
 8003ad8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003ada:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8003ade:	461a      	mov	r2, r3
 8003ae0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003ae2:	18d4      	adds	r4, r2, r3
 8003ae4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003ae6:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 8003aea:	461a      	mov	r2, r3
 8003aec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003aee:	1ad3      	subs	r3, r2, r3
 8003af0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8003af2:	8a52      	ldrh	r2, [r2, #18]
 8003af4:	441a      	add	r2, r3
 8003af6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003af8:	1ad5      	subs	r5, r2, r3
 8003afa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003afc:	6958      	ldr	r0, [r3, #20]
 8003afe:	f7fe f835 	bl	8001b6c <nk_colot_to_rgb666>
 8003b02:	4603      	mov	r3, r0
 8003b04:	2202      	movs	r2, #2
 8003b06:	9201      	str	r2, [sp, #4]
 8003b08:	9300      	str	r3, [sp, #0]
 8003b0a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003b0c:	462a      	mov	r2, r5
 8003b0e:	4621      	mov	r1, r4
 8003b10:	68b8      	ldr	r0, [r7, #8]
 8003b12:	f009 fd70 	bl	800d5f6 <framebuf_circle_quadrant>
                    framebuf_circle_quadrant( pfb, r->x+rad, r->y-y0+rad, rad, nk_colot_to_rgb666( r->color ), QUADRANT_180 );
 8003b16:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003b18:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8003b1c:	461a      	mov	r2, r3
 8003b1e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003b20:	18d4      	adds	r4, r2, r3
 8003b22:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003b24:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 8003b28:	461a      	mov	r2, r3
 8003b2a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003b2c:	1ad2      	subs	r2, r2, r3
 8003b2e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003b30:	18d5      	adds	r5, r2, r3
 8003b32:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003b34:	6958      	ldr	r0, [r3, #20]
 8003b36:	f7fe f819 	bl	8001b6c <nk_colot_to_rgb666>
 8003b3a:	4603      	mov	r3, r0
 8003b3c:	2204      	movs	r2, #4
 8003b3e:	9201      	str	r2, [sp, #4]
 8003b40:	9300      	str	r3, [sp, #0]
 8003b42:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003b44:	462a      	mov	r2, r5
 8003b46:	4621      	mov	r1, r4
 8003b48:	68b8      	ldr	r0, [r7, #8]
 8003b4a:	f009 fd54 	bl	800d5f6 <framebuf_circle_quadrant>
                    framebuf_circle_quadrant( pfb, r->x+r->w-rad, r->y-y0+rad, rad, nk_colot_to_rgb666( r->color ), QUADRANT_270 );
 8003b4e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003b50:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8003b54:	461a      	mov	r2, r3
 8003b56:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003b58:	8a1b      	ldrh	r3, [r3, #16]
 8003b5a:	441a      	add	r2, r3
 8003b5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003b5e:	1ad4      	subs	r4, r2, r3
 8003b60:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003b62:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 8003b66:	461a      	mov	r2, r3
 8003b68:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003b6a:	1ad2      	subs	r2, r2, r3
 8003b6c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003b6e:	18d5      	adds	r5, r2, r3
 8003b70:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003b72:	6958      	ldr	r0, [r3, #20]
 8003b74:	f7fd fffa 	bl	8001b6c <nk_colot_to_rgb666>
 8003b78:	4603      	mov	r3, r0
 8003b7a:	2208      	movs	r2, #8
 8003b7c:	9201      	str	r2, [sp, #4]
 8003b7e:	9300      	str	r3, [sp, #0]
 8003b80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003b82:	462a      	mov	r2, r5
 8003b84:	4621      	mov	r1, r4
 8003b86:	68b8      	ldr	r0, [r7, #8]
 8003b88:	f009 fd35 	bl	800d5f6 <framebuf_circle_quadrant>
                    framebuf_hline( pfb, r->x+rad, r->y-y0, r->w-rad-rad, nk_colot_to_rgb666( r->color ) );
 8003b8c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003b8e:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8003b92:	461a      	mov	r2, r3
 8003b94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003b96:	18d4      	adds	r4, r2, r3
 8003b98:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003b9a:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 8003b9e:	461a      	mov	r2, r3
 8003ba0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003ba2:	1ad5      	subs	r5, r2, r3
 8003ba4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003ba6:	8a1b      	ldrh	r3, [r3, #16]
 8003ba8:	461a      	mov	r2, r3
 8003baa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003bac:	1ad2      	subs	r2, r2, r3
 8003bae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003bb0:	1ad6      	subs	r6, r2, r3
 8003bb2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003bb4:	6958      	ldr	r0, [r3, #20]
 8003bb6:	f7fd ffd9 	bl	8001b6c <nk_colot_to_rgb666>
 8003bba:	4603      	mov	r3, r0
 8003bbc:	9300      	str	r3, [sp, #0]
 8003bbe:	4633      	mov	r3, r6
 8003bc0:	462a      	mov	r2, r5
 8003bc2:	4621      	mov	r1, r4
 8003bc4:	68b8      	ldr	r0, [r7, #8]
 8003bc6:	f009 fb9e 	bl	800d306 <framebuf_hline>
                    framebuf_hline( pfb, r->x+rad, r->y-y0+r->h, r->w-rad-rad, nk_colot_to_rgb666( r->color ) );
 8003bca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003bcc:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8003bd0:	461a      	mov	r2, r3
 8003bd2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003bd4:	18d4      	adds	r4, r2, r3
 8003bd6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003bd8:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 8003bdc:	461a      	mov	r2, r3
 8003bde:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003be0:	1ad3      	subs	r3, r2, r3
 8003be2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8003be4:	8a52      	ldrh	r2, [r2, #18]
 8003be6:	189d      	adds	r5, r3, r2
 8003be8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003bea:	8a1b      	ldrh	r3, [r3, #16]
 8003bec:	461a      	mov	r2, r3
 8003bee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003bf0:	1ad2      	subs	r2, r2, r3
 8003bf2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003bf4:	1ad6      	subs	r6, r2, r3
 8003bf6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003bf8:	6958      	ldr	r0, [r3, #20]
 8003bfa:	f7fd ffb7 	bl	8001b6c <nk_colot_to_rgb666>
 8003bfe:	4603      	mov	r3, r0
 8003c00:	9300      	str	r3, [sp, #0]
 8003c02:	4633      	mov	r3, r6
 8003c04:	462a      	mov	r2, r5
 8003c06:	4621      	mov	r1, r4
 8003c08:	68b8      	ldr	r0, [r7, #8]
 8003c0a:	f009 fb7c 	bl	800d306 <framebuf_hline>
                    framebuf_vline( pfb, r->x, r->y-y0+rad, r->h-rad-rad, nk_colot_to_rgb666( r->color ) );
 8003c0e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003c10:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8003c14:	461e      	mov	r6, r3
 8003c16:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003c18:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 8003c1c:	461a      	mov	r2, r3
 8003c1e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003c20:	1ad2      	subs	r2, r2, r3
 8003c22:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003c24:	18d4      	adds	r4, r2, r3
 8003c26:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003c28:	8a5b      	ldrh	r3, [r3, #18]
 8003c2a:	461a      	mov	r2, r3
 8003c2c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003c2e:	1ad2      	subs	r2, r2, r3
 8003c30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003c32:	1ad5      	subs	r5, r2, r3
 8003c34:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003c36:	6958      	ldr	r0, [r3, #20]
 8003c38:	f7fd ff98 	bl	8001b6c <nk_colot_to_rgb666>
 8003c3c:	4603      	mov	r3, r0
 8003c3e:	9300      	str	r3, [sp, #0]
 8003c40:	462b      	mov	r3, r5
 8003c42:	4622      	mov	r2, r4
 8003c44:	4631      	mov	r1, r6
 8003c46:	68b8      	ldr	r0, [r7, #8]
 8003c48:	f009 fb72 	bl	800d330 <framebuf_vline>
                    framebuf_vline( pfb, r->x+r->w, r->y-y0+rad, r->h-rad-rad, nk_colot_to_rgb666( r->color ) );
 8003c4c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003c4e:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8003c52:	461a      	mov	r2, r3
 8003c54:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003c56:	8a1b      	ldrh	r3, [r3, #16]
 8003c58:	18d4      	adds	r4, r2, r3
 8003c5a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003c5c:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 8003c60:	461a      	mov	r2, r3
 8003c62:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003c64:	1ad2      	subs	r2, r2, r3
 8003c66:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003c68:	18d5      	adds	r5, r2, r3
 8003c6a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003c6c:	8a5b      	ldrh	r3, [r3, #18]
 8003c6e:	461a      	mov	r2, r3
 8003c70:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003c72:	1ad2      	subs	r2, r2, r3
 8003c74:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003c76:	1ad6      	subs	r6, r2, r3
 8003c78:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003c7a:	6958      	ldr	r0, [r3, #20]
 8003c7c:	f7fd ff76 	bl	8001b6c <nk_colot_to_rgb666>
 8003c80:	4603      	mov	r3, r0
 8003c82:	9300      	str	r3, [sp, #0]
 8003c84:	4633      	mov	r3, r6
 8003c86:	462a      	mov	r2, r5
 8003c88:	4621      	mov	r1, r4
 8003c8a:	68b8      	ldr	r0, [r7, #8]
 8003c8c:	f009 fb50 	bl	800d330 <framebuf_vline>
			  } break;
 8003c90:	e1e1      	b.n	8004056 <nk_draw_fb+0x746>
			  case NK_COMMAND_RECT_FILLED: {
				  const struct nk_command_rect_filled *r = (const struct nk_command_rect_filled*)cmd;
 8003c92:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8003c94:	633b      	str	r3, [r7, #48]	; 0x30
				  //framebuf_fill_rect( pfb, r->x, r->y-y0, r->w, r->h, nk_colot_to_rgb666( r->color ) );
                  int rad = 4;//r->rounding;
 8003c96:	2304      	movs	r3, #4
 8003c98:	62fb      	str	r3, [r7, #44]	; 0x2c
                  struct nk_color r_color = r->color;
 8003c9a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8003c9c:	f107 0318 	add.w	r3, r7, #24
 8003ca0:	3212      	adds	r2, #18
 8003ca2:	6810      	ldr	r0, [r2, #0]
 8003ca4:	6018      	str	r0, [r3, #0]
                  if( r_color.r == 50 )
 8003ca6:	7e3b      	ldrb	r3, [r7, #24]
 8003ca8:	2b32      	cmp	r3, #50	; 0x32
 8003caa:	d107      	bne.n	8003cbc <nk_draw_fb+0x3ac>
                  {
                	  r_color.r = 40;
 8003cac:	2328      	movs	r3, #40	; 0x28
 8003cae:	763b      	strb	r3, [r7, #24]
                	  r_color.g = 40;
 8003cb0:	2328      	movs	r3, #40	; 0x28
 8003cb2:	767b      	strb	r3, [r7, #25]
                	  r_color.b = 40;
 8003cb4:	2328      	movs	r3, #40	; 0x28
 8003cb6:	76bb      	strb	r3, [r7, #26]
                	  r_color.a = 255;
 8003cb8:	23ff      	movs	r3, #255	; 0xff
 8003cba:	76fb      	strb	r3, [r7, #27]
                  }
                    framebuf_fill_circle_quadrant( pfb, r->x+r->w-rad, r->y-y0+r->h-rad, rad, nk_colot_to_rgb666( r_color ), QUADRANT_90 );
 8003cbc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003cbe:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8003cc2:	461a      	mov	r2, r3
 8003cc4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003cc6:	89db      	ldrh	r3, [r3, #14]
 8003cc8:	441a      	add	r2, r3
 8003cca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003ccc:	1ad4      	subs	r4, r2, r3
 8003cce:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003cd0:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8003cd4:	461a      	mov	r2, r3
 8003cd6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003cd8:	1ad3      	subs	r3, r2, r3
 8003cda:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8003cdc:	8a12      	ldrh	r2, [r2, #16]
 8003cde:	441a      	add	r2, r3
 8003ce0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003ce2:	1ad5      	subs	r5, r2, r3
 8003ce4:	69b8      	ldr	r0, [r7, #24]
 8003ce6:	f7fd ff41 	bl	8001b6c <nk_colot_to_rgb666>
 8003cea:	4603      	mov	r3, r0
 8003cec:	2202      	movs	r2, #2
 8003cee:	9201      	str	r2, [sp, #4]
 8003cf0:	9300      	str	r3, [sp, #0]
 8003cf2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003cf4:	462a      	mov	r2, r5
 8003cf6:	4621      	mov	r1, r4
 8003cf8:	68b8      	ldr	r0, [r7, #8]
 8003cfa:	f009 fd93 	bl	800d824 <framebuf_fill_circle_quadrant>
                    framebuf_fill_circle_quadrant( pfb, r->x+rad, r->y-y0+r->h-rad, rad, nk_colot_to_rgb666( r_color ), QUADRANT_90 );
 8003cfe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003d00:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8003d04:	461a      	mov	r2, r3
 8003d06:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003d08:	18d4      	adds	r4, r2, r3
 8003d0a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003d0c:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8003d10:	461a      	mov	r2, r3
 8003d12:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003d14:	1ad3      	subs	r3, r2, r3
 8003d16:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8003d18:	8a12      	ldrh	r2, [r2, #16]
 8003d1a:	441a      	add	r2, r3
 8003d1c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003d1e:	1ad5      	subs	r5, r2, r3
 8003d20:	69b8      	ldr	r0, [r7, #24]
 8003d22:	f7fd ff23 	bl	8001b6c <nk_colot_to_rgb666>
 8003d26:	4603      	mov	r3, r0
 8003d28:	2202      	movs	r2, #2
 8003d2a:	9201      	str	r2, [sp, #4]
 8003d2c:	9300      	str	r3, [sp, #0]
 8003d2e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003d30:	462a      	mov	r2, r5
 8003d32:	4621      	mov	r1, r4
 8003d34:	68b8      	ldr	r0, [r7, #8]
 8003d36:	f009 fd75 	bl	800d824 <framebuf_fill_circle_quadrant>
                    framebuf_fill_circle_quadrant( pfb, r->x+rad, r->y-y0+rad, rad, nk_colot_to_rgb666( r_color ), QUADRANT_90 );
 8003d3a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003d3c:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8003d40:	461a      	mov	r2, r3
 8003d42:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003d44:	18d4      	adds	r4, r2, r3
 8003d46:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003d48:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8003d4c:	461a      	mov	r2, r3
 8003d4e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003d50:	1ad2      	subs	r2, r2, r3
 8003d52:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003d54:	18d5      	adds	r5, r2, r3
 8003d56:	69b8      	ldr	r0, [r7, #24]
 8003d58:	f7fd ff08 	bl	8001b6c <nk_colot_to_rgb666>
 8003d5c:	4603      	mov	r3, r0
 8003d5e:	2202      	movs	r2, #2
 8003d60:	9201      	str	r2, [sp, #4]
 8003d62:	9300      	str	r3, [sp, #0]
 8003d64:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003d66:	462a      	mov	r2, r5
 8003d68:	4621      	mov	r1, r4
 8003d6a:	68b8      	ldr	r0, [r7, #8]
 8003d6c:	f009 fd5a 	bl	800d824 <framebuf_fill_circle_quadrant>
                    framebuf_fill_circle_quadrant( pfb, r->x+r->w-rad, r->y-y0+rad, rad, nk_colot_to_rgb666( r_color ), QUADRANT_90 );
 8003d70:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003d72:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8003d76:	461a      	mov	r2, r3
 8003d78:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003d7a:	89db      	ldrh	r3, [r3, #14]
 8003d7c:	441a      	add	r2, r3
 8003d7e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003d80:	1ad4      	subs	r4, r2, r3
 8003d82:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003d84:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8003d88:	461a      	mov	r2, r3
 8003d8a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003d8c:	1ad2      	subs	r2, r2, r3
 8003d8e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003d90:	18d5      	adds	r5, r2, r3
 8003d92:	69b8      	ldr	r0, [r7, #24]
 8003d94:	f7fd feea 	bl	8001b6c <nk_colot_to_rgb666>
 8003d98:	4603      	mov	r3, r0
 8003d9a:	2202      	movs	r2, #2
 8003d9c:	9201      	str	r2, [sp, #4]
 8003d9e:	9300      	str	r3, [sp, #0]
 8003da0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003da2:	462a      	mov	r2, r5
 8003da4:	4621      	mov	r1, r4
 8003da6:	68b8      	ldr	r0, [r7, #8]
 8003da8:	f009 fd3c 	bl	800d824 <framebuf_fill_circle_quadrant>
                    // up and down
                    framebuf_fill_rect( pfb, r->x+rad, r->y-y0, r->w-rad-rad, r->h, nk_colot_to_rgb666( r_color ) );
 8003dac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003dae:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8003db2:	461a      	mov	r2, r3
 8003db4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003db6:	18d4      	adds	r4, r2, r3
 8003db8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003dba:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8003dbe:	461a      	mov	r2, r3
 8003dc0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003dc2:	1ad5      	subs	r5, r2, r3
 8003dc4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003dc6:	89db      	ldrh	r3, [r3, #14]
 8003dc8:	461a      	mov	r2, r3
 8003dca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003dcc:	1ad2      	subs	r2, r2, r3
 8003dce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003dd0:	1ad6      	subs	r6, r2, r3
 8003dd2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003dd4:	8a1b      	ldrh	r3, [r3, #16]
 8003dd6:	607b      	str	r3, [r7, #4]
 8003dd8:	69b8      	ldr	r0, [r7, #24]
 8003dda:	f7fd fec7 	bl	8001b6c <nk_colot_to_rgb666>
 8003dde:	4603      	mov	r3, r0
 8003de0:	9301      	str	r3, [sp, #4]
 8003de2:	687b      	ldr	r3, [r7, #4]
 8003de4:	9300      	str	r3, [sp, #0]
 8003de6:	4633      	mov	r3, r6
 8003de8:	462a      	mov	r2, r5
 8003dea:	4621      	mov	r1, r4
 8003dec:	68b8      	ldr	r0, [r7, #8]
 8003dee:	f009 fa52 	bl	800d296 <framebuf_fill_rect>
                    // middle
                    framebuf_fill_rect(  pfb, r->x, r->y-y0+rad, r->w, r->h-rad-rad, nk_colot_to_rgb666( r_color ) );
 8003df2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003df4:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8003df8:	461e      	mov	r6, r3
 8003dfa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003dfc:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8003e00:	461a      	mov	r2, r3
 8003e02:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003e04:	1ad2      	subs	r2, r2, r3
 8003e06:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003e08:	18d5      	adds	r5, r2, r3
 8003e0a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003e0c:	89db      	ldrh	r3, [r3, #14]
 8003e0e:	4698      	mov	r8, r3
 8003e10:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003e12:	8a1b      	ldrh	r3, [r3, #16]
 8003e14:	461a      	mov	r2, r3
 8003e16:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003e18:	1ad2      	subs	r2, r2, r3
 8003e1a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003e1c:	1ad4      	subs	r4, r2, r3
 8003e1e:	69b8      	ldr	r0, [r7, #24]
 8003e20:	f7fd fea4 	bl	8001b6c <nk_colot_to_rgb666>
 8003e24:	4603      	mov	r3, r0
 8003e26:	9301      	str	r3, [sp, #4]
 8003e28:	9400      	str	r4, [sp, #0]
 8003e2a:	4643      	mov	r3, r8
 8003e2c:	462a      	mov	r2, r5
 8003e2e:	4631      	mov	r1, r6
 8003e30:	68b8      	ldr	r0, [r7, #8]
 8003e32:	f009 fa30 	bl	800d296 <framebuf_fill_rect>
			 } break;
 8003e36:	e10e      	b.n	8004056 <nk_draw_fb+0x746>
			  case NK_COMMAND_CIRCLE: {
				  const struct nk_command_circle *c = (const struct nk_command_circle*)cmd;
 8003e38:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8003e3a:	637b      	str	r3, [r7, #52]	; 0x34
				  framebuf_circle( pfb, c->x+(c->w+c->h)/4, c->y-y0+(c->w+c->h)/4, (c->w+c->h)/4, nk_colot_to_rgb666( c->color ) );
 8003e3c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003e3e:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 8003e42:	461a      	mov	r2, r3
 8003e44:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003e46:	89db      	ldrh	r3, [r3, #14]
 8003e48:	4619      	mov	r1, r3
 8003e4a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003e4c:	8a1b      	ldrh	r3, [r3, #16]
 8003e4e:	440b      	add	r3, r1
 8003e50:	2b00      	cmp	r3, #0
 8003e52:	da00      	bge.n	8003e56 <nk_draw_fb+0x546>
 8003e54:	3303      	adds	r3, #3
 8003e56:	109b      	asrs	r3, r3, #2
 8003e58:	18d4      	adds	r4, r2, r3
 8003e5a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003e5c:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8003e60:	461a      	mov	r2, r3
 8003e62:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003e64:	1ad2      	subs	r2, r2, r3
 8003e66:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003e68:	89db      	ldrh	r3, [r3, #14]
 8003e6a:	4619      	mov	r1, r3
 8003e6c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003e6e:	8a1b      	ldrh	r3, [r3, #16]
 8003e70:	440b      	add	r3, r1
 8003e72:	2b00      	cmp	r3, #0
 8003e74:	da00      	bge.n	8003e78 <nk_draw_fb+0x568>
 8003e76:	3303      	adds	r3, #3
 8003e78:	109b      	asrs	r3, r3, #2
 8003e7a:	18d5      	adds	r5, r2, r3
 8003e7c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003e7e:	89db      	ldrh	r3, [r3, #14]
 8003e80:	461a      	mov	r2, r3
 8003e82:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003e84:	8a1b      	ldrh	r3, [r3, #16]
 8003e86:	4413      	add	r3, r2
 8003e88:	2b00      	cmp	r3, #0
 8003e8a:	da00      	bge.n	8003e8e <nk_draw_fb+0x57e>
 8003e8c:	3303      	adds	r3, #3
 8003e8e:	109b      	asrs	r3, r3, #2
 8003e90:	461e      	mov	r6, r3
 8003e92:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003e94:	f8d3 2012 	ldr.w	r2, [r3, #18]
 8003e98:	4613      	mov	r3, r2
 8003e9a:	4618      	mov	r0, r3
 8003e9c:	f7fd fe66 	bl	8001b6c <nk_colot_to_rgb666>
 8003ea0:	4603      	mov	r3, r0
 8003ea2:	9300      	str	r3, [sp, #0]
 8003ea4:	4633      	mov	r3, r6
 8003ea6:	462a      	mov	r2, r5
 8003ea8:	4621      	mov	r1, r4
 8003eaa:	68b8      	ldr	r0, [r7, #8]
 8003eac:	f009 fb21 	bl	800d4f2 <framebuf_circle>
			  } break;
 8003eb0:	e0d1      	b.n	8004056 <nk_draw_fb+0x746>
			  case NK_COMMAND_CIRCLE_FILLED: {
				  const struct nk_command_circle_filled *c = (const struct nk_command_circle_filled *)cmd;
 8003eb2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8003eb4:	63bb      	str	r3, [r7, #56]	; 0x38
				  framebuf_fill_circle( pfb, c->x+(c->w+c->h)/4, c->y-y0+(c->w+c->h)/4, (c->w+c->h)/4, nk_colot_to_rgb666( c->color ) );
 8003eb6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8003eb8:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 8003ebc:	461a      	mov	r2, r3
 8003ebe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8003ec0:	899b      	ldrh	r3, [r3, #12]
 8003ec2:	4619      	mov	r1, r3
 8003ec4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8003ec6:	89db      	ldrh	r3, [r3, #14]
 8003ec8:	440b      	add	r3, r1
 8003eca:	2b00      	cmp	r3, #0
 8003ecc:	da00      	bge.n	8003ed0 <nk_draw_fb+0x5c0>
 8003ece:	3303      	adds	r3, #3
 8003ed0:	109b      	asrs	r3, r3, #2
 8003ed2:	18d4      	adds	r4, r2, r3
 8003ed4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8003ed6:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8003eda:	461a      	mov	r2, r3
 8003edc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003ede:	1ad2      	subs	r2, r2, r3
 8003ee0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8003ee2:	899b      	ldrh	r3, [r3, #12]
 8003ee4:	4619      	mov	r1, r3
 8003ee6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8003ee8:	89db      	ldrh	r3, [r3, #14]
 8003eea:	440b      	add	r3, r1
 8003eec:	2b00      	cmp	r3, #0
 8003eee:	da00      	bge.n	8003ef2 <nk_draw_fb+0x5e2>
 8003ef0:	3303      	adds	r3, #3
 8003ef2:	109b      	asrs	r3, r3, #2
 8003ef4:	18d5      	adds	r5, r2, r3
 8003ef6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8003ef8:	899b      	ldrh	r3, [r3, #12]
 8003efa:	461a      	mov	r2, r3
 8003efc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8003efe:	89db      	ldrh	r3, [r3, #14]
 8003f00:	4413      	add	r3, r2
 8003f02:	2b00      	cmp	r3, #0
 8003f04:	da00      	bge.n	8003f08 <nk_draw_fb+0x5f8>
 8003f06:	3303      	adds	r3, #3
 8003f08:	109b      	asrs	r3, r3, #2
 8003f0a:	461e      	mov	r6, r3
 8003f0c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8003f0e:	6918      	ldr	r0, [r3, #16]
 8003f10:	f7fd fe2c 	bl	8001b6c <nk_colot_to_rgb666>
 8003f14:	4603      	mov	r3, r0
 8003f16:	9300      	str	r3, [sp, #0]
 8003f18:	4633      	mov	r3, r6
 8003f1a:	462a      	mov	r2, r5
 8003f1c:	4621      	mov	r1, r4
 8003f1e:	68b8      	ldr	r0, [r7, #8]
 8003f20:	f009 fc04 	bl	800d72c <framebuf_fill_circle>
			  } break;
 8003f24:	e097      	b.n	8004056 <nk_draw_fb+0x746>
			  case NK_COMMAND_TEXT: {
				  const struct nk_command_text *t = (const struct nk_command_text*)cmd;
 8003f26:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8003f28:	643b      	str	r3, [r7, #64]	; 0x40
				  //framebuf_text( pfb, t->x, t->y-y0, (char *)t->string, nk_colot_to_rgb666( t->foreground ) );
				  lcd_text( pfb,  t->x, t->y-y0, (char *)t->string, 0xFFFF );
 8003f2a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8003f2c:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 8003f30:	b299      	uxth	r1, r3
 8003f32:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8003f34:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8003f38:	b29a      	uxth	r2, r3
 8003f3a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003f3c:	b29b      	uxth	r3, r3
 8003f3e:	1ad3      	subs	r3, r2, r3
 8003f40:	b29a      	uxth	r2, r3
 8003f42:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8003f44:	3324      	adds	r3, #36	; 0x24
 8003f46:	f64f 70ff 	movw	r0, #65535	; 0xffff
 8003f4a:	9000      	str	r0, [sp, #0]
 8003f4c:	68b8      	ldr	r0, [r7, #8]
 8003f4e:	f7fe f8bd 	bl	80020cc <lcd_text>
			  } break;
 8003f52:	e080      	b.n	8004056 <nk_draw_fb+0x746>
			  case NK_COMMAND_IMAGE: {
				  const struct nk_command_image *i = (const struct nk_command_image*)cmd;
 8003f54:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8003f56:	647b      	str	r3, [r7, #68]	; 0x44
				  framebuf_fill_rect( pfb, i->x, i->y-y0, i->w, i->h, 0x0003FFFF );
 8003f58:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8003f5a:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 8003f5e:	4618      	mov	r0, r3
 8003f60:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8003f62:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8003f66:	461a      	mov	r2, r3
 8003f68:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003f6a:	1ad2      	subs	r2, r2, r3
 8003f6c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8003f6e:	899b      	ldrh	r3, [r3, #12]
 8003f70:	461c      	mov	r4, r3
 8003f72:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8003f74:	89db      	ldrh	r3, [r3, #14]
 8003f76:	4619      	mov	r1, r3
 8003f78:	4b48      	ldr	r3, [pc, #288]	; (800409c <nk_draw_fb+0x78c>)
 8003f7a:	9301      	str	r3, [sp, #4]
 8003f7c:	9100      	str	r1, [sp, #0]
 8003f7e:	4623      	mov	r3, r4
 8003f80:	4601      	mov	r1, r0
 8003f82:	68b8      	ldr	r0, [r7, #8]
 8003f84:	f009 f987 	bl	800d296 <framebuf_fill_rect>
			  } break;
 8003f88:	e065      	b.n	8004056 <nk_draw_fb+0x746>
			  case NK_COMMAND_TRIANGLE_FILLED: {
				  const struct nk_command_triangle_filled *t = (const struct nk_command_triangle_filled*)cmd;
 8003f8a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8003f8c:	63fb      	str	r3, [r7, #60]	; 0x3c
				  struct nk_color t_color = t->color;
 8003f8e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8003f90:	695b      	ldr	r3, [r3, #20]
 8003f92:	617b      	str	r3, [r7, #20]
				if( 1 )
				{
				  t_color.r = 175;
 8003f94:	23af      	movs	r3, #175	; 0xaf
 8003f96:	753b      	strb	r3, [r7, #20]
				  t_color.g = 175;
 8003f98:	23af      	movs	r3, #175	; 0xaf
 8003f9a:	757b      	strb	r3, [r7, #21]
				  t_color.b = 175;
 8003f9c:	23af      	movs	r3, #175	; 0xaf
 8003f9e:	75bb      	strb	r3, [r7, #22]
				  t_color.a = 255;
 8003fa0:	23ff      	movs	r3, #255	; 0xff
 8003fa2:	75fb      	strb	r3, [r7, #23]
				}

				  framebuf_line( pfb, t->a.x, t->a.y-y0, t->b.x, t->b.y-y0, 0xFFFF );
 8003fa4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8003fa6:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 8003faa:	4618      	mov	r0, r3
 8003fac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8003fae:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8003fb2:	461a      	mov	r2, r3
 8003fb4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003fb6:	1ad2      	subs	r2, r2, r3
 8003fb8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8003fba:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8003fbe:	461c      	mov	r4, r3
 8003fc0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8003fc2:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 8003fc6:	4619      	mov	r1, r3
 8003fc8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003fca:	1acb      	subs	r3, r1, r3
 8003fcc:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8003fd0:	9101      	str	r1, [sp, #4]
 8003fd2:	9300      	str	r3, [sp, #0]
 8003fd4:	4623      	mov	r3, r4
 8003fd6:	4601      	mov	r1, r0
 8003fd8:	68b8      	ldr	r0, [r7, #8]
 8003fda:	f009 fa75 	bl	800d4c8 <framebuf_line>
				  framebuf_line( pfb, t->b.x, t->b.y-y0, t->c.x, t->c.y-y0, 0xFFFF );
 8003fde:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8003fe0:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8003fe4:	4618      	mov	r0, r3
 8003fe6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8003fe8:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 8003fec:	461a      	mov	r2, r3
 8003fee:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003ff0:	1ad2      	subs	r2, r2, r3
 8003ff2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8003ff4:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8003ff8:	461c      	mov	r4, r3
 8003ffa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8003ffc:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8004000:	4619      	mov	r1, r3
 8004002:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8004004:	1acb      	subs	r3, r1, r3
 8004006:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800400a:	9101      	str	r1, [sp, #4]
 800400c:	9300      	str	r3, [sp, #0]
 800400e:	4623      	mov	r3, r4
 8004010:	4601      	mov	r1, r0
 8004012:	68b8      	ldr	r0, [r7, #8]
 8004014:	f009 fa58 	bl	800d4c8 <framebuf_line>
				  framebuf_line( pfb, t->c.x, t->c.y-y0, t->a.x, t->a.y-y0, 0xFFFF );
 8004018:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800401a:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 800401e:	4618      	mov	r0, r3
 8004020:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8004022:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8004026:	461a      	mov	r2, r3
 8004028:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800402a:	1ad2      	subs	r2, r2, r3
 800402c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800402e:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 8004032:	461c      	mov	r4, r3
 8004034:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8004036:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 800403a:	4619      	mov	r1, r3
 800403c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800403e:	1acb      	subs	r3, r1, r3
 8004040:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8004044:	9101      	str	r1, [sp, #4]
 8004046:	9300      	str	r3, [sp, #0]
 8004048:	4623      	mov	r3, r4
 800404a:	4601      	mov	r1, r0
 800404c:	68b8      	ldr	r0, [r7, #8]
 800404e:	f009 fa3b 	bl	800d4c8 <framebuf_line>
			  } break;
 8004052:	e000      	b.n	8004056 <nk_draw_fb+0x746>
			  default: break;
 8004054:	bf00      	nop
		  nk_foreach(cmd, ctx)
 8004056:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8004058:	68f8      	ldr	r0, [r7, #12]
 800405a:	f00c f993 	bl	8010384 <nk__next>
 800405e:	64b8      	str	r0, [r7, #72]	; 0x48
 8004060:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8004062:	2b00      	cmp	r3, #0
 8004064:	f47f ac68 	bne.w	8003938 <nk_draw_fb+0x28>
			  }
		  }
	  }

		lcd_bmp( 0, y0, 480, 40, pfb->buf );
 8004068:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800406a:	b219      	sxth	r1, r3
 800406c:	68bb      	ldr	r3, [r7, #8]
 800406e:	681b      	ldr	r3, [r3, #0]
 8004070:	9300      	str	r3, [sp, #0]
 8004072:	2328      	movs	r3, #40	; 0x28
 8004074:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 8004078:	2000      	movs	r0, #0
 800407a:	f7fe f987 	bl	800238c <lcd_bmp>
	  for( int y0 = 0 ; y0 < 320 ; y0 += 40 )
 800407e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8004080:	3328      	adds	r3, #40	; 0x28
 8004082:	64fb      	str	r3, [r7, #76]	; 0x4c
 8004084:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8004086:	f5b3 7fa0 	cmp.w	r3, #320	; 0x140
 800408a:	f6ff ac4a 	blt.w	8003922 <nk_draw_fb+0x12>
	  }
}
 800408e:	bf00      	nop
 8004090:	bf00      	nop
 8004092:	3750      	adds	r7, #80	; 0x50
 8004094:	46bd      	mov	sp, r7
 8004096:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800409a:	bf00      	nop
 800409c:	0003ffff 	.word	0x0003ffff

080040a0 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 80040a0:	b580      	push	{r7, lr}
 80040a2:	b09a      	sub	sp, #104	; 0x68
 80040a4:	af02      	add	r7, sp, #8
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 80040a6:	f001 fdf0 	bl	8005c8a <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 80040aa:	f000 f947 	bl	800433c <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 80040ae:	f7fd fc0d 	bl	80018cc <MX_GPIO_Init>
  MX_DMA_Init();
 80040b2:	f7fd fae1 	bl	8001678 <MX_DMA_Init>
  MX_QUADSPI1_Init();
 80040b6:	f000 fb0f 	bl	80046d8 <MX_QUADSPI1_Init>
  MX_ADC1_Init();
 80040ba:	f7fc fe0d 	bl	8000cd8 <MX_ADC1_Init>
  MX_DAC2_Init();
 80040be:	f7fd f9d7 	bl	8001470 <MX_DAC2_Init>
  MX_OPAMP1_Init();
 80040c2:	f000 f989 	bl	80043d8 <MX_OPAMP1_Init>
  MX_DAC1_Init();
 80040c6:	f7fd f98f 	bl	80013e8 <MX_DAC1_Init>
  MX_ADC3_Init();
 80040ca:	f7fc febf 	bl	8000e4c <MX_ADC3_Init>
  MX_ADC4_Init();
 80040ce:	f7fc ff37 	bl	8000f40 <MX_ADC4_Init>
  MX_ADC5_Init();
 80040d2:	f7fc ff9d 	bl	8001010 <MX_ADC5_Init>
  MX_OPAMP3_Init();
 80040d6:	f000 f9ab 	bl	8004430 <MX_OPAMP3_Init>
  MX_OPAMP5_Init();
 80040da:	f000 f9d5 	bl	8004488 <MX_OPAMP5_Init>
  MX_OPAMP6_Init();
 80040de:	f000 f9ff 	bl	80044e0 <MX_OPAMP6_Init>
  MX_FMC_Init();
 80040e2:	f7fd fb23 	bl	800172c <MX_FMC_Init>
  MX_SPI3_Init();
 80040e6:	f001 fa41 	bl	800556c <MX_SPI3_Init>
  MX_TIM1_Init();
 80040ea:	f001 fc45 	bl	8005978 <MX_TIM1_Init>
  MX_TIM2_Init();
 80040ee:	f001 fc95 	bl	8005a1c <MX_TIM2_Init>
  MX_TIM3_Init();
 80040f2:	f001 fd07 	bl	8005b04 <MX_TIM3_Init>
  //float bx = -15800/989.0;
  //float ay = 250/1407.0;
  //float by = -1150/67.0;

  //solve([50=a*250+b,480-50=a*1760+b],[a,b])
  float ax = 38.0/151.0;
 80040f6:	4b81      	ldr	r3, [pc, #516]	; (80042fc <main+0x25c>)
 80040f8:	653b      	str	r3, [r7, #80]	; 0x50
  float bx = -1950.0/151.0;
 80040fa:	4b81      	ldr	r3, [pc, #516]	; (8004300 <main+0x260>)
 80040fc:	64fb      	str	r3, [r7, #76]	; 0x4c
  //solve([50=a*387+b,320-50=a*1627+b],[a,b])
  float ay = 11.0/62.0;
 80040fe:	4b81      	ldr	r3, [pc, #516]	; (8004304 <main+0x264>)
 8004100:	64bb      	str	r3, [r7, #72]	; 0x48
  float by = -1157.0/62.0;
 8004102:	4b81      	ldr	r3, [pc, #516]	; (8004308 <main+0x268>)
 8004104:	647b      	str	r3, [r7, #68]	; 0x44

  uint16_t x = 0, y = 0;
 8004106:	2300      	movs	r3, #0
 8004108:	86fb      	strh	r3, [r7, #54]	; 0x36
 800410a:	2300      	movs	r3, #0
 800410c:	86bb      	strh	r3, [r7, #52]	; 0x34
  uint16_t x_bck = 0, y_bck = 0;
 800410e:	2300      	movs	r3, #0
 8004110:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
 8004114:	2300      	movs	r3, #0
 8004116:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40



  tTsc2046 tsc;
  tsc2046_init( &tsc, &hspi3, GPIOA, GPIO_PIN_15, ax, bx, ay, by, 32 );
 800411a:	f107 0014 	add.w	r0, r7, #20
 800411e:	2320      	movs	r3, #32
 8004120:	9300      	str	r3, [sp, #0]
 8004122:	edd7 1a11 	vldr	s3, [r7, #68]	; 0x44
 8004126:	ed97 1a12 	vldr	s2, [r7, #72]	; 0x48
 800412a:	edd7 0a13 	vldr	s1, [r7, #76]	; 0x4c
 800412e:	ed97 0a14 	vldr	s0, [r7, #80]	; 0x50
 8004132:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8004136:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
 800413a:	4974      	ldr	r1, [pc, #464]	; (800430c <main+0x26c>)
 800413c:	f019 fb5a 	bl	801d7f4 <tsc2046_init>

  lcd_config();
 8004140:	f7fd fcc0 	bl	8001ac4 <lcd_config>

  lcd_rect( 50, 50, 2, 2, 0xFFFF );
 8004144:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8004148:	9300      	str	r3, [sp, #0]
 800414a:	2302      	movs	r3, #2
 800414c:	2202      	movs	r2, #2
 800414e:	2132      	movs	r1, #50	; 0x32
 8004150:	2032      	movs	r0, #50	; 0x32
 8004152:	f7fd fd6b 	bl	8001c2c <lcd_rect>
  lcd_rect( 480-50, 50, 2, 2, 0xFFFF );
 8004156:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800415a:	9300      	str	r3, [sp, #0]
 800415c:	2302      	movs	r3, #2
 800415e:	2202      	movs	r2, #2
 8004160:	2132      	movs	r1, #50	; 0x32
 8004162:	f44f 70d7 	mov.w	r0, #430	; 0x1ae
 8004166:	f7fd fd61 	bl	8001c2c <lcd_rect>
  lcd_rect( 50, 320-50, 2, 2, 0xFFFF );
 800416a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800416e:	9300      	str	r3, [sp, #0]
 8004170:	2302      	movs	r3, #2
 8004172:	2202      	movs	r2, #2
 8004174:	f44f 7187 	mov.w	r1, #270	; 0x10e
 8004178:	2032      	movs	r0, #50	; 0x32
 800417a:	f7fd fd57 	bl	8001c2c <lcd_rect>
  lcd_rect( 480-50, 320-50, 2, 2, 0xFFFF );
 800417e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8004182:	9300      	str	r3, [sp, #0]
 8004184:	2302      	movs	r3, #2
 8004186:	2202      	movs	r2, #2
 8004188:	f44f 7187 	mov.w	r1, #270	; 0x10e
 800418c:	f44f 70d7 	mov.w	r0, #430	; 0x1ae
 8004190:	f7fd fd4c 	bl	8001c2c <lcd_rect>

  while( 0 )
 8004194:	bf00      	nop
	  lcd_rect( x, y, 2, 2, 0xFFFF );
	  printf("%d, %d, %d\n", cnt++, x, y );
	  HAL_Delay( 1 );
  }

  int d = 0;
 8004196:	2300      	movs	r3, #0
 8004198:	63fb      	str	r3, [r7, #60]	; 0x3c
  d = lcd_set_pixel_bench( 100, 100, 0xFFFF );
 800419a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800419e:	2164      	movs	r1, #100	; 0x64
 80041a0:	2064      	movs	r0, #100	; 0x64
 80041a2:	f7fd fea3 	bl	8001eec <lcd_set_pixel_bench>
 80041a6:	63f8      	str	r0, [r7, #60]	; 0x3c
  d = d+1;
 80041a8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80041aa:	3301      	adds	r3, #1
 80041ac:	63fb      	str	r3, [r7, #60]	; 0x3c
  static struct nk_buffer pool;
  static struct nk_user_font font;
  static uint8_t buf_cmds[1024*8] = {0};
  static uint8_t buf_pool[1024*8] = {0};

  nk_buffer_init_fixed( &cmds, buf_cmds, 1024*8 );
 80041ae:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80041b2:	4957      	ldr	r1, [pc, #348]	; (8004310 <main+0x270>)
 80041b4:	4857      	ldr	r0, [pc, #348]	; (8004314 <main+0x274>)
 80041b6:	f009 fc09 	bl	800d9cc <nk_buffer_init_fixed>
  nk_buffer_init_fixed( &pool, buf_pool, 1024*8 );
 80041ba:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80041be:	4956      	ldr	r1, [pc, #344]	; (8004318 <main+0x278>)
 80041c0:	4856      	ldr	r0, [pc, #344]	; (800431c <main+0x27c>)
 80041c2:	f009 fc03 	bl	800d9cc <nk_buffer_init_fixed>

  font.height = fontUbuntuBookRNormal16.bbxh;
 80041c6:	4b56      	ldr	r3, [pc, #344]	; (8004320 <main+0x280>)
 80041c8:	f993 3009 	ldrsb.w	r3, [r3, #9]
 80041cc:	ee07 3a90 	vmov	s15, r3
 80041d0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80041d4:	4b53      	ldr	r3, [pc, #332]	; (8004324 <main+0x284>)
 80041d6:	edc3 7a01 	vstr	s15, [r3, #4]
  font.width = text_width_f;
 80041da:	4b52      	ldr	r3, [pc, #328]	; (8004324 <main+0x284>)
 80041dc:	4a52      	ldr	r2, [pc, #328]	; (8004328 <main+0x288>)
 80041de:	609a      	str	r2, [r3, #8]
  nk_init_custom( &ctx, &cmds, &pool, &font );
 80041e0:	4b50      	ldr	r3, [pc, #320]	; (8004324 <main+0x284>)
 80041e2:	4a4e      	ldr	r2, [pc, #312]	; (800431c <main+0x27c>)
 80041e4:	494b      	ldr	r1, [pc, #300]	; (8004314 <main+0x274>)
 80041e6:	4851      	ldr	r0, [pc, #324]	; (800432c <main+0x28c>)
 80041e8:	f00b fc38 	bl	800fa5c <nk_init_custom>

	static uint8_t fb_buf[480*40*2];
	tFramebuf fb;

	framebuf_init( &fb, 480, 40, fb_buf );
 80041ec:	f107 0008 	add.w	r0, r7, #8
 80041f0:	4b4f      	ldr	r3, [pc, #316]	; (8004330 <main+0x290>)
 80041f2:	2228      	movs	r2, #40	; 0x28
 80041f4:	f44f 71f0 	mov.w	r1, #480	; 0x1e0
 80041f8:	f009 f819 	bl	800d22e <framebuf_init>

	  int pressed = 1;
 80041fc:	2301      	movs	r3, #1
 80041fe:	65fb      	str	r3, [r7, #92]	; 0x5c
	  int pressed_bck = 0;
 8004200:	2300      	movs	r3, #0
 8004202:	65bb      	str	r3, [r7, #88]	; 0x58
	  int pressed_bck2 = 0;
 8004204:	2300      	movs	r3, #0
 8004206:	63bb      	str	r3, [r7, #56]	; 0x38
	int pressed_cnt = 0;
 8004208:	2300      	movs	r3, #0
 800420a:	657b      	str	r3, [r7, #84]	; 0x54
	static struct Oscilloscope osc = {0};

  while( 1 )
  {
	  x_bck = x;
 800420c:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 800420e:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
	  y_bck = y;
 8004212:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 8004214:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
	  tsc2046_read( &tsc, &x, &y );
 8004218:	f107 0234 	add.w	r2, r7, #52	; 0x34
 800421c:	f107 0136 	add.w	r1, r7, #54	; 0x36
 8004220:	f107 0314 	add.w	r3, r7, #20
 8004224:	4618      	mov	r0, r3
 8004226:	f019 fb7d 	bl	801d924 <tsc2046_read>

	  pressed_bck2 = pressed_bck;
 800422a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800422c:	63bb      	str	r3, [r7, #56]	; 0x38
	  pressed_bck = pressed;
 800422e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004230:	65bb      	str	r3, [r7, #88]	; 0x58
	  pressed = (x!=0);
 8004232:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8004234:	2b00      	cmp	r3, #0
 8004236:	bf14      	ite	ne
 8004238:	2301      	movne	r3, #1
 800423a:	2300      	moveq	r3, #0
 800423c:	b2db      	uxtb	r3, r3
 800423e:	65fb      	str	r3, [r7, #92]	; 0x5c

	  if( (pressed || pressed_bck) )// && (pressed != pressed_bck) )
 8004240:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004242:	2b00      	cmp	r3, #0
 8004244:	d102      	bne.n	800424c <main+0x1ac>
 8004246:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8004248:	2b00      	cmp	r3, #0
 800424a:	d04c      	beq.n	80042e6 <main+0x246>
	  {
		  //printf("%d, %d, %d, %d, %d, %d, %d,\n", pressed_cnt, pressed, pressed_bck, x, y, x_bck, y_bck );
		  pressed_cnt++;
 800424c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800424e:	3301      	adds	r3, #1
 8004250:	657b      	str	r3, [r7, #84]	; 0x54
		  nk_input_begin( &ctx );
 8004252:	4836      	ldr	r0, [pc, #216]	; (800432c <main+0x28c>)
 8004254:	f00d fef4 	bl	8012040 <nk_input_begin>
		  if( pressed )
 8004258:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800425a:	2b00      	cmp	r3, #0
 800425c:	d012      	beq.n	8004284 <main+0x1e4>
		  {
			  nk_input_motion( &ctx, x, y );
 800425e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8004260:	4619      	mov	r1, r3
 8004262:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 8004264:	461a      	mov	r2, r3
 8004266:	4831      	ldr	r0, [pc, #196]	; (800432c <main+0x28c>)
 8004268:	f00d ff8a 	bl	8012180 <nk_input_motion>
			  nk_input_button( &ctx, 0, x, y, 1 );
 800426c:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 800426e:	461a      	mov	r2, r3
 8004270:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 8004272:	4619      	mov	r1, r3
 8004274:	2301      	movs	r3, #1
 8004276:	9300      	str	r3, [sp, #0]
 8004278:	460b      	mov	r3, r1
 800427a:	2100      	movs	r1, #0
 800427c:	482b      	ldr	r0, [pc, #172]	; (800432c <main+0x28c>)
 800427e:	f00d ffc5 	bl	801220c <nk_input_button>
 8004282:	e014      	b.n	80042ae <main+0x20e>
		  }
		  else if( pressed_bck )
 8004284:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8004286:	2b00      	cmp	r3, #0
 8004288:	d011      	beq.n	80042ae <main+0x20e>
		  {
			  nk_input_motion( &ctx, x_bck, y_bck );
 800428a:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
 800428e:	f8b7 2040 	ldrh.w	r2, [r7, #64]	; 0x40
 8004292:	4619      	mov	r1, r3
 8004294:	4825      	ldr	r0, [pc, #148]	; (800432c <main+0x28c>)
 8004296:	f00d ff73 	bl	8012180 <nk_input_motion>
			  nk_input_button( &ctx, 0, x_bck, y_bck, 0 );
 800429a:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 800429e:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 80042a2:	2100      	movs	r1, #0
 80042a4:	9100      	str	r1, [sp, #0]
 80042a6:	2100      	movs	r1, #0
 80042a8:	4820      	ldr	r0, [pc, #128]	; (800432c <main+0x28c>)
 80042aa:	f00d ffaf 	bl	801220c <nk_input_button>
		  }
		  nk_input_end( &ctx );
 80042ae:	481f      	ldr	r0, [pc, #124]	; (800432c <main+0x28c>)
 80042b0:	f00d ff2e 	bl	8012110 <nk_input_end>

		  oscilloscope_process(&osc, &ctx);
 80042b4:	491d      	ldr	r1, [pc, #116]	; (800432c <main+0x28c>)
 80042b6:	481f      	ldr	r0, [pc, #124]	; (8004334 <main+0x294>)
 80042b8:	f7fe f958 	bl	800256c <oscilloscope_process>
		  nk_draw_fb( &ctx, &fb );
 80042bc:	f107 0308 	add.w	r3, r7, #8
 80042c0:	4619      	mov	r1, r3
 80042c2:	481a      	ldr	r0, [pc, #104]	; (800432c <main+0x28c>)
 80042c4:	f7ff fb24 	bl	8003910 <nk_draw_fb>
		  nk_clear(&ctx);
 80042c8:	4818      	ldr	r0, [pc, #96]	; (800432c <main+0x28c>)
 80042ca:	f00b fc2f 	bl	800fb2c <nk_clear>
		  //HAL_Delay(10);

		  lcd_rect( x, y, 2, 2, 0xFFFF );
 80042ce:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 80042d0:	b218      	sxth	r0, r3
 80042d2:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 80042d4:	b219      	sxth	r1, r3
 80042d6:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80042da:	9300      	str	r3, [sp, #0]
 80042dc:	2302      	movs	r3, #2
 80042de:	2202      	movs	r2, #2
 80042e0:	f7fd fca4 	bl	8001c2c <lcd_rect>
 80042e4:	e008      	b.n	80042f8 <main+0x258>
	  }
	  else if( nk_window_is_collapsed( &ctx, "STM32G4 Scope" ) )
 80042e6:	4914      	ldr	r1, [pc, #80]	; (8004338 <main+0x298>)
 80042e8:	4810      	ldr	r0, [pc, #64]	; (800432c <main+0x28c>)
 80042ea:	f019 fa4b 	bl	801d784 <nk_window_is_collapsed>
 80042ee:	4603      	mov	r3, r0
 80042f0:	2b00      	cmp	r3, #0
 80042f2:	d08b      	beq.n	800420c <main+0x16c>
	  {
		  test_scope();
 80042f4:	f000 fde4 	bl	8004ec0 <test_scope>
	  x_bck = x;
 80042f8:	e788      	b.n	800420c <main+0x16c>
 80042fa:	bf00      	nop
 80042fc:	3e80d902 	.word	0x3e80d902
 8004300:	c14e9f5d 	.word	0xc14e9f5d
 8004304:	3e35ad6b 	.word	0x3e35ad6b
 8004308:	c1954a53 	.word	0xc1954a53
 800430c:	200167dc 	.word	0x200167dc
 8004310:	2000082c 	.word	0x2000082c
 8004314:	200007f0 	.word	0x200007f0
 8004318:	20002868 	.word	0x20002868
 800431c:	2000282c 	.word	0x2000282c
 8004320:	08023160 	.word	0x08023160
 8004324:	20004868 	.word	0x20004868
 8004328:	08001a8d 	.word	0x08001a8d
 800432c:	20004874 	.word	0x20004874
 8004330:	20007edc 	.word	0x20007edc
 8004334:	200114dc 	.word	0x200114dc
 8004338:	08021190 	.word	0x08021190

0800433c <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 800433c:	b580      	push	{r7, lr}
 800433e:	b094      	sub	sp, #80	; 0x50
 8004340:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8004342:	f107 0318 	add.w	r3, r7, #24
 8004346:	2238      	movs	r2, #56	; 0x38
 8004348:	2100      	movs	r1, #0
 800434a:	4618      	mov	r0, r3
 800434c:	f01a f90d 	bl	801e56a <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8004350:	1d3b      	adds	r3, r7, #4
 8004352:	2200      	movs	r2, #0
 8004354:	601a      	str	r2, [r3, #0]
 8004356:	605a      	str	r2, [r3, #4]
 8004358:	609a      	str	r2, [r3, #8]
 800435a:	60da      	str	r2, [r3, #12]
 800435c:	611a      	str	r2, [r3, #16]

  /** Configure the main internal regulator output voltage
  */
  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);
 800435e:	2000      	movs	r0, #0
 8004360:	f005 faf0 	bl	8009944 <HAL_PWREx_ControlVoltageScaling>

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8004364:	2301      	movs	r3, #1
 8004366:	61bb      	str	r3, [r7, #24]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8004368:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800436c:	61fb      	str	r3, [r7, #28]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800436e:	2302      	movs	r3, #2
 8004370:	637b      	str	r3, [r7, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8004372:	2303      	movs	r3, #3
 8004374:	63bb      	str	r3, [r7, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV6;
 8004376:	2306      	movs	r3, #6
 8004378:	63fb      	str	r3, [r7, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLN = 85;
 800437a:	2355      	movs	r3, #85	; 0x55
 800437c:	643b      	str	r3, [r7, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 800437e:	2302      	movs	r3, #2
 8004380:	647b      	str	r3, [r7, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV8;
 8004382:	2308      	movs	r3, #8
 8004384:	64bb      	str	r3, [r7, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 8004386:	2302      	movs	r3, #2
 8004388:	64fb      	str	r3, [r7, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800438a:	f107 0318 	add.w	r3, r7, #24
 800438e:	4618      	mov	r0, r3
 8004390:	f005 fe66 	bl	800a060 <HAL_RCC_OscConfig>
 8004394:	4603      	mov	r3, r0
 8004396:	2b00      	cmp	r3, #0
 8004398:	d001      	beq.n	800439e <SystemClock_Config+0x62>
  {
    Error_Handler();
 800439a:	f000 f818 	bl	80043ce <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800439e:	230f      	movs	r3, #15
 80043a0:	607b      	str	r3, [r7, #4]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80043a2:	2303      	movs	r3, #3
 80043a4:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80043a6:	2300      	movs	r3, #0
 80043a8:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 80043aa:	2300      	movs	r3, #0
 80043ac:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80043ae:	2300      	movs	r3, #0
 80043b0:	617b      	str	r3, [r7, #20]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 80043b2:	1d3b      	adds	r3, r7, #4
 80043b4:	2104      	movs	r1, #4
 80043b6:	4618      	mov	r0, r3
 80043b8:	f006 f96a 	bl	800a690 <HAL_RCC_ClockConfig>
 80043bc:	4603      	mov	r3, r0
 80043be:	2b00      	cmp	r3, #0
 80043c0:	d001      	beq.n	80043c6 <SystemClock_Config+0x8a>
  {
    Error_Handler();
 80043c2:	f000 f804 	bl	80043ce <Error_Handler>
  }
}
 80043c6:	bf00      	nop
 80043c8:	3750      	adds	r7, #80	; 0x50
 80043ca:	46bd      	mov	sp, r7
 80043cc:	bd80      	pop	{r7, pc}

080043ce <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 80043ce:	b480      	push	{r7}
 80043d0:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80043d2:	b672      	cpsid	i
}
 80043d4:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 80043d6:	e7fe      	b.n	80043d6 <Error_Handler+0x8>

080043d8 <MX_OPAMP1_Init>:
OPAMP_HandleTypeDef hopamp5;
OPAMP_HandleTypeDef hopamp6;

/* OPAMP1 init function */
void MX_OPAMP1_Init(void)
{
 80043d8:	b580      	push	{r7, lr}
 80043da:	af00      	add	r7, sp, #0
  /* USER CODE END OPAMP1_Init 0 */

  /* USER CODE BEGIN OPAMP1_Init 1 */

  /* USER CODE END OPAMP1_Init 1 */
  hopamp1.Instance = OPAMP1;
 80043dc:	4b12      	ldr	r3, [pc, #72]	; (8004428 <MX_OPAMP1_Init+0x50>)
 80043de:	4a13      	ldr	r2, [pc, #76]	; (800442c <MX_OPAMP1_Init+0x54>)
 80043e0:	601a      	str	r2, [r3, #0]
  hopamp1.Init.PowerMode = OPAMP_POWERMODE_NORMALSPEED;
 80043e2:	4b11      	ldr	r3, [pc, #68]	; (8004428 <MX_OPAMP1_Init+0x50>)
 80043e4:	2200      	movs	r2, #0
 80043e6:	605a      	str	r2, [r3, #4]
  hopamp1.Init.Mode = OPAMP_PGA_MODE;
 80043e8:	4b0f      	ldr	r3, [pc, #60]	; (8004428 <MX_OPAMP1_Init+0x50>)
 80043ea:	2240      	movs	r2, #64	; 0x40
 80043ec:	609a      	str	r2, [r3, #8]
  hopamp1.Init.NonInvertingInput = OPAMP_NONINVERTINGINPUT_IO2;
 80043ee:	4b0e      	ldr	r3, [pc, #56]	; (8004428 <MX_OPAMP1_Init+0x50>)
 80043f0:	2208      	movs	r2, #8
 80043f2:	611a      	str	r2, [r3, #16]
  hopamp1.Init.InternalOutput = ENABLE;
 80043f4:	4b0c      	ldr	r3, [pc, #48]	; (8004428 <MX_OPAMP1_Init+0x50>)
 80043f6:	2201      	movs	r2, #1
 80043f8:	751a      	strb	r2, [r3, #20]
  hopamp1.Init.TimerControlledMuxmode = OPAMP_TIMERCONTROLLEDMUXMODE_DISABLE;
 80043fa:	4b0b      	ldr	r3, [pc, #44]	; (8004428 <MX_OPAMP1_Init+0x50>)
 80043fc:	2200      	movs	r2, #0
 80043fe:	619a      	str	r2, [r3, #24]
  hopamp1.Init.PgaConnect = OPAMP_PGA_CONNECT_INVERTINGINPUT_IO0_BIAS;
 8004400:	4b09      	ldr	r3, [pc, #36]	; (8004428 <MX_OPAMP1_Init+0x50>)
 8004402:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8004406:	625a      	str	r2, [r3, #36]	; 0x24
  hopamp1.Init.PgaGain = OPAMP_PGA_GAIN_2_OR_MINUS_1;
 8004408:	4b07      	ldr	r3, [pc, #28]	; (8004428 <MX_OPAMP1_Init+0x50>)
 800440a:	2200      	movs	r2, #0
 800440c:	629a      	str	r2, [r3, #40]	; 0x28
  hopamp1.Init.UserTrimming = OPAMP_TRIMMING_FACTORY;
 800440e:	4b06      	ldr	r3, [pc, #24]	; (8004428 <MX_OPAMP1_Init+0x50>)
 8004410:	2200      	movs	r2, #0
 8004412:	62da      	str	r2, [r3, #44]	; 0x2c
  if (HAL_OPAMP_Init(&hopamp1) != HAL_OK)
 8004414:	4804      	ldr	r0, [pc, #16]	; (8004428 <MX_OPAMP1_Init+0x50>)
 8004416:	f005 f993 	bl	8009740 <HAL_OPAMP_Init>
 800441a:	4603      	mov	r3, r0
 800441c:	2b00      	cmp	r3, #0
 800441e:	d001      	beq.n	8004424 <MX_OPAMP1_Init+0x4c>
  {
    Error_Handler();
 8004420:	f7ff ffd5 	bl	80043ce <Error_Handler>
  }
  /* USER CODE BEGIN OPAMP1_Init 2 */

  /* USER CODE END OPAMP1_Init 2 */

}
 8004424:	bf00      	nop
 8004426:	bd80      	pop	{r7, pc}
 8004428:	200115bc 	.word	0x200115bc
 800442c:	40010300 	.word	0x40010300

08004430 <MX_OPAMP3_Init>:
/* OPAMP3 init function */
void MX_OPAMP3_Init(void)
{
 8004430:	b580      	push	{r7, lr}
 8004432:	af00      	add	r7, sp, #0
  /* USER CODE END OPAMP3_Init 0 */

  /* USER CODE BEGIN OPAMP3_Init 1 */

  /* USER CODE END OPAMP3_Init 1 */
  hopamp3.Instance = OPAMP3;
 8004434:	4b12      	ldr	r3, [pc, #72]	; (8004480 <MX_OPAMP3_Init+0x50>)
 8004436:	4a13      	ldr	r2, [pc, #76]	; (8004484 <MX_OPAMP3_Init+0x54>)
 8004438:	601a      	str	r2, [r3, #0]
  hopamp3.Init.PowerMode = OPAMP_POWERMODE_NORMALSPEED;
 800443a:	4b11      	ldr	r3, [pc, #68]	; (8004480 <MX_OPAMP3_Init+0x50>)
 800443c:	2200      	movs	r2, #0
 800443e:	605a      	str	r2, [r3, #4]
  hopamp3.Init.Mode = OPAMP_PGA_MODE;
 8004440:	4b0f      	ldr	r3, [pc, #60]	; (8004480 <MX_OPAMP3_Init+0x50>)
 8004442:	2240      	movs	r2, #64	; 0x40
 8004444:	609a      	str	r2, [r3, #8]
  hopamp3.Init.NonInvertingInput = OPAMP_NONINVERTINGINPUT_IO0;
 8004446:	4b0e      	ldr	r3, [pc, #56]	; (8004480 <MX_OPAMP3_Init+0x50>)
 8004448:	2200      	movs	r2, #0
 800444a:	611a      	str	r2, [r3, #16]
  hopamp3.Init.InternalOutput = ENABLE;
 800444c:	4b0c      	ldr	r3, [pc, #48]	; (8004480 <MX_OPAMP3_Init+0x50>)
 800444e:	2201      	movs	r2, #1
 8004450:	751a      	strb	r2, [r3, #20]
  hopamp3.Init.TimerControlledMuxmode = OPAMP_TIMERCONTROLLEDMUXMODE_DISABLE;
 8004452:	4b0b      	ldr	r3, [pc, #44]	; (8004480 <MX_OPAMP3_Init+0x50>)
 8004454:	2200      	movs	r2, #0
 8004456:	619a      	str	r2, [r3, #24]
  hopamp3.Init.PgaConnect = OPAMP_PGA_CONNECT_INVERTINGINPUT_IO0_BIAS;
 8004458:	4b09      	ldr	r3, [pc, #36]	; (8004480 <MX_OPAMP3_Init+0x50>)
 800445a:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 800445e:	625a      	str	r2, [r3, #36]	; 0x24
  hopamp3.Init.PgaGain = OPAMP_PGA_GAIN_2_OR_MINUS_1;
 8004460:	4b07      	ldr	r3, [pc, #28]	; (8004480 <MX_OPAMP3_Init+0x50>)
 8004462:	2200      	movs	r2, #0
 8004464:	629a      	str	r2, [r3, #40]	; 0x28
  hopamp3.Init.UserTrimming = OPAMP_TRIMMING_FACTORY;
 8004466:	4b06      	ldr	r3, [pc, #24]	; (8004480 <MX_OPAMP3_Init+0x50>)
 8004468:	2200      	movs	r2, #0
 800446a:	62da      	str	r2, [r3, #44]	; 0x2c
  if (HAL_OPAMP_Init(&hopamp3) != HAL_OK)
 800446c:	4804      	ldr	r0, [pc, #16]	; (8004480 <MX_OPAMP3_Init+0x50>)
 800446e:	f005 f967 	bl	8009740 <HAL_OPAMP_Init>
 8004472:	4603      	mov	r3, r0
 8004474:	2b00      	cmp	r3, #0
 8004476:	d001      	beq.n	800447c <MX_OPAMP3_Init+0x4c>
  {
    Error_Handler();
 8004478:	f7ff ffa9 	bl	80043ce <Error_Handler>
  }
  /* USER CODE BEGIN OPAMP3_Init 2 */

  /* USER CODE END OPAMP3_Init 2 */

}
 800447c:	bf00      	nop
 800447e:	bd80      	pop	{r7, pc}
 8004480:	200115f8 	.word	0x200115f8
 8004484:	40010308 	.word	0x40010308

08004488 <MX_OPAMP5_Init>:
/* OPAMP5 init function */
void MX_OPAMP5_Init(void)
{
 8004488:	b580      	push	{r7, lr}
 800448a:	af00      	add	r7, sp, #0
  /* USER CODE END OPAMP5_Init 0 */

  /* USER CODE BEGIN OPAMP5_Init 1 */

  /* USER CODE END OPAMP5_Init 1 */
  hopamp5.Instance = OPAMP5;
 800448c:	4b12      	ldr	r3, [pc, #72]	; (80044d8 <MX_OPAMP5_Init+0x50>)
 800448e:	4a13      	ldr	r2, [pc, #76]	; (80044dc <MX_OPAMP5_Init+0x54>)
 8004490:	601a      	str	r2, [r3, #0]
  hopamp5.Init.PowerMode = OPAMP_POWERMODE_NORMALSPEED;
 8004492:	4b11      	ldr	r3, [pc, #68]	; (80044d8 <MX_OPAMP5_Init+0x50>)
 8004494:	2200      	movs	r2, #0
 8004496:	605a      	str	r2, [r3, #4]
  hopamp5.Init.Mode = OPAMP_PGA_MODE;
 8004498:	4b0f      	ldr	r3, [pc, #60]	; (80044d8 <MX_OPAMP5_Init+0x50>)
 800449a:	2240      	movs	r2, #64	; 0x40
 800449c:	609a      	str	r2, [r3, #8]
  hopamp5.Init.NonInvertingInput = OPAMP_NONINVERTINGINPUT_IO0;
 800449e:	4b0e      	ldr	r3, [pc, #56]	; (80044d8 <MX_OPAMP5_Init+0x50>)
 80044a0:	2200      	movs	r2, #0
 80044a2:	611a      	str	r2, [r3, #16]
  hopamp5.Init.InternalOutput = ENABLE;
 80044a4:	4b0c      	ldr	r3, [pc, #48]	; (80044d8 <MX_OPAMP5_Init+0x50>)
 80044a6:	2201      	movs	r2, #1
 80044a8:	751a      	strb	r2, [r3, #20]
  hopamp5.Init.TimerControlledMuxmode = OPAMP_TIMERCONTROLLEDMUXMODE_DISABLE;
 80044aa:	4b0b      	ldr	r3, [pc, #44]	; (80044d8 <MX_OPAMP5_Init+0x50>)
 80044ac:	2200      	movs	r2, #0
 80044ae:	619a      	str	r2, [r3, #24]
  hopamp5.Init.PgaConnect = OPAMP_PGA_CONNECT_INVERTINGINPUT_IO0_BIAS;
 80044b0:	4b09      	ldr	r3, [pc, #36]	; (80044d8 <MX_OPAMP5_Init+0x50>)
 80044b2:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 80044b6:	625a      	str	r2, [r3, #36]	; 0x24
  hopamp5.Init.PgaGain = OPAMP_PGA_GAIN_2_OR_MINUS_1;
 80044b8:	4b07      	ldr	r3, [pc, #28]	; (80044d8 <MX_OPAMP5_Init+0x50>)
 80044ba:	2200      	movs	r2, #0
 80044bc:	629a      	str	r2, [r3, #40]	; 0x28
  hopamp5.Init.UserTrimming = OPAMP_TRIMMING_FACTORY;
 80044be:	4b06      	ldr	r3, [pc, #24]	; (80044d8 <MX_OPAMP5_Init+0x50>)
 80044c0:	2200      	movs	r2, #0
 80044c2:	62da      	str	r2, [r3, #44]	; 0x2c
  if (HAL_OPAMP_Init(&hopamp5) != HAL_OK)
 80044c4:	4804      	ldr	r0, [pc, #16]	; (80044d8 <MX_OPAMP5_Init+0x50>)
 80044c6:	f005 f93b 	bl	8009740 <HAL_OPAMP_Init>
 80044ca:	4603      	mov	r3, r0
 80044cc:	2b00      	cmp	r3, #0
 80044ce:	d001      	beq.n	80044d4 <MX_OPAMP5_Init+0x4c>
  {
    Error_Handler();
 80044d0:	f7ff ff7d 	bl	80043ce <Error_Handler>
  }
  /* USER CODE BEGIN OPAMP5_Init 2 */

  /* USER CODE END OPAMP5_Init 2 */

}
 80044d4:	bf00      	nop
 80044d6:	bd80      	pop	{r7, pc}
 80044d8:	20011634 	.word	0x20011634
 80044dc:	40010310 	.word	0x40010310

080044e0 <MX_OPAMP6_Init>:
/* OPAMP6 init function */
void MX_OPAMP6_Init(void)
{
 80044e0:	b580      	push	{r7, lr}
 80044e2:	af00      	add	r7, sp, #0
  /* USER CODE END OPAMP6_Init 0 */

  /* USER CODE BEGIN OPAMP6_Init 1 */

  /* USER CODE END OPAMP6_Init 1 */
  hopamp6.Instance = OPAMP6;
 80044e4:	4b12      	ldr	r3, [pc, #72]	; (8004530 <MX_OPAMP6_Init+0x50>)
 80044e6:	4a13      	ldr	r2, [pc, #76]	; (8004534 <MX_OPAMP6_Init+0x54>)
 80044e8:	601a      	str	r2, [r3, #0]
  hopamp6.Init.PowerMode = OPAMP_POWERMODE_NORMALSPEED;
 80044ea:	4b11      	ldr	r3, [pc, #68]	; (8004530 <MX_OPAMP6_Init+0x50>)
 80044ec:	2200      	movs	r2, #0
 80044ee:	605a      	str	r2, [r3, #4]
  hopamp6.Init.Mode = OPAMP_PGA_MODE;
 80044f0:	4b0f      	ldr	r3, [pc, #60]	; (8004530 <MX_OPAMP6_Init+0x50>)
 80044f2:	2240      	movs	r2, #64	; 0x40
 80044f4:	609a      	str	r2, [r3, #8]
  hopamp6.Init.NonInvertingInput = OPAMP_NONINVERTINGINPUT_IO2;
 80044f6:	4b0e      	ldr	r3, [pc, #56]	; (8004530 <MX_OPAMP6_Init+0x50>)
 80044f8:	2208      	movs	r2, #8
 80044fa:	611a      	str	r2, [r3, #16]
  hopamp6.Init.InternalOutput = ENABLE;
 80044fc:	4b0c      	ldr	r3, [pc, #48]	; (8004530 <MX_OPAMP6_Init+0x50>)
 80044fe:	2201      	movs	r2, #1
 8004500:	751a      	strb	r2, [r3, #20]
  hopamp6.Init.TimerControlledMuxmode = OPAMP_TIMERCONTROLLEDMUXMODE_DISABLE;
 8004502:	4b0b      	ldr	r3, [pc, #44]	; (8004530 <MX_OPAMP6_Init+0x50>)
 8004504:	2200      	movs	r2, #0
 8004506:	619a      	str	r2, [r3, #24]
  hopamp6.Init.PgaConnect = OPAMP_PGA_CONNECT_INVERTINGINPUT_IO0_BIAS;
 8004508:	4b09      	ldr	r3, [pc, #36]	; (8004530 <MX_OPAMP6_Init+0x50>)
 800450a:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 800450e:	625a      	str	r2, [r3, #36]	; 0x24
  hopamp6.Init.PgaGain = OPAMP_PGA_GAIN_2_OR_MINUS_1;
 8004510:	4b07      	ldr	r3, [pc, #28]	; (8004530 <MX_OPAMP6_Init+0x50>)
 8004512:	2200      	movs	r2, #0
 8004514:	629a      	str	r2, [r3, #40]	; 0x28
  hopamp6.Init.UserTrimming = OPAMP_TRIMMING_FACTORY;
 8004516:	4b06      	ldr	r3, [pc, #24]	; (8004530 <MX_OPAMP6_Init+0x50>)
 8004518:	2200      	movs	r2, #0
 800451a:	62da      	str	r2, [r3, #44]	; 0x2c
  if (HAL_OPAMP_Init(&hopamp6) != HAL_OK)
 800451c:	4804      	ldr	r0, [pc, #16]	; (8004530 <MX_OPAMP6_Init+0x50>)
 800451e:	f005 f90f 	bl	8009740 <HAL_OPAMP_Init>
 8004522:	4603      	mov	r3, r0
 8004524:	2b00      	cmp	r3, #0
 8004526:	d001      	beq.n	800452c <MX_OPAMP6_Init+0x4c>
  {
    Error_Handler();
 8004528:	f7ff ff51 	bl	80043ce <Error_Handler>
  }
  /* USER CODE BEGIN OPAMP6_Init 2 */

  /* USER CODE END OPAMP6_Init 2 */

}
 800452c:	bf00      	nop
 800452e:	bd80      	pop	{r7, pc}
 8004530:	20011670 	.word	0x20011670
 8004534:	40010314 	.word	0x40010314

08004538 <HAL_OPAMP_MspInit>:

void HAL_OPAMP_MspInit(OPAMP_HandleTypeDef* opampHandle)
{
 8004538:	b580      	push	{r7, lr}
 800453a:	b08c      	sub	sp, #48	; 0x30
 800453c:	af00      	add	r7, sp, #0
 800453e:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004540:	f107 031c 	add.w	r3, r7, #28
 8004544:	2200      	movs	r2, #0
 8004546:	601a      	str	r2, [r3, #0]
 8004548:	605a      	str	r2, [r3, #4]
 800454a:	609a      	str	r2, [r3, #8]
 800454c:	60da      	str	r2, [r3, #12]
 800454e:	611a      	str	r2, [r3, #16]
  if(opampHandle->Instance==OPAMP1)
 8004550:	687b      	ldr	r3, [r7, #4]
 8004552:	681b      	ldr	r3, [r3, #0]
 8004554:	4a4a      	ldr	r2, [pc, #296]	; (8004680 <HAL_OPAMP_MspInit+0x148>)
 8004556:	4293      	cmp	r3, r2
 8004558:	d119      	bne.n	800458e <HAL_OPAMP_MspInit+0x56>
  {
  /* USER CODE BEGIN OPAMP1_MspInit 0 */

  /* USER CODE END OPAMP1_MspInit 0 */

    __HAL_RCC_GPIOA_CLK_ENABLE();
 800455a:	4b4a      	ldr	r3, [pc, #296]	; (8004684 <HAL_OPAMP_MspInit+0x14c>)
 800455c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800455e:	4a49      	ldr	r2, [pc, #292]	; (8004684 <HAL_OPAMP_MspInit+0x14c>)
 8004560:	f043 0301 	orr.w	r3, r3, #1
 8004564:	64d3      	str	r3, [r2, #76]	; 0x4c
 8004566:	4b47      	ldr	r3, [pc, #284]	; (8004684 <HAL_OPAMP_MspInit+0x14c>)
 8004568:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800456a:	f003 0301 	and.w	r3, r3, #1
 800456e:	61bb      	str	r3, [r7, #24]
 8004570:	69bb      	ldr	r3, [r7, #24]
    /**OPAMP1 GPIO Configuration
    PA3     ------> OPAMP1_VINM0
    PA7     ------> OPAMP1_VINP
    */
    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_7;
 8004572:	2388      	movs	r3, #136	; 0x88
 8004574:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8004576:	2303      	movs	r3, #3
 8004578:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800457a:	2300      	movs	r3, #0
 800457c:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800457e:	f107 031c 	add.w	r3, r7, #28
 8004582:	4619      	mov	r1, r3
 8004584:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8004588:	f004 ff40 	bl	800940c <HAL_GPIO_Init>

  /* USER CODE BEGIN OPAMP6_MspInit 1 */

  /* USER CODE END OPAMP6_MspInit 1 */
  }
}
 800458c:	e073      	b.n	8004676 <HAL_OPAMP_MspInit+0x13e>
  else if(opampHandle->Instance==OPAMP3)
 800458e:	687b      	ldr	r3, [r7, #4]
 8004590:	681b      	ldr	r3, [r3, #0]
 8004592:	4a3d      	ldr	r2, [pc, #244]	; (8004688 <HAL_OPAMP_MspInit+0x150>)
 8004594:	4293      	cmp	r3, r2
 8004596:	d118      	bne.n	80045ca <HAL_OPAMP_MspInit+0x92>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8004598:	4b3a      	ldr	r3, [pc, #232]	; (8004684 <HAL_OPAMP_MspInit+0x14c>)
 800459a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800459c:	4a39      	ldr	r2, [pc, #228]	; (8004684 <HAL_OPAMP_MspInit+0x14c>)
 800459e:	f043 0302 	orr.w	r3, r3, #2
 80045a2:	64d3      	str	r3, [r2, #76]	; 0x4c
 80045a4:	4b37      	ldr	r3, [pc, #220]	; (8004684 <HAL_OPAMP_MspInit+0x14c>)
 80045a6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80045a8:	f003 0302 	and.w	r3, r3, #2
 80045ac:	617b      	str	r3, [r7, #20]
 80045ae:	697b      	ldr	r3, [r7, #20]
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2;
 80045b0:	2305      	movs	r3, #5
 80045b2:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80045b4:	2303      	movs	r3, #3
 80045b6:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80045b8:	2300      	movs	r3, #0
 80045ba:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80045bc:	f107 031c 	add.w	r3, r7, #28
 80045c0:	4619      	mov	r1, r3
 80045c2:	4832      	ldr	r0, [pc, #200]	; (800468c <HAL_OPAMP_MspInit+0x154>)
 80045c4:	f004 ff22 	bl	800940c <HAL_GPIO_Init>
}
 80045c8:	e055      	b.n	8004676 <HAL_OPAMP_MspInit+0x13e>
  else if(opampHandle->Instance==OPAMP5)
 80045ca:	687b      	ldr	r3, [r7, #4]
 80045cc:	681b      	ldr	r3, [r3, #0]
 80045ce:	4a30      	ldr	r2, [pc, #192]	; (8004690 <HAL_OPAMP_MspInit+0x158>)
 80045d0:	4293      	cmp	r3, r2
 80045d2:	d119      	bne.n	8004608 <HAL_OPAMP_MspInit+0xd0>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80045d4:	4b2b      	ldr	r3, [pc, #172]	; (8004684 <HAL_OPAMP_MspInit+0x14c>)
 80045d6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80045d8:	4a2a      	ldr	r2, [pc, #168]	; (8004684 <HAL_OPAMP_MspInit+0x14c>)
 80045da:	f043 0302 	orr.w	r3, r3, #2
 80045de:	64d3      	str	r3, [r2, #76]	; 0x4c
 80045e0:	4b28      	ldr	r3, [pc, #160]	; (8004684 <HAL_OPAMP_MspInit+0x14c>)
 80045e2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80045e4:	f003 0302 	and.w	r3, r3, #2
 80045e8:	613b      	str	r3, [r7, #16]
 80045ea:	693b      	ldr	r3, [r7, #16]
    GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15;
 80045ec:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 80045f0:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80045f2:	2303      	movs	r3, #3
 80045f4:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80045f6:	2300      	movs	r3, #0
 80045f8:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80045fa:	f107 031c 	add.w	r3, r7, #28
 80045fe:	4619      	mov	r1, r3
 8004600:	4822      	ldr	r0, [pc, #136]	; (800468c <HAL_OPAMP_MspInit+0x154>)
 8004602:	f004 ff03 	bl	800940c <HAL_GPIO_Init>
}
 8004606:	e036      	b.n	8004676 <HAL_OPAMP_MspInit+0x13e>
  else if(opampHandle->Instance==OPAMP6)
 8004608:	687b      	ldr	r3, [r7, #4]
 800460a:	681b      	ldr	r3, [r3, #0]
 800460c:	4a21      	ldr	r2, [pc, #132]	; (8004694 <HAL_OPAMP_MspInit+0x15c>)
 800460e:	4293      	cmp	r3, r2
 8004610:	d131      	bne.n	8004676 <HAL_OPAMP_MspInit+0x13e>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8004612:	4b1c      	ldr	r3, [pc, #112]	; (8004684 <HAL_OPAMP_MspInit+0x14c>)
 8004614:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004616:	4a1b      	ldr	r2, [pc, #108]	; (8004684 <HAL_OPAMP_MspInit+0x14c>)
 8004618:	f043 0301 	orr.w	r3, r3, #1
 800461c:	64d3      	str	r3, [r2, #76]	; 0x4c
 800461e:	4b19      	ldr	r3, [pc, #100]	; (8004684 <HAL_OPAMP_MspInit+0x14c>)
 8004620:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004622:	f003 0301 	and.w	r3, r3, #1
 8004626:	60fb      	str	r3, [r7, #12]
 8004628:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800462a:	4b16      	ldr	r3, [pc, #88]	; (8004684 <HAL_OPAMP_MspInit+0x14c>)
 800462c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800462e:	4a15      	ldr	r2, [pc, #84]	; (8004684 <HAL_OPAMP_MspInit+0x14c>)
 8004630:	f043 0302 	orr.w	r3, r3, #2
 8004634:	64d3      	str	r3, [r2, #76]	; 0x4c
 8004636:	4b13      	ldr	r3, [pc, #76]	; (8004684 <HAL_OPAMP_MspInit+0x14c>)
 8004638:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800463a:	f003 0302 	and.w	r3, r3, #2
 800463e:	60bb      	str	r3, [r7, #8]
 8004640:	68bb      	ldr	r3, [r7, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_1;
 8004642:	2302      	movs	r3, #2
 8004644:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8004646:	2303      	movs	r3, #3
 8004648:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800464a:	2300      	movs	r3, #0
 800464c:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800464e:	f107 031c 	add.w	r3, r7, #28
 8004652:	4619      	mov	r1, r3
 8004654:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8004658:	f004 fed8 	bl	800940c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_13;
 800465c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8004660:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8004662:	2303      	movs	r3, #3
 8004664:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8004666:	2300      	movs	r3, #0
 8004668:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800466a:	f107 031c 	add.w	r3, r7, #28
 800466e:	4619      	mov	r1, r3
 8004670:	4806      	ldr	r0, [pc, #24]	; (800468c <HAL_OPAMP_MspInit+0x154>)
 8004672:	f004 fecb 	bl	800940c <HAL_GPIO_Init>
}
 8004676:	bf00      	nop
 8004678:	3730      	adds	r7, #48	; 0x30
 800467a:	46bd      	mov	sp, r7
 800467c:	bd80      	pop	{r7, pc}
 800467e:	bf00      	nop
 8004680:	40010300 	.word	0x40010300
 8004684:	40021000 	.word	0x40021000
 8004688:	40010308 	.word	0x40010308
 800468c:	48000400 	.word	0x48000400
 8004690:	40010310 	.word	0x40010310
 8004694:	40010314 	.word	0x40010314

08004698 <HAL_QSPI_TxCpltCallback>:
    uint32_t SIOOMode,
	enum ePsram_Direction direction
);

void HAL_QSPI_TxCpltCallback(QSPI_HandleTypeDef *hqspi)
{
 8004698:	b480      	push	{r7}
 800469a:	b083      	sub	sp, #12
 800469c:	af00      	add	r7, sp, #0
 800469e:	6078      	str	r0, [r7, #4]
    TxCpltCallback = 1;
 80046a0:	4b04      	ldr	r3, [pc, #16]	; (80046b4 <HAL_QSPI_TxCpltCallback+0x1c>)
 80046a2:	2201      	movs	r2, #1
 80046a4:	701a      	strb	r2, [r3, #0]
}
 80046a6:	bf00      	nop
 80046a8:	370c      	adds	r7, #12
 80046aa:	46bd      	mov	sp, r7
 80046ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80046b0:	4770      	bx	lr
 80046b2:	bf00      	nop
 80046b4:	200116ac 	.word	0x200116ac

080046b8 <HAL_QSPI_RxCpltCallback>:
void HAL_QSPI_RxCpltCallback(QSPI_HandleTypeDef *hqspi)
{
 80046b8:	b480      	push	{r7}
 80046ba:	b083      	sub	sp, #12
 80046bc:	af00      	add	r7, sp, #0
 80046be:	6078      	str	r0, [r7, #4]
    RxCpltCallback = 1;
 80046c0:	4b04      	ldr	r3, [pc, #16]	; (80046d4 <HAL_QSPI_RxCpltCallback+0x1c>)
 80046c2:	2201      	movs	r2, #1
 80046c4:	701a      	strb	r2, [r3, #0]
}
 80046c6:	bf00      	nop
 80046c8:	370c      	adds	r7, #12
 80046ca:	46bd      	mov	sp, r7
 80046cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80046d0:	4770      	bx	lr
 80046d2:	bf00      	nop
 80046d4:	200116ad 	.word	0x200116ad

080046d8 <MX_QUADSPI1_Init>:
QSPI_HandleTypeDef hqspi1;
DMA_HandleTypeDef hdma_quadspi;

/* QUADSPI1 init function */
void MX_QUADSPI1_Init(void)
{
 80046d8:	b580      	push	{r7, lr}
 80046da:	af00      	add	r7, sp, #0
  /* USER CODE END QUADSPI1_Init 0 */

  /* USER CODE BEGIN QUADSPI1_Init 1 */

  /* USER CODE END QUADSPI1_Init 1 */
  hqspi1.Instance = QUADSPI;
 80046dc:	4b12      	ldr	r3, [pc, #72]	; (8004728 <MX_QUADSPI1_Init+0x50>)
 80046de:	4a13      	ldr	r2, [pc, #76]	; (800472c <MX_QUADSPI1_Init+0x54>)
 80046e0:	601a      	str	r2, [r3, #0]
  hqspi1.Init.ClockPrescaler = 6;
 80046e2:	4b11      	ldr	r3, [pc, #68]	; (8004728 <MX_QUADSPI1_Init+0x50>)
 80046e4:	2206      	movs	r2, #6
 80046e6:	605a      	str	r2, [r3, #4]
  hqspi1.Init.FifoThreshold = 1;
 80046e8:	4b0f      	ldr	r3, [pc, #60]	; (8004728 <MX_QUADSPI1_Init+0x50>)
 80046ea:	2201      	movs	r2, #1
 80046ec:	609a      	str	r2, [r3, #8]
  hqspi1.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_NONE;
 80046ee:	4b0e      	ldr	r3, [pc, #56]	; (8004728 <MX_QUADSPI1_Init+0x50>)
 80046f0:	2200      	movs	r2, #0
 80046f2:	60da      	str	r2, [r3, #12]
  hqspi1.Init.FlashSize = 23;
 80046f4:	4b0c      	ldr	r3, [pc, #48]	; (8004728 <MX_QUADSPI1_Init+0x50>)
 80046f6:	2217      	movs	r2, #23
 80046f8:	611a      	str	r2, [r3, #16]
  hqspi1.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_1_CYCLE;
 80046fa:	4b0b      	ldr	r3, [pc, #44]	; (8004728 <MX_QUADSPI1_Init+0x50>)
 80046fc:	2200      	movs	r2, #0
 80046fe:	615a      	str	r2, [r3, #20]
  hqspi1.Init.ClockMode = QSPI_CLOCK_MODE_0;
 8004700:	4b09      	ldr	r3, [pc, #36]	; (8004728 <MX_QUADSPI1_Init+0x50>)
 8004702:	2200      	movs	r2, #0
 8004704:	619a      	str	r2, [r3, #24]
  hqspi1.Init.FlashID = QSPI_FLASH_ID_2;
 8004706:	4b08      	ldr	r3, [pc, #32]	; (8004728 <MX_QUADSPI1_Init+0x50>)
 8004708:	2280      	movs	r2, #128	; 0x80
 800470a:	61da      	str	r2, [r3, #28]
  hqspi1.Init.DualFlash = QSPI_DUALFLASH_DISABLE;
 800470c:	4b06      	ldr	r3, [pc, #24]	; (8004728 <MX_QUADSPI1_Init+0x50>)
 800470e:	2200      	movs	r2, #0
 8004710:	621a      	str	r2, [r3, #32]
  if (HAL_QSPI_Init(&hqspi1) != HAL_OK)
 8004712:	4805      	ldr	r0, [pc, #20]	; (8004728 <MX_QUADSPI1_Init+0x50>)
 8004714:	f005 f9ba 	bl	8009a8c <HAL_QSPI_Init>
 8004718:	4603      	mov	r3, r0
 800471a:	2b00      	cmp	r3, #0
 800471c:	d001      	beq.n	8004722 <MX_QUADSPI1_Init+0x4a>
  {
    Error_Handler();
 800471e:	f7ff fe56 	bl	80043ce <Error_Handler>
  }
  /* USER CODE BEGIN QUADSPI1_Init 2 */

  /* USER CODE END QUADSPI1_Init 2 */

}
 8004722:	bf00      	nop
 8004724:	bd80      	pop	{r7, pc}
 8004726:	bf00      	nop
 8004728:	200116b0 	.word	0x200116b0
 800472c:	a0001000 	.word	0xa0001000

08004730 <HAL_QSPI_MspInit>:

void HAL_QSPI_MspInit(QSPI_HandleTypeDef* qspiHandle)
{
 8004730:	b580      	push	{r7, lr}
 8004732:	b0a0      	sub	sp, #128	; 0x80
 8004734:	af00      	add	r7, sp, #0
 8004736:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004738:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 800473c:	2200      	movs	r2, #0
 800473e:	601a      	str	r2, [r3, #0]
 8004740:	605a      	str	r2, [r3, #4]
 8004742:	609a      	str	r2, [r3, #8]
 8004744:	60da      	str	r2, [r3, #12]
 8004746:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8004748:	f107 0318 	add.w	r3, r7, #24
 800474c:	2254      	movs	r2, #84	; 0x54
 800474e:	2100      	movs	r1, #0
 8004750:	4618      	mov	r0, r3
 8004752:	f019 ff0a 	bl	801e56a <memset>
  if(qspiHandle->Instance==QUADSPI)
 8004756:	687b      	ldr	r3, [r7, #4]
 8004758:	681b      	ldr	r3, [r3, #0]
 800475a:	4a54      	ldr	r2, [pc, #336]	; (80048ac <HAL_QSPI_MspInit+0x17c>)
 800475c:	4293      	cmp	r3, r2
 800475e:	f040 80a1 	bne.w	80048a4 <HAL_QSPI_MspInit+0x174>

  /* USER CODE END QUADSPI_MspInit 0 */

  /** Initializes the peripherals clocks
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_QSPI;
 8004762:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8004766:	61bb      	str	r3, [r7, #24]
    PeriphClkInit.QspiClockSelection = RCC_QSPICLKSOURCE_SYSCLK;
 8004768:	2300      	movs	r3, #0
 800476a:	667b      	str	r3, [r7, #100]	; 0x64

    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 800476c:	f107 0318 	add.w	r3, r7, #24
 8004770:	4618      	mov	r0, r3
 8004772:	f006 f97d 	bl	800aa70 <HAL_RCCEx_PeriphCLKConfig>
 8004776:	4603      	mov	r3, r0
 8004778:	2b00      	cmp	r3, #0
 800477a:	d001      	beq.n	8004780 <HAL_QSPI_MspInit+0x50>
    {
      Error_Handler();
 800477c:	f7ff fe27 	bl	80043ce <Error_Handler>
    }

    /* QUADSPI clock enable */
    __HAL_RCC_QSPI_CLK_ENABLE();
 8004780:	4b4b      	ldr	r3, [pc, #300]	; (80048b0 <HAL_QSPI_MspInit+0x180>)
 8004782:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004784:	4a4a      	ldr	r2, [pc, #296]	; (80048b0 <HAL_QSPI_MspInit+0x180>)
 8004786:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800478a:	6513      	str	r3, [r2, #80]	; 0x50
 800478c:	4b48      	ldr	r3, [pc, #288]	; (80048b0 <HAL_QSPI_MspInit+0x180>)
 800478e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004790:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8004794:	617b      	str	r3, [r7, #20]
 8004796:	697b      	ldr	r3, [r7, #20]

    __HAL_RCC_GPIOC_CLK_ENABLE();
 8004798:	4b45      	ldr	r3, [pc, #276]	; (80048b0 <HAL_QSPI_MspInit+0x180>)
 800479a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800479c:	4a44      	ldr	r2, [pc, #272]	; (80048b0 <HAL_QSPI_MspInit+0x180>)
 800479e:	f043 0304 	orr.w	r3, r3, #4
 80047a2:	64d3      	str	r3, [r2, #76]	; 0x4c
 80047a4:	4b42      	ldr	r3, [pc, #264]	; (80048b0 <HAL_QSPI_MspInit+0x180>)
 80047a6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80047a8:	f003 0304 	and.w	r3, r3, #4
 80047ac:	613b      	str	r3, [r7, #16]
 80047ae:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80047b0:	4b3f      	ldr	r3, [pc, #252]	; (80048b0 <HAL_QSPI_MspInit+0x180>)
 80047b2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80047b4:	4a3e      	ldr	r2, [pc, #248]	; (80048b0 <HAL_QSPI_MspInit+0x180>)
 80047b6:	f043 0302 	orr.w	r3, r3, #2
 80047ba:	64d3      	str	r3, [r2, #76]	; 0x4c
 80047bc:	4b3c      	ldr	r3, [pc, #240]	; (80048b0 <HAL_QSPI_MspInit+0x180>)
 80047be:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80047c0:	f003 0302 	and.w	r3, r3, #2
 80047c4:	60fb      	str	r3, [r7, #12]
 80047c6:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80047c8:	4b39      	ldr	r3, [pc, #228]	; (80048b0 <HAL_QSPI_MspInit+0x180>)
 80047ca:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80047cc:	4a38      	ldr	r2, [pc, #224]	; (80048b0 <HAL_QSPI_MspInit+0x180>)
 80047ce:	f043 0308 	orr.w	r3, r3, #8
 80047d2:	64d3      	str	r3, [r2, #76]	; 0x4c
 80047d4:	4b36      	ldr	r3, [pc, #216]	; (80048b0 <HAL_QSPI_MspInit+0x180>)
 80047d6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80047d8:	f003 0308 	and.w	r3, r3, #8
 80047dc:	60bb      	str	r3, [r7, #8]
 80047de:	68bb      	ldr	r3, [r7, #8]
    PC3     ------> QUADSPI1_BK2_IO2
    PC4     ------> QUADSPI1_BK2_IO3
    PB10     ------> QUADSPI1_CLK
    PD3     ------> QUADSPI1_BK2_NCS
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4;
 80047e0:	231e      	movs	r3, #30
 80047e2:	66fb      	str	r3, [r7, #108]	; 0x6c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80047e4:	2302      	movs	r3, #2
 80047e6:	673b      	str	r3, [r7, #112]	; 0x70
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80047e8:	2300      	movs	r3, #0
 80047ea:	677b      	str	r3, [r7, #116]	; 0x74
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80047ec:	2300      	movs	r3, #0
 80047ee:	67bb      	str	r3, [r7, #120]	; 0x78
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
 80047f0:	230a      	movs	r3, #10
 80047f2:	67fb      	str	r3, [r7, #124]	; 0x7c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80047f4:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80047f8:	4619      	mov	r1, r3
 80047fa:	482e      	ldr	r0, [pc, #184]	; (80048b4 <HAL_QSPI_MspInit+0x184>)
 80047fc:	f004 fe06 	bl	800940c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_10;
 8004800:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004804:	66fb      	str	r3, [r7, #108]	; 0x6c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8004806:	2302      	movs	r3, #2
 8004808:	673b      	str	r3, [r7, #112]	; 0x70
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800480a:	2300      	movs	r3, #0
 800480c:	677b      	str	r3, [r7, #116]	; 0x74
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800480e:	2300      	movs	r3, #0
 8004810:	67bb      	str	r3, [r7, #120]	; 0x78
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
 8004812:	230a      	movs	r3, #10
 8004814:	67fb      	str	r3, [r7, #124]	; 0x7c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8004816:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 800481a:	4619      	mov	r1, r3
 800481c:	4826      	ldr	r0, [pc, #152]	; (80048b8 <HAL_QSPI_MspInit+0x188>)
 800481e:	f004 fdf5 	bl	800940c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_3;
 8004822:	2308      	movs	r3, #8
 8004824:	66fb      	str	r3, [r7, #108]	; 0x6c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8004826:	2302      	movs	r3, #2
 8004828:	673b      	str	r3, [r7, #112]	; 0x70
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800482a:	2300      	movs	r3, #0
 800482c:	677b      	str	r3, [r7, #116]	; 0x74
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800482e:	2300      	movs	r3, #0
 8004830:	67bb      	str	r3, [r7, #120]	; 0x78
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
 8004832:	230a      	movs	r3, #10
 8004834:	67fb      	str	r3, [r7, #124]	; 0x7c
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8004836:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 800483a:	4619      	mov	r1, r3
 800483c:	481f      	ldr	r0, [pc, #124]	; (80048bc <HAL_QSPI_MspInit+0x18c>)
 800483e:	f004 fde5 	bl	800940c <HAL_GPIO_Init>

    /* QUADSPI DMA Init */
    /* QUADSPI Init */
    hdma_quadspi.Instance = DMA1_Channel1;
 8004842:	4b1f      	ldr	r3, [pc, #124]	; (80048c0 <HAL_QSPI_MspInit+0x190>)
 8004844:	4a1f      	ldr	r2, [pc, #124]	; (80048c4 <HAL_QSPI_MspInit+0x194>)
 8004846:	601a      	str	r2, [r3, #0]
    hdma_quadspi.Init.Request = DMA_REQUEST_QUADSPI;
 8004848:	4b1d      	ldr	r3, [pc, #116]	; (80048c0 <HAL_QSPI_MspInit+0x190>)
 800484a:	2228      	movs	r2, #40	; 0x28
 800484c:	605a      	str	r2, [r3, #4]
    hdma_quadspi.Init.Direction = DMA_MEMORY_TO_PERIPH;
 800484e:	4b1c      	ldr	r3, [pc, #112]	; (80048c0 <HAL_QSPI_MspInit+0x190>)
 8004850:	2210      	movs	r2, #16
 8004852:	609a      	str	r2, [r3, #8]
    hdma_quadspi.Init.PeriphInc = DMA_PINC_DISABLE;
 8004854:	4b1a      	ldr	r3, [pc, #104]	; (80048c0 <HAL_QSPI_MspInit+0x190>)
 8004856:	2200      	movs	r2, #0
 8004858:	60da      	str	r2, [r3, #12]
    hdma_quadspi.Init.MemInc = DMA_MINC_ENABLE;
 800485a:	4b19      	ldr	r3, [pc, #100]	; (80048c0 <HAL_QSPI_MspInit+0x190>)
 800485c:	2280      	movs	r2, #128	; 0x80
 800485e:	611a      	str	r2, [r3, #16]
    hdma_quadspi.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8004860:	4b17      	ldr	r3, [pc, #92]	; (80048c0 <HAL_QSPI_MspInit+0x190>)
 8004862:	2200      	movs	r2, #0
 8004864:	615a      	str	r2, [r3, #20]
    hdma_quadspi.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8004866:	4b16      	ldr	r3, [pc, #88]	; (80048c0 <HAL_QSPI_MspInit+0x190>)
 8004868:	2200      	movs	r2, #0
 800486a:	619a      	str	r2, [r3, #24]
    hdma_quadspi.Init.Mode = DMA_NORMAL;
 800486c:	4b14      	ldr	r3, [pc, #80]	; (80048c0 <HAL_QSPI_MspInit+0x190>)
 800486e:	2200      	movs	r2, #0
 8004870:	61da      	str	r2, [r3, #28]
    hdma_quadspi.Init.Priority = DMA_PRIORITY_LOW;
 8004872:	4b13      	ldr	r3, [pc, #76]	; (80048c0 <HAL_QSPI_MspInit+0x190>)
 8004874:	2200      	movs	r2, #0
 8004876:	621a      	str	r2, [r3, #32]
    if (HAL_DMA_Init(&hdma_quadspi) != HAL_OK)
 8004878:	4811      	ldr	r0, [pc, #68]	; (80048c0 <HAL_QSPI_MspInit+0x190>)
 800487a:	f004 fa95 	bl	8008da8 <HAL_DMA_Init>
 800487e:	4603      	mov	r3, r0
 8004880:	2b00      	cmp	r3, #0
 8004882:	d001      	beq.n	8004888 <HAL_QSPI_MspInit+0x158>
    {
      Error_Handler();
 8004884:	f7ff fda3 	bl	80043ce <Error_Handler>
    }

    __HAL_LINKDMA(qspiHandle,hdma,hdma_quadspi);
 8004888:	687b      	ldr	r3, [r7, #4]
 800488a:	4a0d      	ldr	r2, [pc, #52]	; (80048c0 <HAL_QSPI_MspInit+0x190>)
 800488c:	63da      	str	r2, [r3, #60]	; 0x3c
 800488e:	4a0c      	ldr	r2, [pc, #48]	; (80048c0 <HAL_QSPI_MspInit+0x190>)
 8004890:	687b      	ldr	r3, [r7, #4]
 8004892:	6293      	str	r3, [r2, #40]	; 0x28

    /* QUADSPI interrupt Init */
    HAL_NVIC_SetPriority(QUADSPI_IRQn, 0, 0);
 8004894:	2200      	movs	r2, #0
 8004896:	2100      	movs	r1, #0
 8004898:	205f      	movs	r0, #95	; 0x5f
 800489a:	f003 fe96 	bl	80085ca <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(QUADSPI_IRQn);
 800489e:	205f      	movs	r0, #95	; 0x5f
 80048a0:	f003 fead 	bl	80085fe <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN QUADSPI_MspInit 1 */

  /* USER CODE END QUADSPI_MspInit 1 */
  }
}
 80048a4:	bf00      	nop
 80048a6:	3780      	adds	r7, #128	; 0x80
 80048a8:	46bd      	mov	sp, r7
 80048aa:	bd80      	pop	{r7, pc}
 80048ac:	a0001000 	.word	0xa0001000
 80048b0:	40021000 	.word	0x40021000
 80048b4:	48000800 	.word	0x48000800
 80048b8:	48000400 	.word	0x48000400
 80048bc:	48000c00 	.word	0x48000c00
 80048c0:	200116fc 	.word	0x200116fc
 80048c4:	40020008 	.word	0x40020008

080048c8 <LL_ADC_EnableIT_AWD1>:
  * @rmtoll IER      AWD1IE         LL_ADC_EnableIT_AWD1
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableIT_AWD1(ADC_TypeDef *ADCx)
{
 80048c8:	b480      	push	{r7}
 80048ca:	b083      	sub	sp, #12
 80048cc:	af00      	add	r7, sp, #0
 80048ce:	6078      	str	r0, [r7, #4]
  SET_BIT(ADCx->IER, LL_ADC_IT_AWD1);
 80048d0:	687b      	ldr	r3, [r7, #4]
 80048d2:	685b      	ldr	r3, [r3, #4]
 80048d4:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 80048d8:	687b      	ldr	r3, [r7, #4]
 80048da:	605a      	str	r2, [r3, #4]
}
 80048dc:	bf00      	nop
 80048de:	370c      	adds	r7, #12
 80048e0:	46bd      	mov	sp, r7
 80048e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80048e6:	4770      	bx	lr

080048e8 <LL_ADC_EnableIT_AWD2>:
  * @rmtoll IER      AWD2IE         LL_ADC_EnableIT_AWD2
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableIT_AWD2(ADC_TypeDef *ADCx)
{
 80048e8:	b480      	push	{r7}
 80048ea:	b083      	sub	sp, #12
 80048ec:	af00      	add	r7, sp, #0
 80048ee:	6078      	str	r0, [r7, #4]
  SET_BIT(ADCx->IER, LL_ADC_IT_AWD2);
 80048f0:	687b      	ldr	r3, [r7, #4]
 80048f2:	685b      	ldr	r3, [r3, #4]
 80048f4:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 80048f8:	687b      	ldr	r3, [r7, #4]
 80048fa:	605a      	str	r2, [r3, #4]
}
 80048fc:	bf00      	nop
 80048fe:	370c      	adds	r7, #12
 8004900:	46bd      	mov	sp, r7
 8004902:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004906:	4770      	bx	lr

08004908 <LL_ADC_DisableIT_AWD1>:
  * @rmtoll IER      AWD1IE         LL_ADC_DisableIT_AWD1
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_AWD1(ADC_TypeDef *ADCx)
{
 8004908:	b480      	push	{r7}
 800490a:	b083      	sub	sp, #12
 800490c:	af00      	add	r7, sp, #0
 800490e:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_AWD1);
 8004910:	687b      	ldr	r3, [r7, #4]
 8004912:	685b      	ldr	r3, [r3, #4]
 8004914:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 8004918:	687b      	ldr	r3, [r7, #4]
 800491a:	605a      	str	r2, [r3, #4]
}
 800491c:	bf00      	nop
 800491e:	370c      	adds	r7, #12
 8004920:	46bd      	mov	sp, r7
 8004922:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004926:	4770      	bx	lr

08004928 <LL_ADC_DisableIT_AWD2>:
  * @rmtoll IER      AWD2IE         LL_ADC_DisableIT_AWD2
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_AWD2(ADC_TypeDef *ADCx)
{
 8004928:	b480      	push	{r7}
 800492a:	b083      	sub	sp, #12
 800492c:	af00      	add	r7, sp, #0
 800492e:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_AWD2);
 8004930:	687b      	ldr	r3, [r7, #4]
 8004932:	685b      	ldr	r3, [r3, #4]
 8004934:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 8004938:	687b      	ldr	r3, [r7, #4]
 800493a:	605a      	str	r2, [r3, #4]
}
 800493c:	bf00      	nop
 800493e:	370c      	adds	r7, #12
 8004940:	46bd      	mov	sp, r7
 8004942:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004946:	4770      	bx	lr

08004948 <scope_init>:
#include "scope.h"

static tScope *_scope;

void scope_init( tScope *scope, uint16_t trigger_level, uint16_t sample_rate, uint16_t *buffer1, uint16_t *buffer2, uint16_t *buffer3, uint16_t *buffer4, uint16_t len )
{
 8004948:	b480      	push	{r7}
 800494a:	b085      	sub	sp, #20
 800494c:	af00      	add	r7, sp, #0
 800494e:	60f8      	str	r0, [r7, #12]
 8004950:	607b      	str	r3, [r7, #4]
 8004952:	460b      	mov	r3, r1
 8004954:	817b      	strh	r3, [r7, #10]
 8004956:	4613      	mov	r3, r2
 8004958:	813b      	strh	r3, [r7, #8]
	scope->trigger_level = trigger_level;
 800495a:	68fb      	ldr	r3, [r7, #12]
 800495c:	897a      	ldrh	r2, [r7, #10]
 800495e:	82da      	strh	r2, [r3, #22]
	scope->sample_rate = sample_rate;
 8004960:	68fb      	ldr	r3, [r7, #12]
 8004962:	893a      	ldrh	r2, [r7, #8]
 8004964:	805a      	strh	r2, [r3, #2]
	scope->buffer1 = buffer1;
 8004966:	68fb      	ldr	r3, [r7, #12]
 8004968:	687a      	ldr	r2, [r7, #4]
 800496a:	605a      	str	r2, [r3, #4]
	scope->buffer2 = buffer2;
 800496c:	68fb      	ldr	r3, [r7, #12]
 800496e:	69ba      	ldr	r2, [r7, #24]
 8004970:	609a      	str	r2, [r3, #8]
	scope->buffer3 = buffer3;
 8004972:	68fb      	ldr	r3, [r7, #12]
 8004974:	69fa      	ldr	r2, [r7, #28]
 8004976:	60da      	str	r2, [r3, #12]
	scope->buffer4 = buffer4;
 8004978:	68fb      	ldr	r3, [r7, #12]
 800497a:	6a3a      	ldr	r2, [r7, #32]
 800497c:	611a      	str	r2, [r3, #16]
	scope->len = len;
 800497e:	68fb      	ldr	r3, [r7, #12]
 8004980:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8004982:	829a      	strh	r2, [r3, #20]
	scope->trigger_location = 0;
 8004984:	68fb      	ldr	r3, [r7, #12]
 8004986:	2200      	movs	r2, #0
 8004988:	831a      	strh	r2, [r3, #24]
	scope->state = SCOPE_STATE_RESET;
 800498a:	68fb      	ldr	r3, [r7, #12]
 800498c:	2200      	movs	r2, #0
 800498e:	701a      	strb	r2, [r3, #0]

	_scope = scope;
 8004990:	4a13      	ldr	r2, [pc, #76]	; (80049e0 <scope_init+0x98>)
 8004992:	68fb      	ldr	r3, [r7, #12]
 8004994:	6013      	str	r3, [r2, #0]
	extern DMA_HandleTypeDef hdma_adc5;
	extern DMA_HandleTypeDef hdma_adc4;
	extern TIM_HandleTypeDef htim1;
	extern TIM_HandleTypeDef htim2;

	scope->hadc1 = &hadc1;
 8004996:	68fb      	ldr	r3, [r7, #12]
 8004998:	4a12      	ldr	r2, [pc, #72]	; (80049e4 <scope_init+0x9c>)
 800499a:	61da      	str	r2, [r3, #28]
	scope->hadc2 = &hadc3;
 800499c:	68fb      	ldr	r3, [r7, #12]
 800499e:	4a12      	ldr	r2, [pc, #72]	; (80049e8 <scope_init+0xa0>)
 80049a0:	621a      	str	r2, [r3, #32]
	scope->hadc3 = &hadc5;
 80049a2:	68fb      	ldr	r3, [r7, #12]
 80049a4:	4a11      	ldr	r2, [pc, #68]	; (80049ec <scope_init+0xa4>)
 80049a6:	625a      	str	r2, [r3, #36]	; 0x24
	scope->hadc4 = &hadc4;
 80049a8:	68fb      	ldr	r3, [r7, #12]
 80049aa:	4a11      	ldr	r2, [pc, #68]	; (80049f0 <scope_init+0xa8>)
 80049ac:	629a      	str	r2, [r3, #40]	; 0x28
	scope->hdma_adc1 = &hdma_adc1;
 80049ae:	68fb      	ldr	r3, [r7, #12]
 80049b0:	4a10      	ldr	r2, [pc, #64]	; (80049f4 <scope_init+0xac>)
 80049b2:	62da      	str	r2, [r3, #44]	; 0x2c
	scope->hdma_adc2 = &hdma_adc3;
 80049b4:	68fb      	ldr	r3, [r7, #12]
 80049b6:	4a10      	ldr	r2, [pc, #64]	; (80049f8 <scope_init+0xb0>)
 80049b8:	631a      	str	r2, [r3, #48]	; 0x30
	scope->hdma_adc3 = &hdma_adc5;
 80049ba:	68fb      	ldr	r3, [r7, #12]
 80049bc:	4a0f      	ldr	r2, [pc, #60]	; (80049fc <scope_init+0xb4>)
 80049be:	635a      	str	r2, [r3, #52]	; 0x34
	scope->hdma_adc4 = &hdma_adc4;
 80049c0:	68fb      	ldr	r3, [r7, #12]
 80049c2:	4a0f      	ldr	r2, [pc, #60]	; (8004a00 <scope_init+0xb8>)
 80049c4:	639a      	str	r2, [r3, #56]	; 0x38
	scope->htim1 = &htim1;
 80049c6:	68fb      	ldr	r3, [r7, #12]
 80049c8:	4a0e      	ldr	r2, [pc, #56]	; (8004a04 <scope_init+0xbc>)
 80049ca:	63da      	str	r2, [r3, #60]	; 0x3c
	scope->htim2 = &htim2;
 80049cc:	68fb      	ldr	r3, [r7, #12]
 80049ce:	4a0e      	ldr	r2, [pc, #56]	; (8004a08 <scope_init+0xc0>)
 80049d0:	641a      	str	r2, [r3, #64]	; 0x40
	//MX_DMA_Init();
	//MX_ADC1_Init();
	//MX_OPAMP1_Init();
	//MX_TIM1_Init();
	//MX_TIM2_Init();
}
 80049d2:	bf00      	nop
 80049d4:	3714      	adds	r7, #20
 80049d6:	46bd      	mov	sp, r7
 80049d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80049dc:	4770      	bx	lr
 80049de:	bf00      	nop
 80049e0:	2001175c 	.word	0x2001175c
 80049e4:	20000374 	.word	0x20000374
 80049e8:	200003e0 	.word	0x200003e0
 80049ec:	200004b8 	.word	0x200004b8
 80049f0:	2000044c 	.word	0x2000044c
 80049f4:	20000524 	.word	0x20000524
 80049f8:	20000584 	.word	0x20000584
 80049fc:	20000644 	.word	0x20000644
 8004a00:	200005e4 	.word	0x200005e4
 8004a04:	20016844 	.word	0x20016844
 8004a08:	20016890 	.word	0x20016890
 8004a0c:	00000000 	.word	0x00000000

08004a10 <scope_start>:
	scope->CNDTRs[SCOPE_STATE_WAIT_FOR_STOP] = 0;
	scope->state = SCOPE_STATE_RESET;
}

void scope_start( tScope *scope )
{
 8004a10:	b5b0      	push	{r4, r5, r7, lr}
 8004a12:	b084      	sub	sp, #16
 8004a14:	af00      	add	r7, sp, #0
 8004a16:	6078      	str	r0, [r7, #4]
	for( int i = 0; i < SCOPE_STATE_MAX ; i++ )
 8004a18:	2300      	movs	r3, #0
 8004a1a:	60fb      	str	r3, [r7, #12]
 8004a1c:	e009      	b.n	8004a32 <scope_start+0x22>
	{
		scope->CNDTRs[i] = 0;
 8004a1e:	687a      	ldr	r2, [r7, #4]
 8004a20:	68fb      	ldr	r3, [r7, #12]
 8004a22:	3310      	adds	r3, #16
 8004a24:	009b      	lsls	r3, r3, #2
 8004a26:	4413      	add	r3, r2
 8004a28:	2200      	movs	r2, #0
 8004a2a:	605a      	str	r2, [r3, #4]
	for( int i = 0; i < SCOPE_STATE_MAX ; i++ )
 8004a2c:	68fb      	ldr	r3, [r7, #12]
 8004a2e:	3301      	adds	r3, #1
 8004a30:	60fb      	str	r3, [r7, #12]
 8004a32:	68fb      	ldr	r3, [r7, #12]
 8004a34:	2b05      	cmp	r3, #5
 8004a36:	ddf2      	ble.n	8004a1e <scope_start+0xe>
	}

	__HAL_DBGMCU_FREEZE_TIM1();
 8004a38:	4b5b      	ldr	r3, [pc, #364]	; (8004ba8 <scope_start+0x198>)
 8004a3a:	691b      	ldr	r3, [r3, #16]
 8004a3c:	4a5a      	ldr	r2, [pc, #360]	; (8004ba8 <scope_start+0x198>)
 8004a3e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8004a42:	6113      	str	r3, [r2, #16]
	__HAL_DBGMCU_FREEZE_TIM2();
 8004a44:	4b58      	ldr	r3, [pc, #352]	; (8004ba8 <scope_start+0x198>)
 8004a46:	689b      	ldr	r3, [r3, #8]
 8004a48:	4a57      	ldr	r2, [pc, #348]	; (8004ba8 <scope_start+0x198>)
 8004a4a:	f043 0301 	orr.w	r3, r3, #1
 8004a4e:	6093      	str	r3, [r2, #8]

	extern DAC_HandleTypeDef hdac2;
	int vcc = 3.3;
 8004a50:	2303      	movs	r3, #3
 8004a52:	60bb      	str	r3, [r7, #8]
	HAL_DAC_SetValue(&hdac2, DAC_CHANNEL_1, DAC_ALIGN_12B_R, (vcc/2.0)/vcc*4095);
 8004a54:	68b8      	ldr	r0, [r7, #8]
 8004a56:	f7fb fd8d 	bl	8000574 <__aeabi_i2d>
 8004a5a:	f04f 0200 	mov.w	r2, #0
 8004a5e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004a62:	f7fb ff1b 	bl	800089c <__aeabi_ddiv>
 8004a66:	4602      	mov	r2, r0
 8004a68:	460b      	mov	r3, r1
 8004a6a:	4614      	mov	r4, r2
 8004a6c:	461d      	mov	r5, r3
 8004a6e:	68b8      	ldr	r0, [r7, #8]
 8004a70:	f7fb fd80 	bl	8000574 <__aeabi_i2d>
 8004a74:	4602      	mov	r2, r0
 8004a76:	460b      	mov	r3, r1
 8004a78:	4620      	mov	r0, r4
 8004a7a:	4629      	mov	r1, r5
 8004a7c:	f7fb ff0e 	bl	800089c <__aeabi_ddiv>
 8004a80:	4602      	mov	r2, r0
 8004a82:	460b      	mov	r3, r1
 8004a84:	4610      	mov	r0, r2
 8004a86:	4619      	mov	r1, r3
 8004a88:	a345      	add	r3, pc, #276	; (adr r3, 8004ba0 <scope_start+0x190>)
 8004a8a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004a8e:	f7fb fddb 	bl	8000648 <__aeabi_dmul>
 8004a92:	4602      	mov	r2, r0
 8004a94:	460b      	mov	r3, r1
 8004a96:	4610      	mov	r0, r2
 8004a98:	4619      	mov	r1, r3
 8004a9a:	f7fc f8ad 	bl	8000bf8 <__aeabi_d2uiz>
 8004a9e:	4603      	mov	r3, r0
 8004aa0:	2200      	movs	r2, #0
 8004aa2:	2100      	movs	r1, #0
 8004aa4:	4841      	ldr	r0, [pc, #260]	; (8004bac <scope_start+0x19c>)
 8004aa6:	f003 ff07 	bl	80088b8 <HAL_DAC_SetValue>
	HAL_DAC_Start(&hdac2, DAC_CHANNEL_1);
 8004aaa:	2100      	movs	r1, #0
 8004aac:	483f      	ldr	r0, [pc, #252]	; (8004bac <scope_start+0x19c>)
 8004aae:	f003 fde2 	bl	8008676 <HAL_DAC_Start>

	extern OPAMP_HandleTypeDef hopamp1;
	extern OPAMP_HandleTypeDef hopamp3;
	extern OPAMP_HandleTypeDef hopamp5;
	extern OPAMP_HandleTypeDef hopamp6;
	HAL_OPAMP_Start(&hopamp1);
 8004ab2:	483f      	ldr	r0, [pc, #252]	; (8004bb0 <scope_start+0x1a0>)
 8004ab4:	f004 ff14 	bl	80098e0 <HAL_OPAMP_Start>
	HAL_OPAMP_Start(&hopamp3);
 8004ab8:	483e      	ldr	r0, [pc, #248]	; (8004bb4 <scope_start+0x1a4>)
 8004aba:	f004 ff11 	bl	80098e0 <HAL_OPAMP_Start>
	HAL_OPAMP_Start(&hopamp5);
 8004abe:	483e      	ldr	r0, [pc, #248]	; (8004bb8 <scope_start+0x1a8>)
 8004ac0:	f004 ff0e 	bl	80098e0 <HAL_OPAMP_Start>
	HAL_OPAMP_Start(&hopamp6);
 8004ac4:	483d      	ldr	r0, [pc, #244]	; (8004bbc <scope_start+0x1ac>)
 8004ac6:	f004 ff0b 	bl	80098e0 <HAL_OPAMP_Start>

	HAL_ADCEx_Calibration_Start( scope->hadc1, ADC_SINGLE_ENDED );
 8004aca:	687b      	ldr	r3, [r7, #4]
 8004acc:	69db      	ldr	r3, [r3, #28]
 8004ace:	217f      	movs	r1, #127	; 0x7f
 8004ad0:	4618      	mov	r0, r3
 8004ad2:	f003 fb0d 	bl	80080f0 <HAL_ADCEx_Calibration_Start>
	HAL_ADCEx_Calibration_Start( scope->hadc2, ADC_SINGLE_ENDED );
 8004ad6:	687b      	ldr	r3, [r7, #4]
 8004ad8:	6a1b      	ldr	r3, [r3, #32]
 8004ada:	217f      	movs	r1, #127	; 0x7f
 8004adc:	4618      	mov	r0, r3
 8004ade:	f003 fb07 	bl	80080f0 <HAL_ADCEx_Calibration_Start>
	HAL_ADCEx_Calibration_Start( scope->hadc3, ADC_SINGLE_ENDED );
 8004ae2:	687b      	ldr	r3, [r7, #4]
 8004ae4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004ae6:	217f      	movs	r1, #127	; 0x7f
 8004ae8:	4618      	mov	r0, r3
 8004aea:	f003 fb01 	bl	80080f0 <HAL_ADCEx_Calibration_Start>
	HAL_ADCEx_Calibration_Start( scope->hadc4, ADC_SINGLE_ENDED );
 8004aee:	687b      	ldr	r3, [r7, #4]
 8004af0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004af2:	217f      	movs	r1, #127	; 0x7f
 8004af4:	4618      	mov	r0, r3
 8004af6:	f003 fafb 	bl	80080f0 <HAL_ADCEx_Calibration_Start>

	LL_ADC_DisableIT_AWD1( scope->hadc1->Instance );
 8004afa:	687b      	ldr	r3, [r7, #4]
 8004afc:	69db      	ldr	r3, [r3, #28]
 8004afe:	681b      	ldr	r3, [r3, #0]
 8004b00:	4618      	mov	r0, r3
 8004b02:	f7ff ff01 	bl	8004908 <LL_ADC_DisableIT_AWD1>
	LL_ADC_DisableIT_AWD2( scope->hadc1->Instance );
 8004b06:	687b      	ldr	r3, [r7, #4]
 8004b08:	69db      	ldr	r3, [r3, #28]
 8004b0a:	681b      	ldr	r3, [r3, #0]
 8004b0c:	4618      	mov	r0, r3
 8004b0e:	f7ff ff0b 	bl	8004928 <LL_ADC_DisableIT_AWD2>
	__HAL_ADC_CLEAR_FLAG( scope->hadc1, ADC_FLAG_AWD1 );
 8004b12:	687b      	ldr	r3, [r7, #4]
 8004b14:	69db      	ldr	r3, [r3, #28]
 8004b16:	681b      	ldr	r3, [r3, #0]
 8004b18:	2280      	movs	r2, #128	; 0x80
 8004b1a:	601a      	str	r2, [r3, #0]
	__HAL_ADC_CLEAR_FLAG( scope->hadc1, ADC_FLAG_AWD2 );
 8004b1c:	687b      	ldr	r3, [r7, #4]
 8004b1e:	69db      	ldr	r3, [r3, #28]
 8004b20:	681b      	ldr	r3, [r3, #0]
 8004b22:	f44f 7280 	mov.w	r2, #256	; 0x100
 8004b26:	601a      	str	r2, [r3, #0]

	scope->htim1->Instance->CNT = 0;
 8004b28:	687b      	ldr	r3, [r7, #4]
 8004b2a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004b2c:	681b      	ldr	r3, [r3, #0]
 8004b2e:	2200      	movs	r2, #0
 8004b30:	625a      	str	r2, [r3, #36]	; 0x24
	scope->htim2->Instance->CNT = 0;
 8004b32:	687b      	ldr	r3, [r7, #4]
 8004b34:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004b36:	681b      	ldr	r3, [r3, #0]
 8004b38:	2200      	movs	r2, #0
 8004b3a:	625a      	str	r2, [r3, #36]	; 0x24

	HAL_ADC_Start_DMA( scope->hadc1, (uint32_t*)scope->buffer1, scope->len );
 8004b3c:	687b      	ldr	r3, [r7, #4]
 8004b3e:	69d8      	ldr	r0, [r3, #28]
 8004b40:	687b      	ldr	r3, [r7, #4]
 8004b42:	6859      	ldr	r1, [r3, #4]
 8004b44:	687b      	ldr	r3, [r7, #4]
 8004b46:	8a9b      	ldrh	r3, [r3, #20]
 8004b48:	461a      	mov	r2, r3
 8004b4a:	f001 fe81 	bl	8006850 <HAL_ADC_Start_DMA>
	HAL_ADC_Start_DMA( scope->hadc2, (uint32_t*)scope->buffer2, scope->len );
 8004b4e:	687b      	ldr	r3, [r7, #4]
 8004b50:	6a18      	ldr	r0, [r3, #32]
 8004b52:	687b      	ldr	r3, [r7, #4]
 8004b54:	6899      	ldr	r1, [r3, #8]
 8004b56:	687b      	ldr	r3, [r7, #4]
 8004b58:	8a9b      	ldrh	r3, [r3, #20]
 8004b5a:	461a      	mov	r2, r3
 8004b5c:	f001 fe78 	bl	8006850 <HAL_ADC_Start_DMA>
	HAL_ADC_Start_DMA( scope->hadc3, (uint32_t*)scope->buffer3, scope->len );
 8004b60:	687b      	ldr	r3, [r7, #4]
 8004b62:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8004b64:	687b      	ldr	r3, [r7, #4]
 8004b66:	68d9      	ldr	r1, [r3, #12]
 8004b68:	687b      	ldr	r3, [r7, #4]
 8004b6a:	8a9b      	ldrh	r3, [r3, #20]
 8004b6c:	461a      	mov	r2, r3
 8004b6e:	f001 fe6f 	bl	8006850 <HAL_ADC_Start_DMA>
	HAL_ADC_Start_DMA( scope->hadc4, (uint32_t*)scope->buffer4, scope->len );
 8004b72:	687b      	ldr	r3, [r7, #4]
 8004b74:	6a98      	ldr	r0, [r3, #40]	; 0x28
 8004b76:	687b      	ldr	r3, [r7, #4]
 8004b78:	6919      	ldr	r1, [r3, #16]
 8004b7a:	687b      	ldr	r3, [r7, #4]
 8004b7c:	8a9b      	ldrh	r3, [r3, #20]
 8004b7e:	461a      	mov	r2, r3
 8004b80:	f001 fe66 	bl	8006850 <HAL_ADC_Start_DMA>
	HAL_TIM_Base_Start( scope->htim1 );
 8004b84:	687b      	ldr	r3, [r7, #4]
 8004b86:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004b88:	4618      	mov	r0, r3
 8004b8a:	f006 fe81 	bl	800b890 <HAL_TIM_Base_Start>
	scope->state = SCOPE_STATE_WAIT_FOR_CONVERSION_COMPLETE;
 8004b8e:	687b      	ldr	r3, [r7, #4]
 8004b90:	2201      	movs	r2, #1
 8004b92:	701a      	strb	r2, [r3, #0]
}
 8004b94:	bf00      	nop
 8004b96:	3710      	adds	r7, #16
 8004b98:	46bd      	mov	sp, r7
 8004b9a:	bdb0      	pop	{r4, r5, r7, pc}
 8004b9c:	f3af 8000 	nop.w
 8004ba0:	00000000 	.word	0x00000000
 8004ba4:	40affe00 	.word	0x40affe00
 8004ba8:	e0042000 	.word	0xe0042000
 8004bac:	200006bc 	.word	0x200006bc
 8004bb0:	200115bc 	.word	0x200115bc
 8004bb4:	200115f8 	.word	0x200115f8
 8004bb8:	20011634 	.word	0x20011634
 8004bbc:	20011670 	.word	0x20011670

08004bc0 <scope_stop>:

void scope_stop( tScope *scope )
{
 8004bc0:	b580      	push	{r7, lr}
 8004bc2:	b082      	sub	sp, #8
 8004bc4:	af00      	add	r7, sp, #0
 8004bc6:	6078      	str	r0, [r7, #4]
	HAL_TIM_Base_Stop( scope->htim1 );
 8004bc8:	687b      	ldr	r3, [r7, #4]
 8004bca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004bcc:	4618      	mov	r0, r3
 8004bce:	f006 fecf 	bl	800b970 <HAL_TIM_Base_Stop>
	HAL_TIM_OnePulse_Stop_IT( scope->htim2, TIM_CHANNEL_1);
 8004bd2:	687b      	ldr	r3, [r7, #4]
 8004bd4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004bd6:	2100      	movs	r1, #0
 8004bd8:	4618      	mov	r0, r3
 8004bda:	f006 ffdf 	bl	800bb9c <HAL_TIM_OnePulse_Stop_IT>
	HAL_TIM_Base_Stop( scope->htim2 );
 8004bde:	687b      	ldr	r3, [r7, #4]
 8004be0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004be2:	4618      	mov	r0, r3
 8004be4:	f006 fec4 	bl	800b970 <HAL_TIM_Base_Stop>
	HAL_ADC_Stop_DMA( scope->hadc1 );
 8004be8:	687b      	ldr	r3, [r7, #4]
 8004bea:	69db      	ldr	r3, [r3, #28]
 8004bec:	4618      	mov	r0, r3
 8004bee:	f001 ff03 	bl	80069f8 <HAL_ADC_Stop_DMA>
	HAL_ADC_Stop_DMA( scope->hadc2 );
 8004bf2:	687b      	ldr	r3, [r7, #4]
 8004bf4:	6a1b      	ldr	r3, [r3, #32]
 8004bf6:	4618      	mov	r0, r3
 8004bf8:	f001 fefe 	bl	80069f8 <HAL_ADC_Stop_DMA>
	HAL_ADC_Stop_DMA( scope->hadc3 );
 8004bfc:	687b      	ldr	r3, [r7, #4]
 8004bfe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004c00:	4618      	mov	r0, r3
 8004c02:	f001 fef9 	bl	80069f8 <HAL_ADC_Stop_DMA>
	HAL_ADC_Stop_DMA( scope->hadc4 );
 8004c06:	687b      	ldr	r3, [r7, #4]
 8004c08:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004c0a:	4618      	mov	r0, r3
 8004c0c:	f001 fef4 	bl	80069f8 <HAL_ADC_Stop_DMA>
	scope->state = SCOPE_STATE_DONE;
 8004c10:	687b      	ldr	r3, [r7, #4]
 8004c12:	2205      	movs	r2, #5
 8004c14:	701a      	strb	r2, [r3, #0]
}
 8004c16:	bf00      	nop
 8004c18:	3708      	adds	r7, #8
 8004c1a:	46bd      	mov	sp, r7
 8004c1c:	bd80      	pop	{r7, pc}

08004c1e <scope_is_busy>:

uint8_t scope_is_busy( tScope *scope )
{
 8004c1e:	b480      	push	{r7}
 8004c20:	b083      	sub	sp, #12
 8004c22:	af00      	add	r7, sp, #0
 8004c24:	6078      	str	r0, [r7, #4]
	return scope->state != SCOPE_STATE_DONE;
 8004c26:	687b      	ldr	r3, [r7, #4]
 8004c28:	781b      	ldrb	r3, [r3, #0]
 8004c2a:	2b05      	cmp	r3, #5
 8004c2c:	bf14      	ite	ne
 8004c2e:	2301      	movne	r3, #1
 8004c30:	2300      	moveq	r3, #0
 8004c32:	b2db      	uxtb	r3, r3
}
 8004c34:	4618      	mov	r0, r3
 8004c36:	370c      	adds	r7, #12
 8004c38:	46bd      	mov	sp, r7
 8004c3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004c3e:	4770      	bx	lr

08004c40 <scope_get_trigger>:

int32_t scope_get_trigger( tScope *scope )
{
 8004c40:	b480      	push	{r7}
 8004c42:	b083      	sub	sp, #12
 8004c44:	af00      	add	r7, sp, #0
 8004c46:	6078      	str	r0, [r7, #4]
	return scope->len - scope->CNDTRs[SCOPE_STATE_WAIT_FOR_STOP];
 8004c48:	687b      	ldr	r3, [r7, #4]
 8004c4a:	8a9b      	ldrh	r3, [r3, #20]
 8004c4c:	461a      	mov	r2, r3
 8004c4e:	687b      	ldr	r3, [r7, #4]
 8004c50:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004c52:	1ad3      	subs	r3, r2, r3
}
 8004c54:	4618      	mov	r0, r3
 8004c56:	370c      	adds	r7, #12
 8004c58:	46bd      	mov	sp, r7
 8004c5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004c5e:	4770      	bx	lr

08004c60 <HAL_ADC_ConvHalfCpltCallback>:

// ********************** IRQs ********************** //
int cndtr1 = 0;
int cndtr2 = 0;
void HAL_ADC_ConvHalfCpltCallback( ADC_HandleTypeDef* hadc )
{
 8004c60:	b480      	push	{r7}
 8004c62:	b083      	sub	sp, #12
 8004c64:	af00      	add	r7, sp, #0
 8004c66:	6078      	str	r0, [r7, #4]
	if( hadc == _scope->hadc1 )
	{
	}
}
 8004c68:	bf00      	nop
 8004c6a:	370c      	adds	r7, #12
 8004c6c:	46bd      	mov	sp, r7
 8004c6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004c72:	4770      	bx	lr

08004c74 <HAL_ADC_ConvCpltCallback>:

void HAL_ADC_ConvCpltCallback( ADC_HandleTypeDef* hadc )
{
 8004c74:	b580      	push	{r7, lr}
 8004c76:	b082      	sub	sp, #8
 8004c78:	af00      	add	r7, sp, #0
 8004c7a:	6078      	str	r0, [r7, #4]
	if( hadc == _scope->hadc1 )
 8004c7c:	4b15      	ldr	r3, [pc, #84]	; (8004cd4 <HAL_ADC_ConvCpltCallback+0x60>)
 8004c7e:	681b      	ldr	r3, [r3, #0]
 8004c80:	69db      	ldr	r3, [r3, #28]
 8004c82:	687a      	ldr	r2, [r7, #4]
 8004c84:	429a      	cmp	r2, r3
 8004c86:	d120      	bne.n	8004cca <HAL_ADC_ConvCpltCallback+0x56>
	{
		if( 1 && _scope->state == SCOPE_STATE_WAIT_FOR_CONVERSION_COMPLETE )
 8004c88:	4b12      	ldr	r3, [pc, #72]	; (8004cd4 <HAL_ADC_ConvCpltCallback+0x60>)
 8004c8a:	681b      	ldr	r3, [r3, #0]
 8004c8c:	781b      	ldrb	r3, [r3, #0]
 8004c8e:	2b01      	cmp	r3, #1
 8004c90:	d11b      	bne.n	8004cca <HAL_ADC_ConvCpltCallback+0x56>
		{
			_scope->state = SCOPE_STATE_WAIT_FOR_ARM;
 8004c92:	4b10      	ldr	r3, [pc, #64]	; (8004cd4 <HAL_ADC_ConvCpltCallback+0x60>)
 8004c94:	681b      	ldr	r3, [r3, #0]
 8004c96:	2202      	movs	r2, #2
 8004c98:	701a      	strb	r2, [r3, #0]
			_scope->CNDTRs[SCOPE_STATE_WAIT_FOR_ARM] = cndtr1;//_scope->hdma_adc1->Instance->CNDTR;
 8004c9a:	4b0e      	ldr	r3, [pc, #56]	; (8004cd4 <HAL_ADC_ConvCpltCallback+0x60>)
 8004c9c:	681b      	ldr	r3, [r3, #0]
 8004c9e:	4a0e      	ldr	r2, [pc, #56]	; (8004cd8 <HAL_ADC_ConvCpltCallback+0x64>)
 8004ca0:	6812      	ldr	r2, [r2, #0]
 8004ca2:	64da      	str	r2, [r3, #76]	; 0x4c
			__HAL_ADC_CLEAR_FLAG( _scope->hadc1, ADC_FLAG_AWD1 );
 8004ca4:	4b0b      	ldr	r3, [pc, #44]	; (8004cd4 <HAL_ADC_ConvCpltCallback+0x60>)
 8004ca6:	681b      	ldr	r3, [r3, #0]
 8004ca8:	69db      	ldr	r3, [r3, #28]
 8004caa:	681b      	ldr	r3, [r3, #0]
 8004cac:	2280      	movs	r2, #128	; 0x80
 8004cae:	601a      	str	r2, [r3, #0]
			//__HAL_ADC_CLEAR_FLAG( _scope->hadc1, ADC_FLAG_AWD2 );
			LL_ADC_EnableIT_AWD1( _scope->hadc1->Instance );
 8004cb0:	4b08      	ldr	r3, [pc, #32]	; (8004cd4 <HAL_ADC_ConvCpltCallback+0x60>)
 8004cb2:	681b      	ldr	r3, [r3, #0]
 8004cb4:	69db      	ldr	r3, [r3, #28]
 8004cb6:	681b      	ldr	r3, [r3, #0]
 8004cb8:	4618      	mov	r0, r3
 8004cba:	f7ff fe05 	bl	80048c8 <LL_ADC_EnableIT_AWD1>
			cndtr1 = 0;
 8004cbe:	4b06      	ldr	r3, [pc, #24]	; (8004cd8 <HAL_ADC_ConvCpltCallback+0x64>)
 8004cc0:	2200      	movs	r2, #0
 8004cc2:	601a      	str	r2, [r3, #0]
			cndtr2 = 0;
 8004cc4:	4b05      	ldr	r3, [pc, #20]	; (8004cdc <HAL_ADC_ConvCpltCallback+0x68>)
 8004cc6:	2200      	movs	r2, #0
 8004cc8:	601a      	str	r2, [r3, #0]
			LL_ADC_DisableIT_AWD2( _scope->hadc1->Instance );
			//__HAL_ADC_CLEAR_FLAG( _scope->hadc1, ADC_FLAG_AWD1 );
			//__HAL_ADC_CLEAR_FLAG( _scope->hadc1, ADC_FLAG_AWD2 );
		}
	}
}
 8004cca:	bf00      	nop
 8004ccc:	3708      	adds	r7, #8
 8004cce:	46bd      	mov	sp, r7
 8004cd0:	bd80      	pop	{r7, pc}
 8004cd2:	bf00      	nop
 8004cd4:	2001175c 	.word	0x2001175c
 8004cd8:	20011760 	.word	0x20011760
 8004cdc:	20011764 	.word	0x20011764

08004ce0 <HAL_ADC_LevelOutOfWindowCallback>:

void HAL_ADC_LevelOutOfWindowCallback( ADC_HandleTypeDef* hadc )
{
 8004ce0:	b580      	push	{r7, lr}
 8004ce2:	b082      	sub	sp, #8
 8004ce4:	af00      	add	r7, sp, #0
 8004ce6:	6078      	str	r0, [r7, #4]
	if( hadc == _scope->hadc1 )
 8004ce8:	4b17      	ldr	r3, [pc, #92]	; (8004d48 <HAL_ADC_LevelOutOfWindowCallback+0x68>)
 8004cea:	681b      	ldr	r3, [r3, #0]
 8004cec:	69db      	ldr	r3, [r3, #28]
 8004cee:	687a      	ldr	r2, [r7, #4]
 8004cf0:	429a      	cmp	r2, r3
 8004cf2:	d125      	bne.n	8004d40 <HAL_ADC_LevelOutOfWindowCallback+0x60>
	{
		if( _scope->state == SCOPE_STATE_WAIT_FOR_ARM )
 8004cf4:	4b14      	ldr	r3, [pc, #80]	; (8004d48 <HAL_ADC_LevelOutOfWindowCallback+0x68>)
 8004cf6:	681b      	ldr	r3, [r3, #0]
 8004cf8:	781b      	ldrb	r3, [r3, #0]
 8004cfa:	2b02      	cmp	r3, #2
 8004cfc:	d120      	bne.n	8004d40 <HAL_ADC_LevelOutOfWindowCallback+0x60>
		{
			_scope->state = SCOPE_STATE_WAIT_FOR_TRIGGER;
 8004cfe:	4b12      	ldr	r3, [pc, #72]	; (8004d48 <HAL_ADC_LevelOutOfWindowCallback+0x68>)
 8004d00:	681b      	ldr	r3, [r3, #0]
 8004d02:	2203      	movs	r2, #3
 8004d04:	701a      	strb	r2, [r3, #0]
			_scope->CNDTRs[SCOPE_STATE_WAIT_FOR_TRIGGER] = _scope->hdma_adc1->Instance->CNDTR;
 8004d06:	4b10      	ldr	r3, [pc, #64]	; (8004d48 <HAL_ADC_LevelOutOfWindowCallback+0x68>)
 8004d08:	681b      	ldr	r3, [r3, #0]
 8004d0a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004d0c:	681b      	ldr	r3, [r3, #0]
 8004d0e:	685a      	ldr	r2, [r3, #4]
 8004d10:	4b0d      	ldr	r3, [pc, #52]	; (8004d48 <HAL_ADC_LevelOutOfWindowCallback+0x68>)
 8004d12:	681b      	ldr	r3, [r3, #0]
 8004d14:	651a      	str	r2, [r3, #80]	; 0x50
			LL_ADC_DisableIT_AWD1( _scope->hadc1->Instance );
 8004d16:	4b0c      	ldr	r3, [pc, #48]	; (8004d48 <HAL_ADC_LevelOutOfWindowCallback+0x68>)
 8004d18:	681b      	ldr	r3, [r3, #0]
 8004d1a:	69db      	ldr	r3, [r3, #28]
 8004d1c:	681b      	ldr	r3, [r3, #0]
 8004d1e:	4618      	mov	r0, r3
 8004d20:	f7ff fdf2 	bl	8004908 <LL_ADC_DisableIT_AWD1>
			//__HAL_ADC_CLEAR_FLAG( _scope->hadc1, ADC_FLAG_AWD1 );
			__HAL_ADC_CLEAR_FLAG( _scope->hadc1, ADC_FLAG_AWD2 );
 8004d24:	4b08      	ldr	r3, [pc, #32]	; (8004d48 <HAL_ADC_LevelOutOfWindowCallback+0x68>)
 8004d26:	681b      	ldr	r3, [r3, #0]
 8004d28:	69db      	ldr	r3, [r3, #28]
 8004d2a:	681b      	ldr	r3, [r3, #0]
 8004d2c:	f44f 7280 	mov.w	r2, #256	; 0x100
 8004d30:	601a      	str	r2, [r3, #0]
			LL_ADC_EnableIT_AWD2( _scope->hadc1->Instance );
 8004d32:	4b05      	ldr	r3, [pc, #20]	; (8004d48 <HAL_ADC_LevelOutOfWindowCallback+0x68>)
 8004d34:	681b      	ldr	r3, [r3, #0]
 8004d36:	69db      	ldr	r3, [r3, #28]
 8004d38:	681b      	ldr	r3, [r3, #0]
 8004d3a:	4618      	mov	r0, r3
 8004d3c:	f7ff fdd4 	bl	80048e8 <LL_ADC_EnableIT_AWD2>
		}
	}
}
 8004d40:	bf00      	nop
 8004d42:	3708      	adds	r7, #8
 8004d44:	46bd      	mov	sp, r7
 8004d46:	bd80      	pop	{r7, pc}
 8004d48:	2001175c 	.word	0x2001175c

08004d4c <HAL_ADCEx_LevelOutOfWindow2Callback>:
uint32_t start_cpu;
uint32_t stop_cpu;

void HAL_ADCEx_LevelOutOfWindow2Callback( ADC_HandleTypeDef* hadc )
{
 8004d4c:	b580      	push	{r7, lr}
 8004d4e:	b082      	sub	sp, #8
 8004d50:	af00      	add	r7, sp, #0
 8004d52:	6078      	str	r0, [r7, #4]
	if( hadc == _scope->hadc1 )
 8004d54:	4b2c      	ldr	r3, [pc, #176]	; (8004e08 <HAL_ADCEx_LevelOutOfWindow2Callback+0xbc>)
 8004d56:	681b      	ldr	r3, [r3, #0]
 8004d58:	69db      	ldr	r3, [r3, #28]
 8004d5a:	687a      	ldr	r2, [r7, #4]
 8004d5c:	429a      	cmp	r2, r3
 8004d5e:	d14f      	bne.n	8004e00 <HAL_ADCEx_LevelOutOfWindow2Callback+0xb4>
	{
		if( _scope->state == SCOPE_STATE_WAIT_FOR_TRIGGER )
 8004d60:	4b29      	ldr	r3, [pc, #164]	; (8004e08 <HAL_ADCEx_LevelOutOfWindow2Callback+0xbc>)
 8004d62:	681b      	ldr	r3, [r3, #0]
 8004d64:	781b      	ldrb	r3, [r3, #0]
 8004d66:	2b03      	cmp	r3, #3
 8004d68:	d14a      	bne.n	8004e00 <HAL_ADCEx_LevelOutOfWindow2Callback+0xb4>
		{
			_scope->state = SCOPE_STATE_WAIT_FOR_STOP;
 8004d6a:	4b27      	ldr	r3, [pc, #156]	; (8004e08 <HAL_ADCEx_LevelOutOfWindow2Callback+0xbc>)
 8004d6c:	681b      	ldr	r3, [r3, #0]
 8004d6e:	2204      	movs	r2, #4
 8004d70:	701a      	strb	r2, [r3, #0]
			_scope->CNDTRs[SCOPE_STATE_WAIT_FOR_STOP] = cndtr1;//_scope->hdma_adc1->Instance->CNDTR;
 8004d72:	4b25      	ldr	r3, [pc, #148]	; (8004e08 <HAL_ADCEx_LevelOutOfWindow2Callback+0xbc>)
 8004d74:	681b      	ldr	r3, [r3, #0]
 8004d76:	4a25      	ldr	r2, [pc, #148]	; (8004e0c <HAL_ADCEx_LevelOutOfWindow2Callback+0xc0>)
 8004d78:	6812      	ldr	r2, [r2, #0]
 8004d7a:	655a      	str	r2, [r3, #84]	; 0x54

			//_scope->htim2->Instance->CCR1 = 127;
			__HAL_TIM_CLEAR_IT( _scope->htim2, TIM_IT_CC1 );
 8004d7c:	4b22      	ldr	r3, [pc, #136]	; (8004e08 <HAL_ADCEx_LevelOutOfWindow2Callback+0xbc>)
 8004d7e:	681b      	ldr	r3, [r3, #0]
 8004d80:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004d82:	681b      	ldr	r3, [r3, #0]
 8004d84:	f06f 0202 	mvn.w	r2, #2
 8004d88:	611a      	str	r2, [r3, #16]
			__HAL_TIM_CLEAR_IT( _scope->htim2, TIM_IT_CC2 );
 8004d8a:	4b1f      	ldr	r3, [pc, #124]	; (8004e08 <HAL_ADCEx_LevelOutOfWindow2Callback+0xbc>)
 8004d8c:	681b      	ldr	r3, [r3, #0]
 8004d8e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004d90:	681b      	ldr	r3, [r3, #0]
 8004d92:	f06f 0204 	mvn.w	r2, #4
 8004d96:	611a      	str	r2, [r3, #16]
			__HAL_TIM_CLEAR_IT( _scope->htim2, TIM_IT_UPDATE );
 8004d98:	4b1b      	ldr	r3, [pc, #108]	; (8004e08 <HAL_ADCEx_LevelOutOfWindow2Callback+0xbc>)
 8004d9a:	681b      	ldr	r3, [r3, #0]
 8004d9c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004d9e:	681b      	ldr	r3, [r3, #0]
 8004da0:	f06f 0201 	mvn.w	r2, #1
 8004da4:	611a      	str	r2, [r3, #16]
			__HAL_TIM_CLEAR_FLAG( _scope->htim2, TIM_FLAG_CC1 );
 8004da6:	4b18      	ldr	r3, [pc, #96]	; (8004e08 <HAL_ADCEx_LevelOutOfWindow2Callback+0xbc>)
 8004da8:	681b      	ldr	r3, [r3, #0]
 8004daa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004dac:	681b      	ldr	r3, [r3, #0]
 8004dae:	f06f 0202 	mvn.w	r2, #2
 8004db2:	611a      	str	r2, [r3, #16]
			__HAL_TIM_CLEAR_FLAG( _scope->htim2, TIM_FLAG_CC2 );
 8004db4:	4b14      	ldr	r3, [pc, #80]	; (8004e08 <HAL_ADCEx_LevelOutOfWindow2Callback+0xbc>)
 8004db6:	681b      	ldr	r3, [r3, #0]
 8004db8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004dba:	681b      	ldr	r3, [r3, #0]
 8004dbc:	f06f 0204 	mvn.w	r2, #4
 8004dc0:	611a      	str	r2, [r3, #16]
			__HAL_TIM_CLEAR_FLAG( _scope->htim2, TIM_FLAG_UPDATE );
 8004dc2:	4b11      	ldr	r3, [pc, #68]	; (8004e08 <HAL_ADCEx_LevelOutOfWindow2Callback+0xbc>)
 8004dc4:	681b      	ldr	r3, [r3, #0]
 8004dc6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004dc8:	681b      	ldr	r3, [r3, #0]
 8004dca:	f06f 0201 	mvn.w	r2, #1
 8004dce:	611a      	str	r2, [r3, #16]
			start_cpu = SysTick->VAL;
 8004dd0:	4b0f      	ldr	r3, [pc, #60]	; (8004e10 <HAL_ADCEx_LevelOutOfWindow2Callback+0xc4>)
 8004dd2:	689b      	ldr	r3, [r3, #8]
 8004dd4:	4a0f      	ldr	r2, [pc, #60]	; (8004e14 <HAL_ADCEx_LevelOutOfWindow2Callback+0xc8>)
 8004dd6:	6013      	str	r3, [r2, #0]
			HAL_TIM_Base_Start( _scope->htim2 );
 8004dd8:	4b0b      	ldr	r3, [pc, #44]	; (8004e08 <HAL_ADCEx_LevelOutOfWindow2Callback+0xbc>)
 8004dda:	681b      	ldr	r3, [r3, #0]
 8004ddc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004dde:	4618      	mov	r0, r3
 8004de0:	f006 fd56 	bl	800b890 <HAL_TIM_Base_Start>
			HAL_TIM_OnePulse_Start_IT( _scope->htim2, TIM_CHANNEL_1);
 8004de4:	4b08      	ldr	r3, [pc, #32]	; (8004e08 <HAL_ADCEx_LevelOutOfWindow2Callback+0xbc>)
 8004de6:	681b      	ldr	r3, [r3, #0]
 8004de8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004dea:	2100      	movs	r1, #0
 8004dec:	4618      	mov	r0, r3
 8004dee:	f006 fe47 	bl	800ba80 <HAL_TIM_OnePulse_Start_IT>
			//LL_ADC_DisableIT_AWD1( _scope->hadc1->Instance );
			LL_ADC_DisableIT_AWD2( _scope->hadc1->Instance );
 8004df2:	4b05      	ldr	r3, [pc, #20]	; (8004e08 <HAL_ADCEx_LevelOutOfWindow2Callback+0xbc>)
 8004df4:	681b      	ldr	r3, [r3, #0]
 8004df6:	69db      	ldr	r3, [r3, #28]
 8004df8:	681b      	ldr	r3, [r3, #0]
 8004dfa:	4618      	mov	r0, r3
 8004dfc:	f7ff fd94 	bl	8004928 <LL_ADC_DisableIT_AWD2>
			//__HAL_ADC_CLEAR_FLAG( _scope->hadc1, ADC_FLAG_AWD1 );
			//__HAL_ADC_CLEAR_FLAG( _scope->hadc1, ADC_FLAG_AWD2 );
		}
	}
}
 8004e00:	bf00      	nop
 8004e02:	3708      	adds	r7, #8
 8004e04:	46bd      	mov	sp, r7
 8004e06:	bd80      	pop	{r7, pc}
 8004e08:	2001175c 	.word	0x2001175c
 8004e0c:	20011760 	.word	0x20011760
 8004e10:	e000e010 	.word	0xe000e010
 8004e14:	20011768 	.word	0x20011768

08004e18 <HAL_TIM_OC_DelayElapsedCallback>:

void HAL_TIM_OC_DelayElapsedCallback( TIM_HandleTypeDef *htim )
{
 8004e18:	b580      	push	{r7, lr}
 8004e1a:	b082      	sub	sp, #8
 8004e1c:	af00      	add	r7, sp, #0
 8004e1e:	6078      	str	r0, [r7, #4]
	if( htim == _scope->htim2 ) // htim2
 8004e20:	4b23      	ldr	r3, [pc, #140]	; (8004eb0 <HAL_TIM_OC_DelayElapsedCallback+0x98>)
 8004e22:	681b      	ldr	r3, [r3, #0]
 8004e24:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004e26:	687a      	ldr	r2, [r7, #4]
 8004e28:	429a      	cmp	r2, r3
 8004e2a:	d13c      	bne.n	8004ea6 <HAL_TIM_OC_DelayElapsedCallback+0x8e>
	{
		if( _scope->state == SCOPE_STATE_WAIT_FOR_STOP )
 8004e2c:	4b20      	ldr	r3, [pc, #128]	; (8004eb0 <HAL_TIM_OC_DelayElapsedCallback+0x98>)
 8004e2e:	681b      	ldr	r3, [r3, #0]
 8004e30:	781b      	ldrb	r3, [r3, #0]
 8004e32:	2b04      	cmp	r3, #4
 8004e34:	d137      	bne.n	8004ea6 <HAL_TIM_OC_DelayElapsedCallback+0x8e>
		{
			stop_cpu = SysTick->VAL;
 8004e36:	4b1f      	ldr	r3, [pc, #124]	; (8004eb4 <HAL_TIM_OC_DelayElapsedCallback+0x9c>)
 8004e38:	689b      	ldr	r3, [r3, #8]
 8004e3a:	4a1f      	ldr	r2, [pc, #124]	; (8004eb8 <HAL_TIM_OC_DelayElapsedCallback+0xa0>)
 8004e3c:	6013      	str	r3, [r2, #0]
			_scope->state = SCOPE_STATE_DONE;
 8004e3e:	4b1c      	ldr	r3, [pc, #112]	; (8004eb0 <HAL_TIM_OC_DelayElapsedCallback+0x98>)
 8004e40:	681b      	ldr	r3, [r3, #0]
 8004e42:	2205      	movs	r2, #5
 8004e44:	701a      	strb	r2, [r3, #0]
			_scope->CNDTRs[SCOPE_STATE_DONE] = cndtr2;//_scope->hdma_adc1->Instance->CNDTR;
 8004e46:	4b1a      	ldr	r3, [pc, #104]	; (8004eb0 <HAL_TIM_OC_DelayElapsedCallback+0x98>)
 8004e48:	681b      	ldr	r3, [r3, #0]
 8004e4a:	4a1c      	ldr	r2, [pc, #112]	; (8004ebc <HAL_TIM_OC_DelayElapsedCallback+0xa4>)
 8004e4c:	6812      	ldr	r2, [r2, #0]
 8004e4e:	659a      	str	r2, [r3, #88]	; 0x58
			HAL_TIM_Base_Stop( _scope->htim1 );
 8004e50:	4b17      	ldr	r3, [pc, #92]	; (8004eb0 <HAL_TIM_OC_DelayElapsedCallback+0x98>)
 8004e52:	681b      	ldr	r3, [r3, #0]
 8004e54:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004e56:	4618      	mov	r0, r3
 8004e58:	f006 fd8a 	bl	800b970 <HAL_TIM_Base_Stop>
			HAL_ADC_Stop_DMA( _scope->hadc1 );
 8004e5c:	4b14      	ldr	r3, [pc, #80]	; (8004eb0 <HAL_TIM_OC_DelayElapsedCallback+0x98>)
 8004e5e:	681b      	ldr	r3, [r3, #0]
 8004e60:	69db      	ldr	r3, [r3, #28]
 8004e62:	4618      	mov	r0, r3
 8004e64:	f001 fdc8 	bl	80069f8 <HAL_ADC_Stop_DMA>
			HAL_ADC_Stop_DMA( _scope->hadc2 );
 8004e68:	4b11      	ldr	r3, [pc, #68]	; (8004eb0 <HAL_TIM_OC_DelayElapsedCallback+0x98>)
 8004e6a:	681b      	ldr	r3, [r3, #0]
 8004e6c:	6a1b      	ldr	r3, [r3, #32]
 8004e6e:	4618      	mov	r0, r3
 8004e70:	f001 fdc2 	bl	80069f8 <HAL_ADC_Stop_DMA>
			HAL_ADC_Stop_DMA( _scope->hadc3 );
 8004e74:	4b0e      	ldr	r3, [pc, #56]	; (8004eb0 <HAL_TIM_OC_DelayElapsedCallback+0x98>)
 8004e76:	681b      	ldr	r3, [r3, #0]
 8004e78:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004e7a:	4618      	mov	r0, r3
 8004e7c:	f001 fdbc 	bl	80069f8 <HAL_ADC_Stop_DMA>
			HAL_ADC_Stop_DMA( _scope->hadc4 );
 8004e80:	4b0b      	ldr	r3, [pc, #44]	; (8004eb0 <HAL_TIM_OC_DelayElapsedCallback+0x98>)
 8004e82:	681b      	ldr	r3, [r3, #0]
 8004e84:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004e86:	4618      	mov	r0, r3
 8004e88:	f001 fdb6 	bl	80069f8 <HAL_ADC_Stop_DMA>
			HAL_TIM_OnePulse_Stop_IT( _scope->htim2, TIM_CHANNEL_1);
 8004e8c:	4b08      	ldr	r3, [pc, #32]	; (8004eb0 <HAL_TIM_OC_DelayElapsedCallback+0x98>)
 8004e8e:	681b      	ldr	r3, [r3, #0]
 8004e90:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004e92:	2100      	movs	r1, #0
 8004e94:	4618      	mov	r0, r3
 8004e96:	f006 fe81 	bl	800bb9c <HAL_TIM_OnePulse_Stop_IT>
			HAL_TIM_Base_Stop( _scope->htim2 );
 8004e9a:	4b05      	ldr	r3, [pc, #20]	; (8004eb0 <HAL_TIM_OC_DelayElapsedCallback+0x98>)
 8004e9c:	681b      	ldr	r3, [r3, #0]
 8004e9e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004ea0:	4618      	mov	r0, r3
 8004ea2:	f006 fd65 	bl	800b970 <HAL_TIM_Base_Stop>
		}
	}
}
 8004ea6:	bf00      	nop
 8004ea8:	3708      	adds	r7, #8
 8004eaa:	46bd      	mov	sp, r7
 8004eac:	bd80      	pop	{r7, pc}
 8004eae:	bf00      	nop
 8004eb0:	2001175c 	.word	0x2001175c
 8004eb4:	e000e010 	.word	0xe000e010
 8004eb8:	2001176c 	.word	0x2001176c
 8004ebc:	20011764 	.word	0x20011764

08004ec0 <test_scope>:
uint16_t buffer6[BUFFER_LEN];
uint16_t buffer7[BUFFER_LEN];
uint16_t buffer8[BUFFER_LEN];
tScope scope = {0};
void test_scope( void )
{
 8004ec0:	b5b0      	push	{r4, r5, r7, lr}
 8004ec2:	b092      	sub	sp, #72	; 0x48
 8004ec4:	af04      	add	r7, sp, #16
	// test scope

	uint16_t start = 0;
 8004ec6:	2300      	movs	r3, #0
 8004ec8:	83fb      	strh	r3, [r7, #30]
	  static int trigger_bck = 0;
	  static int i = 0;

	if( _scope_init == 0 )
 8004eca:	4bab      	ldr	r3, [pc, #684]	; (8005178 <test_scope+0x2b8>)
 8004ecc:	681b      	ldr	r3, [r3, #0]
 8004ece:	2b00      	cmp	r3, #0
 8004ed0:	d17b      	bne.n	8004fca <test_scope+0x10a>
	{

		float freq = 3;
 8004ed2:	4baa      	ldr	r3, [pc, #680]	; (800517c <test_scope+0x2bc>)
 8004ed4:	61bb      	str	r3, [r7, #24]
		for( int i = 0 ; i < BUFFER_LEN ; i++ )
 8004ed6:	2300      	movs	r3, #0
 8004ed8:	637b      	str	r3, [r7, #52]	; 0x34
 8004eda:	e054      	b.n	8004f86 <test_scope+0xc6>
		{
			dac1_buffer[i] = sinf(freq*2*M_PI*i/BUFFER_LEN)*1023 + 2048;
 8004edc:	edd7 7a06 	vldr	s15, [r7, #24]
 8004ee0:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8004ee4:	ee17 0a90 	vmov	r0, s15
 8004ee8:	f7fb fb56 	bl	8000598 <__aeabi_f2d>
 8004eec:	a3a0      	add	r3, pc, #640	; (adr r3, 8005170 <test_scope+0x2b0>)
 8004eee:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004ef2:	f7fb fba9 	bl	8000648 <__aeabi_dmul>
 8004ef6:	4602      	mov	r2, r0
 8004ef8:	460b      	mov	r3, r1
 8004efa:	4614      	mov	r4, r2
 8004efc:	461d      	mov	r5, r3
 8004efe:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8004f00:	f7fb fb38 	bl	8000574 <__aeabi_i2d>
 8004f04:	4602      	mov	r2, r0
 8004f06:	460b      	mov	r3, r1
 8004f08:	4620      	mov	r0, r4
 8004f0a:	4629      	mov	r1, r5
 8004f0c:	f7fb fb9c 	bl	8000648 <__aeabi_dmul>
 8004f10:	4602      	mov	r2, r0
 8004f12:	460b      	mov	r3, r1
 8004f14:	4610      	mov	r0, r2
 8004f16:	4619      	mov	r1, r3
 8004f18:	f04f 0200 	mov.w	r2, #0
 8004f1c:	4b98      	ldr	r3, [pc, #608]	; (8005180 <test_scope+0x2c0>)
 8004f1e:	f7fb fcbd 	bl	800089c <__aeabi_ddiv>
 8004f22:	4602      	mov	r2, r0
 8004f24:	460b      	mov	r3, r1
 8004f26:	4610      	mov	r0, r2
 8004f28:	4619      	mov	r1, r3
 8004f2a:	f7fb fe85 	bl	8000c38 <__aeabi_d2f>
 8004f2e:	4603      	mov	r3, r0
 8004f30:	ee00 3a10 	vmov	s0, r3
 8004f34:	f01b fbe4 	bl	8020700 <sinf>
 8004f38:	eef0 7a40 	vmov.f32	s15, s0
 8004f3c:	ed9f 7a91 	vldr	s14, [pc, #580]	; 8005184 <test_scope+0x2c4>
 8004f40:	ee67 7a87 	vmul.f32	s15, s15, s14
 8004f44:	ed9f 7a90 	vldr	s14, [pc, #576]	; 8005188 <test_scope+0x2c8>
 8004f48:	ee77 7a87 	vadd.f32	s15, s15, s14
 8004f4c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8004f50:	ee17 3a90 	vmov	r3, s15
 8004f54:	b299      	uxth	r1, r3
 8004f56:	4a8d      	ldr	r2, [pc, #564]	; (800518c <test_scope+0x2cc>)
 8004f58:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004f5a:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
			//dac2_buffer[i] = sinf(freq*2*M_PI*i/BUFFER_LEN)*2000 + 2048;
			dac2_buffer[i] = 1024+((i*8)%2048);
 8004f5e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004f60:	00db      	lsls	r3, r3, #3
 8004f62:	425a      	negs	r2, r3
 8004f64:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8004f68:	f3c2 020a 	ubfx	r2, r2, #0, #11
 8004f6c:	bf58      	it	pl
 8004f6e:	4253      	negpl	r3, r2
 8004f70:	b29b      	uxth	r3, r3
 8004f72:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8004f76:	b299      	uxth	r1, r3
 8004f78:	4a85      	ldr	r2, [pc, #532]	; (8005190 <test_scope+0x2d0>)
 8004f7a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004f7c:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
		for( int i = 0 ; i < BUFFER_LEN ; i++ )
 8004f80:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004f82:	3301      	adds	r3, #1
 8004f84:	637b      	str	r3, [r7, #52]	; 0x34
 8004f86:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004f88:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8004f8c:	dba6      	blt.n	8004edc <test_scope+0x1c>
		}
		extern DAC_HandleTypeDef hdac1;
		extern TIM_HandleTypeDef htim2;
		extern TIM_HandleTypeDef htim3;
		__HAL_DBGMCU_FREEZE_TIM3();
 8004f8e:	4b81      	ldr	r3, [pc, #516]	; (8005194 <test_scope+0x2d4>)
 8004f90:	689b      	ldr	r3, [r3, #8]
 8004f92:	4a80      	ldr	r2, [pc, #512]	; (8005194 <test_scope+0x2d4>)
 8004f94:	f043 0302 	orr.w	r3, r3, #2
 8004f98:	6093      	str	r3, [r2, #8]
		HAL_DAC_Start_DMA( &hdac1, DAC_CHANNEL_1, (uint32_t*)dac1_buffer, BUFFER_LEN, DAC_ALIGN_12B_R );
 8004f9a:	2300      	movs	r3, #0
 8004f9c:	9300      	str	r3, [sp, #0]
 8004f9e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004fa2:	4a7a      	ldr	r2, [pc, #488]	; (800518c <test_scope+0x2cc>)
 8004fa4:	2100      	movs	r1, #0
 8004fa6:	487c      	ldr	r0, [pc, #496]	; (8005198 <test_scope+0x2d8>)
 8004fa8:	f003 fbb8 	bl	800871c <HAL_DAC_Start_DMA>
		HAL_DAC_Start_DMA( &hdac1, DAC_CHANNEL_2, (uint32_t*)dac2_buffer, BUFFER_LEN, DAC_ALIGN_12B_R );
 8004fac:	2300      	movs	r3, #0
 8004fae:	9300      	str	r3, [sp, #0]
 8004fb0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004fb4:	4a76      	ldr	r2, [pc, #472]	; (8005190 <test_scope+0x2d0>)
 8004fb6:	2110      	movs	r1, #16
 8004fb8:	4877      	ldr	r0, [pc, #476]	; (8005198 <test_scope+0x2d8>)
 8004fba:	f003 fbaf 	bl	800871c <HAL_DAC_Start_DMA>
		//HAL_DAC_Start(&hdac1, DAC_CHANNEL_1);
		HAL_TIM_Base_Start( &htim3 );
 8004fbe:	4877      	ldr	r0, [pc, #476]	; (800519c <test_scope+0x2dc>)
 8004fc0:	f006 fc66 	bl	800b890 <HAL_TIM_Base_Start>
		//htim1.Instance->ARR = 0x54;
		//htim1.Instance->CNT = 0x2A;
		//HAL_TIM_Base_Start( &htim1 );


		_scope_init = 1;
 8004fc4:	4b6c      	ldr	r3, [pc, #432]	; (8005178 <test_scope+0x2b8>)
 8004fc6:	2201      	movs	r2, #1
 8004fc8:	601a      	str	r2, [r3, #0]


	{

		static int dd = 0;
		if( dd<10 )
 8004fca:	4b75      	ldr	r3, [pc, #468]	; (80051a0 <test_scope+0x2e0>)
 8004fcc:	681b      	ldr	r3, [r3, #0]
 8004fce:	2b09      	cmp	r3, #9
 8004fd0:	dc05      	bgt.n	8004fde <test_scope+0x11e>
		{
			dd++;
 8004fd2:	4b73      	ldr	r3, [pc, #460]	; (80051a0 <test_scope+0x2e0>)
 8004fd4:	681b      	ldr	r3, [r3, #0]
 8004fd6:	3301      	adds	r3, #1
 8004fd8:	4a71      	ldr	r2, [pc, #452]	; (80051a0 <test_scope+0x2e0>)
 8004fda:	6013      	str	r3, [r2, #0]
 8004fdc:	e04a      	b.n	8005074 <test_scope+0x1b4>
		}
		else
		{
			dd = 0;
 8004fde:	4b70      	ldr	r3, [pc, #448]	; (80051a0 <test_scope+0x2e0>)
 8004fe0:	2200      	movs	r2, #0
 8004fe2:	601a      	str	r2, [r3, #0]
			for( int d = 0 ; d < 480 ; d += 40 )
 8004fe4:	2300      	movs	r3, #0
 8004fe6:	633b      	str	r3, [r7, #48]	; 0x30
 8004fe8:	e00c      	b.n	8005004 <test_scope+0x144>
			{
				lcd_rect( d, 0, 1, 320, 0x55555555 );
 8004fea:	f04f 3355 	mov.w	r3, #1431655765	; 0x55555555
 8004fee:	9300      	str	r3, [sp, #0]
 8004ff0:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8004ff4:	2201      	movs	r2, #1
 8004ff6:	2100      	movs	r1, #0
 8004ff8:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8004ffa:	f7fc fe17 	bl	8001c2c <lcd_rect>
			for( int d = 0 ; d < 480 ; d += 40 )
 8004ffe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005000:	3328      	adds	r3, #40	; 0x28
 8005002:	633b      	str	r3, [r7, #48]	; 0x30
 8005004:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005006:	f5b3 7ff0 	cmp.w	r3, #480	; 0x1e0
 800500a:	dbee      	blt.n	8004fea <test_scope+0x12a>
			}
			lcd_rect( 480, 0, 1, 320, 0x55555555 );
 800500c:	f04f 3355 	mov.w	r3, #1431655765	; 0x55555555
 8005010:	9300      	str	r3, [sp, #0]
 8005012:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8005016:	2201      	movs	r2, #1
 8005018:	2100      	movs	r1, #0
 800501a:	f44f 70f0 	mov.w	r0, #480	; 0x1e0
 800501e:	f7fc fe05 	bl	8001c2c <lcd_rect>
			for( int d = 0 ; d < 320 ; d += 40 )
 8005022:	2300      	movs	r3, #0
 8005024:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005026:	e00c      	b.n	8005042 <test_scope+0x182>
			{
				lcd_rect( 0, d, 480, 1, 0x55555555 );
 8005028:	f04f 3355 	mov.w	r3, #1431655765	; 0x55555555
 800502c:	9300      	str	r3, [sp, #0]
 800502e:	2301      	movs	r3, #1
 8005030:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 8005034:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8005036:	2000      	movs	r0, #0
 8005038:	f7fc fdf8 	bl	8001c2c <lcd_rect>
			for( int d = 0 ; d < 320 ; d += 40 )
 800503c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800503e:	3328      	adds	r3, #40	; 0x28
 8005040:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005042:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005044:	f5b3 7fa0 	cmp.w	r3, #320	; 0x140
 8005048:	dbee      	blt.n	8005028 <test_scope+0x168>
			}
			lcd_rect( 0, 320, 480, 1, 0x55555555 );
 800504a:	f04f 3355 	mov.w	r3, #1431655765	; 0x55555555
 800504e:	9300      	str	r3, [sp, #0]
 8005050:	2301      	movs	r3, #1
 8005052:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 8005056:	f44f 71a0 	mov.w	r1, #320	; 0x140
 800505a:	2000      	movs	r0, #0
 800505c:	f7fc fde6 	bl	8001c2c <lcd_rect>

			lcd_rect( 0, 320-((2048+768)*320)/4096, 480, 1, 0xFFFFFF00 );
 8005060:	f06f 03ff 	mvn.w	r3, #255	; 0xff
 8005064:	9300      	str	r3, [sp, #0]
 8005066:	2301      	movs	r3, #1
 8005068:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 800506c:	2164      	movs	r1, #100	; 0x64
 800506e:	2000      	movs	r0, #0
 8005070:	f7fc fddc 	bl	8001c2c <lcd_rect>

		}


		scope_init( &scope, 2048, 1000000,
				(i&0x01)?buffer1:buffer5,
 8005074:	4b4b      	ldr	r3, [pc, #300]	; (80051a4 <test_scope+0x2e4>)
 8005076:	681b      	ldr	r3, [r3, #0]
 8005078:	f003 0301 	and.w	r3, r3, #1
		scope_init( &scope, 2048, 1000000,
 800507c:	2b00      	cmp	r3, #0
 800507e:	d001      	beq.n	8005084 <test_scope+0x1c4>
 8005080:	4849      	ldr	r0, [pc, #292]	; (80051a8 <test_scope+0x2e8>)
 8005082:	e000      	b.n	8005086 <test_scope+0x1c6>
 8005084:	4849      	ldr	r0, [pc, #292]	; (80051ac <test_scope+0x2ec>)
				(i&0x01)?buffer2:buffer6,
 8005086:	4b47      	ldr	r3, [pc, #284]	; (80051a4 <test_scope+0x2e4>)
 8005088:	681b      	ldr	r3, [r3, #0]
 800508a:	f003 0301 	and.w	r3, r3, #1
		scope_init( &scope, 2048, 1000000,
 800508e:	2b00      	cmp	r3, #0
 8005090:	d001      	beq.n	8005096 <test_scope+0x1d6>
 8005092:	4b47      	ldr	r3, [pc, #284]	; (80051b0 <test_scope+0x2f0>)
 8005094:	e000      	b.n	8005098 <test_scope+0x1d8>
 8005096:	4b47      	ldr	r3, [pc, #284]	; (80051b4 <test_scope+0x2f4>)
				(i&0x01)?buffer3:buffer7,
 8005098:	4a42      	ldr	r2, [pc, #264]	; (80051a4 <test_scope+0x2e4>)
 800509a:	6812      	ldr	r2, [r2, #0]
 800509c:	f002 0201 	and.w	r2, r2, #1
		scope_init( &scope, 2048, 1000000,
 80050a0:	2a00      	cmp	r2, #0
 80050a2:	d001      	beq.n	80050a8 <test_scope+0x1e8>
 80050a4:	4a44      	ldr	r2, [pc, #272]	; (80051b8 <test_scope+0x2f8>)
 80050a6:	e000      	b.n	80050aa <test_scope+0x1ea>
 80050a8:	4a44      	ldr	r2, [pc, #272]	; (80051bc <test_scope+0x2fc>)
				(i&0x01)?buffer4:buffer8,
 80050aa:	493e      	ldr	r1, [pc, #248]	; (80051a4 <test_scope+0x2e4>)
 80050ac:	6809      	ldr	r1, [r1, #0]
 80050ae:	f001 0101 	and.w	r1, r1, #1
		scope_init( &scope, 2048, 1000000,
 80050b2:	2900      	cmp	r1, #0
 80050b4:	d001      	beq.n	80050ba <test_scope+0x1fa>
 80050b6:	4942      	ldr	r1, [pc, #264]	; (80051c0 <test_scope+0x300>)
 80050b8:	e000      	b.n	80050bc <test_scope+0x1fc>
 80050ba:	4942      	ldr	r1, [pc, #264]	; (80051c4 <test_scope+0x304>)
 80050bc:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80050c0:	9403      	str	r4, [sp, #12]
 80050c2:	9102      	str	r1, [sp, #8]
 80050c4:	9201      	str	r2, [sp, #4]
 80050c6:	9300      	str	r3, [sp, #0]
 80050c8:	4603      	mov	r3, r0
 80050ca:	f244 2240 	movw	r2, #16960	; 0x4240
 80050ce:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80050d2:	483d      	ldr	r0, [pc, #244]	; (80051c8 <test_scope+0x308>)
 80050d4:	f7ff fc38 	bl	8004948 <scope_init>
				BUFFER_LEN );
		scope_start( &scope );
 80050d8:	483b      	ldr	r0, [pc, #236]	; (80051c8 <test_scope+0x308>)
 80050da:	f7ff fc99 	bl	8004a10 <scope_start>
		while( scope_is_busy( &scope ) );
 80050de:	bf00      	nop
 80050e0:	4839      	ldr	r0, [pc, #228]	; (80051c8 <test_scope+0x308>)
 80050e2:	f7ff fd9c 	bl	8004c1e <scope_is_busy>
 80050e6:	4603      	mov	r3, r0
 80050e8:	2b00      	cmp	r3, #0
 80050ea:	d1f9      	bne.n	80050e0 <test_scope+0x220>
		scope_stop( &scope );
 80050ec:	4836      	ldr	r0, [pc, #216]	; (80051c8 <test_scope+0x308>)
 80050ee:	f7ff fd67 	bl	8004bc0 <scope_stop>

		int32_t trigger = scope_get_trigger( &scope ) - BUFFER_LEN/2;
 80050f2:	4835      	ldr	r0, [pc, #212]	; (80051c8 <test_scope+0x308>)
 80050f4:	f7ff fda4 	bl	8004c40 <scope_get_trigger>
 80050f8:	4603      	mov	r3, r0
 80050fa:	f5a3 7300 	sub.w	r3, r3, #512	; 0x200
 80050fe:	617b      	str	r3, [r7, #20]

		//printf( "data%d = np.array( [", i );
		for( int jj = 0; jj < 480; jj++ )
 8005100:	2300      	movs	r3, #0
 8005102:	62bb      	str	r3, [r7, #40]	; 0x28
 8005104:	e21a      	b.n	800553c <test_scope+0x67c>
		//for( int jj = 0; jj < BUFFER_LEN; jj++ )
		{
			int j = (jj*BUFFER_LEN)/480.0;
 8005106:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005108:	029b      	lsls	r3, r3, #10
 800510a:	4618      	mov	r0, r3
 800510c:	f7fb fa32 	bl	8000574 <__aeabi_i2d>
 8005110:	f04f 0200 	mov.w	r2, #0
 8005114:	4b2d      	ldr	r3, [pc, #180]	; (80051cc <test_scope+0x30c>)
 8005116:	f7fb fbc1 	bl	800089c <__aeabi_ddiv>
 800511a:	4602      	mov	r2, r0
 800511c:	460b      	mov	r3, r1
 800511e:	4610      	mov	r0, r2
 8005120:	4619      	mov	r1, r3
 8005122:	f7fb fd41 	bl	8000ba8 <__aeabi_d2iz>
 8005126:	4603      	mov	r3, r0
 8005128:	613b      	str	r3, [r7, #16]
			//int j = jj;
			int n = trigger + j;
 800512a:	697a      	ldr	r2, [r7, #20]
 800512c:	693b      	ldr	r3, [r7, #16]
 800512e:	4413      	add	r3, r2
 8005130:	627b      	str	r3, [r7, #36]	; 0x24
			if( n < 0 )
 8005132:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005134:	2b00      	cmp	r3, #0
 8005136:	da04      	bge.n	8005142 <test_scope+0x282>
			{
				n += BUFFER_LEN;
 8005138:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800513a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800513e:	627b      	str	r3, [r7, #36]	; 0x24
 8005140:	e007      	b.n	8005152 <test_scope+0x292>
			}
			else if( n >= BUFFER_LEN )
 8005142:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005144:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8005148:	db03      	blt.n	8005152 <test_scope+0x292>
			{
				n -= BUFFER_LEN;
 800514a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800514c:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
 8005150:	627b      	str	r3, [r7, #36]	; 0x24
			}

			int n2 = trigger_bck + j;
 8005152:	4b1f      	ldr	r3, [pc, #124]	; (80051d0 <test_scope+0x310>)
 8005154:	681b      	ldr	r3, [r3, #0]
 8005156:	693a      	ldr	r2, [r7, #16]
 8005158:	4413      	add	r3, r2
 800515a:	623b      	str	r3, [r7, #32]
			if( n2 < 0 )
 800515c:	6a3b      	ldr	r3, [r7, #32]
 800515e:	2b00      	cmp	r3, #0
 8005160:	da38      	bge.n	80051d4 <test_scope+0x314>
			{
				n2 += BUFFER_LEN;
 8005162:	6a3b      	ldr	r3, [r7, #32]
 8005164:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005168:	623b      	str	r3, [r7, #32]
 800516a:	e03b      	b.n	80051e4 <test_scope+0x324>
 800516c:	f3af 8000 	nop.w
 8005170:	54442d18 	.word	0x54442d18
 8005174:	400921fb 	.word	0x400921fb
 8005178:	20011770 	.word	0x20011770
 800517c:	40400000 	.word	0x40400000
 8005180:	40900000 	.word	0x40900000
 8005184:	447fc000 	.word	0x447fc000
 8005188:	45000000 	.word	0x45000000
 800518c:	20011774 	.word	0x20011774
 8005190:	20011f74 	.word	0x20011f74
 8005194:	e0042000 	.word	0xe0042000
 8005198:	200006a8 	.word	0x200006a8
 800519c:	200168dc 	.word	0x200168dc
 80051a0:	200167d0 	.word	0x200167d0
 80051a4:	200167d4 	.word	0x200167d4
 80051a8:	20012774 	.word	0x20012774
 80051ac:	20014774 	.word	0x20014774
 80051b0:	20012f74 	.word	0x20012f74
 80051b4:	20014f74 	.word	0x20014f74
 80051b8:	20013774 	.word	0x20013774
 80051bc:	20015774 	.word	0x20015774
 80051c0:	20013f74 	.word	0x20013f74
 80051c4:	20015f74 	.word	0x20015f74
 80051c8:	20016774 	.word	0x20016774
 80051cc:	407e0000 	.word	0x407e0000
 80051d0:	200167d8 	.word	0x200167d8
			}
			else if( n2 >= BUFFER_LEN )
 80051d4:	6a3b      	ldr	r3, [r7, #32]
 80051d6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80051da:	db03      	blt.n	80051e4 <test_scope+0x324>
			{
				n2 -= BUFFER_LEN;
 80051dc:	6a3b      	ldr	r3, [r7, #32]
 80051de:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
 80051e2:	623b      	str	r3, [r7, #32]
			}
			//printf( "%d, ", buffer[n] );

			int x0, y0, y1;
			x0 = jj;//(j*480)/BUFFER_LEN;
 80051e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80051e6:	60fb      	str	r3, [r7, #12]
			y0 = 320-(((i&0x01)?buffer5[n2]:buffer1[n2])*320)/4096;
 80051e8:	4bb7      	ldr	r3, [pc, #732]	; (80054c8 <test_scope+0x608>)
 80051ea:	681b      	ldr	r3, [r3, #0]
 80051ec:	f003 0301 	and.w	r3, r3, #1
 80051f0:	2b00      	cmp	r3, #0
 80051f2:	d011      	beq.n	8005218 <test_scope+0x358>
 80051f4:	4ab5      	ldr	r2, [pc, #724]	; (80054cc <test_scope+0x60c>)
 80051f6:	6a3b      	ldr	r3, [r7, #32]
 80051f8:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80051fc:	461a      	mov	r2, r3
 80051fe:	4613      	mov	r3, r2
 8005200:	009b      	lsls	r3, r3, #2
 8005202:	4413      	add	r3, r2
 8005204:	019b      	lsls	r3, r3, #6
 8005206:	2b00      	cmp	r3, #0
 8005208:	da01      	bge.n	800520e <test_scope+0x34e>
 800520a:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
 800520e:	131b      	asrs	r3, r3, #12
 8005210:	425b      	negs	r3, r3
 8005212:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 8005216:	e010      	b.n	800523a <test_scope+0x37a>
 8005218:	4aad      	ldr	r2, [pc, #692]	; (80054d0 <test_scope+0x610>)
 800521a:	6a3b      	ldr	r3, [r7, #32]
 800521c:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8005220:	461a      	mov	r2, r3
 8005222:	4613      	mov	r3, r2
 8005224:	009b      	lsls	r3, r3, #2
 8005226:	4413      	add	r3, r2
 8005228:	019b      	lsls	r3, r3, #6
 800522a:	2b00      	cmp	r3, #0
 800522c:	da01      	bge.n	8005232 <test_scope+0x372>
 800522e:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
 8005232:	131b      	asrs	r3, r3, #12
 8005234:	425b      	negs	r3, r3
 8005236:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 800523a:	60bb      	str	r3, [r7, #8]
			y1 = 320-(((i&0x01)?buffer1[n]:buffer5[n])*320)/4096;
 800523c:	4ba2      	ldr	r3, [pc, #648]	; (80054c8 <test_scope+0x608>)
 800523e:	681b      	ldr	r3, [r3, #0]
 8005240:	f003 0301 	and.w	r3, r3, #1
 8005244:	2b00      	cmp	r3, #0
 8005246:	d011      	beq.n	800526c <test_scope+0x3ac>
 8005248:	4aa1      	ldr	r2, [pc, #644]	; (80054d0 <test_scope+0x610>)
 800524a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800524c:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8005250:	461a      	mov	r2, r3
 8005252:	4613      	mov	r3, r2
 8005254:	009b      	lsls	r3, r3, #2
 8005256:	4413      	add	r3, r2
 8005258:	019b      	lsls	r3, r3, #6
 800525a:	2b00      	cmp	r3, #0
 800525c:	da01      	bge.n	8005262 <test_scope+0x3a2>
 800525e:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
 8005262:	131b      	asrs	r3, r3, #12
 8005264:	425b      	negs	r3, r3
 8005266:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 800526a:	e010      	b.n	800528e <test_scope+0x3ce>
 800526c:	4a97      	ldr	r2, [pc, #604]	; (80054cc <test_scope+0x60c>)
 800526e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005270:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8005274:	461a      	mov	r2, r3
 8005276:	4613      	mov	r3, r2
 8005278:	009b      	lsls	r3, r3, #2
 800527a:	4413      	add	r3, r2
 800527c:	019b      	lsls	r3, r3, #6
 800527e:	2b00      	cmp	r3, #0
 8005280:	da01      	bge.n	8005286 <test_scope+0x3c6>
 8005282:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
 8005286:	131b      	asrs	r3, r3, #12
 8005288:	425b      	negs	r3, r3
 800528a:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 800528e:	607b      	str	r3, [r7, #4]
			extern void lcd_set_pixel( int16_t x, int16_t y, uint32_t color );
			lcd_set_pixel( x0, y0, 0x00000000 );
 8005290:	68fb      	ldr	r3, [r7, #12]
 8005292:	b21b      	sxth	r3, r3
 8005294:	68ba      	ldr	r2, [r7, #8]
 8005296:	b211      	sxth	r1, r2
 8005298:	2200      	movs	r2, #0
 800529a:	4618      	mov	r0, r3
 800529c:	f7fc fdb8 	bl	8001e10 <lcd_set_pixel>
			lcd_set_pixel( x0, y1, 0x0001C007 );
 80052a0:	68fb      	ldr	r3, [r7, #12]
 80052a2:	b21b      	sxth	r3, r3
 80052a4:	687a      	ldr	r2, [r7, #4]
 80052a6:	b211      	sxth	r1, r2
 80052a8:	4a8a      	ldr	r2, [pc, #552]	; (80054d4 <test_scope+0x614>)
 80052aa:	4618      	mov	r0, r3
 80052ac:	f7fc fdb0 	bl	8001e10 <lcd_set_pixel>

			y0 = 320-(((i&0x01)?buffer6[n2]:buffer2[n2])*320)/4096;
 80052b0:	4b85      	ldr	r3, [pc, #532]	; (80054c8 <test_scope+0x608>)
 80052b2:	681b      	ldr	r3, [r3, #0]
 80052b4:	f003 0301 	and.w	r3, r3, #1
 80052b8:	2b00      	cmp	r3, #0
 80052ba:	d011      	beq.n	80052e0 <test_scope+0x420>
 80052bc:	4a86      	ldr	r2, [pc, #536]	; (80054d8 <test_scope+0x618>)
 80052be:	6a3b      	ldr	r3, [r7, #32]
 80052c0:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80052c4:	461a      	mov	r2, r3
 80052c6:	4613      	mov	r3, r2
 80052c8:	009b      	lsls	r3, r3, #2
 80052ca:	4413      	add	r3, r2
 80052cc:	019b      	lsls	r3, r3, #6
 80052ce:	2b00      	cmp	r3, #0
 80052d0:	da01      	bge.n	80052d6 <test_scope+0x416>
 80052d2:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
 80052d6:	131b      	asrs	r3, r3, #12
 80052d8:	425b      	negs	r3, r3
 80052da:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 80052de:	e010      	b.n	8005302 <test_scope+0x442>
 80052e0:	4a7e      	ldr	r2, [pc, #504]	; (80054dc <test_scope+0x61c>)
 80052e2:	6a3b      	ldr	r3, [r7, #32]
 80052e4:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80052e8:	461a      	mov	r2, r3
 80052ea:	4613      	mov	r3, r2
 80052ec:	009b      	lsls	r3, r3, #2
 80052ee:	4413      	add	r3, r2
 80052f0:	019b      	lsls	r3, r3, #6
 80052f2:	2b00      	cmp	r3, #0
 80052f4:	da01      	bge.n	80052fa <test_scope+0x43a>
 80052f6:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
 80052fa:	131b      	asrs	r3, r3, #12
 80052fc:	425b      	negs	r3, r3
 80052fe:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 8005302:	60bb      	str	r3, [r7, #8]
			y1 = 320-(((i&0x01)?buffer2[n]:buffer6[n])*320)/4096;
 8005304:	4b70      	ldr	r3, [pc, #448]	; (80054c8 <test_scope+0x608>)
 8005306:	681b      	ldr	r3, [r3, #0]
 8005308:	f003 0301 	and.w	r3, r3, #1
 800530c:	2b00      	cmp	r3, #0
 800530e:	d011      	beq.n	8005334 <test_scope+0x474>
 8005310:	4a72      	ldr	r2, [pc, #456]	; (80054dc <test_scope+0x61c>)
 8005312:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005314:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8005318:	461a      	mov	r2, r3
 800531a:	4613      	mov	r3, r2
 800531c:	009b      	lsls	r3, r3, #2
 800531e:	4413      	add	r3, r2
 8005320:	019b      	lsls	r3, r3, #6
 8005322:	2b00      	cmp	r3, #0
 8005324:	da01      	bge.n	800532a <test_scope+0x46a>
 8005326:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
 800532a:	131b      	asrs	r3, r3, #12
 800532c:	425b      	negs	r3, r3
 800532e:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 8005332:	e010      	b.n	8005356 <test_scope+0x496>
 8005334:	4a68      	ldr	r2, [pc, #416]	; (80054d8 <test_scope+0x618>)
 8005336:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005338:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800533c:	461a      	mov	r2, r3
 800533e:	4613      	mov	r3, r2
 8005340:	009b      	lsls	r3, r3, #2
 8005342:	4413      	add	r3, r2
 8005344:	019b      	lsls	r3, r3, #6
 8005346:	2b00      	cmp	r3, #0
 8005348:	da01      	bge.n	800534e <test_scope+0x48e>
 800534a:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
 800534e:	131b      	asrs	r3, r3, #12
 8005350:	425b      	negs	r3, r3
 8005352:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 8005356:	607b      	str	r3, [r7, #4]
			lcd_set_pixel( x0, y0, 0x00000000 );
 8005358:	68fb      	ldr	r3, [r7, #12]
 800535a:	b21b      	sxth	r3, r3
 800535c:	68ba      	ldr	r2, [r7, #8]
 800535e:	b211      	sxth	r1, r2
 8005360:	2200      	movs	r2, #0
 8005362:	4618      	mov	r0, r3
 8005364:	f7fc fd54 	bl	8001e10 <lcd_set_pixel>
			lcd_set_pixel( x0, y1, 0x00003F00 );
 8005368:	68fb      	ldr	r3, [r7, #12]
 800536a:	b21b      	sxth	r3, r3
 800536c:	687a      	ldr	r2, [r7, #4]
 800536e:	b211      	sxth	r1, r2
 8005370:	f44f 527c 	mov.w	r2, #16128	; 0x3f00
 8005374:	4618      	mov	r0, r3
 8005376:	f7fc fd4b 	bl	8001e10 <lcd_set_pixel>

			y0 = 320-(((i&0x01)?buffer7[n2]:buffer3[n2])*320)/4096;
 800537a:	4b53      	ldr	r3, [pc, #332]	; (80054c8 <test_scope+0x608>)
 800537c:	681b      	ldr	r3, [r3, #0]
 800537e:	f003 0301 	and.w	r3, r3, #1
 8005382:	2b00      	cmp	r3, #0
 8005384:	d011      	beq.n	80053aa <test_scope+0x4ea>
 8005386:	4a56      	ldr	r2, [pc, #344]	; (80054e0 <test_scope+0x620>)
 8005388:	6a3b      	ldr	r3, [r7, #32]
 800538a:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800538e:	461a      	mov	r2, r3
 8005390:	4613      	mov	r3, r2
 8005392:	009b      	lsls	r3, r3, #2
 8005394:	4413      	add	r3, r2
 8005396:	019b      	lsls	r3, r3, #6
 8005398:	2b00      	cmp	r3, #0
 800539a:	da01      	bge.n	80053a0 <test_scope+0x4e0>
 800539c:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
 80053a0:	131b      	asrs	r3, r3, #12
 80053a2:	425b      	negs	r3, r3
 80053a4:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 80053a8:	e010      	b.n	80053cc <test_scope+0x50c>
 80053aa:	4a4e      	ldr	r2, [pc, #312]	; (80054e4 <test_scope+0x624>)
 80053ac:	6a3b      	ldr	r3, [r7, #32]
 80053ae:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80053b2:	461a      	mov	r2, r3
 80053b4:	4613      	mov	r3, r2
 80053b6:	009b      	lsls	r3, r3, #2
 80053b8:	4413      	add	r3, r2
 80053ba:	019b      	lsls	r3, r3, #6
 80053bc:	2b00      	cmp	r3, #0
 80053be:	da01      	bge.n	80053c4 <test_scope+0x504>
 80053c0:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
 80053c4:	131b      	asrs	r3, r3, #12
 80053c6:	425b      	negs	r3, r3
 80053c8:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 80053cc:	60bb      	str	r3, [r7, #8]
			y1 = 320-(((i&0x01)?buffer3[n]:buffer7[n])*320)/4096;
 80053ce:	4b3e      	ldr	r3, [pc, #248]	; (80054c8 <test_scope+0x608>)
 80053d0:	681b      	ldr	r3, [r3, #0]
 80053d2:	f003 0301 	and.w	r3, r3, #1
 80053d6:	2b00      	cmp	r3, #0
 80053d8:	d011      	beq.n	80053fe <test_scope+0x53e>
 80053da:	4a42      	ldr	r2, [pc, #264]	; (80054e4 <test_scope+0x624>)
 80053dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80053de:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80053e2:	461a      	mov	r2, r3
 80053e4:	4613      	mov	r3, r2
 80053e6:	009b      	lsls	r3, r3, #2
 80053e8:	4413      	add	r3, r2
 80053ea:	019b      	lsls	r3, r3, #6
 80053ec:	2b00      	cmp	r3, #0
 80053ee:	da01      	bge.n	80053f4 <test_scope+0x534>
 80053f0:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
 80053f4:	131b      	asrs	r3, r3, #12
 80053f6:	425b      	negs	r3, r3
 80053f8:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 80053fc:	e010      	b.n	8005420 <test_scope+0x560>
 80053fe:	4a38      	ldr	r2, [pc, #224]	; (80054e0 <test_scope+0x620>)
 8005400:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005402:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8005406:	461a      	mov	r2, r3
 8005408:	4613      	mov	r3, r2
 800540a:	009b      	lsls	r3, r3, #2
 800540c:	4413      	add	r3, r2
 800540e:	019b      	lsls	r3, r3, #6
 8005410:	2b00      	cmp	r3, #0
 8005412:	da01      	bge.n	8005418 <test_scope+0x558>
 8005414:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
 8005418:	131b      	asrs	r3, r3, #12
 800541a:	425b      	negs	r3, r3
 800541c:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 8005420:	607b      	str	r3, [r7, #4]
			lcd_set_pixel( x0, y0, 0x00000000 );
 8005422:	68fb      	ldr	r3, [r7, #12]
 8005424:	b21b      	sxth	r3, r3
 8005426:	68ba      	ldr	r2, [r7, #8]
 8005428:	b211      	sxth	r1, r2
 800542a:	2200      	movs	r2, #0
 800542c:	4618      	mov	r0, r3
 800542e:	f7fc fcef 	bl	8001e10 <lcd_set_pixel>
			lcd_set_pixel( x0, y1, 0x000001F8 );
 8005432:	68fb      	ldr	r3, [r7, #12]
 8005434:	b21b      	sxth	r3, r3
 8005436:	687a      	ldr	r2, [r7, #4]
 8005438:	b211      	sxth	r1, r2
 800543a:	f44f 72fc 	mov.w	r2, #504	; 0x1f8
 800543e:	4618      	mov	r0, r3
 8005440:	f7fc fce6 	bl	8001e10 <lcd_set_pixel>

			y0 = 320-(((i&0x01)?buffer8[n2]:buffer4[n2])*320)/4096;
 8005444:	4b20      	ldr	r3, [pc, #128]	; (80054c8 <test_scope+0x608>)
 8005446:	681b      	ldr	r3, [r3, #0]
 8005448:	f003 0301 	and.w	r3, r3, #1
 800544c:	2b00      	cmp	r3, #0
 800544e:	d011      	beq.n	8005474 <test_scope+0x5b4>
 8005450:	4a25      	ldr	r2, [pc, #148]	; (80054e8 <test_scope+0x628>)
 8005452:	6a3b      	ldr	r3, [r7, #32]
 8005454:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8005458:	461a      	mov	r2, r3
 800545a:	4613      	mov	r3, r2
 800545c:	009b      	lsls	r3, r3, #2
 800545e:	4413      	add	r3, r2
 8005460:	019b      	lsls	r3, r3, #6
 8005462:	2b00      	cmp	r3, #0
 8005464:	da01      	bge.n	800546a <test_scope+0x5aa>
 8005466:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
 800546a:	131b      	asrs	r3, r3, #12
 800546c:	425b      	negs	r3, r3
 800546e:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 8005472:	e010      	b.n	8005496 <test_scope+0x5d6>
 8005474:	4a1d      	ldr	r2, [pc, #116]	; (80054ec <test_scope+0x62c>)
 8005476:	6a3b      	ldr	r3, [r7, #32]
 8005478:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800547c:	461a      	mov	r2, r3
 800547e:	4613      	mov	r3, r2
 8005480:	009b      	lsls	r3, r3, #2
 8005482:	4413      	add	r3, r2
 8005484:	019b      	lsls	r3, r3, #6
 8005486:	2b00      	cmp	r3, #0
 8005488:	da01      	bge.n	800548e <test_scope+0x5ce>
 800548a:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
 800548e:	131b      	asrs	r3, r3, #12
 8005490:	425b      	negs	r3, r3
 8005492:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 8005496:	60bb      	str	r3, [r7, #8]
			y1 = 320-(((i&0x01)?buffer4[n]:buffer8[n])*320)/4096;
 8005498:	4b0b      	ldr	r3, [pc, #44]	; (80054c8 <test_scope+0x608>)
 800549a:	681b      	ldr	r3, [r3, #0]
 800549c:	f003 0301 	and.w	r3, r3, #1
 80054a0:	2b00      	cmp	r3, #0
 80054a2:	d025      	beq.n	80054f0 <test_scope+0x630>
 80054a4:	4a11      	ldr	r2, [pc, #68]	; (80054ec <test_scope+0x62c>)
 80054a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80054a8:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80054ac:	461a      	mov	r2, r3
 80054ae:	4613      	mov	r3, r2
 80054b0:	009b      	lsls	r3, r3, #2
 80054b2:	4413      	add	r3, r2
 80054b4:	019b      	lsls	r3, r3, #6
 80054b6:	2b00      	cmp	r3, #0
 80054b8:	da01      	bge.n	80054be <test_scope+0x5fe>
 80054ba:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
 80054be:	131b      	asrs	r3, r3, #12
 80054c0:	425b      	negs	r3, r3
 80054c2:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 80054c6:	e024      	b.n	8005512 <test_scope+0x652>
 80054c8:	200167d4 	.word	0x200167d4
 80054cc:	20014774 	.word	0x20014774
 80054d0:	20012774 	.word	0x20012774
 80054d4:	0001c007 	.word	0x0001c007
 80054d8:	20014f74 	.word	0x20014f74
 80054dc:	20012f74 	.word	0x20012f74
 80054e0:	20015774 	.word	0x20015774
 80054e4:	20013774 	.word	0x20013774
 80054e8:	20015f74 	.word	0x20015f74
 80054ec:	20013f74 	.word	0x20013f74
 80054f0:	4a1b      	ldr	r2, [pc, #108]	; (8005560 <test_scope+0x6a0>)
 80054f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80054f4:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80054f8:	461a      	mov	r2, r3
 80054fa:	4613      	mov	r3, r2
 80054fc:	009b      	lsls	r3, r3, #2
 80054fe:	4413      	add	r3, r2
 8005500:	019b      	lsls	r3, r3, #6
 8005502:	2b00      	cmp	r3, #0
 8005504:	da01      	bge.n	800550a <test_scope+0x64a>
 8005506:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
 800550a:	131b      	asrs	r3, r3, #12
 800550c:	425b      	negs	r3, r3
 800550e:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 8005512:	607b      	str	r3, [r7, #4]
			lcd_set_pixel( x0, y0, 0x00000000 );
 8005514:	68fb      	ldr	r3, [r7, #12]
 8005516:	b21b      	sxth	r3, r3
 8005518:	68ba      	ldr	r2, [r7, #8]
 800551a:	b211      	sxth	r1, r2
 800551c:	2200      	movs	r2, #0
 800551e:	4618      	mov	r0, r3
 8005520:	f7fc fc76 	bl	8001e10 <lcd_set_pixel>
			lcd_set_pixel( x0, y1, 0xFFFFFFFF );
 8005524:	68fb      	ldr	r3, [r7, #12]
 8005526:	b21b      	sxth	r3, r3
 8005528:	687a      	ldr	r2, [r7, #4]
 800552a:	b211      	sxth	r1, r2
 800552c:	f04f 32ff 	mov.w	r2, #4294967295
 8005530:	4618      	mov	r0, r3
 8005532:	f7fc fc6d 	bl	8001e10 <lcd_set_pixel>
		for( int jj = 0; jj < 480; jj++ )
 8005536:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005538:	3301      	adds	r3, #1
 800553a:	62bb      	str	r3, [r7, #40]	; 0x28
 800553c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800553e:	f5b3 7ff0 	cmp.w	r3, #480	; 0x1e0
 8005542:	f6ff ade0 	blt.w	8005106 <test_scope+0x246>

		}

		//lcd_rect( 240, 0, 1, 320, 0xFFFFFF00 );
		//printf( "], dtype=np.float32 )\n" );
		i += 1;
 8005546:	4b07      	ldr	r3, [pc, #28]	; (8005564 <test_scope+0x6a4>)
 8005548:	681b      	ldr	r3, [r3, #0]
 800554a:	3301      	adds	r3, #1
 800554c:	4a05      	ldr	r2, [pc, #20]	; (8005564 <test_scope+0x6a4>)
 800554e:	6013      	str	r3, [r2, #0]
		trigger_bck = trigger;
 8005550:	4a05      	ldr	r2, [pc, #20]	; (8005568 <test_scope+0x6a8>)
 8005552:	697b      	ldr	r3, [r7, #20]
 8005554:	6013      	str	r3, [r2, #0]
		//HAL_Delay( 10 );
	}
}
 8005556:	bf00      	nop
 8005558:	3738      	adds	r7, #56	; 0x38
 800555a:	46bd      	mov	sp, r7
 800555c:	bdb0      	pop	{r4, r5, r7, pc}
 800555e:	bf00      	nop
 8005560:	20015f74 	.word	0x20015f74
 8005564:	200167d4 	.word	0x200167d4
 8005568:	200167d8 	.word	0x200167d8

0800556c <MX_SPI3_Init>:

SPI_HandleTypeDef hspi3;

/* SPI3 init function */
void MX_SPI3_Init(void)
{
 800556c:	b580      	push	{r7, lr}
 800556e:	af00      	add	r7, sp, #0
  /* USER CODE END SPI3_Init 0 */

  /* USER CODE BEGIN SPI3_Init 1 */

  /* USER CODE END SPI3_Init 1 */
  hspi3.Instance = SPI3;
 8005570:	4b1b      	ldr	r3, [pc, #108]	; (80055e0 <MX_SPI3_Init+0x74>)
 8005572:	4a1c      	ldr	r2, [pc, #112]	; (80055e4 <MX_SPI3_Init+0x78>)
 8005574:	601a      	str	r2, [r3, #0]
  hspi3.Init.Mode = SPI_MODE_MASTER;
 8005576:	4b1a      	ldr	r3, [pc, #104]	; (80055e0 <MX_SPI3_Init+0x74>)
 8005578:	f44f 7282 	mov.w	r2, #260	; 0x104
 800557c:	605a      	str	r2, [r3, #4]
  hspi3.Init.Direction = SPI_DIRECTION_2LINES;
 800557e:	4b18      	ldr	r3, [pc, #96]	; (80055e0 <MX_SPI3_Init+0x74>)
 8005580:	2200      	movs	r2, #0
 8005582:	609a      	str	r2, [r3, #8]
  hspi3.Init.DataSize = SPI_DATASIZE_8BIT;
 8005584:	4b16      	ldr	r3, [pc, #88]	; (80055e0 <MX_SPI3_Init+0x74>)
 8005586:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 800558a:	60da      	str	r2, [r3, #12]
  hspi3.Init.CLKPolarity = SPI_POLARITY_LOW;
 800558c:	4b14      	ldr	r3, [pc, #80]	; (80055e0 <MX_SPI3_Init+0x74>)
 800558e:	2200      	movs	r2, #0
 8005590:	611a      	str	r2, [r3, #16]
  hspi3.Init.CLKPhase = SPI_PHASE_1EDGE;
 8005592:	4b13      	ldr	r3, [pc, #76]	; (80055e0 <MX_SPI3_Init+0x74>)
 8005594:	2200      	movs	r2, #0
 8005596:	615a      	str	r2, [r3, #20]
  hspi3.Init.NSS = SPI_NSS_SOFT;
 8005598:	4b11      	ldr	r3, [pc, #68]	; (80055e0 <MX_SPI3_Init+0x74>)
 800559a:	f44f 7200 	mov.w	r2, #512	; 0x200
 800559e:	619a      	str	r2, [r3, #24]
  hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_128;
 80055a0:	4b0f      	ldr	r3, [pc, #60]	; (80055e0 <MX_SPI3_Init+0x74>)
 80055a2:	2230      	movs	r2, #48	; 0x30
 80055a4:	61da      	str	r2, [r3, #28]
  hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;
 80055a6:	4b0e      	ldr	r3, [pc, #56]	; (80055e0 <MX_SPI3_Init+0x74>)
 80055a8:	2200      	movs	r2, #0
 80055aa:	621a      	str	r2, [r3, #32]
  hspi3.Init.TIMode = SPI_TIMODE_DISABLE;
 80055ac:	4b0c      	ldr	r3, [pc, #48]	; (80055e0 <MX_SPI3_Init+0x74>)
 80055ae:	2200      	movs	r2, #0
 80055b0:	625a      	str	r2, [r3, #36]	; 0x24
  hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80055b2:	4b0b      	ldr	r3, [pc, #44]	; (80055e0 <MX_SPI3_Init+0x74>)
 80055b4:	2200      	movs	r2, #0
 80055b6:	629a      	str	r2, [r3, #40]	; 0x28
  hspi3.Init.CRCPolynomial = 7;
 80055b8:	4b09      	ldr	r3, [pc, #36]	; (80055e0 <MX_SPI3_Init+0x74>)
 80055ba:	2207      	movs	r2, #7
 80055bc:	62da      	str	r2, [r3, #44]	; 0x2c
  hspi3.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 80055be:	4b08      	ldr	r3, [pc, #32]	; (80055e0 <MX_SPI3_Init+0x74>)
 80055c0:	2200      	movs	r2, #0
 80055c2:	631a      	str	r2, [r3, #48]	; 0x30
  hspi3.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
 80055c4:	4b06      	ldr	r3, [pc, #24]	; (80055e0 <MX_SPI3_Init+0x74>)
 80055c6:	2200      	movs	r2, #0
 80055c8:	635a      	str	r2, [r3, #52]	; 0x34
  if (HAL_SPI_Init(&hspi3) != HAL_OK)
 80055ca:	4805      	ldr	r0, [pc, #20]	; (80055e0 <MX_SPI3_Init+0x74>)
 80055cc:	f005 fc9e 	bl	800af0c <HAL_SPI_Init>
 80055d0:	4603      	mov	r3, r0
 80055d2:	2b00      	cmp	r3, #0
 80055d4:	d001      	beq.n	80055da <MX_SPI3_Init+0x6e>
  {
    Error_Handler();
 80055d6:	f7fe fefa 	bl	80043ce <Error_Handler>
  }
  /* USER CODE BEGIN SPI3_Init 2 */

  /* USER CODE END SPI3_Init 2 */

}
 80055da:	bf00      	nop
 80055dc:	bd80      	pop	{r7, pc}
 80055de:	bf00      	nop
 80055e0:	200167dc 	.word	0x200167dc
 80055e4:	40003c00 	.word	0x40003c00

080055e8 <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{
 80055e8:	b580      	push	{r7, lr}
 80055ea:	b08a      	sub	sp, #40	; 0x28
 80055ec:	af00      	add	r7, sp, #0
 80055ee:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80055f0:	f107 0314 	add.w	r3, r7, #20
 80055f4:	2200      	movs	r2, #0
 80055f6:	601a      	str	r2, [r3, #0]
 80055f8:	605a      	str	r2, [r3, #4]
 80055fa:	609a      	str	r2, [r3, #8]
 80055fc:	60da      	str	r2, [r3, #12]
 80055fe:	611a      	str	r2, [r3, #16]
  if(spiHandle->Instance==SPI3)
 8005600:	687b      	ldr	r3, [r7, #4]
 8005602:	681b      	ldr	r3, [r3, #0]
 8005604:	4a17      	ldr	r2, [pc, #92]	; (8005664 <HAL_SPI_MspInit+0x7c>)
 8005606:	4293      	cmp	r3, r2
 8005608:	d128      	bne.n	800565c <HAL_SPI_MspInit+0x74>
  {
  /* USER CODE BEGIN SPI3_MspInit 0 */

  /* USER CODE END SPI3_MspInit 0 */
    /* SPI3 clock enable */
    __HAL_RCC_SPI3_CLK_ENABLE();
 800560a:	4b17      	ldr	r3, [pc, #92]	; (8005668 <HAL_SPI_MspInit+0x80>)
 800560c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800560e:	4a16      	ldr	r2, [pc, #88]	; (8005668 <HAL_SPI_MspInit+0x80>)
 8005610:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8005614:	6593      	str	r3, [r2, #88]	; 0x58
 8005616:	4b14      	ldr	r3, [pc, #80]	; (8005668 <HAL_SPI_MspInit+0x80>)
 8005618:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800561a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800561e:	613b      	str	r3, [r7, #16]
 8005620:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOC_CLK_ENABLE();
 8005622:	4b11      	ldr	r3, [pc, #68]	; (8005668 <HAL_SPI_MspInit+0x80>)
 8005624:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8005626:	4a10      	ldr	r2, [pc, #64]	; (8005668 <HAL_SPI_MspInit+0x80>)
 8005628:	f043 0304 	orr.w	r3, r3, #4
 800562c:	64d3      	str	r3, [r2, #76]	; 0x4c
 800562e:	4b0e      	ldr	r3, [pc, #56]	; (8005668 <HAL_SPI_MspInit+0x80>)
 8005630:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8005632:	f003 0304 	and.w	r3, r3, #4
 8005636:	60fb      	str	r3, [r7, #12]
 8005638:	68fb      	ldr	r3, [r7, #12]
    /**SPI3 GPIO Configuration
    PC10     ------> SPI3_SCK
    PC11     ------> SPI3_MISO
    PC12     ------> SPI3_MOSI
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12;
 800563a:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 800563e:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005640:	2302      	movs	r3, #2
 8005642:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005644:	2300      	movs	r3, #0
 8005646:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8005648:	2300      	movs	r3, #0
 800564a:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 800564c:	2306      	movs	r3, #6
 800564e:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8005650:	f107 0314 	add.w	r3, r7, #20
 8005654:	4619      	mov	r1, r3
 8005656:	4805      	ldr	r0, [pc, #20]	; (800566c <HAL_SPI_MspInit+0x84>)
 8005658:	f003 fed8 	bl	800940c <HAL_GPIO_Init>

  /* USER CODE BEGIN SPI3_MspInit 1 */

  /* USER CODE END SPI3_MspInit 1 */
  }
}
 800565c:	bf00      	nop
 800565e:	3728      	adds	r7, #40	; 0x28
 8005660:	46bd      	mov	sp, r7
 8005662:	bd80      	pop	{r7, pc}
 8005664:	40003c00 	.word	0x40003c00
 8005668:	40021000 	.word	0x40021000
 800566c:	48000800 	.word	0x48000800

08005670 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8005670:	b580      	push	{r7, lr}
 8005672:	b082      	sub	sp, #8
 8005674:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8005676:	4b10      	ldr	r3, [pc, #64]	; (80056b8 <HAL_MspInit+0x48>)
 8005678:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800567a:	4a0f      	ldr	r2, [pc, #60]	; (80056b8 <HAL_MspInit+0x48>)
 800567c:	f043 0301 	orr.w	r3, r3, #1
 8005680:	6613      	str	r3, [r2, #96]	; 0x60
 8005682:	4b0d      	ldr	r3, [pc, #52]	; (80056b8 <HAL_MspInit+0x48>)
 8005684:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8005686:	f003 0301 	and.w	r3, r3, #1
 800568a:	607b      	str	r3, [r7, #4]
 800568c:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 800568e:	4b0a      	ldr	r3, [pc, #40]	; (80056b8 <HAL_MspInit+0x48>)
 8005690:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005692:	4a09      	ldr	r2, [pc, #36]	; (80056b8 <HAL_MspInit+0x48>)
 8005694:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8005698:	6593      	str	r3, [r2, #88]	; 0x58
 800569a:	4b07      	ldr	r3, [pc, #28]	; (80056b8 <HAL_MspInit+0x48>)
 800569c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800569e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80056a2:	603b      	str	r3, [r7, #0]
 80056a4:	683b      	ldr	r3, [r7, #0]

  /* System interrupt init*/

  /** Disable the Internal Voltage Reference buffer
  */
  HAL_SYSCFG_DisableVREFBUF();
 80056a6:	f000 fb97 	bl	8005dd8 <HAL_SYSCFG_DisableVREFBUF>

  /** Configure the internal voltage reference buffer high impedance mode
  */
  HAL_SYSCFG_VREFBUF_HighImpedanceConfig(SYSCFG_VREFBUF_HIGH_IMPEDANCE_ENABLE);
 80056aa:	2002      	movs	r0, #2
 80056ac:	f000 fb80 	bl	8005db0 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80056b0:	bf00      	nop
 80056b2:	3708      	adds	r7, #8
 80056b4:	46bd      	mov	sp, r7
 80056b6:	bd80      	pop	{r7, pc}
 80056b8:	40021000 	.word	0x40021000

080056bc <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 80056bc:	b480      	push	{r7}
 80056be:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 80056c0:	e7fe      	b.n	80056c0 <NMI_Handler+0x4>

080056c2 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 80056c2:	b480      	push	{r7}
 80056c4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 80056c6:	e7fe      	b.n	80056c6 <HardFault_Handler+0x4>

080056c8 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 80056c8:	b480      	push	{r7}
 80056ca:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 80056cc:	e7fe      	b.n	80056cc <MemManage_Handler+0x4>

080056ce <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 80056ce:	b480      	push	{r7}
 80056d0:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 80056d2:	e7fe      	b.n	80056d2 <BusFault_Handler+0x4>

080056d4 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 80056d4:	b480      	push	{r7}
 80056d6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 80056d8:	e7fe      	b.n	80056d8 <UsageFault_Handler+0x4>

080056da <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 80056da:	b480      	push	{r7}
 80056dc:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 80056de:	bf00      	nop
 80056e0:	46bd      	mov	sp, r7
 80056e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80056e6:	4770      	bx	lr

080056e8 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 80056e8:	b480      	push	{r7}
 80056ea:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 80056ec:	bf00      	nop
 80056ee:	46bd      	mov	sp, r7
 80056f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80056f4:	4770      	bx	lr

080056f6 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 80056f6:	b480      	push	{r7}
 80056f8:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 80056fa:	bf00      	nop
 80056fc:	46bd      	mov	sp, r7
 80056fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005702:	4770      	bx	lr

08005704 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8005704:	b580      	push	{r7, lr}
 8005706:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8005708:	f000 fb12 	bl	8005d30 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 800570c:	bf00      	nop
 800570e:	bd80      	pop	{r7, pc}

08005710 <DMA1_Channel1_IRQHandler>:

/**
  * @brief This function handles DMA1 channel1 global interrupt.
  */
void DMA1_Channel1_IRQHandler(void)
{
 8005710:	b580      	push	{r7, lr}
 8005712:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Channel1_IRQn 0 */

  /* USER CODE END DMA1_Channel1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_quadspi);
 8005714:	4802      	ldr	r0, [pc, #8]	; (8005720 <DMA1_Channel1_IRQHandler+0x10>)
 8005716:	f003 fd2a 	bl	800916e <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel1_IRQn 1 */

  /* USER CODE END DMA1_Channel1_IRQn 1 */
}
 800571a:	bf00      	nop
 800571c:	bd80      	pop	{r7, pc}
 800571e:	bf00      	nop
 8005720:	200116fc 	.word	0x200116fc

08005724 <DMA1_Channel2_IRQHandler>:

/**
  * @brief This function handles DMA1 channel2 global interrupt.
  */
void DMA1_Channel2_IRQHandler(void)
{
 8005724:	b580      	push	{r7, lr}
 8005726:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Channel2_IRQn 0 */

  /* USER CODE END DMA1_Channel2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc1);
 8005728:	4802      	ldr	r0, [pc, #8]	; (8005734 <DMA1_Channel2_IRQHandler+0x10>)
 800572a:	f003 fd20 	bl	800916e <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel2_IRQn 1 */

  /* USER CODE END DMA1_Channel2_IRQn 1 */
}
 800572e:	bf00      	nop
 8005730:	bd80      	pop	{r7, pc}
 8005732:	bf00      	nop
 8005734:	20000524 	.word	0x20000524

08005738 <DMA1_Channel3_IRQHandler>:

/**
  * @brief This function handles DMA1 channel3 global interrupt.
  */
void DMA1_Channel3_IRQHandler(void)
{
 8005738:	b580      	push	{r7, lr}
 800573a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Channel3_IRQn 0 */

  /* USER CODE END DMA1_Channel3_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_dac1_ch1);
 800573c:	4802      	ldr	r0, [pc, #8]	; (8005748 <DMA1_Channel3_IRQHandler+0x10>)
 800573e:	f003 fd16 	bl	800916e <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel3_IRQn 1 */

  /* USER CODE END DMA1_Channel3_IRQn 1 */
}
 8005742:	bf00      	nop
 8005744:	bd80      	pop	{r7, pc}
 8005746:	bf00      	nop
 8005748:	200006d0 	.word	0x200006d0

0800574c <DMA1_Channel4_IRQHandler>:

/**
  * @brief This function handles DMA1 channel4 global interrupt.
  */
void DMA1_Channel4_IRQHandler(void)
{
 800574c:	b580      	push	{r7, lr}
 800574e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Channel4_IRQn 0 */

  /* USER CODE END DMA1_Channel4_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_dac1_ch2);
 8005750:	4802      	ldr	r0, [pc, #8]	; (800575c <DMA1_Channel4_IRQHandler+0x10>)
 8005752:	f003 fd0c 	bl	800916e <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel4_IRQn 1 */

  /* USER CODE END DMA1_Channel4_IRQn 1 */
}
 8005756:	bf00      	nop
 8005758:	bd80      	pop	{r7, pc}
 800575a:	bf00      	nop
 800575c:	20000730 	.word	0x20000730

08005760 <DMA1_Channel5_IRQHandler>:

/**
  * @brief This function handles DMA1 channel5 global interrupt.
  */
void DMA1_Channel5_IRQHandler(void)
{
 8005760:	b580      	push	{r7, lr}
 8005762:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Channel5_IRQn 0 */

  /* USER CODE END DMA1_Channel5_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc3);
 8005764:	4802      	ldr	r0, [pc, #8]	; (8005770 <DMA1_Channel5_IRQHandler+0x10>)
 8005766:	f003 fd02 	bl	800916e <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel5_IRQn 1 */

  /* USER CODE END DMA1_Channel5_IRQn 1 */
}
 800576a:	bf00      	nop
 800576c:	bd80      	pop	{r7, pc}
 800576e:	bf00      	nop
 8005770:	20000584 	.word	0x20000584

08005774 <DMA1_Channel6_IRQHandler>:

/**
  * @brief This function handles DMA1 channel6 global interrupt.
  */
void DMA1_Channel6_IRQHandler(void)
{
 8005774:	b580      	push	{r7, lr}
 8005776:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Channel6_IRQn 0 */

  /* USER CODE END DMA1_Channel6_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc4);
 8005778:	4802      	ldr	r0, [pc, #8]	; (8005784 <DMA1_Channel6_IRQHandler+0x10>)
 800577a:	f003 fcf8 	bl	800916e <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel6_IRQn 1 */

  /* USER CODE END DMA1_Channel6_IRQn 1 */
}
 800577e:	bf00      	nop
 8005780:	bd80      	pop	{r7, pc}
 8005782:	bf00      	nop
 8005784:	200005e4 	.word	0x200005e4

08005788 <DMA1_Channel7_IRQHandler>:

/**
  * @brief This function handles DMA1 channel7 global interrupt.
  */
void DMA1_Channel7_IRQHandler(void)
{
 8005788:	b580      	push	{r7, lr}
 800578a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Channel7_IRQn 0 */

  /* USER CODE END DMA1_Channel7_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc5);
 800578c:	4802      	ldr	r0, [pc, #8]	; (8005798 <DMA1_Channel7_IRQHandler+0x10>)
 800578e:	f003 fcee 	bl	800916e <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel7_IRQn 1 */

  /* USER CODE END DMA1_Channel7_IRQn 1 */
}
 8005792:	bf00      	nop
 8005794:	bd80      	pop	{r7, pc}
 8005796:	bf00      	nop
 8005798:	20000644 	.word	0x20000644

0800579c <ADC1_2_IRQHandler>:

/**
  * @brief This function handles ADC1 and ADC2 global interrupt.
  */
void ADC1_2_IRQHandler(void)
{
 800579c:	b580      	push	{r7, lr}
 800579e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN ADC1_2_IRQn 0 */
	extern int cndtr1;
	cndtr1 = hdma_adc1.Instance->CNDTR;
 80057a0:	4b05      	ldr	r3, [pc, #20]	; (80057b8 <ADC1_2_IRQHandler+0x1c>)
 80057a2:	681b      	ldr	r3, [r3, #0]
 80057a4:	685b      	ldr	r3, [r3, #4]
 80057a6:	461a      	mov	r2, r3
 80057a8:	4b04      	ldr	r3, [pc, #16]	; (80057bc <ADC1_2_IRQHandler+0x20>)
 80057aa:	601a      	str	r2, [r3, #0]
  /* USER CODE END ADC1_2_IRQn 0 */
  HAL_ADC_IRQHandler(&hadc1);
 80057ac:	4804      	ldr	r0, [pc, #16]	; (80057c0 <ADC1_2_IRQHandler+0x24>)
 80057ae:	f001 f985 	bl	8006abc <HAL_ADC_IRQHandler>
  /* USER CODE BEGIN ADC1_2_IRQn 1 */

  /* USER CODE END ADC1_2_IRQn 1 */
}
 80057b2:	bf00      	nop
 80057b4:	bd80      	pop	{r7, pc}
 80057b6:	bf00      	nop
 80057b8:	20000524 	.word	0x20000524
 80057bc:	20011760 	.word	0x20011760
 80057c0:	20000374 	.word	0x20000374

080057c4 <TIM2_IRQHandler>:

/**
  * @brief This function handles TIM2 global interrupt.
  */
void TIM2_IRQHandler(void)
{
 80057c4:	b580      	push	{r7, lr}
 80057c6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM2_IRQn 0 */
	extern int cndtr2;
	cndtr2 = hdma_adc1.Instance->CNDTR;
 80057c8:	4b05      	ldr	r3, [pc, #20]	; (80057e0 <TIM2_IRQHandler+0x1c>)
 80057ca:	681b      	ldr	r3, [r3, #0]
 80057cc:	685b      	ldr	r3, [r3, #4]
 80057ce:	461a      	mov	r2, r3
 80057d0:	4b04      	ldr	r3, [pc, #16]	; (80057e4 <TIM2_IRQHandler+0x20>)
 80057d2:	601a      	str	r2, [r3, #0]
  /* USER CODE END TIM2_IRQn 0 */
  HAL_TIM_IRQHandler(&htim2);
 80057d4:	4804      	ldr	r0, [pc, #16]	; (80057e8 <TIM2_IRQHandler+0x24>)
 80057d6:	f006 fa79 	bl	800bccc <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM2_IRQn 1 */

  /* USER CODE END TIM2_IRQn 1 */
}
 80057da:	bf00      	nop
 80057dc:	bd80      	pop	{r7, pc}
 80057de:	bf00      	nop
 80057e0:	20000524 	.word	0x20000524
 80057e4:	20011764 	.word	0x20011764
 80057e8:	20016890 	.word	0x20016890

080057ec <QUADSPI_IRQHandler>:

/**
  * @brief This function handles QUADSPI global interrupt.
  */
void QUADSPI_IRQHandler(void)
{
 80057ec:	b580      	push	{r7, lr}
 80057ee:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN QUADSPI_IRQn 0 */

  /* USER CODE END QUADSPI_IRQn 0 */
  HAL_QSPI_IRQHandler(&hqspi1);
 80057f0:	4802      	ldr	r0, [pc, #8]	; (80057fc <QUADSPI_IRQHandler+0x10>)
 80057f2:	f004 f9c7 	bl	8009b84 <HAL_QSPI_IRQHandler>
  /* USER CODE BEGIN QUADSPI_IRQn 1 */

  /* USER CODE END QUADSPI_IRQn 1 */
}
 80057f6:	bf00      	nop
 80057f8:	bd80      	pop	{r7, pc}
 80057fa:	bf00      	nop
 80057fc:	200116b0 	.word	0x200116b0

08005800 <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
 8005800:	b480      	push	{r7}
 8005802:	af00      	add	r7, sp, #0
  return 1;
 8005804:	2301      	movs	r3, #1
}
 8005806:	4618      	mov	r0, r3
 8005808:	46bd      	mov	sp, r7
 800580a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800580e:	4770      	bx	lr

08005810 <_kill>:

int _kill(int pid, int sig)
{
 8005810:	b580      	push	{r7, lr}
 8005812:	b082      	sub	sp, #8
 8005814:	af00      	add	r7, sp, #0
 8005816:	6078      	str	r0, [r7, #4]
 8005818:	6039      	str	r1, [r7, #0]
  (void)pid;
  (void)sig;
  errno = EINVAL;
 800581a:	f018 fef9 	bl	801e610 <__errno>
 800581e:	4603      	mov	r3, r0
 8005820:	2216      	movs	r2, #22
 8005822:	601a      	str	r2, [r3, #0]
  return -1;
 8005824:	f04f 33ff 	mov.w	r3, #4294967295
}
 8005828:	4618      	mov	r0, r3
 800582a:	3708      	adds	r7, #8
 800582c:	46bd      	mov	sp, r7
 800582e:	bd80      	pop	{r7, pc}

08005830 <_exit>:

void _exit (int status)
{
 8005830:	b580      	push	{r7, lr}
 8005832:	b082      	sub	sp, #8
 8005834:	af00      	add	r7, sp, #0
 8005836:	6078      	str	r0, [r7, #4]
  _kill(status, -1);
 8005838:	f04f 31ff 	mov.w	r1, #4294967295
 800583c:	6878      	ldr	r0, [r7, #4]
 800583e:	f7ff ffe7 	bl	8005810 <_kill>
  while (1) {}    /* Make sure we hang here */
 8005842:	e7fe      	b.n	8005842 <_exit+0x12>

08005844 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8005844:	b580      	push	{r7, lr}
 8005846:	b086      	sub	sp, #24
 8005848:	af00      	add	r7, sp, #0
 800584a:	60f8      	str	r0, [r7, #12]
 800584c:	60b9      	str	r1, [r7, #8]
 800584e:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8005850:	2300      	movs	r3, #0
 8005852:	617b      	str	r3, [r7, #20]
 8005854:	e00a      	b.n	800586c <_read+0x28>
  {
    *ptr++ = __io_getchar();
 8005856:	f3af 8000 	nop.w
 800585a:	4601      	mov	r1, r0
 800585c:	68bb      	ldr	r3, [r7, #8]
 800585e:	1c5a      	adds	r2, r3, #1
 8005860:	60ba      	str	r2, [r7, #8]
 8005862:	b2ca      	uxtb	r2, r1
 8005864:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8005866:	697b      	ldr	r3, [r7, #20]
 8005868:	3301      	adds	r3, #1
 800586a:	617b      	str	r3, [r7, #20]
 800586c:	697a      	ldr	r2, [r7, #20]
 800586e:	687b      	ldr	r3, [r7, #4]
 8005870:	429a      	cmp	r2, r3
 8005872:	dbf0      	blt.n	8005856 <_read+0x12>
  }

  return len;
 8005874:	687b      	ldr	r3, [r7, #4]
}
 8005876:	4618      	mov	r0, r3
 8005878:	3718      	adds	r7, #24
 800587a:	46bd      	mov	sp, r7
 800587c:	bd80      	pop	{r7, pc}

0800587e <_close>:
  }
  return len;
}

int _close(int file)
{
 800587e:	b480      	push	{r7}
 8005880:	b083      	sub	sp, #12
 8005882:	af00      	add	r7, sp, #0
 8005884:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
 8005886:	f04f 33ff 	mov.w	r3, #4294967295
}
 800588a:	4618      	mov	r0, r3
 800588c:	370c      	adds	r7, #12
 800588e:	46bd      	mov	sp, r7
 8005890:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005894:	4770      	bx	lr

08005896 <_fstat>:


int _fstat(int file, struct stat *st)
{
 8005896:	b480      	push	{r7}
 8005898:	b083      	sub	sp, #12
 800589a:	af00      	add	r7, sp, #0
 800589c:	6078      	str	r0, [r7, #4]
 800589e:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
 80058a0:	683b      	ldr	r3, [r7, #0]
 80058a2:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80058a6:	605a      	str	r2, [r3, #4]
  return 0;
 80058a8:	2300      	movs	r3, #0
}
 80058aa:	4618      	mov	r0, r3
 80058ac:	370c      	adds	r7, #12
 80058ae:	46bd      	mov	sp, r7
 80058b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80058b4:	4770      	bx	lr

080058b6 <_isatty>:

int _isatty(int file)
{
 80058b6:	b480      	push	{r7}
 80058b8:	b083      	sub	sp, #12
 80058ba:	af00      	add	r7, sp, #0
 80058bc:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
 80058be:	2301      	movs	r3, #1
}
 80058c0:	4618      	mov	r0, r3
 80058c2:	370c      	adds	r7, #12
 80058c4:	46bd      	mov	sp, r7
 80058c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80058ca:	4770      	bx	lr

080058cc <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 80058cc:	b480      	push	{r7}
 80058ce:	b085      	sub	sp, #20
 80058d0:	af00      	add	r7, sp, #0
 80058d2:	60f8      	str	r0, [r7, #12]
 80058d4:	60b9      	str	r1, [r7, #8]
 80058d6:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
 80058d8:	2300      	movs	r3, #0
}
 80058da:	4618      	mov	r0, r3
 80058dc:	3714      	adds	r7, #20
 80058de:	46bd      	mov	sp, r7
 80058e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80058e4:	4770      	bx	lr
	...

080058e8 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 80058e8:	b580      	push	{r7, lr}
 80058ea:	b086      	sub	sp, #24
 80058ec:	af00      	add	r7, sp, #0
 80058ee:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 80058f0:	4a14      	ldr	r2, [pc, #80]	; (8005944 <_sbrk+0x5c>)
 80058f2:	4b15      	ldr	r3, [pc, #84]	; (8005948 <_sbrk+0x60>)
 80058f4:	1ad3      	subs	r3, r2, r3
 80058f6:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 80058f8:	697b      	ldr	r3, [r7, #20]
 80058fa:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 80058fc:	4b13      	ldr	r3, [pc, #76]	; (800594c <_sbrk+0x64>)
 80058fe:	681b      	ldr	r3, [r3, #0]
 8005900:	2b00      	cmp	r3, #0
 8005902:	d102      	bne.n	800590a <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8005904:	4b11      	ldr	r3, [pc, #68]	; (800594c <_sbrk+0x64>)
 8005906:	4a12      	ldr	r2, [pc, #72]	; (8005950 <_sbrk+0x68>)
 8005908:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 800590a:	4b10      	ldr	r3, [pc, #64]	; (800594c <_sbrk+0x64>)
 800590c:	681a      	ldr	r2, [r3, #0]
 800590e:	687b      	ldr	r3, [r7, #4]
 8005910:	4413      	add	r3, r2
 8005912:	693a      	ldr	r2, [r7, #16]
 8005914:	429a      	cmp	r2, r3
 8005916:	d207      	bcs.n	8005928 <_sbrk+0x40>
  {
    errno = ENOMEM;
 8005918:	f018 fe7a 	bl	801e610 <__errno>
 800591c:	4603      	mov	r3, r0
 800591e:	220c      	movs	r2, #12
 8005920:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 8005922:	f04f 33ff 	mov.w	r3, #4294967295
 8005926:	e009      	b.n	800593c <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 8005928:	4b08      	ldr	r3, [pc, #32]	; (800594c <_sbrk+0x64>)
 800592a:	681b      	ldr	r3, [r3, #0]
 800592c:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 800592e:	4b07      	ldr	r3, [pc, #28]	; (800594c <_sbrk+0x64>)
 8005930:	681a      	ldr	r2, [r3, #0]
 8005932:	687b      	ldr	r3, [r7, #4]
 8005934:	4413      	add	r3, r2
 8005936:	4a05      	ldr	r2, [pc, #20]	; (800594c <_sbrk+0x64>)
 8005938:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 800593a:	68fb      	ldr	r3, [r7, #12]
}
 800593c:	4618      	mov	r0, r3
 800593e:	3718      	adds	r7, #24
 8005940:	46bd      	mov	sp, r7
 8005942:	bd80      	pop	{r7, pc}
 8005944:	20020000 	.word	0x20020000
 8005948:	00000400 	.word	0x00000400
 800594c:	20016840 	.word	0x20016840
 8005950:	20016a78 	.word	0x20016a78

08005954 <SystemInit>:
  * @param  None
  * @retval None
  */

void SystemInit(void)
{
 8005954:	b480      	push	{r7}
 8005956:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 8005958:	4b06      	ldr	r3, [pc, #24]	; (8005974 <SystemInit+0x20>)
 800595a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800595e:	4a05      	ldr	r2, [pc, #20]	; (8005974 <SystemInit+0x20>)
 8005960:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8005964:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

  /* Configure the Vector Table location add offset address ------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8005968:	bf00      	nop
 800596a:	46bd      	mov	sp, r7
 800596c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005970:	4770      	bx	lr
 8005972:	bf00      	nop
 8005974:	e000ed00 	.word	0xe000ed00

08005978 <MX_TIM1_Init>:
TIM_HandleTypeDef htim2;
TIM_HandleTypeDef htim3;

/* TIM1 init function */
void MX_TIM1_Init(void)
{
 8005978:	b580      	push	{r7, lr}
 800597a:	b088      	sub	sp, #32
 800597c:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM1_Init 0 */

  /* USER CODE END TIM1_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 800597e:	f107 0310 	add.w	r3, r7, #16
 8005982:	2200      	movs	r2, #0
 8005984:	601a      	str	r2, [r3, #0]
 8005986:	605a      	str	r2, [r3, #4]
 8005988:	609a      	str	r2, [r3, #8]
 800598a:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 800598c:	1d3b      	adds	r3, r7, #4
 800598e:	2200      	movs	r2, #0
 8005990:	601a      	str	r2, [r3, #0]
 8005992:	605a      	str	r2, [r3, #4]
 8005994:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN TIM1_Init 1 */

  /* USER CODE END TIM1_Init 1 */
  htim1.Instance = TIM1;
 8005996:	4b1f      	ldr	r3, [pc, #124]	; (8005a14 <MX_TIM1_Init+0x9c>)
 8005998:	4a1f      	ldr	r2, [pc, #124]	; (8005a18 <MX_TIM1_Init+0xa0>)
 800599a:	601a      	str	r2, [r3, #0]
  htim1.Init.Prescaler = 85-1;
 800599c:	4b1d      	ldr	r3, [pc, #116]	; (8005a14 <MX_TIM1_Init+0x9c>)
 800599e:	2254      	movs	r2, #84	; 0x54
 80059a0:	605a      	str	r2, [r3, #4]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 80059a2:	4b1c      	ldr	r3, [pc, #112]	; (8005a14 <MX_TIM1_Init+0x9c>)
 80059a4:	2200      	movs	r2, #0
 80059a6:	609a      	str	r2, [r3, #8]
  htim1.Init.Period = 1;
 80059a8:	4b1a      	ldr	r3, [pc, #104]	; (8005a14 <MX_TIM1_Init+0x9c>)
 80059aa:	2201      	movs	r2, #1
 80059ac:	60da      	str	r2, [r3, #12]
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80059ae:	4b19      	ldr	r3, [pc, #100]	; (8005a14 <MX_TIM1_Init+0x9c>)
 80059b0:	2200      	movs	r2, #0
 80059b2:	611a      	str	r2, [r3, #16]
  htim1.Init.RepetitionCounter = 0;
 80059b4:	4b17      	ldr	r3, [pc, #92]	; (8005a14 <MX_TIM1_Init+0x9c>)
 80059b6:	2200      	movs	r2, #0
 80059b8:	615a      	str	r2, [r3, #20]
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 80059ba:	4b16      	ldr	r3, [pc, #88]	; (8005a14 <MX_TIM1_Init+0x9c>)
 80059bc:	2200      	movs	r2, #0
 80059be:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
 80059c0:	4814      	ldr	r0, [pc, #80]	; (8005a14 <MX_TIM1_Init+0x9c>)
 80059c2:	f005 ff0d 	bl	800b7e0 <HAL_TIM_Base_Init>
 80059c6:	4603      	mov	r3, r0
 80059c8:	2b00      	cmp	r3, #0
 80059ca:	d001      	beq.n	80059d0 <MX_TIM1_Init+0x58>
  {
    Error_Handler();
 80059cc:	f7fe fcff 	bl	80043ce <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 80059d0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80059d4:	613b      	str	r3, [r7, #16]
  if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
 80059d6:	f107 0310 	add.w	r3, r7, #16
 80059da:	4619      	mov	r1, r3
 80059dc:	480d      	ldr	r0, [pc, #52]	; (8005a14 <MX_TIM1_Init+0x9c>)
 80059de:	f006 fb6f 	bl	800c0c0 <HAL_TIM_ConfigClockSource>
 80059e2:	4603      	mov	r3, r0
 80059e4:	2b00      	cmp	r3, #0
 80059e6:	d001      	beq.n	80059ec <MX_TIM1_Init+0x74>
  {
    Error_Handler();
 80059e8:	f7fe fcf1 	bl	80043ce <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
 80059ec:	2320      	movs	r3, #32
 80059ee:	607b      	str	r3, [r7, #4]
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
 80059f0:	2300      	movs	r3, #0
 80059f2:	60bb      	str	r3, [r7, #8]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80059f4:	2300      	movs	r3, #0
 80059f6:	60fb      	str	r3, [r7, #12]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 80059f8:	1d3b      	adds	r3, r7, #4
 80059fa:	4619      	mov	r1, r3
 80059fc:	4805      	ldr	r0, [pc, #20]	; (8005a14 <MX_TIM1_Init+0x9c>)
 80059fe:	f007 f927 	bl	800cc50 <HAL_TIMEx_MasterConfigSynchronization>
 8005a02:	4603      	mov	r3, r0
 8005a04:	2b00      	cmp	r3, #0
 8005a06:	d001      	beq.n	8005a0c <MX_TIM1_Init+0x94>
  {
    Error_Handler();
 8005a08:	f7fe fce1 	bl	80043ce <Error_Handler>
  }
  /* USER CODE BEGIN TIM1_Init 2 */

  /* USER CODE END TIM1_Init 2 */

}
 8005a0c:	bf00      	nop
 8005a0e:	3720      	adds	r7, #32
 8005a10:	46bd      	mov	sp, r7
 8005a12:	bd80      	pop	{r7, pc}
 8005a14:	20016844 	.word	0x20016844
 8005a18:	40012c00 	.word	0x40012c00

08005a1c <MX_TIM2_Init>:
/* TIM2 init function */
void MX_TIM2_Init(void)
{
 8005a1c:	b580      	push	{r7, lr}
 8005a1e:	b08e      	sub	sp, #56	; 0x38
 8005a20:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8005a22:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8005a26:	2200      	movs	r2, #0
 8005a28:	601a      	str	r2, [r3, #0]
 8005a2a:	605a      	str	r2, [r3, #4]
 8005a2c:	609a      	str	r2, [r3, #8]
 8005a2e:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8005a30:	f107 031c 	add.w	r3, r7, #28
 8005a34:	2200      	movs	r2, #0
 8005a36:	601a      	str	r2, [r3, #0]
 8005a38:	605a      	str	r2, [r3, #4]
 8005a3a:	609a      	str	r2, [r3, #8]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8005a3c:	463b      	mov	r3, r7
 8005a3e:	2200      	movs	r2, #0
 8005a40:	601a      	str	r2, [r3, #0]
 8005a42:	605a      	str	r2, [r3, #4]
 8005a44:	609a      	str	r2, [r3, #8]
 8005a46:	60da      	str	r2, [r3, #12]
 8005a48:	611a      	str	r2, [r3, #16]
 8005a4a:	615a      	str	r2, [r3, #20]
 8005a4c:	619a      	str	r2, [r3, #24]

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
 8005a4e:	4b2c      	ldr	r3, [pc, #176]	; (8005b00 <MX_TIM2_Init+0xe4>)
 8005a50:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8005a54:	601a      	str	r2, [r3, #0]
  htim2.Init.Prescaler = 85-1;
 8005a56:	4b2a      	ldr	r3, [pc, #168]	; (8005b00 <MX_TIM2_Init+0xe4>)
 8005a58:	2254      	movs	r2, #84	; 0x54
 8005a5a:	605a      	str	r2, [r3, #4]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 8005a5c:	4b28      	ldr	r3, [pc, #160]	; (8005b00 <MX_TIM2_Init+0xe4>)
 8005a5e:	2200      	movs	r2, #0
 8005a60:	609a      	str	r2, [r3, #8]
  htim2.Init.Period = 1023;
 8005a62:	4b27      	ldr	r3, [pc, #156]	; (8005b00 <MX_TIM2_Init+0xe4>)
 8005a64:	f240 32ff 	movw	r2, #1023	; 0x3ff
 8005a68:	60da      	str	r2, [r3, #12]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8005a6a:	4b25      	ldr	r3, [pc, #148]	; (8005b00 <MX_TIM2_Init+0xe4>)
 8005a6c:	2200      	movs	r2, #0
 8005a6e:	611a      	str	r2, [r3, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8005a70:	4b23      	ldr	r3, [pc, #140]	; (8005b00 <MX_TIM2_Init+0xe4>)
 8005a72:	2200      	movs	r2, #0
 8005a74:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 8005a76:	4822      	ldr	r0, [pc, #136]	; (8005b00 <MX_TIM2_Init+0xe4>)
 8005a78:	f005 feb2 	bl	800b7e0 <HAL_TIM_Base_Init>
 8005a7c:	4603      	mov	r3, r0
 8005a7e:	2b00      	cmp	r3, #0
 8005a80:	d001      	beq.n	8005a86 <MX_TIM2_Init+0x6a>
  {
    Error_Handler();
 8005a82:	f7fe fca4 	bl	80043ce <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8005a86:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8005a8a:	62bb      	str	r3, [r7, #40]	; 0x28
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 8005a8c:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8005a90:	4619      	mov	r1, r3
 8005a92:	481b      	ldr	r0, [pc, #108]	; (8005b00 <MX_TIM2_Init+0xe4>)
 8005a94:	f006 fb14 	bl	800c0c0 <HAL_TIM_ConfigClockSource>
 8005a98:	4603      	mov	r3, r0
 8005a9a:	2b00      	cmp	r3, #0
 8005a9c:	d001      	beq.n	8005aa2 <MX_TIM2_Init+0x86>
  {
    Error_Handler();
 8005a9e:	f7fe fc96 	bl	80043ce <Error_Handler>
  }
  if (HAL_TIM_OC_Init(&htim2) != HAL_OK)
 8005aa2:	4817      	ldr	r0, [pc, #92]	; (8005b00 <MX_TIM2_Init+0xe4>)
 8005aa4:	f005 ff8b 	bl	800b9be <HAL_TIM_OC_Init>
 8005aa8:	4603      	mov	r3, r0
 8005aaa:	2b00      	cmp	r3, #0
 8005aac:	d001      	beq.n	8005ab2 <MX_TIM2_Init+0x96>
  {
    Error_Handler();
 8005aae:	f7fe fc8e 	bl	80043ce <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8005ab2:	2300      	movs	r3, #0
 8005ab4:	61fb      	str	r3, [r7, #28]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8005ab6:	2300      	movs	r3, #0
 8005ab8:	627b      	str	r3, [r7, #36]	; 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8005aba:	f107 031c 	add.w	r3, r7, #28
 8005abe:	4619      	mov	r1, r3
 8005ac0:	480f      	ldr	r0, [pc, #60]	; (8005b00 <MX_TIM2_Init+0xe4>)
 8005ac2:	f007 f8c5 	bl	800cc50 <HAL_TIMEx_MasterConfigSynchronization>
 8005ac6:	4603      	mov	r3, r0
 8005ac8:	2b00      	cmp	r3, #0
 8005aca:	d001      	beq.n	8005ad0 <MX_TIM2_Init+0xb4>
  {
    Error_Handler();
 8005acc:	f7fe fc7f 	bl	80043ce <Error_Handler>
  }
  sConfigOC.OCMode = TIM_OCMODE_TIMING;
 8005ad0:	2300      	movs	r3, #0
 8005ad2:	603b      	str	r3, [r7, #0]
  sConfigOC.Pulse = 1023;
 8005ad4:	f240 33ff 	movw	r3, #1023	; 0x3ff
 8005ad8:	607b      	str	r3, [r7, #4]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8005ada:	2300      	movs	r3, #0
 8005adc:	60bb      	str	r3, [r7, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8005ade:	2300      	movs	r3, #0
 8005ae0:	613b      	str	r3, [r7, #16]
  if (HAL_TIM_OC_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8005ae2:	463b      	mov	r3, r7
 8005ae4:	2200      	movs	r2, #0
 8005ae6:	4619      	mov	r1, r3
 8005ae8:	4805      	ldr	r0, [pc, #20]	; (8005b00 <MX_TIM2_Init+0xe4>)
 8005aea:	f006 fa6f 	bl	800bfcc <HAL_TIM_OC_ConfigChannel>
 8005aee:	4603      	mov	r3, r0
 8005af0:	2b00      	cmp	r3, #0
 8005af2:	d001      	beq.n	8005af8 <MX_TIM2_Init+0xdc>
  {
    Error_Handler();
 8005af4:	f7fe fc6b 	bl	80043ce <Error_Handler>
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */

}
 8005af8:	bf00      	nop
 8005afa:	3738      	adds	r7, #56	; 0x38
 8005afc:	46bd      	mov	sp, r7
 8005afe:	bd80      	pop	{r7, pc}
 8005b00:	20016890 	.word	0x20016890

08005b04 <MX_TIM3_Init>:
/* TIM3 init function */
void MX_TIM3_Init(void)
{
 8005b04:	b580      	push	{r7, lr}
 8005b06:	b088      	sub	sp, #32
 8005b08:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM3_Init 0 */

  /* USER CODE END TIM3_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8005b0a:	f107 0310 	add.w	r3, r7, #16
 8005b0e:	2200      	movs	r2, #0
 8005b10:	601a      	str	r2, [r3, #0]
 8005b12:	605a      	str	r2, [r3, #4]
 8005b14:	609a      	str	r2, [r3, #8]
 8005b16:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8005b18:	1d3b      	adds	r3, r7, #4
 8005b1a:	2200      	movs	r2, #0
 8005b1c:	601a      	str	r2, [r3, #0]
 8005b1e:	605a      	str	r2, [r3, #4]
 8005b20:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN TIM3_Init 1 */

  /* USER CODE END TIM3_Init 1 */
  htim3.Instance = TIM3;
 8005b22:	4b1d      	ldr	r3, [pc, #116]	; (8005b98 <MX_TIM3_Init+0x94>)
 8005b24:	4a1d      	ldr	r2, [pc, #116]	; (8005b9c <MX_TIM3_Init+0x98>)
 8005b26:	601a      	str	r2, [r3, #0]
  htim3.Init.Prescaler = 85-1;
 8005b28:	4b1b      	ldr	r3, [pc, #108]	; (8005b98 <MX_TIM3_Init+0x94>)
 8005b2a:	2254      	movs	r2, #84	; 0x54
 8005b2c:	605a      	str	r2, [r3, #4]
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 8005b2e:	4b1a      	ldr	r3, [pc, #104]	; (8005b98 <MX_TIM3_Init+0x94>)
 8005b30:	2200      	movs	r2, #0
 8005b32:	609a      	str	r2, [r3, #8]
  htim3.Init.Period = 1;
 8005b34:	4b18      	ldr	r3, [pc, #96]	; (8005b98 <MX_TIM3_Init+0x94>)
 8005b36:	2201      	movs	r2, #1
 8005b38:	60da      	str	r2, [r3, #12]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8005b3a:	4b17      	ldr	r3, [pc, #92]	; (8005b98 <MX_TIM3_Init+0x94>)
 8005b3c:	2200      	movs	r2, #0
 8005b3e:	611a      	str	r2, [r3, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8005b40:	4b15      	ldr	r3, [pc, #84]	; (8005b98 <MX_TIM3_Init+0x94>)
 8005b42:	2200      	movs	r2, #0
 8005b44:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 8005b46:	4814      	ldr	r0, [pc, #80]	; (8005b98 <MX_TIM3_Init+0x94>)
 8005b48:	f005 fe4a 	bl	800b7e0 <HAL_TIM_Base_Init>
 8005b4c:	4603      	mov	r3, r0
 8005b4e:	2b00      	cmp	r3, #0
 8005b50:	d001      	beq.n	8005b56 <MX_TIM3_Init+0x52>
  {
    Error_Handler();
 8005b52:	f7fe fc3c 	bl	80043ce <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8005b56:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8005b5a:	613b      	str	r3, [r7, #16]
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 8005b5c:	f107 0310 	add.w	r3, r7, #16
 8005b60:	4619      	mov	r1, r3
 8005b62:	480d      	ldr	r0, [pc, #52]	; (8005b98 <MX_TIM3_Init+0x94>)
 8005b64:	f006 faac 	bl	800c0c0 <HAL_TIM_ConfigClockSource>
 8005b68:	4603      	mov	r3, r0
 8005b6a:	2b00      	cmp	r3, #0
 8005b6c:	d001      	beq.n	8005b72 <MX_TIM3_Init+0x6e>
  {
    Error_Handler();
 8005b6e:	f7fe fc2e 	bl	80043ce <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
 8005b72:	2320      	movs	r3, #32
 8005b74:	607b      	str	r3, [r7, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8005b76:	2300      	movs	r3, #0
 8005b78:	60fb      	str	r3, [r7, #12]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8005b7a:	1d3b      	adds	r3, r7, #4
 8005b7c:	4619      	mov	r1, r3
 8005b7e:	4806      	ldr	r0, [pc, #24]	; (8005b98 <MX_TIM3_Init+0x94>)
 8005b80:	f007 f866 	bl	800cc50 <HAL_TIMEx_MasterConfigSynchronization>
 8005b84:	4603      	mov	r3, r0
 8005b86:	2b00      	cmp	r3, #0
 8005b88:	d001      	beq.n	8005b8e <MX_TIM3_Init+0x8a>
  {
    Error_Handler();
 8005b8a:	f7fe fc20 	bl	80043ce <Error_Handler>
  }
  /* USER CODE BEGIN TIM3_Init 2 */

  /* USER CODE END TIM3_Init 2 */

}
 8005b8e:	bf00      	nop
 8005b90:	3720      	adds	r7, #32
 8005b92:	46bd      	mov	sp, r7
 8005b94:	bd80      	pop	{r7, pc}
 8005b96:	bf00      	nop
 8005b98:	200168dc 	.word	0x200168dc
 8005b9c:	40000400 	.word	0x40000400

08005ba0 <HAL_TIM_Base_MspInit>:

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{
 8005ba0:	b580      	push	{r7, lr}
 8005ba2:	b086      	sub	sp, #24
 8005ba4:	af00      	add	r7, sp, #0
 8005ba6:	6078      	str	r0, [r7, #4]

  if(tim_baseHandle->Instance==TIM1)
 8005ba8:	687b      	ldr	r3, [r7, #4]
 8005baa:	681b      	ldr	r3, [r3, #0]
 8005bac:	4a1f      	ldr	r2, [pc, #124]	; (8005c2c <HAL_TIM_Base_MspInit+0x8c>)
 8005bae:	4293      	cmp	r3, r2
 8005bb0:	d10c      	bne.n	8005bcc <HAL_TIM_Base_MspInit+0x2c>
  {
  /* USER CODE BEGIN TIM1_MspInit 0 */

  /* USER CODE END TIM1_MspInit 0 */
    /* TIM1 clock enable */
    __HAL_RCC_TIM1_CLK_ENABLE();
 8005bb2:	4b1f      	ldr	r3, [pc, #124]	; (8005c30 <HAL_TIM_Base_MspInit+0x90>)
 8005bb4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8005bb6:	4a1e      	ldr	r2, [pc, #120]	; (8005c30 <HAL_TIM_Base_MspInit+0x90>)
 8005bb8:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8005bbc:	6613      	str	r3, [r2, #96]	; 0x60
 8005bbe:	4b1c      	ldr	r3, [pc, #112]	; (8005c30 <HAL_TIM_Base_MspInit+0x90>)
 8005bc0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8005bc2:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8005bc6:	617b      	str	r3, [r7, #20]
 8005bc8:	697b      	ldr	r3, [r7, #20]
    __HAL_RCC_TIM3_CLK_ENABLE();
  /* USER CODE BEGIN TIM3_MspInit 1 */

  /* USER CODE END TIM3_MspInit 1 */
  }
}
 8005bca:	e02a      	b.n	8005c22 <HAL_TIM_Base_MspInit+0x82>
  else if(tim_baseHandle->Instance==TIM2)
 8005bcc:	687b      	ldr	r3, [r7, #4]
 8005bce:	681b      	ldr	r3, [r3, #0]
 8005bd0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8005bd4:	d114      	bne.n	8005c00 <HAL_TIM_Base_MspInit+0x60>
    __HAL_RCC_TIM2_CLK_ENABLE();
 8005bd6:	4b16      	ldr	r3, [pc, #88]	; (8005c30 <HAL_TIM_Base_MspInit+0x90>)
 8005bd8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005bda:	4a15      	ldr	r2, [pc, #84]	; (8005c30 <HAL_TIM_Base_MspInit+0x90>)
 8005bdc:	f043 0301 	orr.w	r3, r3, #1
 8005be0:	6593      	str	r3, [r2, #88]	; 0x58
 8005be2:	4b13      	ldr	r3, [pc, #76]	; (8005c30 <HAL_TIM_Base_MspInit+0x90>)
 8005be4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005be6:	f003 0301 	and.w	r3, r3, #1
 8005bea:	613b      	str	r3, [r7, #16]
 8005bec:	693b      	ldr	r3, [r7, #16]
    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
 8005bee:	2200      	movs	r2, #0
 8005bf0:	2100      	movs	r1, #0
 8005bf2:	201c      	movs	r0, #28
 8005bf4:	f002 fce9 	bl	80085ca <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
 8005bf8:	201c      	movs	r0, #28
 8005bfa:	f002 fd00 	bl	80085fe <HAL_NVIC_EnableIRQ>
}
 8005bfe:	e010      	b.n	8005c22 <HAL_TIM_Base_MspInit+0x82>
  else if(tim_baseHandle->Instance==TIM3)
 8005c00:	687b      	ldr	r3, [r7, #4]
 8005c02:	681b      	ldr	r3, [r3, #0]
 8005c04:	4a0b      	ldr	r2, [pc, #44]	; (8005c34 <HAL_TIM_Base_MspInit+0x94>)
 8005c06:	4293      	cmp	r3, r2
 8005c08:	d10b      	bne.n	8005c22 <HAL_TIM_Base_MspInit+0x82>
    __HAL_RCC_TIM3_CLK_ENABLE();
 8005c0a:	4b09      	ldr	r3, [pc, #36]	; (8005c30 <HAL_TIM_Base_MspInit+0x90>)
 8005c0c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005c0e:	4a08      	ldr	r2, [pc, #32]	; (8005c30 <HAL_TIM_Base_MspInit+0x90>)
 8005c10:	f043 0302 	orr.w	r3, r3, #2
 8005c14:	6593      	str	r3, [r2, #88]	; 0x58
 8005c16:	4b06      	ldr	r3, [pc, #24]	; (8005c30 <HAL_TIM_Base_MspInit+0x90>)
 8005c18:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005c1a:	f003 0302 	and.w	r3, r3, #2
 8005c1e:	60fb      	str	r3, [r7, #12]
 8005c20:	68fb      	ldr	r3, [r7, #12]
}
 8005c22:	bf00      	nop
 8005c24:	3718      	adds	r7, #24
 8005c26:	46bd      	mov	sp, r7
 8005c28:	bd80      	pop	{r7, pc}
 8005c2a:	bf00      	nop
 8005c2c:	40012c00 	.word	0x40012c00
 8005c30:	40021000 	.word	0x40021000
 8005c34:	40000400 	.word	0x40000400

08005c38 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8005c38:	480d      	ldr	r0, [pc, #52]	; (8005c70 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8005c3a:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8005c3c:	480d      	ldr	r0, [pc, #52]	; (8005c74 <LoopForever+0x6>)
  ldr r1, =_edata
 8005c3e:	490e      	ldr	r1, [pc, #56]	; (8005c78 <LoopForever+0xa>)
  ldr r2, =_sidata
 8005c40:	4a0e      	ldr	r2, [pc, #56]	; (8005c7c <LoopForever+0xe>)
  movs r3, #0
 8005c42:	2300      	movs	r3, #0
  b	LoopCopyDataInit
 8005c44:	e002      	b.n	8005c4c <LoopCopyDataInit>

08005c46 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8005c46:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8005c48:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8005c4a:	3304      	adds	r3, #4

08005c4c <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8005c4c:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8005c4e:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8005c50:	d3f9      	bcc.n	8005c46 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8005c52:	4a0b      	ldr	r2, [pc, #44]	; (8005c80 <LoopForever+0x12>)
  ldr r4, =_ebss
 8005c54:	4c0b      	ldr	r4, [pc, #44]	; (8005c84 <LoopForever+0x16>)
  movs r3, #0
 8005c56:	2300      	movs	r3, #0
  b LoopFillZerobss
 8005c58:	e001      	b.n	8005c5e <LoopFillZerobss>

08005c5a <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8005c5a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8005c5c:	3204      	adds	r2, #4

08005c5e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8005c5e:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8005c60:	d3fb      	bcc.n	8005c5a <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 8005c62:	f7ff fe77 	bl	8005954 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8005c66:	f018 fcd9 	bl	801e61c <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 8005c6a:	f7fe fa19 	bl	80040a0 <main>

08005c6e <LoopForever>:

LoopForever:
    b LoopForever
 8005c6e:	e7fe      	b.n	8005c6e <LoopForever>
  ldr   r0, =_estack
 8005c70:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 8005c74:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8005c78:	20000358 	.word	0x20000358
  ldr r2, =_sidata
 8005c7c:	08023fd8 	.word	0x08023fd8
  ldr r2, =_sbss
 8005c80:	20000358 	.word	0x20000358
  ldr r4, =_ebss
 8005c84:	20016a78 	.word	0x20016a78

08005c88 <ADC3_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8005c88:	e7fe      	b.n	8005c88 <ADC3_IRQHandler>

08005c8a <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8005c8a:	b580      	push	{r7, lr}
 8005c8c:	b082      	sub	sp, #8
 8005c8e:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 8005c90:	2300      	movs	r3, #0
 8005c92:	71fb      	strb	r3, [r7, #7]
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8005c94:	2003      	movs	r0, #3
 8005c96:	f002 fc8d 	bl	80085b4 <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8005c9a:	2000      	movs	r0, #0
 8005c9c:	f000 f80e 	bl	8005cbc <HAL_InitTick>
 8005ca0:	4603      	mov	r3, r0
 8005ca2:	2b00      	cmp	r3, #0
 8005ca4:	d002      	beq.n	8005cac <HAL_Init+0x22>
  {
    status = HAL_ERROR;
 8005ca6:	2301      	movs	r3, #1
 8005ca8:	71fb      	strb	r3, [r7, #7]
 8005caa:	e001      	b.n	8005cb0 <HAL_Init+0x26>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 8005cac:	f7ff fce0 	bl	8005670 <HAL_MspInit>
  }

  /* Return function status */
  return status;
 8005cb0:	79fb      	ldrb	r3, [r7, #7]

}
 8005cb2:	4618      	mov	r0, r3
 8005cb4:	3708      	adds	r7, #8
 8005cb6:	46bd      	mov	sp, r7
 8005cb8:	bd80      	pop	{r7, pc}
	...

08005cbc <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8005cbc:	b580      	push	{r7, lr}
 8005cbe:	b084      	sub	sp, #16
 8005cc0:	af00      	add	r7, sp, #0
 8005cc2:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
 8005cc4:	2300      	movs	r3, #0
 8005cc6:	73fb      	strb	r3, [r7, #15]

  if (uwTickFreq != 0U)
 8005cc8:	4b16      	ldr	r3, [pc, #88]	; (8005d24 <HAL_InitTick+0x68>)
 8005cca:	681b      	ldr	r3, [r3, #0]
 8005ccc:	2b00      	cmp	r3, #0
 8005cce:	d022      	beq.n	8005d16 <HAL_InitTick+0x5a>
  {
    /* Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) == 0U)
 8005cd0:	4b15      	ldr	r3, [pc, #84]	; (8005d28 <HAL_InitTick+0x6c>)
 8005cd2:	681a      	ldr	r2, [r3, #0]
 8005cd4:	4b13      	ldr	r3, [pc, #76]	; (8005d24 <HAL_InitTick+0x68>)
 8005cd6:	681b      	ldr	r3, [r3, #0]
 8005cd8:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8005cdc:	fbb1 f3f3 	udiv	r3, r1, r3
 8005ce0:	fbb2 f3f3 	udiv	r3, r2, r3
 8005ce4:	4618      	mov	r0, r3
 8005ce6:	f002 fc98 	bl	800861a <HAL_SYSTICK_Config>
 8005cea:	4603      	mov	r3, r0
 8005cec:	2b00      	cmp	r3, #0
 8005cee:	d10f      	bne.n	8005d10 <HAL_InitTick+0x54>
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8005cf0:	687b      	ldr	r3, [r7, #4]
 8005cf2:	2b0f      	cmp	r3, #15
 8005cf4:	d809      	bhi.n	8005d0a <HAL_InitTick+0x4e>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8005cf6:	2200      	movs	r2, #0
 8005cf8:	6879      	ldr	r1, [r7, #4]
 8005cfa:	f04f 30ff 	mov.w	r0, #4294967295
 8005cfe:	f002 fc64 	bl	80085ca <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 8005d02:	4a0a      	ldr	r2, [pc, #40]	; (8005d2c <HAL_InitTick+0x70>)
 8005d04:	687b      	ldr	r3, [r7, #4]
 8005d06:	6013      	str	r3, [r2, #0]
 8005d08:	e007      	b.n	8005d1a <HAL_InitTick+0x5e>
      }
      else
      {
        status = HAL_ERROR;
 8005d0a:	2301      	movs	r3, #1
 8005d0c:	73fb      	strb	r3, [r7, #15]
 8005d0e:	e004      	b.n	8005d1a <HAL_InitTick+0x5e>
      }
    }
    else
    {
      status = HAL_ERROR;
 8005d10:	2301      	movs	r3, #1
 8005d12:	73fb      	strb	r3, [r7, #15]
 8005d14:	e001      	b.n	8005d1a <HAL_InitTick+0x5e>
    }
  }
  else
  {
    status = HAL_ERROR;
 8005d16:	2301      	movs	r3, #1
 8005d18:	73fb      	strb	r3, [r7, #15]
  }

  /* Return function status */
  return status;
 8005d1a:	7bfb      	ldrb	r3, [r7, #15]
}
 8005d1c:	4618      	mov	r0, r3
 8005d1e:	3710      	adds	r7, #16
 8005d20:	46bd      	mov	sp, r7
 8005d22:	bd80      	pop	{r7, pc}
 8005d24:	20000010 	.word	0x20000010
 8005d28:	20000008 	.word	0x20000008
 8005d2c:	2000000c 	.word	0x2000000c

08005d30 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8005d30:	b480      	push	{r7}
 8005d32:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8005d34:	4b05      	ldr	r3, [pc, #20]	; (8005d4c <HAL_IncTick+0x1c>)
 8005d36:	681a      	ldr	r2, [r3, #0]
 8005d38:	4b05      	ldr	r3, [pc, #20]	; (8005d50 <HAL_IncTick+0x20>)
 8005d3a:	681b      	ldr	r3, [r3, #0]
 8005d3c:	4413      	add	r3, r2
 8005d3e:	4a03      	ldr	r2, [pc, #12]	; (8005d4c <HAL_IncTick+0x1c>)
 8005d40:	6013      	str	r3, [r2, #0]
}
 8005d42:	bf00      	nop
 8005d44:	46bd      	mov	sp, r7
 8005d46:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005d4a:	4770      	bx	lr
 8005d4c:	20016928 	.word	0x20016928
 8005d50:	20000010 	.word	0x20000010

08005d54 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8005d54:	b480      	push	{r7}
 8005d56:	af00      	add	r7, sp, #0
  return uwTick;
 8005d58:	4b03      	ldr	r3, [pc, #12]	; (8005d68 <HAL_GetTick+0x14>)
 8005d5a:	681b      	ldr	r3, [r3, #0]
}
 8005d5c:	4618      	mov	r0, r3
 8005d5e:	46bd      	mov	sp, r7
 8005d60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005d64:	4770      	bx	lr
 8005d66:	bf00      	nop
 8005d68:	20016928 	.word	0x20016928

08005d6c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8005d6c:	b580      	push	{r7, lr}
 8005d6e:	b084      	sub	sp, #16
 8005d70:	af00      	add	r7, sp, #0
 8005d72:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8005d74:	f7ff ffee 	bl	8005d54 <HAL_GetTick>
 8005d78:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 8005d7a:	687b      	ldr	r3, [r7, #4]
 8005d7c:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8005d7e:	68fb      	ldr	r3, [r7, #12]
 8005d80:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005d84:	d004      	beq.n	8005d90 <HAL_Delay+0x24>
  {
    wait += (uint32_t)(uwTickFreq);
 8005d86:	4b09      	ldr	r3, [pc, #36]	; (8005dac <HAL_Delay+0x40>)
 8005d88:	681b      	ldr	r3, [r3, #0]
 8005d8a:	68fa      	ldr	r2, [r7, #12]
 8005d8c:	4413      	add	r3, r2
 8005d8e:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8005d90:	bf00      	nop
 8005d92:	f7ff ffdf 	bl	8005d54 <HAL_GetTick>
 8005d96:	4602      	mov	r2, r0
 8005d98:	68bb      	ldr	r3, [r7, #8]
 8005d9a:	1ad3      	subs	r3, r2, r3
 8005d9c:	68fa      	ldr	r2, [r7, #12]
 8005d9e:	429a      	cmp	r2, r3
 8005da0:	d8f7      	bhi.n	8005d92 <HAL_Delay+0x26>
  {
  }
}
 8005da2:	bf00      	nop
 8005da4:	bf00      	nop
 8005da6:	3710      	adds	r7, #16
 8005da8:	46bd      	mov	sp, r7
 8005daa:	bd80      	pop	{r7, pc}
 8005dac:	20000010 	.word	0x20000010

08005db0 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig>:
  *            @arg SYSCFG_VREFBUF_HIGH_IMPEDANCE_DISABLE: VREF+ pin is internally connect to VREFINT output.
  *            @arg SYSCFG_VREFBUF_HIGH_IMPEDANCE_ENABLE: VREF+ pin is high impedance.
  * @retval None
  */
void HAL_SYSCFG_VREFBUF_HighImpedanceConfig(uint32_t Mode)
{
 8005db0:	b480      	push	{r7}
 8005db2:	b083      	sub	sp, #12
 8005db4:	af00      	add	r7, sp, #0
 8005db6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_HIGH_IMPEDANCE(Mode));

  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_HIZ, Mode);
 8005db8:	4b06      	ldr	r3, [pc, #24]	; (8005dd4 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x24>)
 8005dba:	681b      	ldr	r3, [r3, #0]
 8005dbc:	f023 0202 	bic.w	r2, r3, #2
 8005dc0:	4904      	ldr	r1, [pc, #16]	; (8005dd4 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x24>)
 8005dc2:	687b      	ldr	r3, [r7, #4]
 8005dc4:	4313      	orrs	r3, r2
 8005dc6:	600b      	str	r3, [r1, #0]
}
 8005dc8:	bf00      	nop
 8005dca:	370c      	adds	r7, #12
 8005dcc:	46bd      	mov	sp, r7
 8005dce:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005dd2:	4770      	bx	lr
 8005dd4:	40010030 	.word	0x40010030

08005dd8 <HAL_SYSCFG_DisableVREFBUF>:
  * @brief  Disable the Internal Voltage Reference buffer (VREFBUF).
  *
  * @retval None
  */
void HAL_SYSCFG_DisableVREFBUF(void)
{
 8005dd8:	b480      	push	{r7}
 8005dda:	af00      	add	r7, sp, #0
  CLEAR_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
 8005ddc:	4b05      	ldr	r3, [pc, #20]	; (8005df4 <HAL_SYSCFG_DisableVREFBUF+0x1c>)
 8005dde:	681b      	ldr	r3, [r3, #0]
 8005de0:	4a04      	ldr	r2, [pc, #16]	; (8005df4 <HAL_SYSCFG_DisableVREFBUF+0x1c>)
 8005de2:	f023 0301 	bic.w	r3, r3, #1
 8005de6:	6013      	str	r3, [r2, #0]
}
 8005de8:	bf00      	nop
 8005dea:	46bd      	mov	sp, r7
 8005dec:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005df0:	4770      	bx	lr
 8005df2:	bf00      	nop
 8005df4:	40010030 	.word	0x40010030

08005df8 <LL_ADC_SetCommonClock>:
{
 8005df8:	b480      	push	{r7}
 8005dfa:	b083      	sub	sp, #12
 8005dfc:	af00      	add	r7, sp, #0
 8005dfe:	6078      	str	r0, [r7, #4]
 8005e00:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 8005e02:	687b      	ldr	r3, [r7, #4]
 8005e04:	689b      	ldr	r3, [r3, #8]
 8005e06:	f423 127c 	bic.w	r2, r3, #4128768	; 0x3f0000
 8005e0a:	683b      	ldr	r3, [r7, #0]
 8005e0c:	431a      	orrs	r2, r3
 8005e0e:	687b      	ldr	r3, [r7, #4]
 8005e10:	609a      	str	r2, [r3, #8]
}
 8005e12:	bf00      	nop
 8005e14:	370c      	adds	r7, #12
 8005e16:	46bd      	mov	sp, r7
 8005e18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005e1c:	4770      	bx	lr

08005e1e <LL_ADC_SetCommonPathInternalCh>:
{
 8005e1e:	b480      	push	{r7}
 8005e20:	b083      	sub	sp, #12
 8005e22:	af00      	add	r7, sp, #0
 8005e24:	6078      	str	r0, [r7, #4]
 8005e26:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 8005e28:	687b      	ldr	r3, [r7, #4]
 8005e2a:	689b      	ldr	r3, [r3, #8]
 8005e2c:	f023 72e0 	bic.w	r2, r3, #29360128	; 0x1c00000
 8005e30:	683b      	ldr	r3, [r7, #0]
 8005e32:	431a      	orrs	r2, r3
 8005e34:	687b      	ldr	r3, [r7, #4]
 8005e36:	609a      	str	r2, [r3, #8]
}
 8005e38:	bf00      	nop
 8005e3a:	370c      	adds	r7, #12
 8005e3c:	46bd      	mov	sp, r7
 8005e3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005e42:	4770      	bx	lr

08005e44 <LL_ADC_GetCommonPathInternalCh>:
{
 8005e44:	b480      	push	{r7}
 8005e46:	b083      	sub	sp, #12
 8005e48:	af00      	add	r7, sp, #0
 8005e4a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL));
 8005e4c:	687b      	ldr	r3, [r7, #4]
 8005e4e:	689b      	ldr	r3, [r3, #8]
 8005e50:	f003 73e0 	and.w	r3, r3, #29360128	; 0x1c00000
}
 8005e54:	4618      	mov	r0, r3
 8005e56:	370c      	adds	r7, #12
 8005e58:	46bd      	mov	sp, r7
 8005e5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005e5e:	4770      	bx	lr

08005e60 <LL_ADC_SetOffset>:
{
 8005e60:	b480      	push	{r7}
 8005e62:	b087      	sub	sp, #28
 8005e64:	af00      	add	r7, sp, #0
 8005e66:	60f8      	str	r0, [r7, #12]
 8005e68:	60b9      	str	r1, [r7, #8]
 8005e6a:	607a      	str	r2, [r7, #4]
 8005e6c:	603b      	str	r3, [r7, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005e6e:	68fb      	ldr	r3, [r7, #12]
 8005e70:	3360      	adds	r3, #96	; 0x60
 8005e72:	461a      	mov	r2, r3
 8005e74:	68bb      	ldr	r3, [r7, #8]
 8005e76:	009b      	lsls	r3, r3, #2
 8005e78:	4413      	add	r3, r2
 8005e7a:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg,
 8005e7c:	697b      	ldr	r3, [r7, #20]
 8005e7e:	681a      	ldr	r2, [r3, #0]
 8005e80:	4b08      	ldr	r3, [pc, #32]	; (8005ea4 <LL_ADC_SetOffset+0x44>)
 8005e82:	4013      	ands	r3, r2
 8005e84:	687a      	ldr	r2, [r7, #4]
 8005e86:	f002 41f8 	and.w	r1, r2, #2080374784	; 0x7c000000
 8005e8a:	683a      	ldr	r2, [r7, #0]
 8005e8c:	430a      	orrs	r2, r1
 8005e8e:	4313      	orrs	r3, r2
 8005e90:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 8005e94:	697b      	ldr	r3, [r7, #20]
 8005e96:	601a      	str	r2, [r3, #0]
}
 8005e98:	bf00      	nop
 8005e9a:	371c      	adds	r7, #28
 8005e9c:	46bd      	mov	sp, r7
 8005e9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005ea2:	4770      	bx	lr
 8005ea4:	03fff000 	.word	0x03fff000

08005ea8 <LL_ADC_GetOffsetChannel>:
{
 8005ea8:	b480      	push	{r7}
 8005eaa:	b085      	sub	sp, #20
 8005eac:	af00      	add	r7, sp, #0
 8005eae:	6078      	str	r0, [r7, #4]
 8005eb0:	6039      	str	r1, [r7, #0]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005eb2:	687b      	ldr	r3, [r7, #4]
 8005eb4:	3360      	adds	r3, #96	; 0x60
 8005eb6:	461a      	mov	r2, r3
 8005eb8:	683b      	ldr	r3, [r7, #0]
 8005eba:	009b      	lsls	r3, r3, #2
 8005ebc:	4413      	add	r3, r2
 8005ebe:	60fb      	str	r3, [r7, #12]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005ec0:	68fb      	ldr	r3, [r7, #12]
 8005ec2:	681b      	ldr	r3, [r3, #0]
 8005ec4:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
}
 8005ec8:	4618      	mov	r0, r3
 8005eca:	3714      	adds	r7, #20
 8005ecc:	46bd      	mov	sp, r7
 8005ece:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005ed2:	4770      	bx	lr

08005ed4 <LL_ADC_SetOffsetState>:
{
 8005ed4:	b480      	push	{r7}
 8005ed6:	b087      	sub	sp, #28
 8005ed8:	af00      	add	r7, sp, #0
 8005eda:	60f8      	str	r0, [r7, #12]
 8005edc:	60b9      	str	r1, [r7, #8]
 8005ede:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005ee0:	68fb      	ldr	r3, [r7, #12]
 8005ee2:	3360      	adds	r3, #96	; 0x60
 8005ee4:	461a      	mov	r2, r3
 8005ee6:	68bb      	ldr	r3, [r7, #8]
 8005ee8:	009b      	lsls	r3, r3, #2
 8005eea:	4413      	add	r3, r2
 8005eec:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg,
 8005eee:	697b      	ldr	r3, [r7, #20]
 8005ef0:	681b      	ldr	r3, [r3, #0]
 8005ef2:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8005ef6:	687b      	ldr	r3, [r7, #4]
 8005ef8:	431a      	orrs	r2, r3
 8005efa:	697b      	ldr	r3, [r7, #20]
 8005efc:	601a      	str	r2, [r3, #0]
}
 8005efe:	bf00      	nop
 8005f00:	371c      	adds	r7, #28
 8005f02:	46bd      	mov	sp, r7
 8005f04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005f08:	4770      	bx	lr

08005f0a <LL_ADC_SetOffsetSign>:
{
 8005f0a:	b480      	push	{r7}
 8005f0c:	b087      	sub	sp, #28
 8005f0e:	af00      	add	r7, sp, #0
 8005f10:	60f8      	str	r0, [r7, #12]
 8005f12:	60b9      	str	r1, [r7, #8]
 8005f14:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005f16:	68fb      	ldr	r3, [r7, #12]
 8005f18:	3360      	adds	r3, #96	; 0x60
 8005f1a:	461a      	mov	r2, r3
 8005f1c:	68bb      	ldr	r3, [r7, #8]
 8005f1e:	009b      	lsls	r3, r3, #2
 8005f20:	4413      	add	r3, r2
 8005f22:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg,
 8005f24:	697b      	ldr	r3, [r7, #20]
 8005f26:	681b      	ldr	r3, [r3, #0]
 8005f28:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
 8005f2c:	687b      	ldr	r3, [r7, #4]
 8005f2e:	431a      	orrs	r2, r3
 8005f30:	697b      	ldr	r3, [r7, #20]
 8005f32:	601a      	str	r2, [r3, #0]
}
 8005f34:	bf00      	nop
 8005f36:	371c      	adds	r7, #28
 8005f38:	46bd      	mov	sp, r7
 8005f3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005f3e:	4770      	bx	lr

08005f40 <LL_ADC_SetOffsetSaturation>:
{
 8005f40:	b480      	push	{r7}
 8005f42:	b087      	sub	sp, #28
 8005f44:	af00      	add	r7, sp, #0
 8005f46:	60f8      	str	r0, [r7, #12]
 8005f48:	60b9      	str	r1, [r7, #8]
 8005f4a:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005f4c:	68fb      	ldr	r3, [r7, #12]
 8005f4e:	3360      	adds	r3, #96	; 0x60
 8005f50:	461a      	mov	r2, r3
 8005f52:	68bb      	ldr	r3, [r7, #8]
 8005f54:	009b      	lsls	r3, r3, #2
 8005f56:	4413      	add	r3, r2
 8005f58:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg,
 8005f5a:	697b      	ldr	r3, [r7, #20]
 8005f5c:	681b      	ldr	r3, [r3, #0]
 8005f5e:	f023 7200 	bic.w	r2, r3, #33554432	; 0x2000000
 8005f62:	687b      	ldr	r3, [r7, #4]
 8005f64:	431a      	orrs	r2, r3
 8005f66:	697b      	ldr	r3, [r7, #20]
 8005f68:	601a      	str	r2, [r3, #0]
}
 8005f6a:	bf00      	nop
 8005f6c:	371c      	adds	r7, #28
 8005f6e:	46bd      	mov	sp, r7
 8005f70:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005f74:	4770      	bx	lr

08005f76 <LL_ADC_SetSamplingTimeCommonConfig>:
{
 8005f76:	b480      	push	{r7}
 8005f78:	b083      	sub	sp, #12
 8005f7a:	af00      	add	r7, sp, #0
 8005f7c:	6078      	str	r0, [r7, #4]
 8005f7e:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 8005f80:	687b      	ldr	r3, [r7, #4]
 8005f82:	695b      	ldr	r3, [r3, #20]
 8005f84:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8005f88:	683b      	ldr	r3, [r7, #0]
 8005f8a:	431a      	orrs	r2, r3
 8005f8c:	687b      	ldr	r3, [r7, #4]
 8005f8e:	615a      	str	r2, [r3, #20]
}
 8005f90:	bf00      	nop
 8005f92:	370c      	adds	r7, #12
 8005f94:	46bd      	mov	sp, r7
 8005f96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005f9a:	4770      	bx	lr

08005f9c <LL_ADC_REG_IsTriggerSourceSWStart>:
{
 8005f9c:	b480      	push	{r7}
 8005f9e:	b083      	sub	sp, #12
 8005fa0:	af00      	add	r7, sp, #0
 8005fa2:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN)) ? 1UL : 0UL);
 8005fa4:	687b      	ldr	r3, [r7, #4]
 8005fa6:	68db      	ldr	r3, [r3, #12]
 8005fa8:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 8005fac:	2b00      	cmp	r3, #0
 8005fae:	d101      	bne.n	8005fb4 <LL_ADC_REG_IsTriggerSourceSWStart+0x18>
 8005fb0:	2301      	movs	r3, #1
 8005fb2:	e000      	b.n	8005fb6 <LL_ADC_REG_IsTriggerSourceSWStart+0x1a>
 8005fb4:	2300      	movs	r3, #0
}
 8005fb6:	4618      	mov	r0, r3
 8005fb8:	370c      	adds	r7, #12
 8005fba:	46bd      	mov	sp, r7
 8005fbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005fc0:	4770      	bx	lr

08005fc2 <LL_ADC_REG_SetSequencerRanks>:
{
 8005fc2:	b480      	push	{r7}
 8005fc4:	b087      	sub	sp, #28
 8005fc6:	af00      	add	r7, sp, #0
 8005fc8:	60f8      	str	r0, [r7, #12]
 8005fca:	60b9      	str	r1, [r7, #8]
 8005fcc:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 8005fce:	68fb      	ldr	r3, [r7, #12]
 8005fd0:	3330      	adds	r3, #48	; 0x30
 8005fd2:	461a      	mov	r2, r3
 8005fd4:	68bb      	ldr	r3, [r7, #8]
 8005fd6:	0a1b      	lsrs	r3, r3, #8
 8005fd8:	009b      	lsls	r3, r3, #2
 8005fda:	f003 030c 	and.w	r3, r3, #12
 8005fde:	4413      	add	r3, r2
 8005fe0:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg,
 8005fe2:	697b      	ldr	r3, [r7, #20]
 8005fe4:	681a      	ldr	r2, [r3, #0]
 8005fe6:	68bb      	ldr	r3, [r7, #8]
 8005fe8:	f003 031f 	and.w	r3, r3, #31
 8005fec:	211f      	movs	r1, #31
 8005fee:	fa01 f303 	lsl.w	r3, r1, r3
 8005ff2:	43db      	mvns	r3, r3
 8005ff4:	401a      	ands	r2, r3
 8005ff6:	687b      	ldr	r3, [r7, #4]
 8005ff8:	0e9b      	lsrs	r3, r3, #26
 8005ffa:	f003 011f 	and.w	r1, r3, #31
 8005ffe:	68bb      	ldr	r3, [r7, #8]
 8006000:	f003 031f 	and.w	r3, r3, #31
 8006004:	fa01 f303 	lsl.w	r3, r1, r3
 8006008:	431a      	orrs	r2, r3
 800600a:	697b      	ldr	r3, [r7, #20]
 800600c:	601a      	str	r2, [r3, #0]
}
 800600e:	bf00      	nop
 8006010:	371c      	adds	r7, #28
 8006012:	46bd      	mov	sp, r7
 8006014:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006018:	4770      	bx	lr

0800601a <LL_ADC_INJ_IsTriggerSourceSWStart>:
{
 800601a:	b480      	push	{r7}
 800601c:	b083      	sub	sp, #12
 800601e:	af00      	add	r7, sp, #0
 8006020:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->JSQR, ADC_JSQR_JEXTEN) == (LL_ADC_INJ_TRIG_SOFTWARE & ADC_JSQR_JEXTEN)) ? 1UL : 0UL);
 8006022:	687b      	ldr	r3, [r7, #4]
 8006024:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8006026:	f403 73c0 	and.w	r3, r3, #384	; 0x180
 800602a:	2b00      	cmp	r3, #0
 800602c:	d101      	bne.n	8006032 <LL_ADC_INJ_IsTriggerSourceSWStart+0x18>
 800602e:	2301      	movs	r3, #1
 8006030:	e000      	b.n	8006034 <LL_ADC_INJ_IsTriggerSourceSWStart+0x1a>
 8006032:	2300      	movs	r3, #0
}
 8006034:	4618      	mov	r0, r3
 8006036:	370c      	adds	r7, #12
 8006038:	46bd      	mov	sp, r7
 800603a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800603e:	4770      	bx	lr

08006040 <LL_ADC_SetChannelSamplingTime>:
{
 8006040:	b480      	push	{r7}
 8006042:	b087      	sub	sp, #28
 8006044:	af00      	add	r7, sp, #0
 8006046:	60f8      	str	r0, [r7, #12]
 8006048:	60b9      	str	r1, [r7, #8]
 800604a:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 800604c:	68fb      	ldr	r3, [r7, #12]
 800604e:	3314      	adds	r3, #20
 8006050:	461a      	mov	r2, r3
 8006052:	68bb      	ldr	r3, [r7, #8]
 8006054:	0e5b      	lsrs	r3, r3, #25
 8006056:	009b      	lsls	r3, r3, #2
 8006058:	f003 0304 	and.w	r3, r3, #4
 800605c:	4413      	add	r3, r2
 800605e:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg,
 8006060:	697b      	ldr	r3, [r7, #20]
 8006062:	681a      	ldr	r2, [r3, #0]
 8006064:	68bb      	ldr	r3, [r7, #8]
 8006066:	0d1b      	lsrs	r3, r3, #20
 8006068:	f003 031f 	and.w	r3, r3, #31
 800606c:	2107      	movs	r1, #7
 800606e:	fa01 f303 	lsl.w	r3, r1, r3
 8006072:	43db      	mvns	r3, r3
 8006074:	401a      	ands	r2, r3
 8006076:	68bb      	ldr	r3, [r7, #8]
 8006078:	0d1b      	lsrs	r3, r3, #20
 800607a:	f003 031f 	and.w	r3, r3, #31
 800607e:	6879      	ldr	r1, [r7, #4]
 8006080:	fa01 f303 	lsl.w	r3, r1, r3
 8006084:	431a      	orrs	r2, r3
 8006086:	697b      	ldr	r3, [r7, #20]
 8006088:	601a      	str	r2, [r3, #0]
}
 800608a:	bf00      	nop
 800608c:	371c      	adds	r7, #28
 800608e:	46bd      	mov	sp, r7
 8006090:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006094:	4770      	bx	lr
	...

08006098 <LL_ADC_SetChannelSingleDiff>:
{
 8006098:	b480      	push	{r7}
 800609a:	b085      	sub	sp, #20
 800609c:	af00      	add	r7, sp, #0
 800609e:	60f8      	str	r0, [r7, #12]
 80060a0:	60b9      	str	r1, [r7, #8]
 80060a2:	607a      	str	r2, [r7, #4]
  if (SingleDiff == LL_ADC_DIFFERENTIAL_ENDED)
 80060a4:	687b      	ldr	r3, [r7, #4]
 80060a6:	4a0f      	ldr	r2, [pc, #60]	; (80060e4 <LL_ADC_SetChannelSingleDiff+0x4c>)
 80060a8:	4293      	cmp	r3, r2
 80060aa:	d10a      	bne.n	80060c2 <LL_ADC_SetChannelSingleDiff+0x2a>
    SET_BIT(ADCx->DIFSEL,
 80060ac:	68fb      	ldr	r3, [r7, #12]
 80060ae:	f8d3 20b0 	ldr.w	r2, [r3, #176]	; 0xb0
 80060b2:	68bb      	ldr	r3, [r7, #8]
 80060b4:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80060b8:	431a      	orrs	r2, r3
 80060ba:	68fb      	ldr	r3, [r7, #12]
 80060bc:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
}
 80060c0:	e00a      	b.n	80060d8 <LL_ADC_SetChannelSingleDiff+0x40>
    CLEAR_BIT(ADCx->DIFSEL,
 80060c2:	68fb      	ldr	r3, [r7, #12]
 80060c4:	f8d3 20b0 	ldr.w	r2, [r3, #176]	; 0xb0
 80060c8:	68bb      	ldr	r3, [r7, #8]
 80060ca:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80060ce:	43db      	mvns	r3, r3
 80060d0:	401a      	ands	r2, r3
 80060d2:	68fb      	ldr	r3, [r7, #12]
 80060d4:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
}
 80060d8:	bf00      	nop
 80060da:	3714      	adds	r7, #20
 80060dc:	46bd      	mov	sp, r7
 80060de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80060e2:	4770      	bx	lr
 80060e4:	407f0000 	.word	0x407f0000

080060e8 <LL_ADC_SetAnalogWDMonitChannels>:
{
 80060e8:	b480      	push	{r7}
 80060ea:	b087      	sub	sp, #28
 80060ec:	af00      	add	r7, sp, #0
 80060ee:	60f8      	str	r0, [r7, #12]
 80060f0:	60b9      	str	r1, [r7, #8]
 80060f2:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->CFGR, ((AWDy & ADC_AWD_CRX_REGOFFSET_MASK) >> ADC_AWD_CRX_REGOFFSET_POS)
 80060f4:	68fb      	ldr	r3, [r7, #12]
 80060f6:	330c      	adds	r3, #12
 80060f8:	4618      	mov	r0, r3
 80060fa:	68bb      	ldr	r3, [r7, #8]
 80060fc:	0d1b      	lsrs	r3, r3, #20
 80060fe:	f003 0103 	and.w	r1, r3, #3
 8006102:	68bb      	ldr	r3, [r7, #8]
 8006104:	f003 0201 	and.w	r2, r3, #1
 8006108:	4613      	mov	r3, r2
 800610a:	00db      	lsls	r3, r3, #3
 800610c:	4413      	add	r3, r2
 800610e:	009b      	lsls	r3, r3, #2
 8006110:	440b      	add	r3, r1
 8006112:	009b      	lsls	r3, r3, #2
 8006114:	4403      	add	r3, r0
 8006116:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg,
 8006118:	697b      	ldr	r3, [r7, #20]
 800611a:	681a      	ldr	r2, [r3, #0]
 800611c:	68bb      	ldr	r3, [r7, #8]
 800611e:	f023 4302 	bic.w	r3, r3, #2181038080	; 0x82000000
 8006122:	f423 1360 	bic.w	r3, r3, #3670016	; 0x380000
 8006126:	43db      	mvns	r3, r3
 8006128:	401a      	ands	r2, r3
 800612a:	6879      	ldr	r1, [r7, #4]
 800612c:	68bb      	ldr	r3, [r7, #8]
 800612e:	400b      	ands	r3, r1
 8006130:	431a      	orrs	r2, r3
 8006132:	697b      	ldr	r3, [r7, #20]
 8006134:	601a      	str	r2, [r3, #0]
}
 8006136:	bf00      	nop
 8006138:	371c      	adds	r7, #28
 800613a:	46bd      	mov	sp, r7
 800613c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006140:	4770      	bx	lr

08006142 <LL_ADC_ConfigAnalogWDThresholds>:
{
 8006142:	b480      	push	{r7}
 8006144:	b087      	sub	sp, #28
 8006146:	af00      	add	r7, sp, #0
 8006148:	60f8      	str	r0, [r7, #12]
 800614a:	60b9      	str	r1, [r7, #8]
 800614c:	607a      	str	r2, [r7, #4]
 800614e:	603b      	str	r3, [r7, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->TR1, ((AWDy & ADC_AWD_TRX_REGOFFSET_MASK) >> ADC_AWD_TRX_REGOFFSET_POS));
 8006150:	68fb      	ldr	r3, [r7, #12]
 8006152:	3320      	adds	r3, #32
 8006154:	461a      	mov	r2, r3
 8006156:	68bb      	ldr	r3, [r7, #8]
 8006158:	0d1b      	lsrs	r3, r3, #20
 800615a:	009b      	lsls	r3, r3, #2
 800615c:	f003 030c 	and.w	r3, r3, #12
 8006160:	4413      	add	r3, r2
 8006162:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg,
 8006164:	697b      	ldr	r3, [r7, #20]
 8006166:	681b      	ldr	r3, [r3, #0]
 8006168:	f003 22f0 	and.w	r2, r3, #4026593280	; 0xf000f000
 800616c:	687b      	ldr	r3, [r7, #4]
 800616e:	0419      	lsls	r1, r3, #16
 8006170:	683b      	ldr	r3, [r7, #0]
 8006172:	430b      	orrs	r3, r1
 8006174:	431a      	orrs	r2, r3
 8006176:	697b      	ldr	r3, [r7, #20]
 8006178:	601a      	str	r2, [r3, #0]
}
 800617a:	bf00      	nop
 800617c:	371c      	adds	r7, #28
 800617e:	46bd      	mov	sp, r7
 8006180:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006184:	4770      	bx	lr

08006186 <LL_ADC_GetMultimode>:
{
 8006186:	b480      	push	{r7}
 8006188:	b083      	sub	sp, #12
 800618a:	af00      	add	r7, sp, #0
 800618c:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
 800618e:	687b      	ldr	r3, [r7, #4]
 8006190:	689b      	ldr	r3, [r3, #8]
 8006192:	f003 031f 	and.w	r3, r3, #31
}
 8006196:	4618      	mov	r0, r3
 8006198:	370c      	adds	r7, #12
 800619a:	46bd      	mov	sp, r7
 800619c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80061a0:	4770      	bx	lr

080061a2 <LL_ADC_GetMultiDMATransfer>:
{
 80061a2:	b480      	push	{r7}
 80061a4:	b083      	sub	sp, #12
 80061a6:	af00      	add	r7, sp, #0
 80061a8:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG));
 80061aa:	687b      	ldr	r3, [r7, #4]
 80061ac:	689b      	ldr	r3, [r3, #8]
 80061ae:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
}
 80061b2:	4618      	mov	r0, r3
 80061b4:	370c      	adds	r7, #12
 80061b6:	46bd      	mov	sp, r7
 80061b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80061bc:	4770      	bx	lr

080061be <LL_ADC_DisableDeepPowerDown>:
{
 80061be:	b480      	push	{r7}
 80061c0:	b083      	sub	sp, #12
 80061c2:	af00      	add	r7, sp, #0
 80061c4:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 80061c6:	687b      	ldr	r3, [r7, #4]
 80061c8:	689b      	ldr	r3, [r3, #8]
 80061ca:	f023 4320 	bic.w	r3, r3, #2684354560	; 0xa0000000
 80061ce:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 80061d2:	687a      	ldr	r2, [r7, #4]
 80061d4:	6093      	str	r3, [r2, #8]
}
 80061d6:	bf00      	nop
 80061d8:	370c      	adds	r7, #12
 80061da:	46bd      	mov	sp, r7
 80061dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80061e0:	4770      	bx	lr

080061e2 <LL_ADC_IsDeepPowerDownEnabled>:
{
 80061e2:	b480      	push	{r7}
 80061e4:	b083      	sub	sp, #12
 80061e6:	af00      	add	r7, sp, #0
 80061e8:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
 80061ea:	687b      	ldr	r3, [r7, #4]
 80061ec:	689b      	ldr	r3, [r3, #8]
 80061ee:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 80061f2:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 80061f6:	d101      	bne.n	80061fc <LL_ADC_IsDeepPowerDownEnabled+0x1a>
 80061f8:	2301      	movs	r3, #1
 80061fa:	e000      	b.n	80061fe <LL_ADC_IsDeepPowerDownEnabled+0x1c>
 80061fc:	2300      	movs	r3, #0
}
 80061fe:	4618      	mov	r0, r3
 8006200:	370c      	adds	r7, #12
 8006202:	46bd      	mov	sp, r7
 8006204:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006208:	4770      	bx	lr

0800620a <LL_ADC_EnableInternalRegulator>:
{
 800620a:	b480      	push	{r7}
 800620c:	b083      	sub	sp, #12
 800620e:	af00      	add	r7, sp, #0
 8006210:	6078      	str	r0, [r7, #4]
  MODIFY_REG(ADCx->CR,
 8006212:	687b      	ldr	r3, [r7, #4]
 8006214:	689b      	ldr	r3, [r3, #8]
 8006216:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 800621a:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800621e:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
 8006222:	687b      	ldr	r3, [r7, #4]
 8006224:	609a      	str	r2, [r3, #8]
}
 8006226:	bf00      	nop
 8006228:	370c      	adds	r7, #12
 800622a:	46bd      	mov	sp, r7
 800622c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006230:	4770      	bx	lr

08006232 <LL_ADC_IsInternalRegulatorEnabled>:
{
 8006232:	b480      	push	{r7}
 8006234:	b083      	sub	sp, #12
 8006236:	af00      	add	r7, sp, #0
 8006238:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 800623a:	687b      	ldr	r3, [r7, #4]
 800623c:	689b      	ldr	r3, [r3, #8]
 800623e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8006242:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8006246:	d101      	bne.n	800624c <LL_ADC_IsInternalRegulatorEnabled+0x1a>
 8006248:	2301      	movs	r3, #1
 800624a:	e000      	b.n	800624e <LL_ADC_IsInternalRegulatorEnabled+0x1c>
 800624c:	2300      	movs	r3, #0
}
 800624e:	4618      	mov	r0, r3
 8006250:	370c      	adds	r7, #12
 8006252:	46bd      	mov	sp, r7
 8006254:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006258:	4770      	bx	lr

0800625a <LL_ADC_Enable>:
{
 800625a:	b480      	push	{r7}
 800625c:	b083      	sub	sp, #12
 800625e:	af00      	add	r7, sp, #0
 8006260:	6078      	str	r0, [r7, #4]
  MODIFY_REG(ADCx->CR,
 8006262:	687b      	ldr	r3, [r7, #4]
 8006264:	689b      	ldr	r3, [r3, #8]
 8006266:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800626a:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800626e:	f043 0201 	orr.w	r2, r3, #1
 8006272:	687b      	ldr	r3, [r7, #4]
 8006274:	609a      	str	r2, [r3, #8]
}
 8006276:	bf00      	nop
 8006278:	370c      	adds	r7, #12
 800627a:	46bd      	mov	sp, r7
 800627c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006280:	4770      	bx	lr

08006282 <LL_ADC_Disable>:
{
 8006282:	b480      	push	{r7}
 8006284:	b083      	sub	sp, #12
 8006286:	af00      	add	r7, sp, #0
 8006288:	6078      	str	r0, [r7, #4]
  MODIFY_REG(ADCx->CR,
 800628a:	687b      	ldr	r3, [r7, #4]
 800628c:	689b      	ldr	r3, [r3, #8]
 800628e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8006292:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8006296:	f043 0202 	orr.w	r2, r3, #2
 800629a:	687b      	ldr	r3, [r7, #4]
 800629c:	609a      	str	r2, [r3, #8]
}
 800629e:	bf00      	nop
 80062a0:	370c      	adds	r7, #12
 80062a2:	46bd      	mov	sp, r7
 80062a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80062a8:	4770      	bx	lr

080062aa <LL_ADC_IsEnabled>:
{
 80062aa:	b480      	push	{r7}
 80062ac:	b083      	sub	sp, #12
 80062ae:	af00      	add	r7, sp, #0
 80062b0:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80062b2:	687b      	ldr	r3, [r7, #4]
 80062b4:	689b      	ldr	r3, [r3, #8]
 80062b6:	f003 0301 	and.w	r3, r3, #1
 80062ba:	2b01      	cmp	r3, #1
 80062bc:	d101      	bne.n	80062c2 <LL_ADC_IsEnabled+0x18>
 80062be:	2301      	movs	r3, #1
 80062c0:	e000      	b.n	80062c4 <LL_ADC_IsEnabled+0x1a>
 80062c2:	2300      	movs	r3, #0
}
 80062c4:	4618      	mov	r0, r3
 80062c6:	370c      	adds	r7, #12
 80062c8:	46bd      	mov	sp, r7
 80062ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80062ce:	4770      	bx	lr

080062d0 <LL_ADC_IsDisableOngoing>:
{
 80062d0:	b480      	push	{r7}
 80062d2:	b083      	sub	sp, #12
 80062d4:	af00      	add	r7, sp, #0
 80062d6:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 80062d8:	687b      	ldr	r3, [r7, #4]
 80062da:	689b      	ldr	r3, [r3, #8]
 80062dc:	f003 0302 	and.w	r3, r3, #2
 80062e0:	2b02      	cmp	r3, #2
 80062e2:	d101      	bne.n	80062e8 <LL_ADC_IsDisableOngoing+0x18>
 80062e4:	2301      	movs	r3, #1
 80062e6:	e000      	b.n	80062ea <LL_ADC_IsDisableOngoing+0x1a>
 80062e8:	2300      	movs	r3, #0
}
 80062ea:	4618      	mov	r0, r3
 80062ec:	370c      	adds	r7, #12
 80062ee:	46bd      	mov	sp, r7
 80062f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80062f4:	4770      	bx	lr

080062f6 <LL_ADC_REG_StartConversion>:
{
 80062f6:	b480      	push	{r7}
 80062f8:	b083      	sub	sp, #12
 80062fa:	af00      	add	r7, sp, #0
 80062fc:	6078      	str	r0, [r7, #4]
  MODIFY_REG(ADCx->CR,
 80062fe:	687b      	ldr	r3, [r7, #4]
 8006300:	689b      	ldr	r3, [r3, #8]
 8006302:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8006306:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800630a:	f043 0204 	orr.w	r2, r3, #4
 800630e:	687b      	ldr	r3, [r7, #4]
 8006310:	609a      	str	r2, [r3, #8]
}
 8006312:	bf00      	nop
 8006314:	370c      	adds	r7, #12
 8006316:	46bd      	mov	sp, r7
 8006318:	f85d 7b04 	ldr.w	r7, [sp], #4
 800631c:	4770      	bx	lr

0800631e <LL_ADC_REG_StopConversion>:
{
 800631e:	b480      	push	{r7}
 8006320:	b083      	sub	sp, #12
 8006322:	af00      	add	r7, sp, #0
 8006324:	6078      	str	r0, [r7, #4]
  MODIFY_REG(ADCx->CR,
 8006326:	687b      	ldr	r3, [r7, #4]
 8006328:	689b      	ldr	r3, [r3, #8]
 800632a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800632e:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8006332:	f043 0210 	orr.w	r2, r3, #16
 8006336:	687b      	ldr	r3, [r7, #4]
 8006338:	609a      	str	r2, [r3, #8]
}
 800633a:	bf00      	nop
 800633c:	370c      	adds	r7, #12
 800633e:	46bd      	mov	sp, r7
 8006340:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006344:	4770      	bx	lr

08006346 <LL_ADC_REG_IsConversionOngoing>:
{
 8006346:	b480      	push	{r7}
 8006348:	b083      	sub	sp, #12
 800634a:	af00      	add	r7, sp, #0
 800634c:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 800634e:	687b      	ldr	r3, [r7, #4]
 8006350:	689b      	ldr	r3, [r3, #8]
 8006352:	f003 0304 	and.w	r3, r3, #4
 8006356:	2b04      	cmp	r3, #4
 8006358:	d101      	bne.n	800635e <LL_ADC_REG_IsConversionOngoing+0x18>
 800635a:	2301      	movs	r3, #1
 800635c:	e000      	b.n	8006360 <LL_ADC_REG_IsConversionOngoing+0x1a>
 800635e:	2300      	movs	r3, #0
}
 8006360:	4618      	mov	r0, r3
 8006362:	370c      	adds	r7, #12
 8006364:	46bd      	mov	sp, r7
 8006366:	f85d 7b04 	ldr.w	r7, [sp], #4
 800636a:	4770      	bx	lr

0800636c <LL_ADC_INJ_StopConversion>:
{
 800636c:	b480      	push	{r7}
 800636e:	b083      	sub	sp, #12
 8006370:	af00      	add	r7, sp, #0
 8006372:	6078      	str	r0, [r7, #4]
  MODIFY_REG(ADCx->CR,
 8006374:	687b      	ldr	r3, [r7, #4]
 8006376:	689b      	ldr	r3, [r3, #8]
 8006378:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800637c:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8006380:	f043 0220 	orr.w	r2, r3, #32
 8006384:	687b      	ldr	r3, [r7, #4]
 8006386:	609a      	str	r2, [r3, #8]
}
 8006388:	bf00      	nop
 800638a:	370c      	adds	r7, #12
 800638c:	46bd      	mov	sp, r7
 800638e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006392:	4770      	bx	lr

08006394 <LL_ADC_INJ_IsConversionOngoing>:
{
 8006394:	b480      	push	{r7}
 8006396:	b083      	sub	sp, #12
 8006398:	af00      	add	r7, sp, #0
 800639a:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 800639c:	687b      	ldr	r3, [r7, #4]
 800639e:	689b      	ldr	r3, [r3, #8]
 80063a0:	f003 0308 	and.w	r3, r3, #8
 80063a4:	2b08      	cmp	r3, #8
 80063a6:	d101      	bne.n	80063ac <LL_ADC_INJ_IsConversionOngoing+0x18>
 80063a8:	2301      	movs	r3, #1
 80063aa:	e000      	b.n	80063ae <LL_ADC_INJ_IsConversionOngoing+0x1a>
 80063ac:	2300      	movs	r3, #0
}
 80063ae:	4618      	mov	r0, r3
 80063b0:	370c      	adds	r7, #12
 80063b2:	46bd      	mov	sp, r7
 80063b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80063b8:	4770      	bx	lr

080063ba <LL_ADC_ClearFlag_AWD1>:
{
 80063ba:	b480      	push	{r7}
 80063bc:	b083      	sub	sp, #12
 80063be:	af00      	add	r7, sp, #0
 80063c0:	6078      	str	r0, [r7, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_AWD1);
 80063c2:	687b      	ldr	r3, [r7, #4]
 80063c4:	2280      	movs	r2, #128	; 0x80
 80063c6:	601a      	str	r2, [r3, #0]
}
 80063c8:	bf00      	nop
 80063ca:	370c      	adds	r7, #12
 80063cc:	46bd      	mov	sp, r7
 80063ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80063d2:	4770      	bx	lr

080063d4 <LL_ADC_ClearFlag_AWD2>:
{
 80063d4:	b480      	push	{r7}
 80063d6:	b083      	sub	sp, #12
 80063d8:	af00      	add	r7, sp, #0
 80063da:	6078      	str	r0, [r7, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_AWD2);
 80063dc:	687b      	ldr	r3, [r7, #4]
 80063de:	f44f 7280 	mov.w	r2, #256	; 0x100
 80063e2:	601a      	str	r2, [r3, #0]
}
 80063e4:	bf00      	nop
 80063e6:	370c      	adds	r7, #12
 80063e8:	46bd      	mov	sp, r7
 80063ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80063ee:	4770      	bx	lr

080063f0 <LL_ADC_ClearFlag_AWD3>:
{
 80063f0:	b480      	push	{r7}
 80063f2:	b083      	sub	sp, #12
 80063f4:	af00      	add	r7, sp, #0
 80063f6:	6078      	str	r0, [r7, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_AWD3);
 80063f8:	687b      	ldr	r3, [r7, #4]
 80063fa:	f44f 7200 	mov.w	r2, #512	; 0x200
 80063fe:	601a      	str	r2, [r3, #0]
}
 8006400:	bf00      	nop
 8006402:	370c      	adds	r7, #12
 8006404:	46bd      	mov	sp, r7
 8006406:	f85d 7b04 	ldr.w	r7, [sp], #4
 800640a:	4770      	bx	lr

0800640c <LL_ADC_EnableIT_AWD1>:
{
 800640c:	b480      	push	{r7}
 800640e:	b083      	sub	sp, #12
 8006410:	af00      	add	r7, sp, #0
 8006412:	6078      	str	r0, [r7, #4]
  SET_BIT(ADCx->IER, LL_ADC_IT_AWD1);
 8006414:	687b      	ldr	r3, [r7, #4]
 8006416:	685b      	ldr	r3, [r3, #4]
 8006418:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 800641c:	687b      	ldr	r3, [r7, #4]
 800641e:	605a      	str	r2, [r3, #4]
}
 8006420:	bf00      	nop
 8006422:	370c      	adds	r7, #12
 8006424:	46bd      	mov	sp, r7
 8006426:	f85d 7b04 	ldr.w	r7, [sp], #4
 800642a:	4770      	bx	lr

0800642c <LL_ADC_EnableIT_AWD2>:
{
 800642c:	b480      	push	{r7}
 800642e:	b083      	sub	sp, #12
 8006430:	af00      	add	r7, sp, #0
 8006432:	6078      	str	r0, [r7, #4]
  SET_BIT(ADCx->IER, LL_ADC_IT_AWD2);
 8006434:	687b      	ldr	r3, [r7, #4]
 8006436:	685b      	ldr	r3, [r3, #4]
 8006438:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 800643c:	687b      	ldr	r3, [r7, #4]
 800643e:	605a      	str	r2, [r3, #4]
}
 8006440:	bf00      	nop
 8006442:	370c      	adds	r7, #12
 8006444:	46bd      	mov	sp, r7
 8006446:	f85d 7b04 	ldr.w	r7, [sp], #4
 800644a:	4770      	bx	lr

0800644c <LL_ADC_EnableIT_AWD3>:
{
 800644c:	b480      	push	{r7}
 800644e:	b083      	sub	sp, #12
 8006450:	af00      	add	r7, sp, #0
 8006452:	6078      	str	r0, [r7, #4]
  SET_BIT(ADCx->IER, LL_ADC_IT_AWD3);
 8006454:	687b      	ldr	r3, [r7, #4]
 8006456:	685b      	ldr	r3, [r3, #4]
 8006458:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 800645c:	687b      	ldr	r3, [r7, #4]
 800645e:	605a      	str	r2, [r3, #4]
}
 8006460:	bf00      	nop
 8006462:	370c      	adds	r7, #12
 8006464:	46bd      	mov	sp, r7
 8006466:	f85d 7b04 	ldr.w	r7, [sp], #4
 800646a:	4770      	bx	lr

0800646c <LL_ADC_DisableIT_AWD1>:
{
 800646c:	b480      	push	{r7}
 800646e:	b083      	sub	sp, #12
 8006470:	af00      	add	r7, sp, #0
 8006472:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_AWD1);
 8006474:	687b      	ldr	r3, [r7, #4]
 8006476:	685b      	ldr	r3, [r3, #4]
 8006478:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 800647c:	687b      	ldr	r3, [r7, #4]
 800647e:	605a      	str	r2, [r3, #4]
}
 8006480:	bf00      	nop
 8006482:	370c      	adds	r7, #12
 8006484:	46bd      	mov	sp, r7
 8006486:	f85d 7b04 	ldr.w	r7, [sp], #4
 800648a:	4770      	bx	lr

0800648c <LL_ADC_DisableIT_AWD2>:
{
 800648c:	b480      	push	{r7}
 800648e:	b083      	sub	sp, #12
 8006490:	af00      	add	r7, sp, #0
 8006492:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_AWD2);
 8006494:	687b      	ldr	r3, [r7, #4]
 8006496:	685b      	ldr	r3, [r3, #4]
 8006498:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 800649c:	687b      	ldr	r3, [r7, #4]
 800649e:	605a      	str	r2, [r3, #4]
}
 80064a0:	bf00      	nop
 80064a2:	370c      	adds	r7, #12
 80064a4:	46bd      	mov	sp, r7
 80064a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80064aa:	4770      	bx	lr

080064ac <LL_ADC_DisableIT_AWD3>:
  * @rmtoll IER      AWD3IE         LL_ADC_DisableIT_AWD3
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_AWD3(ADC_TypeDef *ADCx)
{
 80064ac:	b480      	push	{r7}
 80064ae:	b083      	sub	sp, #12
 80064b0:	af00      	add	r7, sp, #0
 80064b2:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_AWD3);
 80064b4:	687b      	ldr	r3, [r7, #4]
 80064b6:	685b      	ldr	r3, [r3, #4]
 80064b8:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 80064bc:	687b      	ldr	r3, [r7, #4]
 80064be:	605a      	str	r2, [r3, #4]
}
 80064c0:	bf00      	nop
 80064c2:	370c      	adds	r7, #12
 80064c4:	46bd      	mov	sp, r7
 80064c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80064ca:	4770      	bx	lr

080064cc <HAL_ADC_Init>:
  *         without  disabling the other ADCs.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 80064cc:	b590      	push	{r4, r7, lr}
 80064ce:	b089      	sub	sp, #36	; 0x24
 80064d0:	af00      	add	r7, sp, #0
 80064d2:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80064d4:	2300      	movs	r3, #0
 80064d6:	77fb      	strb	r3, [r7, #31]
  uint32_t tmpCFGR;
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 80064d8:	2300      	movs	r3, #0
 80064da:	60bb      	str	r3, [r7, #8]
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;

  /* Check ADC handle */
  if (hadc == NULL)
 80064dc:	687b      	ldr	r3, [r7, #4]
 80064de:	2b00      	cmp	r3, #0
 80064e0:	d101      	bne.n	80064e6 <HAL_ADC_Init+0x1a>
  {
    return HAL_ERROR;
 80064e2:	2301      	movs	r3, #1
 80064e4:	e1af      	b.n	8006846 <HAL_ADC_Init+0x37a>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));

  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 80064e6:	687b      	ldr	r3, [r7, #4]
 80064e8:	695b      	ldr	r3, [r3, #20]
 80064ea:	2b00      	cmp	r3, #0
  /* DISCEN and CONT bits cannot be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 80064ec:	687b      	ldr	r3, [r7, #4]
 80064ee:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80064f0:	2b00      	cmp	r3, #0
 80064f2:	d109      	bne.n	8006508 <HAL_ADC_Init+0x3c>

    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 80064f4:	6878      	ldr	r0, [r7, #4]
 80064f6:	f7fa fdf3 	bl	80010e0 <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 80064fa:	687b      	ldr	r3, [r7, #4]
 80064fc:	2200      	movs	r2, #0
 80064fe:	661a      	str	r2, [r3, #96]	; 0x60

    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
 8006500:	687b      	ldr	r3, [r7, #4]
 8006502:	2200      	movs	r2, #0
 8006504:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
  }

  /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
 8006508:	687b      	ldr	r3, [r7, #4]
 800650a:	681b      	ldr	r3, [r3, #0]
 800650c:	4618      	mov	r0, r3
 800650e:	f7ff fe68 	bl	80061e2 <LL_ADC_IsDeepPowerDownEnabled>
 8006512:	4603      	mov	r3, r0
 8006514:	2b00      	cmp	r3, #0
 8006516:	d004      	beq.n	8006522 <HAL_ADC_Init+0x56>
  {
    /* Disable ADC deep power down mode */
    LL_ADC_DisableDeepPowerDown(hadc->Instance);
 8006518:	687b      	ldr	r3, [r7, #4]
 800651a:	681b      	ldr	r3, [r3, #0]
 800651c:	4618      	mov	r0, r3
 800651e:	f7ff fe4e 	bl	80061be <LL_ADC_DisableDeepPowerDown>
    /* System was in deep power down mode, calibration must
     be relaunched or a previously saved calibration factor
     re-applied once the ADC voltage regulator is enabled */
  }

  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 8006522:	687b      	ldr	r3, [r7, #4]
 8006524:	681b      	ldr	r3, [r3, #0]
 8006526:	4618      	mov	r0, r3
 8006528:	f7ff fe83 	bl	8006232 <LL_ADC_IsInternalRegulatorEnabled>
 800652c:	4603      	mov	r3, r0
 800652e:	2b00      	cmp	r3, #0
 8006530:	d115      	bne.n	800655e <HAL_ADC_Init+0x92>
  {
    /* Enable ADC internal voltage regulator */
    LL_ADC_EnableInternalRegulator(hadc->Instance);
 8006532:	687b      	ldr	r3, [r7, #4]
 8006534:	681b      	ldr	r3, [r3, #0]
 8006536:	4618      	mov	r0, r3
 8006538:	f7ff fe67 	bl	800620a <LL_ADC_EnableInternalRegulator>

    /* Note: Variable divided by 2 to compensate partially              */
    /*       CPU processing cycles, scaling in us split to not          */
    /*       exceed 32 bits register capacity and handle low frequency. */
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 800653c:	4b9f      	ldr	r3, [pc, #636]	; (80067bc <HAL_ADC_Init+0x2f0>)
 800653e:	681b      	ldr	r3, [r3, #0]
 8006540:	099b      	lsrs	r3, r3, #6
 8006542:	4a9f      	ldr	r2, [pc, #636]	; (80067c0 <HAL_ADC_Init+0x2f4>)
 8006544:	fba2 2303 	umull	r2, r3, r2, r3
 8006548:	099b      	lsrs	r3, r3, #6
 800654a:	3301      	adds	r3, #1
 800654c:	005b      	lsls	r3, r3, #1
 800654e:	60bb      	str	r3, [r7, #8]
    while (wait_loop_index != 0UL)
 8006550:	e002      	b.n	8006558 <HAL_ADC_Init+0x8c>
    {
      wait_loop_index--;
 8006552:	68bb      	ldr	r3, [r7, #8]
 8006554:	3b01      	subs	r3, #1
 8006556:	60bb      	str	r3, [r7, #8]
    while (wait_loop_index != 0UL)
 8006558:	68bb      	ldr	r3, [r7, #8]
 800655a:	2b00      	cmp	r3, #0
 800655c:	d1f9      	bne.n	8006552 <HAL_ADC_Init+0x86>
  }

  /* Verification that ADC voltage regulator is correctly enabled, whether    */
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 800655e:	687b      	ldr	r3, [r7, #4]
 8006560:	681b      	ldr	r3, [r3, #0]
 8006562:	4618      	mov	r0, r3
 8006564:	f7ff fe65 	bl	8006232 <LL_ADC_IsInternalRegulatorEnabled>
 8006568:	4603      	mov	r3, r0
 800656a:	2b00      	cmp	r3, #0
 800656c:	d10d      	bne.n	800658a <HAL_ADC_Init+0xbe>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800656e:	687b      	ldr	r3, [r7, #4]
 8006570:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006572:	f043 0210 	orr.w	r2, r3, #16
 8006576:	687b      	ldr	r3, [r7, #4]
 8006578:	65da      	str	r2, [r3, #92]	; 0x5c

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800657a:	687b      	ldr	r3, [r7, #4]
 800657c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800657e:	f043 0201 	orr.w	r2, r3, #1
 8006582:	687b      	ldr	r3, [r7, #4]
 8006584:	661a      	str	r2, [r3, #96]	; 0x60

    tmp_hal_status = HAL_ERROR;
 8006586:	2301      	movs	r3, #1
 8006588:	77fb      	strb	r3, [r7, #31]

  /* Configuration of ADC parameters if previous preliminary actions are      */
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 800658a:	687b      	ldr	r3, [r7, #4]
 800658c:	681b      	ldr	r3, [r3, #0]
 800658e:	4618      	mov	r0, r3
 8006590:	f7ff fed9 	bl	8006346 <LL_ADC_REG_IsConversionOngoing>
 8006594:	6178      	str	r0, [r7, #20]

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8006596:	687b      	ldr	r3, [r7, #4]
 8006598:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800659a:	f003 0310 	and.w	r3, r3, #16
 800659e:	2b00      	cmp	r3, #0
 80065a0:	f040 8148 	bne.w	8006834 <HAL_ADC_Init+0x368>
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
 80065a4:	697b      	ldr	r3, [r7, #20]
 80065a6:	2b00      	cmp	r3, #0
 80065a8:	f040 8144 	bne.w	8006834 <HAL_ADC_Init+0x368>
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 80065ac:	687b      	ldr	r3, [r7, #4]
 80065ae:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80065b0:	f423 7381 	bic.w	r3, r3, #258	; 0x102
 80065b4:	f043 0202 	orr.w	r2, r3, #2
 80065b8:	687b      	ldr	r3, [r7, #4]
 80065ba:	65da      	str	r2, [r3, #92]	; 0x5c
    /* Configuration of common ADC parameters                                 */

    /* Parameters update conditioned to ADC state:                            */
    /* Parameters that can be updated only when ADC is disabled:              */
    /*  - clock configuration                                                 */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 80065bc:	687b      	ldr	r3, [r7, #4]
 80065be:	681b      	ldr	r3, [r3, #0]
 80065c0:	4618      	mov	r0, r3
 80065c2:	f7ff fe72 	bl	80062aa <LL_ADC_IsEnabled>
 80065c6:	4603      	mov	r3, r0
 80065c8:	2b00      	cmp	r3, #0
 80065ca:	d141      	bne.n	8006650 <HAL_ADC_Init+0x184>
    {
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 80065cc:	687b      	ldr	r3, [r7, #4]
 80065ce:	681b      	ldr	r3, [r3, #0]
 80065d0:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80065d4:	d004      	beq.n	80065e0 <HAL_ADC_Init+0x114>
 80065d6:	687b      	ldr	r3, [r7, #4]
 80065d8:	681b      	ldr	r3, [r3, #0]
 80065da:	4a7a      	ldr	r2, [pc, #488]	; (80067c4 <HAL_ADC_Init+0x2f8>)
 80065dc:	4293      	cmp	r3, r2
 80065de:	d10f      	bne.n	8006600 <HAL_ADC_Init+0x134>
 80065e0:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
 80065e4:	f7ff fe61 	bl	80062aa <LL_ADC_IsEnabled>
 80065e8:	4604      	mov	r4, r0
 80065ea:	4876      	ldr	r0, [pc, #472]	; (80067c4 <HAL_ADC_Init+0x2f8>)
 80065ec:	f7ff fe5d 	bl	80062aa <LL_ADC_IsEnabled>
 80065f0:	4603      	mov	r3, r0
 80065f2:	4323      	orrs	r3, r4
 80065f4:	2b00      	cmp	r3, #0
 80065f6:	bf0c      	ite	eq
 80065f8:	2301      	moveq	r3, #1
 80065fa:	2300      	movne	r3, #0
 80065fc:	b2db      	uxtb	r3, r3
 80065fe:	e012      	b.n	8006626 <HAL_ADC_Init+0x15a>
 8006600:	4871      	ldr	r0, [pc, #452]	; (80067c8 <HAL_ADC_Init+0x2fc>)
 8006602:	f7ff fe52 	bl	80062aa <LL_ADC_IsEnabled>
 8006606:	4604      	mov	r4, r0
 8006608:	4870      	ldr	r0, [pc, #448]	; (80067cc <HAL_ADC_Init+0x300>)
 800660a:	f7ff fe4e 	bl	80062aa <LL_ADC_IsEnabled>
 800660e:	4603      	mov	r3, r0
 8006610:	431c      	orrs	r4, r3
 8006612:	486f      	ldr	r0, [pc, #444]	; (80067d0 <HAL_ADC_Init+0x304>)
 8006614:	f7ff fe49 	bl	80062aa <LL_ADC_IsEnabled>
 8006618:	4603      	mov	r3, r0
 800661a:	4323      	orrs	r3, r4
 800661c:	2b00      	cmp	r3, #0
 800661e:	bf0c      	ite	eq
 8006620:	2301      	moveq	r3, #1
 8006622:	2300      	movne	r3, #0
 8006624:	b2db      	uxtb	r3, r3
 8006626:	2b00      	cmp	r3, #0
 8006628:	d012      	beq.n	8006650 <HAL_ADC_Init+0x184>
        /*     parameters: MDMA, DMACFG, DELAY, DUAL (set by API                */
        /*     HAL_ADCEx_MultiModeConfigChannel() )                             */
        /*   - internal measurement paths: Vbat, temperature sensor, Vref       */
        /*     (set into HAL_ADC_ConfigChannel() or                             */
        /*     HAL_ADCEx_InjectedConfigChannel() )                              */
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
 800662a:	687b      	ldr	r3, [r7, #4]
 800662c:	681b      	ldr	r3, [r3, #0]
 800662e:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8006632:	d004      	beq.n	800663e <HAL_ADC_Init+0x172>
 8006634:	687b      	ldr	r3, [r7, #4]
 8006636:	681b      	ldr	r3, [r3, #0]
 8006638:	4a62      	ldr	r2, [pc, #392]	; (80067c4 <HAL_ADC_Init+0x2f8>)
 800663a:	4293      	cmp	r3, r2
 800663c:	d101      	bne.n	8006642 <HAL_ADC_Init+0x176>
 800663e:	4a65      	ldr	r2, [pc, #404]	; (80067d4 <HAL_ADC_Init+0x308>)
 8006640:	e000      	b.n	8006644 <HAL_ADC_Init+0x178>
 8006642:	4a65      	ldr	r2, [pc, #404]	; (80067d8 <HAL_ADC_Init+0x30c>)
 8006644:	687b      	ldr	r3, [r7, #4]
 8006646:	685b      	ldr	r3, [r3, #4]
 8006648:	4619      	mov	r1, r3
 800664a:	4610      	mov	r0, r2
 800664c:	f7ff fbd4 	bl	8005df8 <LL_ADC_SetCommonClock>
    /*  - external trigger polarity                Init.ExternalTrigConvEdge  */
    /*  - continuous conversion mode               Init.ContinuousConvMode    */
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 8006650:	687b      	ldr	r3, [r7, #4]
 8006652:	7f5b      	ldrb	r3, [r3, #29]
 8006654:	035a      	lsls	r2, r3, #13
                hadc->Init.Overrun                                                     |
 8006656:	687b      	ldr	r3, [r7, #4]
 8006658:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 800665a:	431a      	orrs	r2, r3
                hadc->Init.DataAlign                                                   |
 800665c:	687b      	ldr	r3, [r7, #4]
 800665e:	68db      	ldr	r3, [r3, #12]
                hadc->Init.Overrun                                                     |
 8006660:	431a      	orrs	r2, r3
                hadc->Init.Resolution                                                  |
 8006662:	687b      	ldr	r3, [r7, #4]
 8006664:	689b      	ldr	r3, [r3, #8]
                hadc->Init.DataAlign                                                   |
 8006666:	431a      	orrs	r2, r3
                ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
 8006668:	687b      	ldr	r3, [r7, #4]
 800666a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800666e:	041b      	lsls	r3, r3, #16
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 8006670:	4313      	orrs	r3, r2
 8006672:	61bb      	str	r3, [r7, #24]

    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8006674:	687b      	ldr	r3, [r7, #4]
 8006676:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800667a:	2b01      	cmp	r3, #1
 800667c:	d106      	bne.n	800668c <HAL_ADC_Init+0x1c0>
    {
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 800667e:	687b      	ldr	r3, [r7, #4]
 8006680:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006682:	3b01      	subs	r3, #1
 8006684:	045b      	lsls	r3, r3, #17
 8006686:	69ba      	ldr	r2, [r7, #24]
 8006688:	4313      	orrs	r3, r2
 800668a:	61bb      	str	r3, [r7, #24]
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 800668c:	687b      	ldr	r3, [r7, #4]
 800668e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006690:	2b00      	cmp	r3, #0
 8006692:	d009      	beq.n	80066a8 <HAL_ADC_Init+0x1dc>
    {
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8006694:	687b      	ldr	r3, [r7, #4]
 8006696:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006698:	f403 7278 	and.w	r2, r3, #992	; 0x3e0
                  | hadc->Init.ExternalTrigConvEdge
 800669c:	687b      	ldr	r3, [r7, #4]
 800669e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80066a0:	4313      	orrs	r3, r2
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 80066a2:	69ba      	ldr	r2, [r7, #24]
 80066a4:	4313      	orrs	r3, r2
 80066a6:	61bb      	str	r3, [r7, #24]
                 );
    }

    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
 80066a8:	687b      	ldr	r3, [r7, #4]
 80066aa:	681b      	ldr	r3, [r3, #0]
 80066ac:	68da      	ldr	r2, [r3, #12]
 80066ae:	4b4b      	ldr	r3, [pc, #300]	; (80067dc <HAL_ADC_Init+0x310>)
 80066b0:	4013      	ands	r3, r2
 80066b2:	687a      	ldr	r2, [r7, #4]
 80066b4:	6812      	ldr	r2, [r2, #0]
 80066b6:	69b9      	ldr	r1, [r7, #24]
 80066b8:	430b      	orrs	r3, r1
 80066ba:	60d3      	str	r3, [r2, #12]

    /* Configuration of sampling mode */
    MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_BULB | ADC_CFGR2_SMPTRIG, hadc->Init.SamplingMode);
 80066bc:	687b      	ldr	r3, [r7, #4]
 80066be:	681b      	ldr	r3, [r3, #0]
 80066c0:	691b      	ldr	r3, [r3, #16]
 80066c2:	f023 6140 	bic.w	r1, r3, #201326592	; 0xc000000
 80066c6:	687b      	ldr	r3, [r7, #4]
 80066c8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80066ca:	687b      	ldr	r3, [r7, #4]
 80066cc:	681b      	ldr	r3, [r3, #0]
 80066ce:	430a      	orrs	r2, r1
 80066d0:	611a      	str	r2, [r3, #16]
    /* conversion on going on regular and injected groups:                    */
    /*  - Gain Compensation               Init.GainCompensation               */
    /*  - DMA continuous request          Init.DMAContinuousRequests          */
    /*  - LowPowerAutoWait feature        Init.LowPowerAutoWait               */
    /*  - Oversampling parameters         Init.Oversampling                   */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 80066d2:	687b      	ldr	r3, [r7, #4]
 80066d4:	681b      	ldr	r3, [r3, #0]
 80066d6:	4618      	mov	r0, r3
 80066d8:	f7ff fe35 	bl	8006346 <LL_ADC_REG_IsConversionOngoing>
 80066dc:	6138      	str	r0, [r7, #16]
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 80066de:	687b      	ldr	r3, [r7, #4]
 80066e0:	681b      	ldr	r3, [r3, #0]
 80066e2:	4618      	mov	r0, r3
 80066e4:	f7ff fe56 	bl	8006394 <LL_ADC_INJ_IsConversionOngoing>
 80066e8:	60f8      	str	r0, [r7, #12]
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 80066ea:	693b      	ldr	r3, [r7, #16]
 80066ec:	2b00      	cmp	r3, #0
 80066ee:	d17f      	bne.n	80067f0 <HAL_ADC_Init+0x324>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 80066f0:	68fb      	ldr	r3, [r7, #12]
 80066f2:	2b00      	cmp	r3, #0
 80066f4:	d17c      	bne.n	80067f0 <HAL_ADC_Init+0x324>
       )
    {
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
                 ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 80066f6:	687b      	ldr	r3, [r7, #4]
 80066f8:	7f1b      	ldrb	r3, [r3, #28]
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 80066fa:	039a      	lsls	r2, r3, #14
                 ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 80066fc:	687b      	ldr	r3, [r7, #4]
 80066fe:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8006702:	005b      	lsls	r3, r3, #1
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 8006704:	4313      	orrs	r3, r2
 8006706:	61bb      	str	r3, [r7, #24]

      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 8006708:	687b      	ldr	r3, [r7, #4]
 800670a:	681b      	ldr	r3, [r3, #0]
 800670c:	68db      	ldr	r3, [r3, #12]
 800670e:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8006712:	f023 0302 	bic.w	r3, r3, #2
 8006716:	687a      	ldr	r2, [r7, #4]
 8006718:	6812      	ldr	r2, [r2, #0]
 800671a:	69b9      	ldr	r1, [r7, #24]
 800671c:	430b      	orrs	r3, r1
 800671e:	60d3      	str	r3, [r2, #12]

      if (hadc->Init.GainCompensation != 0UL)
 8006720:	687b      	ldr	r3, [r7, #4]
 8006722:	691b      	ldr	r3, [r3, #16]
 8006724:	2b00      	cmp	r3, #0
 8006726:	d017      	beq.n	8006758 <HAL_ADC_Init+0x28c>
      {
        SET_BIT(hadc->Instance->CFGR2, ADC_CFGR2_GCOMP);
 8006728:	687b      	ldr	r3, [r7, #4]
 800672a:	681b      	ldr	r3, [r3, #0]
 800672c:	691a      	ldr	r2, [r3, #16]
 800672e:	687b      	ldr	r3, [r7, #4]
 8006730:	681b      	ldr	r3, [r3, #0]
 8006732:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8006736:	611a      	str	r2, [r3, #16]
        MODIFY_REG(hadc->Instance->GCOMP, ADC_GCOMP_GCOMPCOEFF, hadc->Init.GainCompensation);
 8006738:	687b      	ldr	r3, [r7, #4]
 800673a:	681b      	ldr	r3, [r3, #0]
 800673c:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8006740:	f423 537f 	bic.w	r3, r3, #16320	; 0x3fc0
 8006744:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8006748:	687a      	ldr	r2, [r7, #4]
 800674a:	6911      	ldr	r1, [r2, #16]
 800674c:	687a      	ldr	r2, [r7, #4]
 800674e:	6812      	ldr	r2, [r2, #0]
 8006750:	430b      	orrs	r3, r1
 8006752:	f8c2 30c0 	str.w	r3, [r2, #192]	; 0xc0
 8006756:	e013      	b.n	8006780 <HAL_ADC_Init+0x2b4>
      }
      else
      {
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_GCOMP);
 8006758:	687b      	ldr	r3, [r7, #4]
 800675a:	681b      	ldr	r3, [r3, #0]
 800675c:	691a      	ldr	r2, [r3, #16]
 800675e:	687b      	ldr	r3, [r7, #4]
 8006760:	681b      	ldr	r3, [r3, #0]
 8006762:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8006766:	611a      	str	r2, [r3, #16]
        MODIFY_REG(hadc->Instance->GCOMP, ADC_GCOMP_GCOMPCOEFF, 0UL);
 8006768:	687b      	ldr	r3, [r7, #4]
 800676a:	681b      	ldr	r3, [r3, #0]
 800676c:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8006770:	687a      	ldr	r2, [r7, #4]
 8006772:	6812      	ldr	r2, [r2, #0]
 8006774:	f423 537f 	bic.w	r3, r3, #16320	; 0x3fc0
 8006778:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800677c:	f8c2 30c0 	str.w	r3, [r2, #192]	; 0xc0
      }

      if (hadc->Init.OversamplingMode == ENABLE)
 8006780:	687b      	ldr	r3, [r7, #4]
 8006782:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 8006786:	2b01      	cmp	r3, #1
 8006788:	d12a      	bne.n	80067e0 <HAL_ADC_Init+0x314>
        /* Configuration of Oversampler:                                      */
        /*  - Oversampling Ratio                                              */
        /*  - Right bit shift                                                 */
        /*  - Triggered mode                                                  */
        /*  - Oversampling mode (continued/resumed)                           */
        MODIFY_REG(hadc->Instance->CFGR2,
 800678a:	687b      	ldr	r3, [r7, #4]
 800678c:	681b      	ldr	r3, [r3, #0]
 800678e:	691b      	ldr	r3, [r3, #16]
 8006790:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 8006794:	f023 0304 	bic.w	r3, r3, #4
 8006798:	687a      	ldr	r2, [r7, #4]
 800679a:	6c51      	ldr	r1, [r2, #68]	; 0x44
 800679c:	687a      	ldr	r2, [r7, #4]
 800679e:	6c92      	ldr	r2, [r2, #72]	; 0x48
 80067a0:	4311      	orrs	r1, r2
 80067a2:	687a      	ldr	r2, [r7, #4]
 80067a4:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 80067a6:	4311      	orrs	r1, r2
 80067a8:	687a      	ldr	r2, [r7, #4]
 80067aa:	6d12      	ldr	r2, [r2, #80]	; 0x50
 80067ac:	430a      	orrs	r2, r1
 80067ae:	431a      	orrs	r2, r3
 80067b0:	687b      	ldr	r3, [r7, #4]
 80067b2:	681b      	ldr	r3, [r3, #0]
 80067b4:	f042 0201 	orr.w	r2, r2, #1
 80067b8:	611a      	str	r2, [r3, #16]
 80067ba:	e019      	b.n	80067f0 <HAL_ADC_Init+0x324>
 80067bc:	20000008 	.word	0x20000008
 80067c0:	053e2d63 	.word	0x053e2d63
 80067c4:	50000100 	.word	0x50000100
 80067c8:	50000400 	.word	0x50000400
 80067cc:	50000500 	.word	0x50000500
 80067d0:	50000600 	.word	0x50000600
 80067d4:	50000300 	.word	0x50000300
 80067d8:	50000700 	.word	0x50000700
 80067dc:	fff04007 	.word	0xfff04007
                  );
      }
      else
      {
        /* Disable ADC oversampling scope on ADC group regular */
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 80067e0:	687b      	ldr	r3, [r7, #4]
 80067e2:	681b      	ldr	r3, [r3, #0]
 80067e4:	691a      	ldr	r2, [r3, #16]
 80067e6:	687b      	ldr	r3, [r7, #4]
 80067e8:	681b      	ldr	r3, [r3, #0]
 80067ea:	f022 0201 	bic.w	r2, r2, #1
 80067ee:	611a      	str	r2, [r3, #16]
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 80067f0:	687b      	ldr	r3, [r7, #4]
 80067f2:	695b      	ldr	r3, [r3, #20]
 80067f4:	2b01      	cmp	r3, #1
 80067f6:	d10c      	bne.n	8006812 <HAL_ADC_Init+0x346>
    {
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 80067f8:	687b      	ldr	r3, [r7, #4]
 80067fa:	681b      	ldr	r3, [r3, #0]
 80067fc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80067fe:	f023 010f 	bic.w	r1, r3, #15
 8006802:	687b      	ldr	r3, [r7, #4]
 8006804:	6a1b      	ldr	r3, [r3, #32]
 8006806:	1e5a      	subs	r2, r3, #1
 8006808:	687b      	ldr	r3, [r7, #4]
 800680a:	681b      	ldr	r3, [r3, #0]
 800680c:	430a      	orrs	r2, r1
 800680e:	631a      	str	r2, [r3, #48]	; 0x30
 8006810:	e007      	b.n	8006822 <HAL_ADC_Init+0x356>
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 8006812:	687b      	ldr	r3, [r7, #4]
 8006814:	681b      	ldr	r3, [r3, #0]
 8006816:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006818:	687b      	ldr	r3, [r7, #4]
 800681a:	681b      	ldr	r3, [r3, #0]
 800681c:	f022 020f 	bic.w	r2, r2, #15
 8006820:	631a      	str	r2, [r3, #48]	; 0x30
    }

    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 8006822:	687b      	ldr	r3, [r7, #4]
 8006824:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006826:	f023 0303 	bic.w	r3, r3, #3
 800682a:	f043 0201 	orr.w	r2, r3, #1
 800682e:	687b      	ldr	r3, [r7, #4]
 8006830:	65da      	str	r2, [r3, #92]	; 0x5c
 8006832:	e007      	b.n	8006844 <HAL_ADC_Init+0x378>
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8006834:	687b      	ldr	r3, [r7, #4]
 8006836:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006838:	f043 0210 	orr.w	r2, r3, #16
 800683c:	687b      	ldr	r3, [r7, #4]
 800683e:	65da      	str	r2, [r3, #92]	; 0x5c

    tmp_hal_status = HAL_ERROR;
 8006840:	2301      	movs	r3, #1
 8006842:	77fb      	strb	r3, [r7, #31]
  }

  /* Return function status */
  return tmp_hal_status;
 8006844:	7ffb      	ldrb	r3, [r7, #31]
}
 8006846:	4618      	mov	r0, r3
 8006848:	3724      	adds	r7, #36	; 0x24
 800684a:	46bd      	mov	sp, r7
 800684c:	bd90      	pop	{r4, r7, pc}
 800684e:	bf00      	nop

08006850 <HAL_ADC_Start_DMA>:
  * @param pData Destination Buffer address.
  * @param Length Number of data to be transferred from ADC peripheral to memory
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef *hadc, uint32_t *pData, uint32_t Length)
{
 8006850:	b580      	push	{r7, lr}
 8006852:	b086      	sub	sp, #24
 8006854:	af00      	add	r7, sp, #0
 8006856:	60f8      	str	r0, [r7, #12]
 8006858:	60b9      	str	r1, [r7, #8]
 800685a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status;
#if defined(ADC_MULTIMODE_SUPPORT)
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 800685c:	68fb      	ldr	r3, [r7, #12]
 800685e:	681b      	ldr	r3, [r3, #0]
 8006860:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8006864:	d004      	beq.n	8006870 <HAL_ADC_Start_DMA+0x20>
 8006866:	68fb      	ldr	r3, [r7, #12]
 8006868:	681b      	ldr	r3, [r3, #0]
 800686a:	4a5a      	ldr	r2, [pc, #360]	; (80069d4 <HAL_ADC_Start_DMA+0x184>)
 800686c:	4293      	cmp	r3, r2
 800686e:	d101      	bne.n	8006874 <HAL_ADC_Start_DMA+0x24>
 8006870:	4b59      	ldr	r3, [pc, #356]	; (80069d8 <HAL_ADC_Start_DMA+0x188>)
 8006872:	e000      	b.n	8006876 <HAL_ADC_Start_DMA+0x26>
 8006874:	4b59      	ldr	r3, [pc, #356]	; (80069dc <HAL_ADC_Start_DMA+0x18c>)
 8006876:	4618      	mov	r0, r3
 8006878:	f7ff fc85 	bl	8006186 <LL_ADC_GetMultimode>
 800687c:	6138      	str	r0, [r7, #16]

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Perform ADC enable and conversion start if no conversion is on going */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 800687e:	68fb      	ldr	r3, [r7, #12]
 8006880:	681b      	ldr	r3, [r3, #0]
 8006882:	4618      	mov	r0, r3
 8006884:	f7ff fd5f 	bl	8006346 <LL_ADC_REG_IsConversionOngoing>
 8006888:	4603      	mov	r3, r0
 800688a:	2b00      	cmp	r3, #0
 800688c:	f040 809b 	bne.w	80069c6 <HAL_ADC_Start_DMA+0x176>
  {
    /* Process locked */
    __HAL_LOCK(hadc);
 8006890:	68fb      	ldr	r3, [r7, #12]
 8006892:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 8006896:	2b01      	cmp	r3, #1
 8006898:	d101      	bne.n	800689e <HAL_ADC_Start_DMA+0x4e>
 800689a:	2302      	movs	r3, #2
 800689c:	e096      	b.n	80069cc <HAL_ADC_Start_DMA+0x17c>
 800689e:	68fb      	ldr	r3, [r7, #12]
 80068a0:	2201      	movs	r2, #1
 80068a2:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

#if defined(ADC_MULTIMODE_SUPPORT)
    /* Ensure that multimode regular conversions are not enabled.   */
    /* Otherwise, dedicated API HAL_ADCEx_MultiModeStart_DMA() must be used.  */
    if ((ADC_IS_INDEPENDENT(hadc) != RESET)
 80068a6:	68fb      	ldr	r3, [r7, #12]
 80068a8:	681b      	ldr	r3, [r3, #0]
 80068aa:	4a4d      	ldr	r2, [pc, #308]	; (80069e0 <HAL_ADC_Start_DMA+0x190>)
 80068ac:	4293      	cmp	r3, r2
 80068ae:	d008      	beq.n	80068c2 <HAL_ADC_Start_DMA+0x72>
        || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 80068b0:	693b      	ldr	r3, [r7, #16]
 80068b2:	2b00      	cmp	r3, #0
 80068b4:	d005      	beq.n	80068c2 <HAL_ADC_Start_DMA+0x72>
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_SIMULT)
 80068b6:	693b      	ldr	r3, [r7, #16]
 80068b8:	2b05      	cmp	r3, #5
 80068ba:	d002      	beq.n	80068c2 <HAL_ADC_Start_DMA+0x72>
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
 80068bc:	693b      	ldr	r3, [r7, #16]
 80068be:	2b09      	cmp	r3, #9
 80068c0:	d17a      	bne.n	80069b8 <HAL_ADC_Start_DMA+0x168>
       )
#endif /* ADC_MULTIMODE_SUPPORT */
    {
      /* Enable the ADC peripheral */
      tmp_hal_status = ADC_Enable(hadc);
 80068c2:	68f8      	ldr	r0, [r7, #12]
 80068c4:	f001 fa6c 	bl	8007da0 <ADC_Enable>
 80068c8:	4603      	mov	r3, r0
 80068ca:	75fb      	strb	r3, [r7, #23]

      /* Start conversion if ADC is effectively enabled */
      if (tmp_hal_status == HAL_OK)
 80068cc:	7dfb      	ldrb	r3, [r7, #23]
 80068ce:	2b00      	cmp	r3, #0
 80068d0:	d16d      	bne.n	80069ae <HAL_ADC_Start_DMA+0x15e>
      {
        /* Set ADC state                                                        */
        /* - Clear state bitfield related to regular group conversion results   */
        /* - Set state bitfield related to regular operation                    */
        ADC_STATE_CLR_SET(hadc->State,
 80068d2:	68fb      	ldr	r3, [r7, #12]
 80068d4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80068d6:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 80068da:	f023 0301 	bic.w	r3, r3, #1
 80068de:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 80068e2:	68fb      	ldr	r3, [r7, #12]
 80068e4:	65da      	str	r2, [r3, #92]	; 0x5c

#if defined(ADC_MULTIMODE_SUPPORT)
        /* Reset HAL_ADC_STATE_MULTIMODE_SLAVE bit
          - if ADC instance is master or if multimode feature is not available
          - if multimode setting is disabled (ADC instance slave in independent mode) */
        if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 80068e6:	68fb      	ldr	r3, [r7, #12]
 80068e8:	681b      	ldr	r3, [r3, #0]
 80068ea:	4a3a      	ldr	r2, [pc, #232]	; (80069d4 <HAL_ADC_Start_DMA+0x184>)
 80068ec:	4293      	cmp	r3, r2
 80068ee:	d009      	beq.n	8006904 <HAL_ADC_Start_DMA+0xb4>
 80068f0:	68fb      	ldr	r3, [r7, #12]
 80068f2:	681b      	ldr	r3, [r3, #0]
 80068f4:	4a3b      	ldr	r2, [pc, #236]	; (80069e4 <HAL_ADC_Start_DMA+0x194>)
 80068f6:	4293      	cmp	r3, r2
 80068f8:	d002      	beq.n	8006900 <HAL_ADC_Start_DMA+0xb0>
 80068fa:	68fb      	ldr	r3, [r7, #12]
 80068fc:	681b      	ldr	r3, [r3, #0]
 80068fe:	e003      	b.n	8006908 <HAL_ADC_Start_DMA+0xb8>
 8006900:	4b39      	ldr	r3, [pc, #228]	; (80069e8 <HAL_ADC_Start_DMA+0x198>)
 8006902:	e001      	b.n	8006908 <HAL_ADC_Start_DMA+0xb8>
 8006904:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8006908:	68fa      	ldr	r2, [r7, #12]
 800690a:	6812      	ldr	r2, [r2, #0]
 800690c:	4293      	cmp	r3, r2
 800690e:	d002      	beq.n	8006916 <HAL_ADC_Start_DMA+0xc6>
            || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8006910:	693b      	ldr	r3, [r7, #16]
 8006912:	2b00      	cmp	r3, #0
 8006914:	d105      	bne.n	8006922 <HAL_ADC_Start_DMA+0xd2>
           )
        {
          CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 8006916:	68fb      	ldr	r3, [r7, #12]
 8006918:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800691a:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
 800691e:	68fb      	ldr	r3, [r7, #12]
 8006920:	65da      	str	r2, [r3, #92]	; 0x5c
        }
#endif

        /* Check if a conversion is on going on ADC group injected */
        if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) != 0UL)
 8006922:	68fb      	ldr	r3, [r7, #12]
 8006924:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006926:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 800692a:	2b00      	cmp	r3, #0
 800692c:	d006      	beq.n	800693c <HAL_ADC_Start_DMA+0xec>
        {
          /* Reset ADC error code fields related to regular conversions only */
          CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));
 800692e:	68fb      	ldr	r3, [r7, #12]
 8006930:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8006932:	f023 0206 	bic.w	r2, r3, #6
 8006936:	68fb      	ldr	r3, [r7, #12]
 8006938:	661a      	str	r2, [r3, #96]	; 0x60
 800693a:	e002      	b.n	8006942 <HAL_ADC_Start_DMA+0xf2>
        }
        else
        {
          /* Reset all ADC error code fields */
          ADC_CLEAR_ERRORCODE(hadc);
 800693c:	68fb      	ldr	r3, [r7, #12]
 800693e:	2200      	movs	r2, #0
 8006940:	661a      	str	r2, [r3, #96]	; 0x60
        }

        /* Set the DMA transfer complete callback */
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 8006942:	68fb      	ldr	r3, [r7, #12]
 8006944:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8006946:	4a29      	ldr	r2, [pc, #164]	; (80069ec <HAL_ADC_Start_DMA+0x19c>)
 8006948:	62da      	str	r2, [r3, #44]	; 0x2c

        /* Set the DMA half transfer complete callback */
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 800694a:	68fb      	ldr	r3, [r7, #12]
 800694c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800694e:	4a28      	ldr	r2, [pc, #160]	; (80069f0 <HAL_ADC_Start_DMA+0x1a0>)
 8006950:	631a      	str	r2, [r3, #48]	; 0x30

        /* Set the DMA error callback */
        hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
 8006952:	68fb      	ldr	r3, [r7, #12]
 8006954:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8006956:	4a27      	ldr	r2, [pc, #156]	; (80069f4 <HAL_ADC_Start_DMA+0x1a4>)
 8006958:	635a      	str	r2, [r3, #52]	; 0x34
        /* ADC start (in case of SW start):                                   */

        /* Clear regular group conversion flag and overrun flag               */
        /* (To ensure of no unknown state from potential previous ADC         */
        /* operations)                                                        */
        __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 800695a:	68fb      	ldr	r3, [r7, #12]
 800695c:	681b      	ldr	r3, [r3, #0]
 800695e:	221c      	movs	r2, #28
 8006960:	601a      	str	r2, [r3, #0]

        /* Process unlocked */
        /* Unlock before starting ADC conversions: in case of potential         */
        /* interruption, to let the process to ADC IRQ Handler.                 */
        __HAL_UNLOCK(hadc);
 8006962:	68fb      	ldr	r3, [r7, #12]
 8006964:	2200      	movs	r2, #0
 8006966:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

        /* With DMA, overrun event is always considered as an error even if
           hadc->Init.Overrun is set to ADC_OVR_DATA_OVERWRITTEN. Therefore,
           ADC_IT_OVR is enabled. */
        __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 800696a:	68fb      	ldr	r3, [r7, #12]
 800696c:	681b      	ldr	r3, [r3, #0]
 800696e:	685a      	ldr	r2, [r3, #4]
 8006970:	68fb      	ldr	r3, [r7, #12]
 8006972:	681b      	ldr	r3, [r3, #0]
 8006974:	f042 0210 	orr.w	r2, r2, #16
 8006978:	605a      	str	r2, [r3, #4]

        /* Enable ADC DMA mode */
        SET_BIT(hadc->Instance->CFGR, ADC_CFGR_DMAEN);
 800697a:	68fb      	ldr	r3, [r7, #12]
 800697c:	681b      	ldr	r3, [r3, #0]
 800697e:	68da      	ldr	r2, [r3, #12]
 8006980:	68fb      	ldr	r3, [r7, #12]
 8006982:	681b      	ldr	r3, [r3, #0]
 8006984:	f042 0201 	orr.w	r2, r2, #1
 8006988:	60da      	str	r2, [r3, #12]

        /* Start the DMA channel */
        tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
 800698a:	68fb      	ldr	r3, [r7, #12]
 800698c:	6d58      	ldr	r0, [r3, #84]	; 0x54
 800698e:	68fb      	ldr	r3, [r7, #12]
 8006990:	681b      	ldr	r3, [r3, #0]
 8006992:	3340      	adds	r3, #64	; 0x40
 8006994:	4619      	mov	r1, r3
 8006996:	68ba      	ldr	r2, [r7, #8]
 8006998:	687b      	ldr	r3, [r7, #4]
 800699a:	f002 faad 	bl	8008ef8 <HAL_DMA_Start_IT>
 800699e:	4603      	mov	r3, r0
 80069a0:	75fb      	strb	r3, [r7, #23]
        /* Enable conversion of regular group.                                  */
        /* If software start has been selected, conversion starts immediately.  */
        /* If external trigger has been selected, conversion will start at next */
        /* trigger event.                                                       */
        /* Start ADC group regular conversion */
        LL_ADC_REG_StartConversion(hadc->Instance);
 80069a2:	68fb      	ldr	r3, [r7, #12]
 80069a4:	681b      	ldr	r3, [r3, #0]
 80069a6:	4618      	mov	r0, r3
 80069a8:	f7ff fca5 	bl	80062f6 <LL_ADC_REG_StartConversion>
      if (tmp_hal_status == HAL_OK)
 80069ac:	e00d      	b.n	80069ca <HAL_ADC_Start_DMA+0x17a>
      }
      else
      {
        /* Process unlocked */
        __HAL_UNLOCK(hadc);
 80069ae:	68fb      	ldr	r3, [r7, #12]
 80069b0:	2200      	movs	r2, #0
 80069b2:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
      if (tmp_hal_status == HAL_OK)
 80069b6:	e008      	b.n	80069ca <HAL_ADC_Start_DMA+0x17a>

    }
#if defined(ADC_MULTIMODE_SUPPORT)
    else
    {
      tmp_hal_status = HAL_ERROR;
 80069b8:	2301      	movs	r3, #1
 80069ba:	75fb      	strb	r3, [r7, #23]
      /* Process unlocked */
      __HAL_UNLOCK(hadc);
 80069bc:	68fb      	ldr	r3, [r7, #12]
 80069be:	2200      	movs	r2, #0
 80069c0:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
 80069c4:	e001      	b.n	80069ca <HAL_ADC_Start_DMA+0x17a>
    }
#endif
  }
  else
  {
    tmp_hal_status = HAL_BUSY;
 80069c6:	2302      	movs	r3, #2
 80069c8:	75fb      	strb	r3, [r7, #23]
  }

  /* Return function status */
  return tmp_hal_status;
 80069ca:	7dfb      	ldrb	r3, [r7, #23]
}
 80069cc:	4618      	mov	r0, r3
 80069ce:	3718      	adds	r7, #24
 80069d0:	46bd      	mov	sp, r7
 80069d2:	bd80      	pop	{r7, pc}
 80069d4:	50000100 	.word	0x50000100
 80069d8:	50000300 	.word	0x50000300
 80069dc:	50000700 	.word	0x50000700
 80069e0:	50000600 	.word	0x50000600
 80069e4:	50000500 	.word	0x50000500
 80069e8:	50000400 	.word	0x50000400
 80069ec:	08007f23 	.word	0x08007f23
 80069f0:	08007ffb 	.word	0x08007ffb
 80069f4:	08008017 	.word	0x08008017

080069f8 <HAL_ADC_Stop_DMA>:
  *         For multimode, the dedicated HAL_ADCEx_MultiModeStop_DMA() API must be used.
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef *hadc)
{
 80069f8:	b580      	push	{r7, lr}
 80069fa:	b084      	sub	sp, #16
 80069fc:	af00      	add	r7, sp, #0
 80069fe:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Process locked */
  __HAL_LOCK(hadc);
 8006a00:	687b      	ldr	r3, [r7, #4]
 8006a02:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 8006a06:	2b01      	cmp	r3, #1
 8006a08:	d101      	bne.n	8006a0e <HAL_ADC_Stop_DMA+0x16>
 8006a0a:	2302      	movs	r3, #2
 8006a0c:	e051      	b.n	8006ab2 <HAL_ADC_Stop_DMA+0xba>
 8006a0e:	687b      	ldr	r3, [r7, #4]
 8006a10:	2201      	movs	r2, #1
 8006a12:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

  /* 1. Stop potential ADC group regular conversion on going */
  tmp_hal_status = ADC_ConversionStop(hadc, ADC_REGULAR_INJECTED_GROUP);
 8006a16:	2103      	movs	r1, #3
 8006a18:	6878      	ldr	r0, [r7, #4]
 8006a1a:	f001 f905 	bl	8007c28 <ADC_ConversionStop>
 8006a1e:	4603      	mov	r3, r0
 8006a20:	73fb      	strb	r3, [r7, #15]

  /* Disable ADC peripheral if conversions are effectively stopped */
  if (tmp_hal_status == HAL_OK)
 8006a22:	7bfb      	ldrb	r3, [r7, #15]
 8006a24:	2b00      	cmp	r3, #0
 8006a26:	d13f      	bne.n	8006aa8 <HAL_ADC_Stop_DMA+0xb0>
  {
    /* Disable ADC DMA (ADC DMA configuration of continuous requests is kept) */
    CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_DMAEN);
 8006a28:	687b      	ldr	r3, [r7, #4]
 8006a2a:	681b      	ldr	r3, [r3, #0]
 8006a2c:	68da      	ldr	r2, [r3, #12]
 8006a2e:	687b      	ldr	r3, [r7, #4]
 8006a30:	681b      	ldr	r3, [r3, #0]
 8006a32:	f022 0201 	bic.w	r2, r2, #1
 8006a36:	60da      	str	r2, [r3, #12]

    /* Disable the DMA channel (in case of DMA in circular mode or stop       */
    /* while DMA transfer is on going)                                        */
    if (hadc->DMA_Handle->State == HAL_DMA_STATE_BUSY)
 8006a38:	687b      	ldr	r3, [r7, #4]
 8006a3a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8006a3c:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8006a40:	b2db      	uxtb	r3, r3
 8006a42:	2b02      	cmp	r3, #2
 8006a44:	d10f      	bne.n	8006a66 <HAL_ADC_Stop_DMA+0x6e>
    {
      tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
 8006a46:	687b      	ldr	r3, [r7, #4]
 8006a48:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8006a4a:	4618      	mov	r0, r3
 8006a4c:	f002 facf 	bl	8008fee <HAL_DMA_Abort>
 8006a50:	4603      	mov	r3, r0
 8006a52:	73fb      	strb	r3, [r7, #15]

      /* Check if DMA channel effectively disabled */
      if (tmp_hal_status != HAL_OK)
 8006a54:	7bfb      	ldrb	r3, [r7, #15]
 8006a56:	2b00      	cmp	r3, #0
 8006a58:	d005      	beq.n	8006a66 <HAL_ADC_Stop_DMA+0x6e>
      {
        /* Update ADC state machine to error */
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
 8006a5a:	687b      	ldr	r3, [r7, #4]
 8006a5c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006a5e:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8006a62:	687b      	ldr	r3, [r7, #4]
 8006a64:	65da      	str	r2, [r3, #92]	; 0x5c
      }
    }

    /* Disable ADC overrun interrupt */
    __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
 8006a66:	687b      	ldr	r3, [r7, #4]
 8006a68:	681b      	ldr	r3, [r3, #0]
 8006a6a:	685a      	ldr	r2, [r3, #4]
 8006a6c:	687b      	ldr	r3, [r7, #4]
 8006a6e:	681b      	ldr	r3, [r3, #0]
 8006a70:	f022 0210 	bic.w	r2, r2, #16
 8006a74:	605a      	str	r2, [r3, #4]

    /* 2. Disable the ADC peripheral */
    /* Update "tmp_hal_status" only if DMA channel disabling passed,          */
    /* to keep in memory a potential failing status.                          */
    if (tmp_hal_status == HAL_OK)
 8006a76:	7bfb      	ldrb	r3, [r7, #15]
 8006a78:	2b00      	cmp	r3, #0
 8006a7a:	d105      	bne.n	8006a88 <HAL_ADC_Stop_DMA+0x90>
    {
      tmp_hal_status = ADC_Disable(hadc);
 8006a7c:	6878      	ldr	r0, [r7, #4]
 8006a7e:	f001 f9f1 	bl	8007e64 <ADC_Disable>
 8006a82:	4603      	mov	r3, r0
 8006a84:	73fb      	strb	r3, [r7, #15]
 8006a86:	e002      	b.n	8006a8e <HAL_ADC_Stop_DMA+0x96>
    }
    else
    {
      (void)ADC_Disable(hadc);
 8006a88:	6878      	ldr	r0, [r7, #4]
 8006a8a:	f001 f9eb 	bl	8007e64 <ADC_Disable>
    }

    /* Check if ADC is effectively disabled */
    if (tmp_hal_status == HAL_OK)
 8006a8e:	7bfb      	ldrb	r3, [r7, #15]
 8006a90:	2b00      	cmp	r3, #0
 8006a92:	d109      	bne.n	8006aa8 <HAL_ADC_Stop_DMA+0xb0>
    {
      /* Set ADC state */
      ADC_STATE_CLR_SET(hadc->State,
 8006a94:	687b      	ldr	r3, [r7, #4]
 8006a96:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006a98:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 8006a9c:	f023 0301 	bic.w	r3, r3, #1
 8006aa0:	f043 0201 	orr.w	r2, r3, #1
 8006aa4:	687b      	ldr	r3, [r7, #4]
 8006aa6:	65da      	str	r2, [r3, #92]	; 0x5c
    }

  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8006aa8:	687b      	ldr	r3, [r7, #4]
 8006aaa:	2200      	movs	r2, #0
 8006aac:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

  /* Return function status */
  return tmp_hal_status;
 8006ab0:	7bfb      	ldrb	r3, [r7, #15]
}
 8006ab2:	4618      	mov	r0, r3
 8006ab4:	3710      	adds	r7, #16
 8006ab6:	46bd      	mov	sp, r7
 8006ab8:	bd80      	pop	{r7, pc}
	...

08006abc <HAL_ADC_IRQHandler>:
  * @brief  Handle ADC interrupt request.
  * @param hadc ADC handle
  * @retval None
  */
void HAL_ADC_IRQHandler(ADC_HandleTypeDef *hadc)
{
 8006abc:	b580      	push	{r7, lr}
 8006abe:	b08a      	sub	sp, #40	; 0x28
 8006ac0:	af00      	add	r7, sp, #0
 8006ac2:	6078      	str	r0, [r7, #4]
  uint32_t overrun_error = 0UL; /* flag set if overrun occurrence has to be considered as an error */
 8006ac4:	2300      	movs	r3, #0
 8006ac6:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t tmp_isr = hadc->Instance->ISR;
 8006ac8:	687b      	ldr	r3, [r7, #4]
 8006aca:	681b      	ldr	r3, [r3, #0]
 8006acc:	681b      	ldr	r3, [r3, #0]
 8006ace:	61fb      	str	r3, [r7, #28]
  uint32_t tmp_ier = hadc->Instance->IER;
 8006ad0:	687b      	ldr	r3, [r7, #4]
 8006ad2:	681b      	ldr	r3, [r3, #0]
 8006ad4:	685b      	ldr	r3, [r3, #4]
 8006ad6:	61bb      	str	r3, [r7, #24]
  uint32_t tmp_adc_inj_is_trigger_source_sw_start;
  uint32_t tmp_adc_reg_is_trigger_source_sw_start;
  uint32_t tmp_cfgr;
#if defined(ADC_MULTIMODE_SUPPORT)
  const ADC_TypeDef *tmpADC_Master;
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8006ad8:	687b      	ldr	r3, [r7, #4]
 8006ada:	681b      	ldr	r3, [r3, #0]
 8006adc:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8006ae0:	d004      	beq.n	8006aec <HAL_ADC_IRQHandler+0x30>
 8006ae2:	687b      	ldr	r3, [r7, #4]
 8006ae4:	681b      	ldr	r3, [r3, #0]
 8006ae6:	4a8e      	ldr	r2, [pc, #568]	; (8006d20 <HAL_ADC_IRQHandler+0x264>)
 8006ae8:	4293      	cmp	r3, r2
 8006aea:	d101      	bne.n	8006af0 <HAL_ADC_IRQHandler+0x34>
 8006aec:	4b8d      	ldr	r3, [pc, #564]	; (8006d24 <HAL_ADC_IRQHandler+0x268>)
 8006aee:	e000      	b.n	8006af2 <HAL_ADC_IRQHandler+0x36>
 8006af0:	4b8d      	ldr	r3, [pc, #564]	; (8006d28 <HAL_ADC_IRQHandler+0x26c>)
 8006af2:	4618      	mov	r0, r3
 8006af4:	f7ff fb47 	bl	8006186 <LL_ADC_GetMultimode>
 8006af8:	6178      	str	r0, [r7, #20]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));

  /* ========== Check End of Sampling flag for ADC group regular ========== */
  if (((tmp_isr & ADC_FLAG_EOSMP) == ADC_FLAG_EOSMP) && ((tmp_ier & ADC_IT_EOSMP) == ADC_IT_EOSMP))
 8006afa:	69fb      	ldr	r3, [r7, #28]
 8006afc:	f003 0302 	and.w	r3, r3, #2
 8006b00:	2b00      	cmp	r3, #0
 8006b02:	d017      	beq.n	8006b34 <HAL_ADC_IRQHandler+0x78>
 8006b04:	69bb      	ldr	r3, [r7, #24]
 8006b06:	f003 0302 	and.w	r3, r3, #2
 8006b0a:	2b00      	cmp	r3, #0
 8006b0c:	d012      	beq.n	8006b34 <HAL_ADC_IRQHandler+0x78>
  {
    /* Update state machine on end of sampling status if not in error state */
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8006b0e:	687b      	ldr	r3, [r7, #4]
 8006b10:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006b12:	f003 0310 	and.w	r3, r3, #16
 8006b16:	2b00      	cmp	r3, #0
 8006b18:	d105      	bne.n	8006b26 <HAL_ADC_IRQHandler+0x6a>
    {
      /* Set ADC state */
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOSMP);
 8006b1a:	687b      	ldr	r3, [r7, #4]
 8006b1c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006b1e:	f443 6200 	orr.w	r2, r3, #2048	; 0x800
 8006b22:	687b      	ldr	r3, [r7, #4]
 8006b24:	65da      	str	r2, [r3, #92]	; 0x5c

    /* End Of Sampling callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->EndOfSamplingCallback(hadc);
#else
    HAL_ADCEx_EndOfSamplingCallback(hadc);
 8006b26:	6878      	ldr	r0, [r7, #4]
 8006b28:	f001 fb62 	bl	80081f0 <HAL_ADCEx_EndOfSamplingCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear regular group conversion flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOSMP);
 8006b2c:	687b      	ldr	r3, [r7, #4]
 8006b2e:	681b      	ldr	r3, [r3, #0]
 8006b30:	2202      	movs	r2, #2
 8006b32:	601a      	str	r2, [r3, #0]
  }

  /* ====== Check ADC group regular end of unitary conversion sequence conversions ===== */
  if ((((tmp_isr & ADC_FLAG_EOC) == ADC_FLAG_EOC) && ((tmp_ier & ADC_IT_EOC) == ADC_IT_EOC)) ||
 8006b34:	69fb      	ldr	r3, [r7, #28]
 8006b36:	f003 0304 	and.w	r3, r3, #4
 8006b3a:	2b00      	cmp	r3, #0
 8006b3c:	d004      	beq.n	8006b48 <HAL_ADC_IRQHandler+0x8c>
 8006b3e:	69bb      	ldr	r3, [r7, #24]
 8006b40:	f003 0304 	and.w	r3, r3, #4
 8006b44:	2b00      	cmp	r3, #0
 8006b46:	d10b      	bne.n	8006b60 <HAL_ADC_IRQHandler+0xa4>
      (((tmp_isr & ADC_FLAG_EOS) == ADC_FLAG_EOS) && ((tmp_ier & ADC_IT_EOS) == ADC_IT_EOS)))
 8006b48:	69fb      	ldr	r3, [r7, #28]
 8006b4a:	f003 0308 	and.w	r3, r3, #8
  if ((((tmp_isr & ADC_FLAG_EOC) == ADC_FLAG_EOC) && ((tmp_ier & ADC_IT_EOC) == ADC_IT_EOC)) ||
 8006b4e:	2b00      	cmp	r3, #0
 8006b50:	f000 8094 	beq.w	8006c7c <HAL_ADC_IRQHandler+0x1c0>
      (((tmp_isr & ADC_FLAG_EOS) == ADC_FLAG_EOS) && ((tmp_ier & ADC_IT_EOS) == ADC_IT_EOS)))
 8006b54:	69bb      	ldr	r3, [r7, #24]
 8006b56:	f003 0308 	and.w	r3, r3, #8
 8006b5a:	2b00      	cmp	r3, #0
 8006b5c:	f000 808e 	beq.w	8006c7c <HAL_ADC_IRQHandler+0x1c0>
  {
    /* Update state machine on conversion status if not in error state */
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8006b60:	687b      	ldr	r3, [r7, #4]
 8006b62:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006b64:	f003 0310 	and.w	r3, r3, #16
 8006b68:	2b00      	cmp	r3, #0
 8006b6a:	d105      	bne.n	8006b78 <HAL_ADC_IRQHandler+0xbc>
    {
      /* Set ADC state */
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 8006b6c:	687b      	ldr	r3, [r7, #4]
 8006b6e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006b70:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 8006b74:	687b      	ldr	r3, [r7, #4]
 8006b76:	65da      	str	r2, [r3, #92]	; 0x5c
    }

    /* Determine whether any further conversion upcoming on group regular     */
    /* by external trigger, continuous mode or scan sequence on going         */
    /* to disable interruption.                                               */
    if (LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance) != 0UL)
 8006b78:	687b      	ldr	r3, [r7, #4]
 8006b7a:	681b      	ldr	r3, [r3, #0]
 8006b7c:	4618      	mov	r0, r3
 8006b7e:	f7ff fa0d 	bl	8005f9c <LL_ADC_REG_IsTriggerSourceSWStart>
 8006b82:	4603      	mov	r3, r0
 8006b84:	2b00      	cmp	r3, #0
 8006b86:	d072      	beq.n	8006c6e <HAL_ADC_IRQHandler+0x1b2>
    {
      /* Get relevant register CFGR in ADC instance of ADC master or slave    */
      /* in function of multimode state (for devices with multimode           */
      /* available).                                                          */
#if defined(ADC_MULTIMODE_SUPPORT)
      if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 8006b88:	687b      	ldr	r3, [r7, #4]
 8006b8a:	681b      	ldr	r3, [r3, #0]
 8006b8c:	4a64      	ldr	r2, [pc, #400]	; (8006d20 <HAL_ADC_IRQHandler+0x264>)
 8006b8e:	4293      	cmp	r3, r2
 8006b90:	d009      	beq.n	8006ba6 <HAL_ADC_IRQHandler+0xea>
 8006b92:	687b      	ldr	r3, [r7, #4]
 8006b94:	681b      	ldr	r3, [r3, #0]
 8006b96:	4a65      	ldr	r2, [pc, #404]	; (8006d2c <HAL_ADC_IRQHandler+0x270>)
 8006b98:	4293      	cmp	r3, r2
 8006b9a:	d002      	beq.n	8006ba2 <HAL_ADC_IRQHandler+0xe6>
 8006b9c:	687b      	ldr	r3, [r7, #4]
 8006b9e:	681b      	ldr	r3, [r3, #0]
 8006ba0:	e003      	b.n	8006baa <HAL_ADC_IRQHandler+0xee>
 8006ba2:	4b63      	ldr	r3, [pc, #396]	; (8006d30 <HAL_ADC_IRQHandler+0x274>)
 8006ba4:	e001      	b.n	8006baa <HAL_ADC_IRQHandler+0xee>
 8006ba6:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8006baa:	687a      	ldr	r2, [r7, #4]
 8006bac:	6812      	ldr	r2, [r2, #0]
 8006bae:	4293      	cmp	r3, r2
 8006bb0:	d008      	beq.n	8006bc4 <HAL_ADC_IRQHandler+0x108>
          || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8006bb2:	697b      	ldr	r3, [r7, #20]
 8006bb4:	2b00      	cmp	r3, #0
 8006bb6:	d005      	beq.n	8006bc4 <HAL_ADC_IRQHandler+0x108>
          || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_SIMULT)
 8006bb8:	697b      	ldr	r3, [r7, #20]
 8006bba:	2b05      	cmp	r3, #5
 8006bbc:	d002      	beq.n	8006bc4 <HAL_ADC_IRQHandler+0x108>
          || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
 8006bbe:	697b      	ldr	r3, [r7, #20]
 8006bc0:	2b09      	cmp	r3, #9
 8006bc2:	d104      	bne.n	8006bce <HAL_ADC_IRQHandler+0x112>
         )
      {
        /* check CONT bit directly in handle ADC CFGR register */
        tmp_cfgr = READ_REG(hadc->Instance->CFGR);
 8006bc4:	687b      	ldr	r3, [r7, #4]
 8006bc6:	681b      	ldr	r3, [r3, #0]
 8006bc8:	68db      	ldr	r3, [r3, #12]
 8006bca:	623b      	str	r3, [r7, #32]
 8006bcc:	e014      	b.n	8006bf8 <HAL_ADC_IRQHandler+0x13c>
      }
      else
      {
        /* else need to check Master ADC CONT bit */
        tmpADC_Master = __LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance);
 8006bce:	687b      	ldr	r3, [r7, #4]
 8006bd0:	681b      	ldr	r3, [r3, #0]
 8006bd2:	4a53      	ldr	r2, [pc, #332]	; (8006d20 <HAL_ADC_IRQHandler+0x264>)
 8006bd4:	4293      	cmp	r3, r2
 8006bd6:	d009      	beq.n	8006bec <HAL_ADC_IRQHandler+0x130>
 8006bd8:	687b      	ldr	r3, [r7, #4]
 8006bda:	681b      	ldr	r3, [r3, #0]
 8006bdc:	4a53      	ldr	r2, [pc, #332]	; (8006d2c <HAL_ADC_IRQHandler+0x270>)
 8006bde:	4293      	cmp	r3, r2
 8006be0:	d002      	beq.n	8006be8 <HAL_ADC_IRQHandler+0x12c>
 8006be2:	687b      	ldr	r3, [r7, #4]
 8006be4:	681b      	ldr	r3, [r3, #0]
 8006be6:	e003      	b.n	8006bf0 <HAL_ADC_IRQHandler+0x134>
 8006be8:	4b51      	ldr	r3, [pc, #324]	; (8006d30 <HAL_ADC_IRQHandler+0x274>)
 8006bea:	e001      	b.n	8006bf0 <HAL_ADC_IRQHandler+0x134>
 8006bec:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8006bf0:	613b      	str	r3, [r7, #16]
        tmp_cfgr = READ_REG(tmpADC_Master->CFGR);
 8006bf2:	693b      	ldr	r3, [r7, #16]
 8006bf4:	68db      	ldr	r3, [r3, #12]
 8006bf6:	623b      	str	r3, [r7, #32]
#else
      tmp_cfgr = READ_REG(hadc->Instance->CFGR);
#endif

      /* Carry on if continuous mode is disabled */
      if (READ_BIT(tmp_cfgr, ADC_CFGR_CONT) != ADC_CFGR_CONT)
 8006bf8:	6a3b      	ldr	r3, [r7, #32]
 8006bfa:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8006bfe:	2b00      	cmp	r3, #0
 8006c00:	d135      	bne.n	8006c6e <HAL_ADC_IRQHandler+0x1b2>
      {
        /* If End of Sequence is reached, disable interrupts */
        if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS))
 8006c02:	687b      	ldr	r3, [r7, #4]
 8006c04:	681b      	ldr	r3, [r3, #0]
 8006c06:	681b      	ldr	r3, [r3, #0]
 8006c08:	f003 0308 	and.w	r3, r3, #8
 8006c0c:	2b08      	cmp	r3, #8
 8006c0e:	d12e      	bne.n	8006c6e <HAL_ADC_IRQHandler+0x1b2>
        {
          /* Allowed to modify bits ADC_IT_EOC/ADC_IT_EOS only if bit         */
          /* ADSTART==0 (no conversion on going)                              */
          if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8006c10:	687b      	ldr	r3, [r7, #4]
 8006c12:	681b      	ldr	r3, [r3, #0]
 8006c14:	4618      	mov	r0, r3
 8006c16:	f7ff fb96 	bl	8006346 <LL_ADC_REG_IsConversionOngoing>
 8006c1a:	4603      	mov	r3, r0
 8006c1c:	2b00      	cmp	r3, #0
 8006c1e:	d11a      	bne.n	8006c56 <HAL_ADC_IRQHandler+0x19a>
          {
            /* Disable ADC end of sequence conversion interrupt */
            /* Note: Overrun interrupt was enabled with EOC interrupt in      */
            /* HAL_Start_IT(), but is not disabled here because can be used   */
            /* by overrun IRQ process below.                                  */
            __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 8006c20:	687b      	ldr	r3, [r7, #4]
 8006c22:	681b      	ldr	r3, [r3, #0]
 8006c24:	685a      	ldr	r2, [r3, #4]
 8006c26:	687b      	ldr	r3, [r7, #4]
 8006c28:	681b      	ldr	r3, [r3, #0]
 8006c2a:	f022 020c 	bic.w	r2, r2, #12
 8006c2e:	605a      	str	r2, [r3, #4]

            /* Set ADC state */
            CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
 8006c30:	687b      	ldr	r3, [r7, #4]
 8006c32:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006c34:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 8006c38:	687b      	ldr	r3, [r7, #4]
 8006c3a:	65da      	str	r2, [r3, #92]	; 0x5c

            if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
 8006c3c:	687b      	ldr	r3, [r7, #4]
 8006c3e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006c40:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8006c44:	2b00      	cmp	r3, #0
 8006c46:	d112      	bne.n	8006c6e <HAL_ADC_IRQHandler+0x1b2>
            {
              SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8006c48:	687b      	ldr	r3, [r7, #4]
 8006c4a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006c4c:	f043 0201 	orr.w	r2, r3, #1
 8006c50:	687b      	ldr	r3, [r7, #4]
 8006c52:	65da      	str	r2, [r3, #92]	; 0x5c
 8006c54:	e00b      	b.n	8006c6e <HAL_ADC_IRQHandler+0x1b2>
            }
          }
          else
          {
            /* Change ADC state to error state */
            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8006c56:	687b      	ldr	r3, [r7, #4]
 8006c58:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006c5a:	f043 0210 	orr.w	r2, r3, #16
 8006c5e:	687b      	ldr	r3, [r7, #4]
 8006c60:	65da      	str	r2, [r3, #92]	; 0x5c

            /* Set ADC error code to ADC peripheral internal error */
            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8006c62:	687b      	ldr	r3, [r7, #4]
 8006c64:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8006c66:	f043 0201 	orr.w	r2, r3, #1
 8006c6a:	687b      	ldr	r3, [r7, #4]
 8006c6c:	661a      	str	r2, [r3, #96]	; 0x60
    /*       possibility to use:                                              */
    /*        " if ( __HAL_ADC_GET_FLAG(&hadc, ADC_FLAG_EOS)) "               */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->ConvCpltCallback(hadc);
#else
    HAL_ADC_ConvCpltCallback(hadc);
 8006c6e:	6878      	ldr	r0, [r7, #4]
 8006c70:	f7fe f800 	bl	8004c74 <HAL_ADC_ConvCpltCallback>
    /* Clear regular group conversion flag */
    /* Note: in case of overrun set to ADC_OVR_DATA_PRESERVED, end of         */
    /*       conversion flags clear induces the release of the preserved data.*/
    /*       Therefore, if the preserved data value is needed, it must be     */
    /*       read preliminarily into HAL_ADC_ConvCpltCallback().              */
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
 8006c74:	687b      	ldr	r3, [r7, #4]
 8006c76:	681b      	ldr	r3, [r3, #0]
 8006c78:	220c      	movs	r2, #12
 8006c7a:	601a      	str	r2, [r3, #0]
  }

  /* ====== Check ADC group injected end of unitary conversion sequence conversions ===== */
  if ((((tmp_isr & ADC_FLAG_JEOC) == ADC_FLAG_JEOC) && ((tmp_ier & ADC_IT_JEOC) == ADC_IT_JEOC)) ||
 8006c7c:	69fb      	ldr	r3, [r7, #28]
 8006c7e:	f003 0320 	and.w	r3, r3, #32
 8006c82:	2b00      	cmp	r3, #0
 8006c84:	d004      	beq.n	8006c90 <HAL_ADC_IRQHandler+0x1d4>
 8006c86:	69bb      	ldr	r3, [r7, #24]
 8006c88:	f003 0320 	and.w	r3, r3, #32
 8006c8c:	2b00      	cmp	r3, #0
 8006c8e:	d10b      	bne.n	8006ca8 <HAL_ADC_IRQHandler+0x1ec>
      (((tmp_isr & ADC_FLAG_JEOS) == ADC_FLAG_JEOS) && ((tmp_ier & ADC_IT_JEOS) == ADC_IT_JEOS)))
 8006c90:	69fb      	ldr	r3, [r7, #28]
 8006c92:	f003 0340 	and.w	r3, r3, #64	; 0x40
  if ((((tmp_isr & ADC_FLAG_JEOC) == ADC_FLAG_JEOC) && ((tmp_ier & ADC_IT_JEOC) == ADC_IT_JEOC)) ||
 8006c96:	2b00      	cmp	r3, #0
 8006c98:	f000 80b3 	beq.w	8006e02 <HAL_ADC_IRQHandler+0x346>
      (((tmp_isr & ADC_FLAG_JEOS) == ADC_FLAG_JEOS) && ((tmp_ier & ADC_IT_JEOS) == ADC_IT_JEOS)))
 8006c9c:	69bb      	ldr	r3, [r7, #24]
 8006c9e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006ca2:	2b00      	cmp	r3, #0
 8006ca4:	f000 80ad 	beq.w	8006e02 <HAL_ADC_IRQHandler+0x346>
  {
    /* Update state machine on conversion status if not in error state */
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8006ca8:	687b      	ldr	r3, [r7, #4]
 8006caa:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006cac:	f003 0310 	and.w	r3, r3, #16
 8006cb0:	2b00      	cmp	r3, #0
 8006cb2:	d105      	bne.n	8006cc0 <HAL_ADC_IRQHandler+0x204>
    {
      /* Set ADC state */
      SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
 8006cb4:	687b      	ldr	r3, [r7, #4]
 8006cb6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006cb8:	f443 5200 	orr.w	r2, r3, #8192	; 0x2000
 8006cbc:	687b      	ldr	r3, [r7, #4]
 8006cbe:	65da      	str	r2, [r3, #92]	; 0x5c
    }

    /* Retrieve ADC configuration */
    tmp_adc_inj_is_trigger_source_sw_start = LL_ADC_INJ_IsTriggerSourceSWStart(hadc->Instance);
 8006cc0:	687b      	ldr	r3, [r7, #4]
 8006cc2:	681b      	ldr	r3, [r3, #0]
 8006cc4:	4618      	mov	r0, r3
 8006cc6:	f7ff f9a8 	bl	800601a <LL_ADC_INJ_IsTriggerSourceSWStart>
 8006cca:	60f8      	str	r0, [r7, #12]
    tmp_adc_reg_is_trigger_source_sw_start = LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance);
 8006ccc:	687b      	ldr	r3, [r7, #4]
 8006cce:	681b      	ldr	r3, [r3, #0]
 8006cd0:	4618      	mov	r0, r3
 8006cd2:	f7ff f963 	bl	8005f9c <LL_ADC_REG_IsTriggerSourceSWStart>
 8006cd6:	60b8      	str	r0, [r7, #8]
    /* Get relevant register CFGR in ADC instance of ADC master or slave  */
    /* in function of multimode state (for devices with multimode         */
    /* available).                                                        */
#if defined(ADC_MULTIMODE_SUPPORT)
    if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 8006cd8:	687b      	ldr	r3, [r7, #4]
 8006cda:	681b      	ldr	r3, [r3, #0]
 8006cdc:	4a10      	ldr	r2, [pc, #64]	; (8006d20 <HAL_ADC_IRQHandler+0x264>)
 8006cde:	4293      	cmp	r3, r2
 8006ce0:	d009      	beq.n	8006cf6 <HAL_ADC_IRQHandler+0x23a>
 8006ce2:	687b      	ldr	r3, [r7, #4]
 8006ce4:	681b      	ldr	r3, [r3, #0]
 8006ce6:	4a11      	ldr	r2, [pc, #68]	; (8006d2c <HAL_ADC_IRQHandler+0x270>)
 8006ce8:	4293      	cmp	r3, r2
 8006cea:	d002      	beq.n	8006cf2 <HAL_ADC_IRQHandler+0x236>
 8006cec:	687b      	ldr	r3, [r7, #4]
 8006cee:	681b      	ldr	r3, [r3, #0]
 8006cf0:	e003      	b.n	8006cfa <HAL_ADC_IRQHandler+0x23e>
 8006cf2:	4b0f      	ldr	r3, [pc, #60]	; (8006d30 <HAL_ADC_IRQHandler+0x274>)
 8006cf4:	e001      	b.n	8006cfa <HAL_ADC_IRQHandler+0x23e>
 8006cf6:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8006cfa:	687a      	ldr	r2, [r7, #4]
 8006cfc:	6812      	ldr	r2, [r2, #0]
 8006cfe:	4293      	cmp	r3, r2
 8006d00:	d008      	beq.n	8006d14 <HAL_ADC_IRQHandler+0x258>
        || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8006d02:	697b      	ldr	r3, [r7, #20]
 8006d04:	2b00      	cmp	r3, #0
 8006d06:	d005      	beq.n	8006d14 <HAL_ADC_IRQHandler+0x258>
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_SIMULT)
 8006d08:	697b      	ldr	r3, [r7, #20]
 8006d0a:	2b06      	cmp	r3, #6
 8006d0c:	d002      	beq.n	8006d14 <HAL_ADC_IRQHandler+0x258>
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_INTERL)
 8006d0e:	697b      	ldr	r3, [r7, #20]
 8006d10:	2b07      	cmp	r3, #7
 8006d12:	d10f      	bne.n	8006d34 <HAL_ADC_IRQHandler+0x278>
       )
    {
      tmp_cfgr = READ_REG(hadc->Instance->CFGR);
 8006d14:	687b      	ldr	r3, [r7, #4]
 8006d16:	681b      	ldr	r3, [r3, #0]
 8006d18:	68db      	ldr	r3, [r3, #12]
 8006d1a:	623b      	str	r3, [r7, #32]
 8006d1c:	e01f      	b.n	8006d5e <HAL_ADC_IRQHandler+0x2a2>
 8006d1e:	bf00      	nop
 8006d20:	50000100 	.word	0x50000100
 8006d24:	50000300 	.word	0x50000300
 8006d28:	50000700 	.word	0x50000700
 8006d2c:	50000500 	.word	0x50000500
 8006d30:	50000400 	.word	0x50000400
    }
    else
    {
      tmpADC_Master = __LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance);
 8006d34:	687b      	ldr	r3, [r7, #4]
 8006d36:	681b      	ldr	r3, [r3, #0]
 8006d38:	4a8b      	ldr	r2, [pc, #556]	; (8006f68 <HAL_ADC_IRQHandler+0x4ac>)
 8006d3a:	4293      	cmp	r3, r2
 8006d3c:	d009      	beq.n	8006d52 <HAL_ADC_IRQHandler+0x296>
 8006d3e:	687b      	ldr	r3, [r7, #4]
 8006d40:	681b      	ldr	r3, [r3, #0]
 8006d42:	4a8a      	ldr	r2, [pc, #552]	; (8006f6c <HAL_ADC_IRQHandler+0x4b0>)
 8006d44:	4293      	cmp	r3, r2
 8006d46:	d002      	beq.n	8006d4e <HAL_ADC_IRQHandler+0x292>
 8006d48:	687b      	ldr	r3, [r7, #4]
 8006d4a:	681b      	ldr	r3, [r3, #0]
 8006d4c:	e003      	b.n	8006d56 <HAL_ADC_IRQHandler+0x29a>
 8006d4e:	4b88      	ldr	r3, [pc, #544]	; (8006f70 <HAL_ADC_IRQHandler+0x4b4>)
 8006d50:	e001      	b.n	8006d56 <HAL_ADC_IRQHandler+0x29a>
 8006d52:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8006d56:	613b      	str	r3, [r7, #16]
      tmp_cfgr = READ_REG(tmpADC_Master->CFGR);
 8006d58:	693b      	ldr	r3, [r7, #16]
 8006d5a:	68db      	ldr	r3, [r3, #12]
 8006d5c:	623b      	str	r3, [r7, #32]
    /* Disable interruption if no further conversion upcoming by injected     */
    /* external trigger or by automatic injected conversion with regular      */
    /* group having no further conversion upcoming (same conditions as        */
    /* regular group interruption disabling above),                           */
    /* and if injected scan sequence is completed.                            */
    if (tmp_adc_inj_is_trigger_source_sw_start != 0UL)
 8006d5e:	68fb      	ldr	r3, [r7, #12]
 8006d60:	2b00      	cmp	r3, #0
 8006d62:	d047      	beq.n	8006df4 <HAL_ADC_IRQHandler+0x338>
    {
      if ((READ_BIT(tmp_cfgr, ADC_CFGR_JAUTO) == 0UL) ||
 8006d64:	6a3b      	ldr	r3, [r7, #32]
 8006d66:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8006d6a:	2b00      	cmp	r3, #0
 8006d6c:	d007      	beq.n	8006d7e <HAL_ADC_IRQHandler+0x2c2>
 8006d6e:	68bb      	ldr	r3, [r7, #8]
 8006d70:	2b00      	cmp	r3, #0
 8006d72:	d03f      	beq.n	8006df4 <HAL_ADC_IRQHandler+0x338>
          ((tmp_adc_reg_is_trigger_source_sw_start != 0UL) &&
           (READ_BIT(tmp_cfgr, ADC_CFGR_CONT) == 0UL)))
 8006d74:	6a3b      	ldr	r3, [r7, #32]
 8006d76:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
          ((tmp_adc_reg_is_trigger_source_sw_start != 0UL) &&
 8006d7a:	2b00      	cmp	r3, #0
 8006d7c:	d13a      	bne.n	8006df4 <HAL_ADC_IRQHandler+0x338>
      {
        /* If End of Sequence is reached, disable interrupts */
        if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS))
 8006d7e:	687b      	ldr	r3, [r7, #4]
 8006d80:	681b      	ldr	r3, [r3, #0]
 8006d82:	681b      	ldr	r3, [r3, #0]
 8006d84:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006d88:	2b40      	cmp	r3, #64	; 0x40
 8006d8a:	d133      	bne.n	8006df4 <HAL_ADC_IRQHandler+0x338>
          /* when the last context has been fully processed, JSQR is reset      */
          /* by the hardware. Even if no injected conversion is planned to come */
          /* (queue empty, triggers are ignored), it can start again            */
          /* immediately after setting a new context (JADSTART is still set).   */
          /* Therefore, state of HAL ADC injected group is kept to busy.        */
          if (READ_BIT(tmp_cfgr, ADC_CFGR_JQM) == 0UL)
 8006d8c:	6a3b      	ldr	r3, [r7, #32]
 8006d8e:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8006d92:	2b00      	cmp	r3, #0
 8006d94:	d12e      	bne.n	8006df4 <HAL_ADC_IRQHandler+0x338>
          {
            /* Allowed to modify bits ADC_IT_JEOC/ADC_IT_JEOS only if bit       */
            /* JADSTART==0 (no conversion on going)                             */
            if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) == 0UL)
 8006d96:	687b      	ldr	r3, [r7, #4]
 8006d98:	681b      	ldr	r3, [r3, #0]
 8006d9a:	4618      	mov	r0, r3
 8006d9c:	f7ff fafa 	bl	8006394 <LL_ADC_INJ_IsConversionOngoing>
 8006da0:	4603      	mov	r3, r0
 8006da2:	2b00      	cmp	r3, #0
 8006da4:	d11a      	bne.n	8006ddc <HAL_ADC_IRQHandler+0x320>
            {
              /* Disable ADC end of sequence conversion interrupt  */
              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC | ADC_IT_JEOS);
 8006da6:	687b      	ldr	r3, [r7, #4]
 8006da8:	681b      	ldr	r3, [r3, #0]
 8006daa:	685a      	ldr	r2, [r3, #4]
 8006dac:	687b      	ldr	r3, [r7, #4]
 8006dae:	681b      	ldr	r3, [r3, #0]
 8006db0:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 8006db4:	605a      	str	r2, [r3, #4]

              /* Set ADC state */
              CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);
 8006db6:	687b      	ldr	r3, [r7, #4]
 8006db8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006dba:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 8006dbe:	687b      	ldr	r3, [r7, #4]
 8006dc0:	65da      	str	r2, [r3, #92]	; 0x5c

              if ((hadc->State & HAL_ADC_STATE_REG_BUSY) == 0UL)
 8006dc2:	687b      	ldr	r3, [r7, #4]
 8006dc4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006dc6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8006dca:	2b00      	cmp	r3, #0
 8006dcc:	d112      	bne.n	8006df4 <HAL_ADC_IRQHandler+0x338>
              {
                SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8006dce:	687b      	ldr	r3, [r7, #4]
 8006dd0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006dd2:	f043 0201 	orr.w	r2, r3, #1
 8006dd6:	687b      	ldr	r3, [r7, #4]
 8006dd8:	65da      	str	r2, [r3, #92]	; 0x5c
 8006dda:	e00b      	b.n	8006df4 <HAL_ADC_IRQHandler+0x338>
              }
            }
            else
            {
              /* Update ADC state machine to error */
              SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8006ddc:	687b      	ldr	r3, [r7, #4]
 8006dde:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006de0:	f043 0210 	orr.w	r2, r3, #16
 8006de4:	687b      	ldr	r3, [r7, #4]
 8006de6:	65da      	str	r2, [r3, #92]	; 0x5c

              /* Set ADC error code to ADC peripheral internal error */
              SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8006de8:	687b      	ldr	r3, [r7, #4]
 8006dea:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8006dec:	f043 0201 	orr.w	r2, r3, #1
 8006df0:	687b      	ldr	r3, [r7, #4]
 8006df2:	661a      	str	r2, [r3, #96]	; 0x60
              interruption has been triggered by end of conversion or end of
              sequence.    */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->InjectedConvCpltCallback(hadc);
#else
    HAL_ADCEx_InjectedConvCpltCallback(hadc);
 8006df4:	6878      	ldr	r0, [r7, #4]
 8006df6:	f001 f9dd 	bl	80081b4 <HAL_ADCEx_InjectedConvCpltCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear injected group conversion flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC | ADC_FLAG_JEOS);
 8006dfa:	687b      	ldr	r3, [r7, #4]
 8006dfc:	681b      	ldr	r3, [r3, #0]
 8006dfe:	2260      	movs	r2, #96	; 0x60
 8006e00:	601a      	str	r2, [r3, #0]
  }

  /* ========== Check Analog watchdog 1 flag ========== */
  if (((tmp_isr & ADC_FLAG_AWD1) == ADC_FLAG_AWD1) && ((tmp_ier & ADC_IT_AWD1) == ADC_IT_AWD1))
 8006e02:	69fb      	ldr	r3, [r7, #28]
 8006e04:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006e08:	2b00      	cmp	r3, #0
 8006e0a:	d011      	beq.n	8006e30 <HAL_ADC_IRQHandler+0x374>
 8006e0c:	69bb      	ldr	r3, [r7, #24]
 8006e0e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006e12:	2b00      	cmp	r3, #0
 8006e14:	d00c      	beq.n	8006e30 <HAL_ADC_IRQHandler+0x374>
  {
    /* Set ADC state */
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
 8006e16:	687b      	ldr	r3, [r7, #4]
 8006e18:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006e1a:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 8006e1e:	687b      	ldr	r3, [r7, #4]
 8006e20:	65da      	str	r2, [r3, #92]	; 0x5c

    /* Level out of window 1 callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->LevelOutOfWindowCallback(hadc);
#else
    HAL_ADC_LevelOutOfWindowCallback(hadc);
 8006e22:	6878      	ldr	r0, [r7, #4]
 8006e24:	f7fd ff5c 	bl	8004ce0 <HAL_ADC_LevelOutOfWindowCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear ADC analog watchdog flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD1);
 8006e28:	687b      	ldr	r3, [r7, #4]
 8006e2a:	681b      	ldr	r3, [r3, #0]
 8006e2c:	2280      	movs	r2, #128	; 0x80
 8006e2e:	601a      	str	r2, [r3, #0]
  }

  /* ========== Check analog watchdog 2 flag ========== */
  if (((tmp_isr & ADC_FLAG_AWD2) == ADC_FLAG_AWD2) && ((tmp_ier & ADC_IT_AWD2) == ADC_IT_AWD2))
 8006e30:	69fb      	ldr	r3, [r7, #28]
 8006e32:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8006e36:	2b00      	cmp	r3, #0
 8006e38:	d012      	beq.n	8006e60 <HAL_ADC_IRQHandler+0x3a4>
 8006e3a:	69bb      	ldr	r3, [r7, #24]
 8006e3c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8006e40:	2b00      	cmp	r3, #0
 8006e42:	d00d      	beq.n	8006e60 <HAL_ADC_IRQHandler+0x3a4>
  {
    /* Set ADC state */
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD2);
 8006e44:	687b      	ldr	r3, [r7, #4]
 8006e46:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006e48:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
 8006e4c:	687b      	ldr	r3, [r7, #4]
 8006e4e:	65da      	str	r2, [r3, #92]	; 0x5c

    /* Level out of window 2 callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->LevelOutOfWindow2Callback(hadc);
#else
    HAL_ADCEx_LevelOutOfWindow2Callback(hadc);
 8006e50:	6878      	ldr	r0, [r7, #4]
 8006e52:	f7fd ff7b 	bl	8004d4c <HAL_ADCEx_LevelOutOfWindow2Callback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear ADC analog watchdog flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD2);
 8006e56:	687b      	ldr	r3, [r7, #4]
 8006e58:	681b      	ldr	r3, [r3, #0]
 8006e5a:	f44f 7280 	mov.w	r2, #256	; 0x100
 8006e5e:	601a      	str	r2, [r3, #0]
  }

  /* ========== Check analog watchdog 3 flag ========== */
  if (((tmp_isr & ADC_FLAG_AWD3) == ADC_FLAG_AWD3) && ((tmp_ier & ADC_IT_AWD3) == ADC_IT_AWD3))
 8006e60:	69fb      	ldr	r3, [r7, #28]
 8006e62:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8006e66:	2b00      	cmp	r3, #0
 8006e68:	d012      	beq.n	8006e90 <HAL_ADC_IRQHandler+0x3d4>
 8006e6a:	69bb      	ldr	r3, [r7, #24]
 8006e6c:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8006e70:	2b00      	cmp	r3, #0
 8006e72:	d00d      	beq.n	8006e90 <HAL_ADC_IRQHandler+0x3d4>
  {
    /* Set ADC state */
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD3);
 8006e74:	687b      	ldr	r3, [r7, #4]
 8006e76:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006e78:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
 8006e7c:	687b      	ldr	r3, [r7, #4]
 8006e7e:	65da      	str	r2, [r3, #92]	; 0x5c

    /* Level out of window 3 callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->LevelOutOfWindow3Callback(hadc);
#else
    HAL_ADCEx_LevelOutOfWindow3Callback(hadc);
 8006e80:	6878      	ldr	r0, [r7, #4]
 8006e82:	f001 f9ab 	bl	80081dc <HAL_ADCEx_LevelOutOfWindow3Callback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear ADC analog watchdog flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD3);
 8006e86:	687b      	ldr	r3, [r7, #4]
 8006e88:	681b      	ldr	r3, [r3, #0]
 8006e8a:	f44f 7200 	mov.w	r2, #512	; 0x200
 8006e8e:	601a      	str	r2, [r3, #0]
  }

  /* ========== Check Overrun flag ========== */
  if (((tmp_isr & ADC_FLAG_OVR) == ADC_FLAG_OVR) && ((tmp_ier & ADC_IT_OVR) == ADC_IT_OVR))
 8006e90:	69fb      	ldr	r3, [r7, #28]
 8006e92:	f003 0310 	and.w	r3, r3, #16
 8006e96:	2b00      	cmp	r3, #0
 8006e98:	d043      	beq.n	8006f22 <HAL_ADC_IRQHandler+0x466>
 8006e9a:	69bb      	ldr	r3, [r7, #24]
 8006e9c:	f003 0310 	and.w	r3, r3, #16
 8006ea0:	2b00      	cmp	r3, #0
 8006ea2:	d03e      	beq.n	8006f22 <HAL_ADC_IRQHandler+0x466>
    /* overrun event is not considered as an error.                           */
    /* (cf ref manual "Managing conversions without using the DMA and without */
    /* overrun ")                                                             */
    /* Exception for usage with DMA overrun event always considered as an     */
    /* error.                                                                 */
    if (hadc->Init.Overrun == ADC_OVR_DATA_PRESERVED)
 8006ea4:	687b      	ldr	r3, [r7, #4]
 8006ea6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006ea8:	2b00      	cmp	r3, #0
 8006eaa:	d102      	bne.n	8006eb2 <HAL_ADC_IRQHandler+0x3f6>
    {
      overrun_error = 1UL;
 8006eac:	2301      	movs	r3, #1
 8006eae:	627b      	str	r3, [r7, #36]	; 0x24
 8006eb0:	e021      	b.n	8006ef6 <HAL_ADC_IRQHandler+0x43a>
    }
    else
    {
      /* Check DMA configuration */
#if defined(ADC_MULTIMODE_SUPPORT)
      if (tmp_multimode_config != LL_ADC_MULTI_INDEPENDENT)
 8006eb2:	697b      	ldr	r3, [r7, #20]
 8006eb4:	2b00      	cmp	r3, #0
 8006eb6:	d015      	beq.n	8006ee4 <HAL_ADC_IRQHandler+0x428>
      {
        /* Multimode (when feature is available) is enabled,
           Common Control Register MDMA bits must be checked. */
        if (LL_ADC_GetMultiDMATransfer(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) != LL_ADC_MULTI_REG_DMA_EACH_ADC)
 8006eb8:	687b      	ldr	r3, [r7, #4]
 8006eba:	681b      	ldr	r3, [r3, #0]
 8006ebc:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8006ec0:	d004      	beq.n	8006ecc <HAL_ADC_IRQHandler+0x410>
 8006ec2:	687b      	ldr	r3, [r7, #4]
 8006ec4:	681b      	ldr	r3, [r3, #0]
 8006ec6:	4a28      	ldr	r2, [pc, #160]	; (8006f68 <HAL_ADC_IRQHandler+0x4ac>)
 8006ec8:	4293      	cmp	r3, r2
 8006eca:	d101      	bne.n	8006ed0 <HAL_ADC_IRQHandler+0x414>
 8006ecc:	4b29      	ldr	r3, [pc, #164]	; (8006f74 <HAL_ADC_IRQHandler+0x4b8>)
 8006ece:	e000      	b.n	8006ed2 <HAL_ADC_IRQHandler+0x416>
 8006ed0:	4b29      	ldr	r3, [pc, #164]	; (8006f78 <HAL_ADC_IRQHandler+0x4bc>)
 8006ed2:	4618      	mov	r0, r3
 8006ed4:	f7ff f965 	bl	80061a2 <LL_ADC_GetMultiDMATransfer>
 8006ed8:	4603      	mov	r3, r0
 8006eda:	2b00      	cmp	r3, #0
 8006edc:	d00b      	beq.n	8006ef6 <HAL_ADC_IRQHandler+0x43a>
        {
          overrun_error = 1UL;
 8006ede:	2301      	movs	r3, #1
 8006ee0:	627b      	str	r3, [r7, #36]	; 0x24
 8006ee2:	e008      	b.n	8006ef6 <HAL_ADC_IRQHandler+0x43a>
      }
      else
#endif
      {
        /* Multimode not set or feature not available or ADC independent */
        if ((hadc->Instance->CFGR & ADC_CFGR_DMAEN) != 0UL)
 8006ee4:	687b      	ldr	r3, [r7, #4]
 8006ee6:	681b      	ldr	r3, [r3, #0]
 8006ee8:	68db      	ldr	r3, [r3, #12]
 8006eea:	f003 0301 	and.w	r3, r3, #1
 8006eee:	2b00      	cmp	r3, #0
 8006ef0:	d001      	beq.n	8006ef6 <HAL_ADC_IRQHandler+0x43a>
        {
          overrun_error = 1UL;
 8006ef2:	2301      	movs	r3, #1
 8006ef4:	627b      	str	r3, [r7, #36]	; 0x24
        }
      }
    }

    if (overrun_error == 1UL)
 8006ef6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006ef8:	2b01      	cmp	r3, #1
 8006efa:	d10e      	bne.n	8006f1a <HAL_ADC_IRQHandler+0x45e>
    {
      /* Change ADC state to error state */
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_OVR);
 8006efc:	687b      	ldr	r3, [r7, #4]
 8006efe:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006f00:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
 8006f04:	687b      	ldr	r3, [r7, #4]
 8006f06:	65da      	str	r2, [r3, #92]	; 0x5c

      /* Set ADC error code to overrun */
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
 8006f08:	687b      	ldr	r3, [r7, #4]
 8006f0a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8006f0c:	f043 0202 	orr.w	r2, r3, #2
 8006f10:	687b      	ldr	r3, [r7, #4]
 8006f12:	661a      	str	r2, [r3, #96]	; 0x60
      /*       Therefore, old ADC conversion data can be retrieved in         */
      /*       function "HAL_ADC_ErrorCallback()".                            */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
      hadc->ErrorCallback(hadc);
#else
      HAL_ADC_ErrorCallback(hadc);
 8006f14:	6878      	ldr	r0, [r7, #4]
 8006f16:	f000 f831 	bl	8006f7c <HAL_ADC_ErrorCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
    }

    /* Clear ADC overrun flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
 8006f1a:	687b      	ldr	r3, [r7, #4]
 8006f1c:	681b      	ldr	r3, [r3, #0]
 8006f1e:	2210      	movs	r2, #16
 8006f20:	601a      	str	r2, [r3, #0]
  }

  /* ========== Check Injected context queue overflow flag ========== */
  if (((tmp_isr & ADC_FLAG_JQOVF) == ADC_FLAG_JQOVF) && ((tmp_ier & ADC_IT_JQOVF) == ADC_IT_JQOVF))
 8006f22:	69fb      	ldr	r3, [r7, #28]
 8006f24:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8006f28:	2b00      	cmp	r3, #0
 8006f2a:	d018      	beq.n	8006f5e <HAL_ADC_IRQHandler+0x4a2>
 8006f2c:	69bb      	ldr	r3, [r7, #24]
 8006f2e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8006f32:	2b00      	cmp	r3, #0
 8006f34:	d013      	beq.n	8006f5e <HAL_ADC_IRQHandler+0x4a2>
  {
    /* Change ADC state to overrun state */
    SET_BIT(hadc->State, HAL_ADC_STATE_INJ_JQOVF);
 8006f36:	687b      	ldr	r3, [r7, #4]
 8006f38:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006f3a:	f443 4280 	orr.w	r2, r3, #16384	; 0x4000
 8006f3e:	687b      	ldr	r3, [r7, #4]
 8006f40:	65da      	str	r2, [r3, #92]	; 0x5c

    /* Set ADC error code to Injected context queue overflow */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_JQOVF);
 8006f42:	687b      	ldr	r3, [r7, #4]
 8006f44:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8006f46:	f043 0208 	orr.w	r2, r3, #8
 8006f4a:	687b      	ldr	r3, [r7, #4]
 8006f4c:	661a      	str	r2, [r3, #96]	; 0x60

    /* Clear the Injected context queue overflow flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JQOVF);
 8006f4e:	687b      	ldr	r3, [r7, #4]
 8006f50:	681b      	ldr	r3, [r3, #0]
 8006f52:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8006f56:	601a      	str	r2, [r3, #0]

    /* Injected context queue overflow callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->InjectedQueueOverflowCallback(hadc);
#else
    HAL_ADCEx_InjectedQueueOverflowCallback(hadc);
 8006f58:	6878      	ldr	r0, [r7, #4]
 8006f5a:	f001 f935 	bl	80081c8 <HAL_ADCEx_InjectedQueueOverflowCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
  }

}
 8006f5e:	bf00      	nop
 8006f60:	3728      	adds	r7, #40	; 0x28
 8006f62:	46bd      	mov	sp, r7
 8006f64:	bd80      	pop	{r7, pc}
 8006f66:	bf00      	nop
 8006f68:	50000100 	.word	0x50000100
 8006f6c:	50000500 	.word	0x50000500
 8006f70:	50000400 	.word	0x50000400
 8006f74:	50000300 	.word	0x50000300
 8006f78:	50000700 	.word	0x50000700

08006f7c <HAL_ADC_ErrorCallback>:
  *           (this function is also clearing overrun flag)
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
{
 8006f7c:	b480      	push	{r7}
 8006f7e:	b083      	sub	sp, #12
 8006f80:	af00      	add	r7, sp, #0
 8006f82:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_ErrorCallback must be implemented in the user file.
  */
}
 8006f84:	bf00      	nop
 8006f86:	370c      	adds	r7, #12
 8006f88:	46bd      	mov	sp, r7
 8006f8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006f8e:	4770      	bx	lr

08006f90 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param sConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *sConfig)
{
 8006f90:	b580      	push	{r7, lr}
 8006f92:	b0b6      	sub	sp, #216	; 0xd8
 8006f94:	af00      	add	r7, sp, #0
 8006f96:	6078      	str	r0, [r7, #4]
 8006f98:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8006f9a:	2300      	movs	r3, #0
 8006f9c:	f887 30d7 	strb.w	r3, [r7, #215]	; 0xd7
  uint32_t tmpOffsetShifted;
  uint32_t tmp_config_internal_channel;
  __IO uint32_t wait_loop_index = 0UL;
 8006fa0:	2300      	movs	r3, #0
 8006fa2:	60fb      	str	r3, [r7, #12]
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, sConfig->Channel));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8006fa4:	687b      	ldr	r3, [r7, #4]
 8006fa6:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 8006faa:	2b01      	cmp	r3, #1
 8006fac:	d102      	bne.n	8006fb4 <HAL_ADC_ConfigChannel+0x24>
 8006fae:	2302      	movs	r3, #2
 8006fb0:	f000 bc13 	b.w	80077da <HAL_ADC_ConfigChannel+0x84a>
 8006fb4:	687b      	ldr	r3, [r7, #4]
 8006fb6:	2201      	movs	r2, #1
 8006fb8:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8006fbc:	687b      	ldr	r3, [r7, #4]
 8006fbe:	681b      	ldr	r3, [r3, #0]
 8006fc0:	4618      	mov	r0, r3
 8006fc2:	f7ff f9c0 	bl	8006346 <LL_ADC_REG_IsConversionOngoing>
 8006fc6:	4603      	mov	r3, r0
 8006fc8:	2b00      	cmp	r3, #0
 8006fca:	f040 83f3 	bne.w	80077b4 <HAL_ADC_ConfigChannel+0x824>
  {
    /* Set ADC group regular sequence: channel on the selected scan sequence rank */
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
 8006fce:	687b      	ldr	r3, [r7, #4]
 8006fd0:	6818      	ldr	r0, [r3, #0]
 8006fd2:	683b      	ldr	r3, [r7, #0]
 8006fd4:	6859      	ldr	r1, [r3, #4]
 8006fd6:	683b      	ldr	r3, [r7, #0]
 8006fd8:	681b      	ldr	r3, [r3, #0]
 8006fda:	461a      	mov	r2, r3
 8006fdc:	f7fe fff1 	bl	8005fc2 <LL_ADC_REG_SetSequencerRanks>
    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated when ADC is disabled or enabled without   */
    /* conversion on going on regular group:                                    */
    /*  - Channel sampling time                                                 */
    /*  - Channel offset                                                        */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8006fe0:	687b      	ldr	r3, [r7, #4]
 8006fe2:	681b      	ldr	r3, [r3, #0]
 8006fe4:	4618      	mov	r0, r3
 8006fe6:	f7ff f9ae 	bl	8006346 <LL_ADC_REG_IsConversionOngoing>
 8006fea:	f8c7 00d0 	str.w	r0, [r7, #208]	; 0xd0
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 8006fee:	687b      	ldr	r3, [r7, #4]
 8006ff0:	681b      	ldr	r3, [r3, #0]
 8006ff2:	4618      	mov	r0, r3
 8006ff4:	f7ff f9ce 	bl	8006394 <LL_ADC_INJ_IsConversionOngoing>
 8006ff8:	f8c7 00cc 	str.w	r0, [r7, #204]	; 0xcc
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 8006ffc:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8007000:	2b00      	cmp	r3, #0
 8007002:	f040 81d9 	bne.w	80073b8 <HAL_ADC_ConfigChannel+0x428>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 8007006:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800700a:	2b00      	cmp	r3, #0
 800700c:	f040 81d4 	bne.w	80073b8 <HAL_ADC_ConfigChannel+0x428>
       )
    {
      /* Manage specific case of sampling time 3.5 cycles replacing 2.5 cyles */
      if (sConfig->SamplingTime == ADC_SAMPLETIME_3CYCLES_5)
 8007010:	683b      	ldr	r3, [r7, #0]
 8007012:	689b      	ldr	r3, [r3, #8]
 8007014:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8007018:	d10f      	bne.n	800703a <HAL_ADC_ConfigChannel+0xaa>
      {
        /* Set sampling time of the selected ADC channel */
        LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, LL_ADC_SAMPLINGTIME_2CYCLES_5);
 800701a:	687b      	ldr	r3, [r7, #4]
 800701c:	6818      	ldr	r0, [r3, #0]
 800701e:	683b      	ldr	r3, [r7, #0]
 8007020:	681b      	ldr	r3, [r3, #0]
 8007022:	2200      	movs	r2, #0
 8007024:	4619      	mov	r1, r3
 8007026:	f7ff f80b 	bl	8006040 <LL_ADC_SetChannelSamplingTime>

        /* Set ADC sampling time common configuration */
        LL_ADC_SetSamplingTimeCommonConfig(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_3C5_REPL_2C5);
 800702a:	687b      	ldr	r3, [r7, #4]
 800702c:	681b      	ldr	r3, [r3, #0]
 800702e:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
 8007032:	4618      	mov	r0, r3
 8007034:	f7fe ff9f 	bl	8005f76 <LL_ADC_SetSamplingTimeCommonConfig>
 8007038:	e00e      	b.n	8007058 <HAL_ADC_ConfigChannel+0xc8>
      }
      else
      {
        /* Set sampling time of the selected ADC channel */
        LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
 800703a:	687b      	ldr	r3, [r7, #4]
 800703c:	6818      	ldr	r0, [r3, #0]
 800703e:	683b      	ldr	r3, [r7, #0]
 8007040:	6819      	ldr	r1, [r3, #0]
 8007042:	683b      	ldr	r3, [r7, #0]
 8007044:	689b      	ldr	r3, [r3, #8]
 8007046:	461a      	mov	r2, r3
 8007048:	f7fe fffa 	bl	8006040 <LL_ADC_SetChannelSamplingTime>

        /* Set ADC sampling time common configuration */
        LL_ADC_SetSamplingTimeCommonConfig(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_DEFAULT);
 800704c:	687b      	ldr	r3, [r7, #4]
 800704e:	681b      	ldr	r3, [r3, #0]
 8007050:	2100      	movs	r1, #0
 8007052:	4618      	mov	r0, r3
 8007054:	f7fe ff8f 	bl	8005f76 <LL_ADC_SetSamplingTimeCommonConfig>

      /* Configure the offset: offset enable/disable, channel, offset value */

      /* Shift the offset with respect to the selected ADC resolution. */
      /* Offset has to be left-aligned on bit 11, the LSB (right bits) are set to 0 */
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 8007058:	683b      	ldr	r3, [r7, #0]
 800705a:	695a      	ldr	r2, [r3, #20]
 800705c:	687b      	ldr	r3, [r7, #4]
 800705e:	681b      	ldr	r3, [r3, #0]
 8007060:	68db      	ldr	r3, [r3, #12]
 8007062:	08db      	lsrs	r3, r3, #3
 8007064:	f003 0303 	and.w	r3, r3, #3
 8007068:	005b      	lsls	r3, r3, #1
 800706a:	fa02 f303 	lsl.w	r3, r2, r3
 800706e:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8

      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
 8007072:	683b      	ldr	r3, [r7, #0]
 8007074:	691b      	ldr	r3, [r3, #16]
 8007076:	2b04      	cmp	r3, #4
 8007078:	d022      	beq.n	80070c0 <HAL_ADC_ConfigChannel+0x130>
      {
        /* Set ADC selected offset number */
        LL_ADC_SetOffset(hadc->Instance, sConfig->OffsetNumber, sConfig->Channel, tmpOffsetShifted);
 800707a:	687b      	ldr	r3, [r7, #4]
 800707c:	6818      	ldr	r0, [r3, #0]
 800707e:	683b      	ldr	r3, [r7, #0]
 8007080:	6919      	ldr	r1, [r3, #16]
 8007082:	683b      	ldr	r3, [r7, #0]
 8007084:	681a      	ldr	r2, [r3, #0]
 8007086:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800708a:	f7fe fee9 	bl	8005e60 <LL_ADC_SetOffset>

        assert_param(IS_ADC_OFFSET_SIGN(sConfig->OffsetSign));
        assert_param(IS_FUNCTIONAL_STATE(sConfig->OffsetSaturation));
        /* Set ADC selected offset sign & saturation */
        LL_ADC_SetOffsetSign(hadc->Instance, sConfig->OffsetNumber, sConfig->OffsetSign);
 800708e:	687b      	ldr	r3, [r7, #4]
 8007090:	6818      	ldr	r0, [r3, #0]
 8007092:	683b      	ldr	r3, [r7, #0]
 8007094:	6919      	ldr	r1, [r3, #16]
 8007096:	683b      	ldr	r3, [r7, #0]
 8007098:	699b      	ldr	r3, [r3, #24]
 800709a:	461a      	mov	r2, r3
 800709c:	f7fe ff35 	bl	8005f0a <LL_ADC_SetOffsetSign>
        LL_ADC_SetOffsetSaturation(hadc->Instance, sConfig->OffsetNumber, (sConfig->OffsetSaturation == ENABLE) ? LL_ADC_OFFSET_SATURATION_ENABLE : LL_ADC_OFFSET_SATURATION_DISABLE);
 80070a0:	687b      	ldr	r3, [r7, #4]
 80070a2:	6818      	ldr	r0, [r3, #0]
 80070a4:	683b      	ldr	r3, [r7, #0]
 80070a6:	6919      	ldr	r1, [r3, #16]
 80070a8:	683b      	ldr	r3, [r7, #0]
 80070aa:	7f1b      	ldrb	r3, [r3, #28]
 80070ac:	2b01      	cmp	r3, #1
 80070ae:	d102      	bne.n	80070b6 <HAL_ADC_ConfigChannel+0x126>
 80070b0:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80070b4:	e000      	b.n	80070b8 <HAL_ADC_ConfigChannel+0x128>
 80070b6:	2300      	movs	r3, #0
 80070b8:	461a      	mov	r2, r3
 80070ba:	f7fe ff41 	bl	8005f40 <LL_ADC_SetOffsetSaturation>
 80070be:	e17b      	b.n	80073b8 <HAL_ADC_ConfigChannel+0x428>
      }
      else
      {
        /* Scan each offset register to check if the selected channel is targeted. */
        /* If this is the case, the corresponding offset number is disabled.       */
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 80070c0:	687b      	ldr	r3, [r7, #4]
 80070c2:	681b      	ldr	r3, [r3, #0]
 80070c4:	2100      	movs	r1, #0
 80070c6:	4618      	mov	r0, r3
 80070c8:	f7fe feee 	bl	8005ea8 <LL_ADC_GetOffsetChannel>
 80070cc:	4603      	mov	r3, r0
 80070ce:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80070d2:	2b00      	cmp	r3, #0
 80070d4:	d10a      	bne.n	80070ec <HAL_ADC_ConfigChannel+0x15c>
 80070d6:	687b      	ldr	r3, [r7, #4]
 80070d8:	681b      	ldr	r3, [r3, #0]
 80070da:	2100      	movs	r1, #0
 80070dc:	4618      	mov	r0, r3
 80070de:	f7fe fee3 	bl	8005ea8 <LL_ADC_GetOffsetChannel>
 80070e2:	4603      	mov	r3, r0
 80070e4:	0e9b      	lsrs	r3, r3, #26
 80070e6:	f003 021f 	and.w	r2, r3, #31
 80070ea:	e01e      	b.n	800712a <HAL_ADC_ConfigChannel+0x19a>
 80070ec:	687b      	ldr	r3, [r7, #4]
 80070ee:	681b      	ldr	r3, [r3, #0]
 80070f0:	2100      	movs	r1, #0
 80070f2:	4618      	mov	r0, r3
 80070f4:	f7fe fed8 	bl	8005ea8 <LL_ADC_GetOffsetChannel>
 80070f8:	4603      	mov	r3, r0
 80070fa:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80070fe:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8007102:	fa93 f3a3 	rbit	r3, r3
 8007106:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
 800710a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800710e:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
 8007112:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8007116:	2b00      	cmp	r3, #0
 8007118:	d101      	bne.n	800711e <HAL_ADC_ConfigChannel+0x18e>
  {
    return 32U;
 800711a:	2320      	movs	r3, #32
 800711c:	e004      	b.n	8007128 <HAL_ADC_ConfigChannel+0x198>
  }
  return __builtin_clz(value);
 800711e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8007122:	fab3 f383 	clz	r3, r3
 8007126:	b2db      	uxtb	r3, r3
 8007128:	461a      	mov	r2, r3
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 800712a:	683b      	ldr	r3, [r7, #0]
 800712c:	681b      	ldr	r3, [r3, #0]
 800712e:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8007132:	2b00      	cmp	r3, #0
 8007134:	d105      	bne.n	8007142 <HAL_ADC_ConfigChannel+0x1b2>
 8007136:	683b      	ldr	r3, [r7, #0]
 8007138:	681b      	ldr	r3, [r3, #0]
 800713a:	0e9b      	lsrs	r3, r3, #26
 800713c:	f003 031f 	and.w	r3, r3, #31
 8007140:	e018      	b.n	8007174 <HAL_ADC_ConfigChannel+0x1e4>
 8007142:	683b      	ldr	r3, [r7, #0]
 8007144:	681b      	ldr	r3, [r3, #0]
 8007146:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800714a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800714e:	fa93 f3a3 	rbit	r3, r3
 8007152:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  return result;
 8007156:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800715a:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
  if (value == 0U)
 800715e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8007162:	2b00      	cmp	r3, #0
 8007164:	d101      	bne.n	800716a <HAL_ADC_ConfigChannel+0x1da>
    return 32U;
 8007166:	2320      	movs	r3, #32
 8007168:	e004      	b.n	8007174 <HAL_ADC_ConfigChannel+0x1e4>
  return __builtin_clz(value);
 800716a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800716e:	fab3 f383 	clz	r3, r3
 8007172:	b2db      	uxtb	r3, r3
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8007174:	429a      	cmp	r2, r3
 8007176:	d106      	bne.n	8007186 <HAL_ADC_ConfigChannel+0x1f6>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_1, LL_ADC_OFFSET_DISABLE);
 8007178:	687b      	ldr	r3, [r7, #4]
 800717a:	681b      	ldr	r3, [r3, #0]
 800717c:	2200      	movs	r2, #0
 800717e:	2100      	movs	r1, #0
 8007180:	4618      	mov	r0, r3
 8007182:	f7fe fea7 	bl	8005ed4 <LL_ADC_SetOffsetState>
        }
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8007186:	687b      	ldr	r3, [r7, #4]
 8007188:	681b      	ldr	r3, [r3, #0]
 800718a:	2101      	movs	r1, #1
 800718c:	4618      	mov	r0, r3
 800718e:	f7fe fe8b 	bl	8005ea8 <LL_ADC_GetOffsetChannel>
 8007192:	4603      	mov	r3, r0
 8007194:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8007198:	2b00      	cmp	r3, #0
 800719a:	d10a      	bne.n	80071b2 <HAL_ADC_ConfigChannel+0x222>
 800719c:	687b      	ldr	r3, [r7, #4]
 800719e:	681b      	ldr	r3, [r3, #0]
 80071a0:	2101      	movs	r1, #1
 80071a2:	4618      	mov	r0, r3
 80071a4:	f7fe fe80 	bl	8005ea8 <LL_ADC_GetOffsetChannel>
 80071a8:	4603      	mov	r3, r0
 80071aa:	0e9b      	lsrs	r3, r3, #26
 80071ac:	f003 021f 	and.w	r2, r3, #31
 80071b0:	e01e      	b.n	80071f0 <HAL_ADC_ConfigChannel+0x260>
 80071b2:	687b      	ldr	r3, [r7, #4]
 80071b4:	681b      	ldr	r3, [r3, #0]
 80071b6:	2101      	movs	r1, #1
 80071b8:	4618      	mov	r0, r3
 80071ba:	f7fe fe75 	bl	8005ea8 <LL_ADC_GetOffsetChannel>
 80071be:	4603      	mov	r3, r0
 80071c0:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80071c4:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80071c8:	fa93 f3a3 	rbit	r3, r3
 80071cc:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
  return result;
 80071d0:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80071d4:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
  if (value == 0U)
 80071d8:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80071dc:	2b00      	cmp	r3, #0
 80071de:	d101      	bne.n	80071e4 <HAL_ADC_ConfigChannel+0x254>
    return 32U;
 80071e0:	2320      	movs	r3, #32
 80071e2:	e004      	b.n	80071ee <HAL_ADC_ConfigChannel+0x25e>
  return __builtin_clz(value);
 80071e4:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80071e8:	fab3 f383 	clz	r3, r3
 80071ec:	b2db      	uxtb	r3, r3
 80071ee:	461a      	mov	r2, r3
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 80071f0:	683b      	ldr	r3, [r7, #0]
 80071f2:	681b      	ldr	r3, [r3, #0]
 80071f4:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80071f8:	2b00      	cmp	r3, #0
 80071fa:	d105      	bne.n	8007208 <HAL_ADC_ConfigChannel+0x278>
 80071fc:	683b      	ldr	r3, [r7, #0]
 80071fe:	681b      	ldr	r3, [r3, #0]
 8007200:	0e9b      	lsrs	r3, r3, #26
 8007202:	f003 031f 	and.w	r3, r3, #31
 8007206:	e018      	b.n	800723a <HAL_ADC_ConfigChannel+0x2aa>
 8007208:	683b      	ldr	r3, [r7, #0]
 800720a:	681b      	ldr	r3, [r3, #0]
 800720c:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8007210:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8007214:	fa93 f3a3 	rbit	r3, r3
 8007218:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
  return result;
 800721c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8007220:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  if (value == 0U)
 8007224:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8007228:	2b00      	cmp	r3, #0
 800722a:	d101      	bne.n	8007230 <HAL_ADC_ConfigChannel+0x2a0>
    return 32U;
 800722c:	2320      	movs	r3, #32
 800722e:	e004      	b.n	800723a <HAL_ADC_ConfigChannel+0x2aa>
  return __builtin_clz(value);
 8007230:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8007234:	fab3 f383 	clz	r3, r3
 8007238:	b2db      	uxtb	r3, r3
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 800723a:	429a      	cmp	r2, r3
 800723c:	d106      	bne.n	800724c <HAL_ADC_ConfigChannel+0x2bc>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_2, LL_ADC_OFFSET_DISABLE);
 800723e:	687b      	ldr	r3, [r7, #4]
 8007240:	681b      	ldr	r3, [r3, #0]
 8007242:	2200      	movs	r2, #0
 8007244:	2101      	movs	r1, #1
 8007246:	4618      	mov	r0, r3
 8007248:	f7fe fe44 	bl	8005ed4 <LL_ADC_SetOffsetState>
        }
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 800724c:	687b      	ldr	r3, [r7, #4]
 800724e:	681b      	ldr	r3, [r3, #0]
 8007250:	2102      	movs	r1, #2
 8007252:	4618      	mov	r0, r3
 8007254:	f7fe fe28 	bl	8005ea8 <LL_ADC_GetOffsetChannel>
 8007258:	4603      	mov	r3, r0
 800725a:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800725e:	2b00      	cmp	r3, #0
 8007260:	d10a      	bne.n	8007278 <HAL_ADC_ConfigChannel+0x2e8>
 8007262:	687b      	ldr	r3, [r7, #4]
 8007264:	681b      	ldr	r3, [r3, #0]
 8007266:	2102      	movs	r1, #2
 8007268:	4618      	mov	r0, r3
 800726a:	f7fe fe1d 	bl	8005ea8 <LL_ADC_GetOffsetChannel>
 800726e:	4603      	mov	r3, r0
 8007270:	0e9b      	lsrs	r3, r3, #26
 8007272:	f003 021f 	and.w	r2, r3, #31
 8007276:	e01e      	b.n	80072b6 <HAL_ADC_ConfigChannel+0x326>
 8007278:	687b      	ldr	r3, [r7, #4]
 800727a:	681b      	ldr	r3, [r3, #0]
 800727c:	2102      	movs	r1, #2
 800727e:	4618      	mov	r0, r3
 8007280:	f7fe fe12 	bl	8005ea8 <LL_ADC_GetOffsetChannel>
 8007284:	4603      	mov	r3, r0
 8007286:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800728a:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800728e:	fa93 f3a3 	rbit	r3, r3
 8007292:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  return result;
 8007296:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800729a:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  if (value == 0U)
 800729e:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80072a2:	2b00      	cmp	r3, #0
 80072a4:	d101      	bne.n	80072aa <HAL_ADC_ConfigChannel+0x31a>
    return 32U;
 80072a6:	2320      	movs	r3, #32
 80072a8:	e004      	b.n	80072b4 <HAL_ADC_ConfigChannel+0x324>
  return __builtin_clz(value);
 80072aa:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80072ae:	fab3 f383 	clz	r3, r3
 80072b2:	b2db      	uxtb	r3, r3
 80072b4:	461a      	mov	r2, r3
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 80072b6:	683b      	ldr	r3, [r7, #0]
 80072b8:	681b      	ldr	r3, [r3, #0]
 80072ba:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80072be:	2b00      	cmp	r3, #0
 80072c0:	d105      	bne.n	80072ce <HAL_ADC_ConfigChannel+0x33e>
 80072c2:	683b      	ldr	r3, [r7, #0]
 80072c4:	681b      	ldr	r3, [r3, #0]
 80072c6:	0e9b      	lsrs	r3, r3, #26
 80072c8:	f003 031f 	and.w	r3, r3, #31
 80072cc:	e016      	b.n	80072fc <HAL_ADC_ConfigChannel+0x36c>
 80072ce:	683b      	ldr	r3, [r7, #0]
 80072d0:	681b      	ldr	r3, [r3, #0]
 80072d2:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80072d6:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 80072da:	fa93 f3a3 	rbit	r3, r3
 80072de:	67fb      	str	r3, [r7, #124]	; 0x7c
  return result;
 80072e0:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80072e2:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  if (value == 0U)
 80072e6:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80072ea:	2b00      	cmp	r3, #0
 80072ec:	d101      	bne.n	80072f2 <HAL_ADC_ConfigChannel+0x362>
    return 32U;
 80072ee:	2320      	movs	r3, #32
 80072f0:	e004      	b.n	80072fc <HAL_ADC_ConfigChannel+0x36c>
  return __builtin_clz(value);
 80072f2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80072f6:	fab3 f383 	clz	r3, r3
 80072fa:	b2db      	uxtb	r3, r3
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 80072fc:	429a      	cmp	r2, r3
 80072fe:	d106      	bne.n	800730e <HAL_ADC_ConfigChannel+0x37e>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_3, LL_ADC_OFFSET_DISABLE);
 8007300:	687b      	ldr	r3, [r7, #4]
 8007302:	681b      	ldr	r3, [r3, #0]
 8007304:	2200      	movs	r2, #0
 8007306:	2102      	movs	r1, #2
 8007308:	4618      	mov	r0, r3
 800730a:	f7fe fde3 	bl	8005ed4 <LL_ADC_SetOffsetState>
        }
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 800730e:	687b      	ldr	r3, [r7, #4]
 8007310:	681b      	ldr	r3, [r3, #0]
 8007312:	2103      	movs	r1, #3
 8007314:	4618      	mov	r0, r3
 8007316:	f7fe fdc7 	bl	8005ea8 <LL_ADC_GetOffsetChannel>
 800731a:	4603      	mov	r3, r0
 800731c:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8007320:	2b00      	cmp	r3, #0
 8007322:	d10a      	bne.n	800733a <HAL_ADC_ConfigChannel+0x3aa>
 8007324:	687b      	ldr	r3, [r7, #4]
 8007326:	681b      	ldr	r3, [r3, #0]
 8007328:	2103      	movs	r1, #3
 800732a:	4618      	mov	r0, r3
 800732c:	f7fe fdbc 	bl	8005ea8 <LL_ADC_GetOffsetChannel>
 8007330:	4603      	mov	r3, r0
 8007332:	0e9b      	lsrs	r3, r3, #26
 8007334:	f003 021f 	and.w	r2, r3, #31
 8007338:	e017      	b.n	800736a <HAL_ADC_ConfigChannel+0x3da>
 800733a:	687b      	ldr	r3, [r7, #4]
 800733c:	681b      	ldr	r3, [r3, #0]
 800733e:	2103      	movs	r1, #3
 8007340:	4618      	mov	r0, r3
 8007342:	f7fe fdb1 	bl	8005ea8 <LL_ADC_GetOffsetChannel>
 8007346:	4603      	mov	r3, r0
 8007348:	677b      	str	r3, [r7, #116]	; 0x74
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800734a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800734c:	fa93 f3a3 	rbit	r3, r3
 8007350:	673b      	str	r3, [r7, #112]	; 0x70
  return result;
 8007352:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8007354:	67bb      	str	r3, [r7, #120]	; 0x78
  if (value == 0U)
 8007356:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8007358:	2b00      	cmp	r3, #0
 800735a:	d101      	bne.n	8007360 <HAL_ADC_ConfigChannel+0x3d0>
    return 32U;
 800735c:	2320      	movs	r3, #32
 800735e:	e003      	b.n	8007368 <HAL_ADC_ConfigChannel+0x3d8>
  return __builtin_clz(value);
 8007360:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8007362:	fab3 f383 	clz	r3, r3
 8007366:	b2db      	uxtb	r3, r3
 8007368:	461a      	mov	r2, r3
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 800736a:	683b      	ldr	r3, [r7, #0]
 800736c:	681b      	ldr	r3, [r3, #0]
 800736e:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8007372:	2b00      	cmp	r3, #0
 8007374:	d105      	bne.n	8007382 <HAL_ADC_ConfigChannel+0x3f2>
 8007376:	683b      	ldr	r3, [r7, #0]
 8007378:	681b      	ldr	r3, [r3, #0]
 800737a:	0e9b      	lsrs	r3, r3, #26
 800737c:	f003 031f 	and.w	r3, r3, #31
 8007380:	e011      	b.n	80073a6 <HAL_ADC_ConfigChannel+0x416>
 8007382:	683b      	ldr	r3, [r7, #0]
 8007384:	681b      	ldr	r3, [r3, #0]
 8007386:	66bb      	str	r3, [r7, #104]	; 0x68
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8007388:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800738a:	fa93 f3a3 	rbit	r3, r3
 800738e:	667b      	str	r3, [r7, #100]	; 0x64
  return result;
 8007390:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8007392:	66fb      	str	r3, [r7, #108]	; 0x6c
  if (value == 0U)
 8007394:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8007396:	2b00      	cmp	r3, #0
 8007398:	d101      	bne.n	800739e <HAL_ADC_ConfigChannel+0x40e>
    return 32U;
 800739a:	2320      	movs	r3, #32
 800739c:	e003      	b.n	80073a6 <HAL_ADC_ConfigChannel+0x416>
  return __builtin_clz(value);
 800739e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80073a0:	fab3 f383 	clz	r3, r3
 80073a4:	b2db      	uxtb	r3, r3
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 80073a6:	429a      	cmp	r2, r3
 80073a8:	d106      	bne.n	80073b8 <HAL_ADC_ConfigChannel+0x428>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_4, LL_ADC_OFFSET_DISABLE);
 80073aa:	687b      	ldr	r3, [r7, #4]
 80073ac:	681b      	ldr	r3, [r3, #0]
 80073ae:	2200      	movs	r2, #0
 80073b0:	2103      	movs	r1, #3
 80073b2:	4618      	mov	r0, r3
 80073b4:	f7fe fd8e 	bl	8005ed4 <LL_ADC_SetOffsetState>
    }

    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated only when ADC is disabled:                */
    /*  - Single or differential mode                                           */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 80073b8:	687b      	ldr	r3, [r7, #4]
 80073ba:	681b      	ldr	r3, [r3, #0]
 80073bc:	4618      	mov	r0, r3
 80073be:	f7fe ff74 	bl	80062aa <LL_ADC_IsEnabled>
 80073c2:	4603      	mov	r3, r0
 80073c4:	2b00      	cmp	r3, #0
 80073c6:	f040 813d 	bne.w	8007644 <HAL_ADC_ConfigChannel+0x6b4>
    {
      /* Set mode single-ended or differential input of the selected ADC channel */
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
 80073ca:	687b      	ldr	r3, [r7, #4]
 80073cc:	6818      	ldr	r0, [r3, #0]
 80073ce:	683b      	ldr	r3, [r7, #0]
 80073d0:	6819      	ldr	r1, [r3, #0]
 80073d2:	683b      	ldr	r3, [r7, #0]
 80073d4:	68db      	ldr	r3, [r3, #12]
 80073d6:	461a      	mov	r2, r3
 80073d8:	f7fe fe5e 	bl	8006098 <LL_ADC_SetChannelSingleDiff>

      /* Configuration of differential mode */
      if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
 80073dc:	683b      	ldr	r3, [r7, #0]
 80073de:	68db      	ldr	r3, [r3, #12]
 80073e0:	4aa2      	ldr	r2, [pc, #648]	; (800766c <HAL_ADC_ConfigChannel+0x6dc>)
 80073e2:	4293      	cmp	r3, r2
 80073e4:	f040 812e 	bne.w	8007644 <HAL_ADC_ConfigChannel+0x6b4>
      {
        /* Set sampling time of the selected ADC channel */
        /* Note: ADC channel number masked with value "0x1F" to ensure shift value within 32 bits range */
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 80073e8:	687b      	ldr	r3, [r7, #4]
 80073ea:	6818      	ldr	r0, [r3, #0]
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 80073ec:	683b      	ldr	r3, [r7, #0]
 80073ee:	681b      	ldr	r3, [r3, #0]
 80073f0:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80073f4:	2b00      	cmp	r3, #0
 80073f6:	d10b      	bne.n	8007410 <HAL_ADC_ConfigChannel+0x480>
 80073f8:	683b      	ldr	r3, [r7, #0]
 80073fa:	681b      	ldr	r3, [r3, #0]
 80073fc:	0e9b      	lsrs	r3, r3, #26
 80073fe:	3301      	adds	r3, #1
 8007400:	f003 031f 	and.w	r3, r3, #31
 8007404:	2b09      	cmp	r3, #9
 8007406:	bf94      	ite	ls
 8007408:	2301      	movls	r3, #1
 800740a:	2300      	movhi	r3, #0
 800740c:	b2db      	uxtb	r3, r3
 800740e:	e019      	b.n	8007444 <HAL_ADC_ConfigChannel+0x4b4>
 8007410:	683b      	ldr	r3, [r7, #0]
 8007412:	681b      	ldr	r3, [r3, #0]
 8007414:	65fb      	str	r3, [r7, #92]	; 0x5c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8007416:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007418:	fa93 f3a3 	rbit	r3, r3
 800741c:	65bb      	str	r3, [r7, #88]	; 0x58
  return result;
 800741e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007420:	663b      	str	r3, [r7, #96]	; 0x60
  if (value == 0U)
 8007422:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8007424:	2b00      	cmp	r3, #0
 8007426:	d101      	bne.n	800742c <HAL_ADC_ConfigChannel+0x49c>
    return 32U;
 8007428:	2320      	movs	r3, #32
 800742a:	e003      	b.n	8007434 <HAL_ADC_ConfigChannel+0x4a4>
  return __builtin_clz(value);
 800742c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800742e:	fab3 f383 	clz	r3, r3
 8007432:	b2db      	uxtb	r3, r3
 8007434:	3301      	adds	r3, #1
 8007436:	f003 031f 	and.w	r3, r3, #31
 800743a:	2b09      	cmp	r3, #9
 800743c:	bf94      	ite	ls
 800743e:	2301      	movls	r3, #1
 8007440:	2300      	movhi	r3, #0
 8007442:	b2db      	uxtb	r3, r3
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8007444:	2b00      	cmp	r3, #0
 8007446:	d079      	beq.n	800753c <HAL_ADC_ConfigChannel+0x5ac>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8007448:	683b      	ldr	r3, [r7, #0]
 800744a:	681b      	ldr	r3, [r3, #0]
 800744c:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8007450:	2b00      	cmp	r3, #0
 8007452:	d107      	bne.n	8007464 <HAL_ADC_ConfigChannel+0x4d4>
 8007454:	683b      	ldr	r3, [r7, #0]
 8007456:	681b      	ldr	r3, [r3, #0]
 8007458:	0e9b      	lsrs	r3, r3, #26
 800745a:	3301      	adds	r3, #1
 800745c:	069b      	lsls	r3, r3, #26
 800745e:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 8007462:	e015      	b.n	8007490 <HAL_ADC_ConfigChannel+0x500>
 8007464:	683b      	ldr	r3, [r7, #0]
 8007466:	681b      	ldr	r3, [r3, #0]
 8007468:	653b      	str	r3, [r7, #80]	; 0x50
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800746a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800746c:	fa93 f3a3 	rbit	r3, r3
 8007470:	64fb      	str	r3, [r7, #76]	; 0x4c
  return result;
 8007472:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007474:	657b      	str	r3, [r7, #84]	; 0x54
  if (value == 0U)
 8007476:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8007478:	2b00      	cmp	r3, #0
 800747a:	d101      	bne.n	8007480 <HAL_ADC_ConfigChannel+0x4f0>
    return 32U;
 800747c:	2320      	movs	r3, #32
 800747e:	e003      	b.n	8007488 <HAL_ADC_ConfigChannel+0x4f8>
  return __builtin_clz(value);
 8007480:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8007482:	fab3 f383 	clz	r3, r3
 8007486:	b2db      	uxtb	r3, r3
 8007488:	3301      	adds	r3, #1
 800748a:	069b      	lsls	r3, r3, #26
 800748c:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 8007490:	683b      	ldr	r3, [r7, #0]
 8007492:	681b      	ldr	r3, [r3, #0]
 8007494:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8007498:	2b00      	cmp	r3, #0
 800749a:	d109      	bne.n	80074b0 <HAL_ADC_ConfigChannel+0x520>
 800749c:	683b      	ldr	r3, [r7, #0]
 800749e:	681b      	ldr	r3, [r3, #0]
 80074a0:	0e9b      	lsrs	r3, r3, #26
 80074a2:	3301      	adds	r3, #1
 80074a4:	f003 031f 	and.w	r3, r3, #31
 80074a8:	2101      	movs	r1, #1
 80074aa:	fa01 f303 	lsl.w	r3, r1, r3
 80074ae:	e017      	b.n	80074e0 <HAL_ADC_ConfigChannel+0x550>
 80074b0:	683b      	ldr	r3, [r7, #0]
 80074b2:	681b      	ldr	r3, [r3, #0]
 80074b4:	647b      	str	r3, [r7, #68]	; 0x44
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80074b6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80074b8:	fa93 f3a3 	rbit	r3, r3
 80074bc:	643b      	str	r3, [r7, #64]	; 0x40
  return result;
 80074be:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80074c0:	64bb      	str	r3, [r7, #72]	; 0x48
  if (value == 0U)
 80074c2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80074c4:	2b00      	cmp	r3, #0
 80074c6:	d101      	bne.n	80074cc <HAL_ADC_ConfigChannel+0x53c>
    return 32U;
 80074c8:	2320      	movs	r3, #32
 80074ca:	e003      	b.n	80074d4 <HAL_ADC_ConfigChannel+0x544>
  return __builtin_clz(value);
 80074cc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80074ce:	fab3 f383 	clz	r3, r3
 80074d2:	b2db      	uxtb	r3, r3
 80074d4:	3301      	adds	r3, #1
 80074d6:	f003 031f 	and.w	r3, r3, #31
 80074da:	2101      	movs	r1, #1
 80074dc:	fa01 f303 	lsl.w	r3, r1, r3
 80074e0:	ea42 0103 	orr.w	r1, r2, r3
 80074e4:	683b      	ldr	r3, [r7, #0]
 80074e6:	681b      	ldr	r3, [r3, #0]
 80074e8:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80074ec:	2b00      	cmp	r3, #0
 80074ee:	d10a      	bne.n	8007506 <HAL_ADC_ConfigChannel+0x576>
 80074f0:	683b      	ldr	r3, [r7, #0]
 80074f2:	681b      	ldr	r3, [r3, #0]
 80074f4:	0e9b      	lsrs	r3, r3, #26
 80074f6:	3301      	adds	r3, #1
 80074f8:	f003 021f 	and.w	r2, r3, #31
 80074fc:	4613      	mov	r3, r2
 80074fe:	005b      	lsls	r3, r3, #1
 8007500:	4413      	add	r3, r2
 8007502:	051b      	lsls	r3, r3, #20
 8007504:	e018      	b.n	8007538 <HAL_ADC_ConfigChannel+0x5a8>
 8007506:	683b      	ldr	r3, [r7, #0]
 8007508:	681b      	ldr	r3, [r3, #0]
 800750a:	63bb      	str	r3, [r7, #56]	; 0x38
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800750c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800750e:	fa93 f3a3 	rbit	r3, r3
 8007512:	637b      	str	r3, [r7, #52]	; 0x34
  return result;
 8007514:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007516:	63fb      	str	r3, [r7, #60]	; 0x3c
  if (value == 0U)
 8007518:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800751a:	2b00      	cmp	r3, #0
 800751c:	d101      	bne.n	8007522 <HAL_ADC_ConfigChannel+0x592>
    return 32U;
 800751e:	2320      	movs	r3, #32
 8007520:	e003      	b.n	800752a <HAL_ADC_ConfigChannel+0x59a>
  return __builtin_clz(value);
 8007522:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007524:	fab3 f383 	clz	r3, r3
 8007528:	b2db      	uxtb	r3, r3
 800752a:	3301      	adds	r3, #1
 800752c:	f003 021f 	and.w	r2, r3, #31
 8007530:	4613      	mov	r3, r2
 8007532:	005b      	lsls	r3, r3, #1
 8007534:	4413      	add	r3, r2
 8007536:	051b      	lsls	r3, r3, #20
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8007538:	430b      	orrs	r3, r1
 800753a:	e07e      	b.n	800763a <HAL_ADC_ConfigChannel+0x6aa>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 800753c:	683b      	ldr	r3, [r7, #0]
 800753e:	681b      	ldr	r3, [r3, #0]
 8007540:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8007544:	2b00      	cmp	r3, #0
 8007546:	d107      	bne.n	8007558 <HAL_ADC_ConfigChannel+0x5c8>
 8007548:	683b      	ldr	r3, [r7, #0]
 800754a:	681b      	ldr	r3, [r3, #0]
 800754c:	0e9b      	lsrs	r3, r3, #26
 800754e:	3301      	adds	r3, #1
 8007550:	069b      	lsls	r3, r3, #26
 8007552:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 8007556:	e015      	b.n	8007584 <HAL_ADC_ConfigChannel+0x5f4>
 8007558:	683b      	ldr	r3, [r7, #0]
 800755a:	681b      	ldr	r3, [r3, #0]
 800755c:	62fb      	str	r3, [r7, #44]	; 0x2c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800755e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007560:	fa93 f3a3 	rbit	r3, r3
 8007564:	62bb      	str	r3, [r7, #40]	; 0x28
  return result;
 8007566:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007568:	633b      	str	r3, [r7, #48]	; 0x30
  if (value == 0U)
 800756a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800756c:	2b00      	cmp	r3, #0
 800756e:	d101      	bne.n	8007574 <HAL_ADC_ConfigChannel+0x5e4>
    return 32U;
 8007570:	2320      	movs	r3, #32
 8007572:	e003      	b.n	800757c <HAL_ADC_ConfigChannel+0x5ec>
  return __builtin_clz(value);
 8007574:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007576:	fab3 f383 	clz	r3, r3
 800757a:	b2db      	uxtb	r3, r3
 800757c:	3301      	adds	r3, #1
 800757e:	069b      	lsls	r3, r3, #26
 8007580:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 8007584:	683b      	ldr	r3, [r7, #0]
 8007586:	681b      	ldr	r3, [r3, #0]
 8007588:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800758c:	2b00      	cmp	r3, #0
 800758e:	d109      	bne.n	80075a4 <HAL_ADC_ConfigChannel+0x614>
 8007590:	683b      	ldr	r3, [r7, #0]
 8007592:	681b      	ldr	r3, [r3, #0]
 8007594:	0e9b      	lsrs	r3, r3, #26
 8007596:	3301      	adds	r3, #1
 8007598:	f003 031f 	and.w	r3, r3, #31
 800759c:	2101      	movs	r1, #1
 800759e:	fa01 f303 	lsl.w	r3, r1, r3
 80075a2:	e017      	b.n	80075d4 <HAL_ADC_ConfigChannel+0x644>
 80075a4:	683b      	ldr	r3, [r7, #0]
 80075a6:	681b      	ldr	r3, [r3, #0]
 80075a8:	623b      	str	r3, [r7, #32]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80075aa:	6a3b      	ldr	r3, [r7, #32]
 80075ac:	fa93 f3a3 	rbit	r3, r3
 80075b0:	61fb      	str	r3, [r7, #28]
  return result;
 80075b2:	69fb      	ldr	r3, [r7, #28]
 80075b4:	627b      	str	r3, [r7, #36]	; 0x24
  if (value == 0U)
 80075b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80075b8:	2b00      	cmp	r3, #0
 80075ba:	d101      	bne.n	80075c0 <HAL_ADC_ConfigChannel+0x630>
    return 32U;
 80075bc:	2320      	movs	r3, #32
 80075be:	e003      	b.n	80075c8 <HAL_ADC_ConfigChannel+0x638>
  return __builtin_clz(value);
 80075c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80075c2:	fab3 f383 	clz	r3, r3
 80075c6:	b2db      	uxtb	r3, r3
 80075c8:	3301      	adds	r3, #1
 80075ca:	f003 031f 	and.w	r3, r3, #31
 80075ce:	2101      	movs	r1, #1
 80075d0:	fa01 f303 	lsl.w	r3, r1, r3
 80075d4:	ea42 0103 	orr.w	r1, r2, r3
 80075d8:	683b      	ldr	r3, [r7, #0]
 80075da:	681b      	ldr	r3, [r3, #0]
 80075dc:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80075e0:	2b00      	cmp	r3, #0
 80075e2:	d10d      	bne.n	8007600 <HAL_ADC_ConfigChannel+0x670>
 80075e4:	683b      	ldr	r3, [r7, #0]
 80075e6:	681b      	ldr	r3, [r3, #0]
 80075e8:	0e9b      	lsrs	r3, r3, #26
 80075ea:	3301      	adds	r3, #1
 80075ec:	f003 021f 	and.w	r2, r3, #31
 80075f0:	4613      	mov	r3, r2
 80075f2:	005b      	lsls	r3, r3, #1
 80075f4:	4413      	add	r3, r2
 80075f6:	3b1e      	subs	r3, #30
 80075f8:	051b      	lsls	r3, r3, #20
 80075fa:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 80075fe:	e01b      	b.n	8007638 <HAL_ADC_ConfigChannel+0x6a8>
 8007600:	683b      	ldr	r3, [r7, #0]
 8007602:	681b      	ldr	r3, [r3, #0]
 8007604:	617b      	str	r3, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8007606:	697b      	ldr	r3, [r7, #20]
 8007608:	fa93 f3a3 	rbit	r3, r3
 800760c:	613b      	str	r3, [r7, #16]
  return result;
 800760e:	693b      	ldr	r3, [r7, #16]
 8007610:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
 8007612:	69bb      	ldr	r3, [r7, #24]
 8007614:	2b00      	cmp	r3, #0
 8007616:	d101      	bne.n	800761c <HAL_ADC_ConfigChannel+0x68c>
    return 32U;
 8007618:	2320      	movs	r3, #32
 800761a:	e003      	b.n	8007624 <HAL_ADC_ConfigChannel+0x694>
  return __builtin_clz(value);
 800761c:	69bb      	ldr	r3, [r7, #24]
 800761e:	fab3 f383 	clz	r3, r3
 8007622:	b2db      	uxtb	r3, r3
 8007624:	3301      	adds	r3, #1
 8007626:	f003 021f 	and.w	r2, r3, #31
 800762a:	4613      	mov	r3, r2
 800762c:	005b      	lsls	r3, r3, #1
 800762e:	4413      	add	r3, r2
 8007630:	3b1e      	subs	r3, #30
 8007632:	051b      	lsls	r3, r3, #20
 8007634:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8007638:	430b      	orrs	r3, r1
 800763a:	683a      	ldr	r2, [r7, #0]
 800763c:	6892      	ldr	r2, [r2, #8]
 800763e:	4619      	mov	r1, r3
 8007640:	f7fe fcfe 	bl	8006040 <LL_ADC_SetChannelSamplingTime>
    /* If internal channel selected, enable dedicated internal buffers and    */
    /* paths.                                                                 */
    /* Note: these internal measurement paths can be disabled using           */
    /* HAL_ADC_DeInit().                                                      */

    if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 8007644:	683b      	ldr	r3, [r7, #0]
 8007646:	681a      	ldr	r2, [r3, #0]
 8007648:	4b09      	ldr	r3, [pc, #36]	; (8007670 <HAL_ADC_ConfigChannel+0x6e0>)
 800764a:	4013      	ands	r3, r2
 800764c:	2b00      	cmp	r3, #0
 800764e:	f000 80be 	beq.w	80077ce <HAL_ADC_ConfigChannel+0x83e>
    {
      tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8007652:	687b      	ldr	r3, [r7, #4]
 8007654:	681b      	ldr	r3, [r3, #0]
 8007656:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 800765a:	d004      	beq.n	8007666 <HAL_ADC_ConfigChannel+0x6d6>
 800765c:	687b      	ldr	r3, [r7, #4]
 800765e:	681b      	ldr	r3, [r3, #0]
 8007660:	4a04      	ldr	r2, [pc, #16]	; (8007674 <HAL_ADC_ConfigChannel+0x6e4>)
 8007662:	4293      	cmp	r3, r2
 8007664:	d10a      	bne.n	800767c <HAL_ADC_ConfigChannel+0x6ec>
 8007666:	4b04      	ldr	r3, [pc, #16]	; (8007678 <HAL_ADC_ConfigChannel+0x6e8>)
 8007668:	e009      	b.n	800767e <HAL_ADC_ConfigChannel+0x6ee>
 800766a:	bf00      	nop
 800766c:	407f0000 	.word	0x407f0000
 8007670:	80080000 	.word	0x80080000
 8007674:	50000100 	.word	0x50000100
 8007678:	50000300 	.word	0x50000300
 800767c:	4b59      	ldr	r3, [pc, #356]	; (80077e4 <HAL_ADC_ConfigChannel+0x854>)
 800767e:	4618      	mov	r0, r3
 8007680:	f7fe fbe0 	bl	8005e44 <LL_ADC_GetCommonPathInternalCh>
 8007684:	f8c7 00c4 	str.w	r0, [r7, #196]	; 0xc4

      /* If the requested internal measurement path has already been enabled, */
      /* bypass the configuration processing.                                 */
      if (((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR_ADC1) || (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR_ADC5))
 8007688:	683b      	ldr	r3, [r7, #0]
 800768a:	681b      	ldr	r3, [r3, #0]
 800768c:	4a56      	ldr	r2, [pc, #344]	; (80077e8 <HAL_ADC_ConfigChannel+0x858>)
 800768e:	4293      	cmp	r3, r2
 8007690:	d004      	beq.n	800769c <HAL_ADC_ConfigChannel+0x70c>
 8007692:	683b      	ldr	r3, [r7, #0]
 8007694:	681b      	ldr	r3, [r3, #0]
 8007696:	4a55      	ldr	r2, [pc, #340]	; (80077ec <HAL_ADC_ConfigChannel+0x85c>)
 8007698:	4293      	cmp	r3, r2
 800769a:	d13a      	bne.n	8007712 <HAL_ADC_ConfigChannel+0x782>
          && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 800769c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 80076a0:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 80076a4:	2b00      	cmp	r3, #0
 80076a6:	d134      	bne.n	8007712 <HAL_ADC_ConfigChannel+0x782>
      {
        if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 80076a8:	687b      	ldr	r3, [r7, #4]
 80076aa:	681b      	ldr	r3, [r3, #0]
 80076ac:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80076b0:	d005      	beq.n	80076be <HAL_ADC_ConfigChannel+0x72e>
 80076b2:	687b      	ldr	r3, [r7, #4]
 80076b4:	681b      	ldr	r3, [r3, #0]
 80076b6:	4a4e      	ldr	r2, [pc, #312]	; (80077f0 <HAL_ADC_ConfigChannel+0x860>)
 80076b8:	4293      	cmp	r3, r2
 80076ba:	f040 8085 	bne.w	80077c8 <HAL_ADC_ConfigChannel+0x838>
        {
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 80076be:	687b      	ldr	r3, [r7, #4]
 80076c0:	681b      	ldr	r3, [r3, #0]
 80076c2:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80076c6:	d004      	beq.n	80076d2 <HAL_ADC_ConfigChannel+0x742>
 80076c8:	687b      	ldr	r3, [r7, #4]
 80076ca:	681b      	ldr	r3, [r3, #0]
 80076cc:	4a49      	ldr	r2, [pc, #292]	; (80077f4 <HAL_ADC_ConfigChannel+0x864>)
 80076ce:	4293      	cmp	r3, r2
 80076d0:	d101      	bne.n	80076d6 <HAL_ADC_ConfigChannel+0x746>
 80076d2:	4a49      	ldr	r2, [pc, #292]	; (80077f8 <HAL_ADC_ConfigChannel+0x868>)
 80076d4:	e000      	b.n	80076d8 <HAL_ADC_ConfigChannel+0x748>
 80076d6:	4a43      	ldr	r2, [pc, #268]	; (80077e4 <HAL_ADC_ConfigChannel+0x854>)
 80076d8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 80076dc:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80076e0:	4619      	mov	r1, r3
 80076e2:	4610      	mov	r0, r2
 80076e4:	f7fe fb9b 	bl	8005e1e <LL_ADC_SetCommonPathInternalCh>
          /* Delay for temperature sensor stabilization time */
          /* Wait loop initialization and execution */
          /* Note: Variable divided by 2 to compensate partially              */
          /*       CPU processing cycles, scaling in us split to not          */
          /*       exceed 32 bits register capacity and handle low frequency. */
          wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 80076e8:	4b44      	ldr	r3, [pc, #272]	; (80077fc <HAL_ADC_ConfigChannel+0x86c>)
 80076ea:	681b      	ldr	r3, [r3, #0]
 80076ec:	099b      	lsrs	r3, r3, #6
 80076ee:	4a44      	ldr	r2, [pc, #272]	; (8007800 <HAL_ADC_ConfigChannel+0x870>)
 80076f0:	fba2 2303 	umull	r2, r3, r2, r3
 80076f4:	099b      	lsrs	r3, r3, #6
 80076f6:	1c5a      	adds	r2, r3, #1
 80076f8:	4613      	mov	r3, r2
 80076fa:	005b      	lsls	r3, r3, #1
 80076fc:	4413      	add	r3, r2
 80076fe:	009b      	lsls	r3, r3, #2
 8007700:	60fb      	str	r3, [r7, #12]
          while (wait_loop_index != 0UL)
 8007702:	e002      	b.n	800770a <HAL_ADC_ConfigChannel+0x77a>
          {
            wait_loop_index--;
 8007704:	68fb      	ldr	r3, [r7, #12]
 8007706:	3b01      	subs	r3, #1
 8007708:	60fb      	str	r3, [r7, #12]
          while (wait_loop_index != 0UL)
 800770a:	68fb      	ldr	r3, [r7, #12]
 800770c:	2b00      	cmp	r3, #0
 800770e:	d1f9      	bne.n	8007704 <HAL_ADC_ConfigChannel+0x774>
        if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 8007710:	e05a      	b.n	80077c8 <HAL_ADC_ConfigChannel+0x838>
          }
        }
      }
      else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 8007712:	683b      	ldr	r3, [r7, #0]
 8007714:	681b      	ldr	r3, [r3, #0]
 8007716:	4a3b      	ldr	r2, [pc, #236]	; (8007804 <HAL_ADC_ConfigChannel+0x874>)
 8007718:	4293      	cmp	r3, r2
 800771a:	d125      	bne.n	8007768 <HAL_ADC_ConfigChannel+0x7d8>
 800771c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8007720:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8007724:	2b00      	cmp	r3, #0
 8007726:	d11f      	bne.n	8007768 <HAL_ADC_ConfigChannel+0x7d8>
      {
        if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 8007728:	687b      	ldr	r3, [r7, #4]
 800772a:	681b      	ldr	r3, [r3, #0]
 800772c:	4a31      	ldr	r2, [pc, #196]	; (80077f4 <HAL_ADC_ConfigChannel+0x864>)
 800772e:	4293      	cmp	r3, r2
 8007730:	d104      	bne.n	800773c <HAL_ADC_ConfigChannel+0x7ac>
 8007732:	687b      	ldr	r3, [r7, #4]
 8007734:	681b      	ldr	r3, [r3, #0]
 8007736:	4a34      	ldr	r2, [pc, #208]	; (8007808 <HAL_ADC_ConfigChannel+0x878>)
 8007738:	4293      	cmp	r3, r2
 800773a:	d047      	beq.n	80077cc <HAL_ADC_ConfigChannel+0x83c>
        {
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 800773c:	687b      	ldr	r3, [r7, #4]
 800773e:	681b      	ldr	r3, [r3, #0]
 8007740:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8007744:	d004      	beq.n	8007750 <HAL_ADC_ConfigChannel+0x7c0>
 8007746:	687b      	ldr	r3, [r7, #4]
 8007748:	681b      	ldr	r3, [r3, #0]
 800774a:	4a2a      	ldr	r2, [pc, #168]	; (80077f4 <HAL_ADC_ConfigChannel+0x864>)
 800774c:	4293      	cmp	r3, r2
 800774e:	d101      	bne.n	8007754 <HAL_ADC_ConfigChannel+0x7c4>
 8007750:	4a29      	ldr	r2, [pc, #164]	; (80077f8 <HAL_ADC_ConfigChannel+0x868>)
 8007752:	e000      	b.n	8007756 <HAL_ADC_ConfigChannel+0x7c6>
 8007754:	4a23      	ldr	r2, [pc, #140]	; (80077e4 <HAL_ADC_ConfigChannel+0x854>)
 8007756:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800775a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800775e:	4619      	mov	r1, r3
 8007760:	4610      	mov	r0, r2
 8007762:	f7fe fb5c 	bl	8005e1e <LL_ADC_SetCommonPathInternalCh>
        if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 8007766:	e031      	b.n	80077cc <HAL_ADC_ConfigChannel+0x83c>
                                         LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
        }
      }
      else if ((sConfig->Channel == ADC_CHANNEL_VREFINT)
 8007768:	683b      	ldr	r3, [r7, #0]
 800776a:	681b      	ldr	r3, [r3, #0]
 800776c:	4a27      	ldr	r2, [pc, #156]	; (800780c <HAL_ADC_ConfigChannel+0x87c>)
 800776e:	4293      	cmp	r3, r2
 8007770:	d12d      	bne.n	80077ce <HAL_ADC_ConfigChannel+0x83e>
               && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 8007772:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8007776:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800777a:	2b00      	cmp	r3, #0
 800777c:	d127      	bne.n	80077ce <HAL_ADC_ConfigChannel+0x83e>
      {
        if (ADC_VREFINT_INSTANCE(hadc))
 800777e:	687b      	ldr	r3, [r7, #4]
 8007780:	681b      	ldr	r3, [r3, #0]
 8007782:	4a1c      	ldr	r2, [pc, #112]	; (80077f4 <HAL_ADC_ConfigChannel+0x864>)
 8007784:	4293      	cmp	r3, r2
 8007786:	d022      	beq.n	80077ce <HAL_ADC_ConfigChannel+0x83e>
        {
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8007788:	687b      	ldr	r3, [r7, #4]
 800778a:	681b      	ldr	r3, [r3, #0]
 800778c:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8007790:	d004      	beq.n	800779c <HAL_ADC_ConfigChannel+0x80c>
 8007792:	687b      	ldr	r3, [r7, #4]
 8007794:	681b      	ldr	r3, [r3, #0]
 8007796:	4a17      	ldr	r2, [pc, #92]	; (80077f4 <HAL_ADC_ConfigChannel+0x864>)
 8007798:	4293      	cmp	r3, r2
 800779a:	d101      	bne.n	80077a0 <HAL_ADC_ConfigChannel+0x810>
 800779c:	4a16      	ldr	r2, [pc, #88]	; (80077f8 <HAL_ADC_ConfigChannel+0x868>)
 800779e:	e000      	b.n	80077a2 <HAL_ADC_ConfigChannel+0x812>
 80077a0:	4a10      	ldr	r2, [pc, #64]	; (80077e4 <HAL_ADC_ConfigChannel+0x854>)
 80077a2:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 80077a6:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80077aa:	4619      	mov	r1, r3
 80077ac:	4610      	mov	r0, r2
 80077ae:	f7fe fb36 	bl	8005e1e <LL_ADC_SetCommonPathInternalCh>
 80077b2:	e00c      	b.n	80077ce <HAL_ADC_ConfigChannel+0x83e>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80077b4:	687b      	ldr	r3, [r7, #4]
 80077b6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80077b8:	f043 0220 	orr.w	r2, r3, #32
 80077bc:	687b      	ldr	r3, [r7, #4]
 80077be:	65da      	str	r2, [r3, #92]	; 0x5c

    tmp_hal_status = HAL_ERROR;
 80077c0:	2301      	movs	r3, #1
 80077c2:	f887 30d7 	strb.w	r3, [r7, #215]	; 0xd7
 80077c6:	e002      	b.n	80077ce <HAL_ADC_ConfigChannel+0x83e>
        if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 80077c8:	bf00      	nop
 80077ca:	e000      	b.n	80077ce <HAL_ADC_ConfigChannel+0x83e>
        if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 80077cc:	bf00      	nop
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80077ce:	687b      	ldr	r3, [r7, #4]
 80077d0:	2200      	movs	r2, #0
 80077d2:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

  /* Return function status */
  return tmp_hal_status;
 80077d6:	f897 30d7 	ldrb.w	r3, [r7, #215]	; 0xd7
}
 80077da:	4618      	mov	r0, r3
 80077dc:	37d8      	adds	r7, #216	; 0xd8
 80077de:	46bd      	mov	sp, r7
 80077e0:	bd80      	pop	{r7, pc}
 80077e2:	bf00      	nop
 80077e4:	50000700 	.word	0x50000700
 80077e8:	c3210000 	.word	0xc3210000
 80077ec:	90c00010 	.word	0x90c00010
 80077f0:	50000600 	.word	0x50000600
 80077f4:	50000100 	.word	0x50000100
 80077f8:	50000300 	.word	0x50000300
 80077fc:	20000008 	.word	0x20000008
 8007800:	053e2d63 	.word	0x053e2d63
 8007804:	c7520000 	.word	0xc7520000
 8007808:	50000500 	.word	0x50000500
 800780c:	cb840000 	.word	0xcb840000

08007810 <HAL_ADC_AnalogWDGConfig>:
  * @param hadc ADC handle
  * @param AnalogWDGConfig Structure of ADC analog watchdog configuration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef *hadc, ADC_AnalogWDGConfTypeDef *AnalogWDGConfig)
{
 8007810:	b580      	push	{r7, lr}
 8007812:	b08e      	sub	sp, #56	; 0x38
 8007814:	af00      	add	r7, sp, #0
 8007816:	6078      	str	r0, [r7, #4]
 8007818:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800781a:	2300      	movs	r3, #0
 800781c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  assert_param(IS_ADC_ANALOG_WATCHDOG_NUMBER(AnalogWDGConfig->WatchdogNumber));
  assert_param(IS_ADC_ANALOG_WATCHDOG_MODE(AnalogWDGConfig->WatchdogMode));
  assert_param(IS_ADC_ANALOG_WATCHDOG_FILTERING_MODE(AnalogWDGConfig->FilteringConfig));
  assert_param(IS_FUNCTIONAL_STATE(AnalogWDGConfig->ITMode));

  if ((AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REG)     ||
 8007820:	683b      	ldr	r3, [r7, #0]
 8007822:	685b      	ldr	r3, [r3, #4]
 8007824:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 8007828:	d003      	beq.n	8007832 <HAL_ADC_AnalogWDGConfig+0x22>
      (AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_INJEC)   ||
 800782a:	683b      	ldr	r3, [r7, #0]
 800782c:	685b      	ldr	r3, [r3, #4]
  if ((AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REG)     ||
 800782e:	f1b3 7fa0 	cmp.w	r3, #20971520	; 0x1400000
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), AnalogWDGConfig->HighThreshold));
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), AnalogWDGConfig->LowThreshold));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8007832:	687b      	ldr	r3, [r7, #4]
 8007834:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 8007838:	2b01      	cmp	r3, #1
 800783a:	d101      	bne.n	8007840 <HAL_ADC_AnalogWDGConfig+0x30>
 800783c:	2302      	movs	r3, #2
 800783e:	e1ea      	b.n	8007c16 <HAL_ADC_AnalogWDGConfig+0x406>
 8007840:	687b      	ldr	r3, [r7, #4]
 8007842:	2201      	movs	r2, #1
 8007844:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on ADC groups regular and injected:                  */
  /*  - Analog watchdog channels                                              */
  tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8007848:	687b      	ldr	r3, [r7, #4]
 800784a:	681b      	ldr	r3, [r3, #0]
 800784c:	4618      	mov	r0, r3
 800784e:	f7fe fd7a 	bl	8006346 <LL_ADC_REG_IsConversionOngoing>
 8007852:	62b8      	str	r0, [r7, #40]	; 0x28
  tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 8007854:	687b      	ldr	r3, [r7, #4]
 8007856:	681b      	ldr	r3, [r3, #0]
 8007858:	4618      	mov	r0, r3
 800785a:	f7fe fd9b 	bl	8006394 <LL_ADC_INJ_IsConversionOngoing>
 800785e:	6278      	str	r0, [r7, #36]	; 0x24
  if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 8007860:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007862:	2b00      	cmp	r3, #0
 8007864:	f040 8175 	bne.w	8007b52 <HAL_ADC_AnalogWDGConfig+0x342>
      && (tmp_adc_is_conversion_on_going_injected == 0UL)
 8007868:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800786a:	2b00      	cmp	r3, #0
 800786c:	f040 8171 	bne.w	8007b52 <HAL_ADC_AnalogWDGConfig+0x342>
     )
  {
    /* Analog watchdog configuration */
    if (AnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_1)
 8007870:	683b      	ldr	r3, [r7, #0]
 8007872:	681b      	ldr	r3, [r3, #0]
 8007874:	4a90      	ldr	r2, [pc, #576]	; (8007ab8 <HAL_ADC_AnalogWDGConfig+0x2a8>)
 8007876:	4293      	cmp	r3, r2
 8007878:	f040 808d 	bne.w	8007996 <HAL_ADC_AnalogWDGConfig+0x186>
    {
      /* Configuration of analog watchdog:                                    */
      /*  - Set the analog watchdog enable mode: one or overall group of      */
      /*    channels, on groups regular and-or injected.                      */
      switch (AnalogWDGConfig->WatchdogMode)
 800787c:	683b      	ldr	r3, [r7, #0]
 800787e:	685b      	ldr	r3, [r3, #4]
 8007880:	f1b3 7fe0 	cmp.w	r3, #29360128	; 0x1c00000
 8007884:	d034      	beq.n	80078f0 <HAL_ADC_AnalogWDGConfig+0xe0>
 8007886:	f1b3 7fe0 	cmp.w	r3, #29360128	; 0x1c00000
 800788a:	d856      	bhi.n	800793a <HAL_ADC_AnalogWDGConfig+0x12a>
 800788c:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 8007890:	d04b      	beq.n	800792a <HAL_ADC_AnalogWDGConfig+0x11a>
 8007892:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 8007896:	d850      	bhi.n	800793a <HAL_ADC_AnalogWDGConfig+0x12a>
 8007898:	f1b3 7fa0 	cmp.w	r3, #20971520	; 0x1400000
 800789c:	d01b      	beq.n	80078d6 <HAL_ADC_AnalogWDGConfig+0xc6>
 800789e:	f1b3 7fa0 	cmp.w	r3, #20971520	; 0x1400000
 80078a2:	d84a      	bhi.n	800793a <HAL_ADC_AnalogWDGConfig+0x12a>
 80078a4:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80078a8:	d037      	beq.n	800791a <HAL_ADC_AnalogWDGConfig+0x10a>
 80078aa:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80078ae:	d844      	bhi.n	800793a <HAL_ADC_AnalogWDGConfig+0x12a>
 80078b0:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 80078b4:	d029      	beq.n	800790a <HAL_ADC_AnalogWDGConfig+0xfa>
 80078b6:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 80078ba:	d13e      	bne.n	800793a <HAL_ADC_AnalogWDGConfig+0x12a>
      {
        case ADC_ANALOGWATCHDOG_SINGLE_REG:
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, __LL_ADC_ANALOGWD_CHANNEL_GROUP(AnalogWDGConfig->Channel,
 80078bc:	687b      	ldr	r3, [r7, #4]
 80078be:	6818      	ldr	r0, [r3, #0]
 80078c0:	683b      	ldr	r3, [r7, #0]
 80078c2:	689b      	ldr	r3, [r3, #8]
 80078c4:	f023 737c 	bic.w	r3, r3, #66060288	; 0x3f00000
 80078c8:	f443 0340 	orr.w	r3, r3, #12582912	; 0xc00000
 80078cc:	461a      	mov	r2, r3
 80078ce:	497a      	ldr	r1, [pc, #488]	; (8007ab8 <HAL_ADC_AnalogWDGConfig+0x2a8>)
 80078d0:	f7fe fc0a 	bl	80060e8 <LL_ADC_SetAnalogWDMonitChannels>
                                          LL_ADC_GROUP_REGULAR));
          break;
 80078d4:	e039      	b.n	800794a <HAL_ADC_AnalogWDGConfig+0x13a>

        case ADC_ANALOGWATCHDOG_SINGLE_INJEC:
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, __LL_ADC_ANALOGWD_CHANNEL_GROUP(AnalogWDGConfig->Channel,
 80078d6:	687b      	ldr	r3, [r7, #4]
 80078d8:	6818      	ldr	r0, [r3, #0]
 80078da:	683b      	ldr	r3, [r7, #0]
 80078dc:	689b      	ldr	r3, [r3, #8]
 80078de:	f023 737c 	bic.w	r3, r3, #66060288	; 0x3f00000
 80078e2:	f043 73a0 	orr.w	r3, r3, #20971520	; 0x1400000
 80078e6:	461a      	mov	r2, r3
 80078e8:	4973      	ldr	r1, [pc, #460]	; (8007ab8 <HAL_ADC_AnalogWDGConfig+0x2a8>)
 80078ea:	f7fe fbfd 	bl	80060e8 <LL_ADC_SetAnalogWDMonitChannels>
                                          LL_ADC_GROUP_INJECTED));
          break;
 80078ee:	e02c      	b.n	800794a <HAL_ADC_AnalogWDGConfig+0x13a>

        case ADC_ANALOGWATCHDOG_SINGLE_REGINJEC:
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, __LL_ADC_ANALOGWD_CHANNEL_GROUP(AnalogWDGConfig->Channel,
 80078f0:	687b      	ldr	r3, [r7, #4]
 80078f2:	6818      	ldr	r0, [r3, #0]
 80078f4:	683b      	ldr	r3, [r7, #0]
 80078f6:	689b      	ldr	r3, [r3, #8]
 80078f8:	f023 737c 	bic.w	r3, r3, #66060288	; 0x3f00000
 80078fc:	f043 73e0 	orr.w	r3, r3, #29360128	; 0x1c00000
 8007900:	461a      	mov	r2, r3
 8007902:	496d      	ldr	r1, [pc, #436]	; (8007ab8 <HAL_ADC_AnalogWDGConfig+0x2a8>)
 8007904:	f7fe fbf0 	bl	80060e8 <LL_ADC_SetAnalogWDMonitChannels>
                                          LL_ADC_GROUP_REGULAR_INJECTED));
          break;
 8007908:	e01f      	b.n	800794a <HAL_ADC_AnalogWDGConfig+0x13a>

        case ADC_ANALOGWATCHDOG_ALL_REG:
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, LL_ADC_AWD_ALL_CHANNELS_REG);
 800790a:	687b      	ldr	r3, [r7, #4]
 800790c:	681b      	ldr	r3, [r3, #0]
 800790e:	4a6b      	ldr	r2, [pc, #428]	; (8007abc <HAL_ADC_AnalogWDGConfig+0x2ac>)
 8007910:	4969      	ldr	r1, [pc, #420]	; (8007ab8 <HAL_ADC_AnalogWDGConfig+0x2a8>)
 8007912:	4618      	mov	r0, r3
 8007914:	f7fe fbe8 	bl	80060e8 <LL_ADC_SetAnalogWDMonitChannels>
          break;
 8007918:	e017      	b.n	800794a <HAL_ADC_AnalogWDGConfig+0x13a>

        case ADC_ANALOGWATCHDOG_ALL_INJEC:
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, LL_ADC_AWD_ALL_CHANNELS_INJ);
 800791a:	687b      	ldr	r3, [r7, #4]
 800791c:	681b      	ldr	r3, [r3, #0]
 800791e:	4a68      	ldr	r2, [pc, #416]	; (8007ac0 <HAL_ADC_AnalogWDGConfig+0x2b0>)
 8007920:	4965      	ldr	r1, [pc, #404]	; (8007ab8 <HAL_ADC_AnalogWDGConfig+0x2a8>)
 8007922:	4618      	mov	r0, r3
 8007924:	f7fe fbe0 	bl	80060e8 <LL_ADC_SetAnalogWDMonitChannels>
          break;
 8007928:	e00f      	b.n	800794a <HAL_ADC_AnalogWDGConfig+0x13a>

        case ADC_ANALOGWATCHDOG_ALL_REGINJEC:
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, LL_ADC_AWD_ALL_CHANNELS_REG_INJ);
 800792a:	687b      	ldr	r3, [r7, #4]
 800792c:	681b      	ldr	r3, [r3, #0]
 800792e:	4a65      	ldr	r2, [pc, #404]	; (8007ac4 <HAL_ADC_AnalogWDGConfig+0x2b4>)
 8007930:	4961      	ldr	r1, [pc, #388]	; (8007ab8 <HAL_ADC_AnalogWDGConfig+0x2a8>)
 8007932:	4618      	mov	r0, r3
 8007934:	f7fe fbd8 	bl	80060e8 <LL_ADC_SetAnalogWDMonitChannels>
          break;
 8007938:	e007      	b.n	800794a <HAL_ADC_AnalogWDGConfig+0x13a>

        default: /* ADC_ANALOGWATCHDOG_NONE */
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, LL_ADC_AWD_DISABLE);
 800793a:	687b      	ldr	r3, [r7, #4]
 800793c:	681b      	ldr	r3, [r3, #0]
 800793e:	2200      	movs	r2, #0
 8007940:	495d      	ldr	r1, [pc, #372]	; (8007ab8 <HAL_ADC_AnalogWDGConfig+0x2a8>)
 8007942:	4618      	mov	r0, r3
 8007944:	f7fe fbd0 	bl	80060e8 <LL_ADC_SetAnalogWDMonitChannels>
          break;
 8007948:	bf00      	nop
      }

      /* Set the filtering configuration */
      MODIFY_REG(hadc->Instance->TR1,
 800794a:	687b      	ldr	r3, [r7, #4]
 800794c:	681b      	ldr	r3, [r3, #0]
 800794e:	6a1b      	ldr	r3, [r3, #32]
 8007950:	f423 41e0 	bic.w	r1, r3, #28672	; 0x7000
 8007954:	683b      	ldr	r3, [r7, #0]
 8007956:	699a      	ldr	r2, [r3, #24]
 8007958:	687b      	ldr	r3, [r7, #4]
 800795a:	681b      	ldr	r3, [r3, #0]
 800795c:	430a      	orrs	r2, r1
 800795e:	621a      	str	r2, [r3, #32]
                 ADC_TR1_AWDFILT,
                 AnalogWDGConfig->FilteringConfig);

      /* Update state, clear previous result related to AWD1 */
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_AWD1);
 8007960:	687b      	ldr	r3, [r7, #4]
 8007962:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8007964:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8007968:	687b      	ldr	r3, [r7, #4]
 800796a:	65da      	str	r2, [r3, #92]	; 0x5c

      /* Clear flag ADC analog watchdog */
      /* Note: Flag cleared Clear the ADC Analog watchdog flag to be ready  */
      /* to use for HAL_ADC_IRQHandler() or HAL_ADC_PollForEvent()          */
      /* (in case left enabled by previous ADC operations).                 */
      LL_ADC_ClearFlag_AWD1(hadc->Instance);
 800796c:	687b      	ldr	r3, [r7, #4]
 800796e:	681b      	ldr	r3, [r3, #0]
 8007970:	4618      	mov	r0, r3
 8007972:	f7fe fd22 	bl	80063ba <LL_ADC_ClearFlag_AWD1>

      /* Configure ADC analog watchdog interrupt */
      if (AnalogWDGConfig->ITMode == ENABLE)
 8007976:	683b      	ldr	r3, [r7, #0]
 8007978:	7b1b      	ldrb	r3, [r3, #12]
 800797a:	2b01      	cmp	r3, #1
 800797c:	d105      	bne.n	800798a <HAL_ADC_AnalogWDGConfig+0x17a>
      {
        LL_ADC_EnableIT_AWD1(hadc->Instance);
 800797e:	687b      	ldr	r3, [r7, #4]
 8007980:	681b      	ldr	r3, [r3, #0]
 8007982:	4618      	mov	r0, r3
 8007984:	f7fe fd42 	bl	800640c <LL_ADC_EnableIT_AWD1>
 8007988:	e0e3      	b.n	8007b52 <HAL_ADC_AnalogWDGConfig+0x342>
      }
      else
      {
        LL_ADC_DisableIT_AWD1(hadc->Instance);
 800798a:	687b      	ldr	r3, [r7, #4]
 800798c:	681b      	ldr	r3, [r3, #0]
 800798e:	4618      	mov	r0, r3
 8007990:	f7fe fd6c 	bl	800646c <LL_ADC_DisableIT_AWD1>
 8007994:	e0dd      	b.n	8007b52 <HAL_ADC_AnalogWDGConfig+0x342>
      }
    }
    /* Case of ADC_ANALOGWATCHDOG_2 or ADC_ANALOGWATCHDOG_3 */
    else
    {
      switch (AnalogWDGConfig->WatchdogMode)
 8007996:	683b      	ldr	r3, [r7, #0]
 8007998:	685b      	ldr	r3, [r3, #4]
 800799a:	f1b3 7fe0 	cmp.w	r3, #29360128	; 0x1c00000
 800799e:	d01d      	beq.n	80079dc <HAL_ADC_AnalogWDGConfig+0x1cc>
 80079a0:	f1b3 7fe0 	cmp.w	r3, #29360128	; 0x1c00000
 80079a4:	f200 8092 	bhi.w	8007acc <HAL_ADC_AnalogWDGConfig+0x2bc>
 80079a8:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 80079ac:	d07b      	beq.n	8007aa6 <HAL_ADC_AnalogWDGConfig+0x296>
 80079ae:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 80079b2:	f200 808b 	bhi.w	8007acc <HAL_ADC_AnalogWDGConfig+0x2bc>
 80079b6:	f1b3 7fa0 	cmp.w	r3, #20971520	; 0x1400000
 80079ba:	d00f      	beq.n	80079dc <HAL_ADC_AnalogWDGConfig+0x1cc>
 80079bc:	f1b3 7fa0 	cmp.w	r3, #20971520	; 0x1400000
 80079c0:	f200 8084 	bhi.w	8007acc <HAL_ADC_AnalogWDGConfig+0x2bc>
 80079c4:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80079c8:	d06d      	beq.n	8007aa6 <HAL_ADC_AnalogWDGConfig+0x296>
 80079ca:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80079ce:	d87d      	bhi.n	8007acc <HAL_ADC_AnalogWDGConfig+0x2bc>
 80079d0:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 80079d4:	d067      	beq.n	8007aa6 <HAL_ADC_AnalogWDGConfig+0x296>
 80079d6:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 80079da:	d177      	bne.n	8007acc <HAL_ADC_AnalogWDGConfig+0x2bc>
        case ADC_ANALOGWATCHDOG_SINGLE_REG:
        case ADC_ANALOGWATCHDOG_SINGLE_INJEC:
        case ADC_ANALOGWATCHDOG_SINGLE_REGINJEC:
          /* Update AWD by bitfield to keep the possibility to monitor        */
          /* several channels by successive calls of this function.           */
          if (AnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_2)
 80079dc:	683b      	ldr	r3, [r7, #0]
 80079de:	681b      	ldr	r3, [r3, #0]
 80079e0:	4a39      	ldr	r2, [pc, #228]	; (8007ac8 <HAL_ADC_AnalogWDGConfig+0x2b8>)
 80079e2:	4293      	cmp	r3, r2
 80079e4:	d12f      	bne.n	8007a46 <HAL_ADC_AnalogWDGConfig+0x236>
          {
            SET_BIT(hadc->Instance->AWD2CR, (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB(AnalogWDGConfig->Channel) & 0x1FUL)));
 80079e6:	683b      	ldr	r3, [r7, #0]
 80079e8:	689b      	ldr	r3, [r3, #8]
 80079ea:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80079ee:	2b00      	cmp	r3, #0
 80079f0:	d108      	bne.n	8007a04 <HAL_ADC_AnalogWDGConfig+0x1f4>
 80079f2:	683b      	ldr	r3, [r7, #0]
 80079f4:	689b      	ldr	r3, [r3, #8]
 80079f6:	0e9b      	lsrs	r3, r3, #26
 80079f8:	f003 031f 	and.w	r3, r3, #31
 80079fc:	2201      	movs	r2, #1
 80079fe:	fa02 f303 	lsl.w	r3, r2, r3
 8007a02:	e016      	b.n	8007a32 <HAL_ADC_AnalogWDGConfig+0x222>
 8007a04:	683b      	ldr	r3, [r7, #0]
 8007a06:	689b      	ldr	r3, [r3, #8]
 8007a08:	61fb      	str	r3, [r7, #28]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8007a0a:	69fb      	ldr	r3, [r7, #28]
 8007a0c:	fa93 f3a3 	rbit	r3, r3
 8007a10:	61bb      	str	r3, [r7, #24]
  return result;
 8007a12:	69bb      	ldr	r3, [r7, #24]
 8007a14:	623b      	str	r3, [r7, #32]
  if (value == 0U)
 8007a16:	6a3b      	ldr	r3, [r7, #32]
 8007a18:	2b00      	cmp	r3, #0
 8007a1a:	d101      	bne.n	8007a20 <HAL_ADC_AnalogWDGConfig+0x210>
    return 32U;
 8007a1c:	2320      	movs	r3, #32
 8007a1e:	e003      	b.n	8007a28 <HAL_ADC_AnalogWDGConfig+0x218>
  return __builtin_clz(value);
 8007a20:	6a3b      	ldr	r3, [r7, #32]
 8007a22:	fab3 f383 	clz	r3, r3
 8007a26:	b2db      	uxtb	r3, r3
 8007a28:	f003 031f 	and.w	r3, r3, #31
 8007a2c:	2201      	movs	r2, #1
 8007a2e:	fa02 f303 	lsl.w	r3, r2, r3
 8007a32:	687a      	ldr	r2, [r7, #4]
 8007a34:	6812      	ldr	r2, [r2, #0]
 8007a36:	f8d2 10a0 	ldr.w	r1, [r2, #160]	; 0xa0
 8007a3a:	687a      	ldr	r2, [r7, #4]
 8007a3c:	6812      	ldr	r2, [r2, #0]
 8007a3e:	430b      	orrs	r3, r1
 8007a40:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
          }
          else
          {
            SET_BIT(hadc->Instance->AWD3CR, (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB(AnalogWDGConfig->Channel) & 0x1FUL)));
          }
          break;
 8007a44:	e04b      	b.n	8007ade <HAL_ADC_AnalogWDGConfig+0x2ce>
            SET_BIT(hadc->Instance->AWD3CR, (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB(AnalogWDGConfig->Channel) & 0x1FUL)));
 8007a46:	683b      	ldr	r3, [r7, #0]
 8007a48:	689b      	ldr	r3, [r3, #8]
 8007a4a:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8007a4e:	2b00      	cmp	r3, #0
 8007a50:	d108      	bne.n	8007a64 <HAL_ADC_AnalogWDGConfig+0x254>
 8007a52:	683b      	ldr	r3, [r7, #0]
 8007a54:	689b      	ldr	r3, [r3, #8]
 8007a56:	0e9b      	lsrs	r3, r3, #26
 8007a58:	f003 031f 	and.w	r3, r3, #31
 8007a5c:	2201      	movs	r2, #1
 8007a5e:	fa02 f303 	lsl.w	r3, r2, r3
 8007a62:	e016      	b.n	8007a92 <HAL_ADC_AnalogWDGConfig+0x282>
 8007a64:	683b      	ldr	r3, [r7, #0]
 8007a66:	689b      	ldr	r3, [r3, #8]
 8007a68:	613b      	str	r3, [r7, #16]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8007a6a:	693b      	ldr	r3, [r7, #16]
 8007a6c:	fa93 f3a3 	rbit	r3, r3
 8007a70:	60fb      	str	r3, [r7, #12]
  return result;
 8007a72:	68fb      	ldr	r3, [r7, #12]
 8007a74:	617b      	str	r3, [r7, #20]
  if (value == 0U)
 8007a76:	697b      	ldr	r3, [r7, #20]
 8007a78:	2b00      	cmp	r3, #0
 8007a7a:	d101      	bne.n	8007a80 <HAL_ADC_AnalogWDGConfig+0x270>
    return 32U;
 8007a7c:	2320      	movs	r3, #32
 8007a7e:	e003      	b.n	8007a88 <HAL_ADC_AnalogWDGConfig+0x278>
  return __builtin_clz(value);
 8007a80:	697b      	ldr	r3, [r7, #20]
 8007a82:	fab3 f383 	clz	r3, r3
 8007a86:	b2db      	uxtb	r3, r3
 8007a88:	f003 031f 	and.w	r3, r3, #31
 8007a8c:	2201      	movs	r2, #1
 8007a8e:	fa02 f303 	lsl.w	r3, r2, r3
 8007a92:	687a      	ldr	r2, [r7, #4]
 8007a94:	6812      	ldr	r2, [r2, #0]
 8007a96:	f8d2 10a4 	ldr.w	r1, [r2, #164]	; 0xa4
 8007a9a:	687a      	ldr	r2, [r7, #4]
 8007a9c:	6812      	ldr	r2, [r2, #0]
 8007a9e:	430b      	orrs	r3, r1
 8007aa0:	f8c2 30a4 	str.w	r3, [r2, #164]	; 0xa4
          break;
 8007aa4:	e01b      	b.n	8007ade <HAL_ADC_AnalogWDGConfig+0x2ce>

        case ADC_ANALOGWATCHDOG_ALL_REG:
        case ADC_ANALOGWATCHDOG_ALL_INJEC:
        case ADC_ANALOGWATCHDOG_ALL_REGINJEC:
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, AnalogWDGConfig->WatchdogNumber, LL_ADC_AWD_ALL_CHANNELS_REG_INJ);
 8007aa6:	687b      	ldr	r3, [r7, #4]
 8007aa8:	6818      	ldr	r0, [r3, #0]
 8007aaa:	683b      	ldr	r3, [r7, #0]
 8007aac:	681b      	ldr	r3, [r3, #0]
 8007aae:	4a05      	ldr	r2, [pc, #20]	; (8007ac4 <HAL_ADC_AnalogWDGConfig+0x2b4>)
 8007ab0:	4619      	mov	r1, r3
 8007ab2:	f7fe fb19 	bl	80060e8 <LL_ADC_SetAnalogWDMonitChannels>
          break;
 8007ab6:	e012      	b.n	8007ade <HAL_ADC_AnalogWDGConfig+0x2ce>
 8007ab8:	7dc00000 	.word	0x7dc00000
 8007abc:	0087ffff 	.word	0x0087ffff
 8007ac0:	0107ffff 	.word	0x0107ffff
 8007ac4:	0187ffff 	.word	0x0187ffff
 8007ac8:	0017ffff 	.word	0x0017ffff

        default: /* ADC_ANALOGWATCHDOG_NONE */
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, AnalogWDGConfig->WatchdogNumber, LL_ADC_AWD_DISABLE);
 8007acc:	687b      	ldr	r3, [r7, #4]
 8007ace:	6818      	ldr	r0, [r3, #0]
 8007ad0:	683b      	ldr	r3, [r7, #0]
 8007ad2:	681b      	ldr	r3, [r3, #0]
 8007ad4:	2200      	movs	r2, #0
 8007ad6:	4619      	mov	r1, r3
 8007ad8:	f7fe fb06 	bl	80060e8 <LL_ADC_SetAnalogWDMonitChannels>
          break;
 8007adc:	bf00      	nop
      }

      if (AnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_2)
 8007ade:	683b      	ldr	r3, [r7, #0]
 8007ae0:	681b      	ldr	r3, [r3, #0]
 8007ae2:	4a4f      	ldr	r2, [pc, #316]	; (8007c20 <HAL_ADC_AnalogWDGConfig+0x410>)
 8007ae4:	4293      	cmp	r3, r2
 8007ae6:	d11a      	bne.n	8007b1e <HAL_ADC_AnalogWDGConfig+0x30e>
      {
        /* Update state, clear previous result related to AWD2 */
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_AWD2);
 8007ae8:	687b      	ldr	r3, [r7, #4]
 8007aea:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8007aec:	f423 3200 	bic.w	r2, r3, #131072	; 0x20000
 8007af0:	687b      	ldr	r3, [r7, #4]
 8007af2:	65da      	str	r2, [r3, #92]	; 0x5c

        /* Clear flag ADC analog watchdog */
        /* Note: Flag cleared Clear the ADC Analog watchdog flag to be ready  */
        /* to use for HAL_ADC_IRQHandler() or HAL_ADC_PollForEvent()          */
        /* (in case left enabled by previous ADC operations).                 */
        LL_ADC_ClearFlag_AWD2(hadc->Instance);
 8007af4:	687b      	ldr	r3, [r7, #4]
 8007af6:	681b      	ldr	r3, [r3, #0]
 8007af8:	4618      	mov	r0, r3
 8007afa:	f7fe fc6b 	bl	80063d4 <LL_ADC_ClearFlag_AWD2>

        /* Configure ADC analog watchdog interrupt */
        if (AnalogWDGConfig->ITMode == ENABLE)
 8007afe:	683b      	ldr	r3, [r7, #0]
 8007b00:	7b1b      	ldrb	r3, [r3, #12]
 8007b02:	2b01      	cmp	r3, #1
 8007b04:	d105      	bne.n	8007b12 <HAL_ADC_AnalogWDGConfig+0x302>
        {
          LL_ADC_EnableIT_AWD2(hadc->Instance);
 8007b06:	687b      	ldr	r3, [r7, #4]
 8007b08:	681b      	ldr	r3, [r3, #0]
 8007b0a:	4618      	mov	r0, r3
 8007b0c:	f7fe fc8e 	bl	800642c <LL_ADC_EnableIT_AWD2>
 8007b10:	e01f      	b.n	8007b52 <HAL_ADC_AnalogWDGConfig+0x342>
        }
        else
        {
          LL_ADC_DisableIT_AWD2(hadc->Instance);
 8007b12:	687b      	ldr	r3, [r7, #4]
 8007b14:	681b      	ldr	r3, [r3, #0]
 8007b16:	4618      	mov	r0, r3
 8007b18:	f7fe fcb8 	bl	800648c <LL_ADC_DisableIT_AWD2>
 8007b1c:	e019      	b.n	8007b52 <HAL_ADC_AnalogWDGConfig+0x342>
      }
      /* (AnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_3) */
      else
      {
        /* Update state, clear previous result related to AWD3 */
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_AWD3);
 8007b1e:	687b      	ldr	r3, [r7, #4]
 8007b20:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8007b22:	f423 2280 	bic.w	r2, r3, #262144	; 0x40000
 8007b26:	687b      	ldr	r3, [r7, #4]
 8007b28:	65da      	str	r2, [r3, #92]	; 0x5c

        /* Clear flag ADC analog watchdog */
        /* Note: Flag cleared Clear the ADC Analog watchdog flag to be ready  */
        /* to use for HAL_ADC_IRQHandler() or HAL_ADC_PollForEvent()          */
        /* (in case left enabled by previous ADC operations).                 */
        LL_ADC_ClearFlag_AWD3(hadc->Instance);
 8007b2a:	687b      	ldr	r3, [r7, #4]
 8007b2c:	681b      	ldr	r3, [r3, #0]
 8007b2e:	4618      	mov	r0, r3
 8007b30:	f7fe fc5e 	bl	80063f0 <LL_ADC_ClearFlag_AWD3>

        /* Configure ADC analog watchdog interrupt */
        if (AnalogWDGConfig->ITMode == ENABLE)
 8007b34:	683b      	ldr	r3, [r7, #0]
 8007b36:	7b1b      	ldrb	r3, [r3, #12]
 8007b38:	2b01      	cmp	r3, #1
 8007b3a:	d105      	bne.n	8007b48 <HAL_ADC_AnalogWDGConfig+0x338>
        {
          LL_ADC_EnableIT_AWD3(hadc->Instance);
 8007b3c:	687b      	ldr	r3, [r7, #4]
 8007b3e:	681b      	ldr	r3, [r3, #0]
 8007b40:	4618      	mov	r0, r3
 8007b42:	f7fe fc83 	bl	800644c <LL_ADC_EnableIT_AWD3>
 8007b46:	e004      	b.n	8007b52 <HAL_ADC_AnalogWDGConfig+0x342>
        }
        else
        {
          LL_ADC_DisableIT_AWD3(hadc->Instance);
 8007b48:	687b      	ldr	r3, [r7, #4]
 8007b4a:	681b      	ldr	r3, [r3, #0]
 8007b4c:	4618      	mov	r0, r3
 8007b4e:	f7fe fcad 	bl	80064ac <LL_ADC_DisableIT_AWD3>
    }

  }

  /* Analog watchdog thresholds configuration */
  if (AnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_1)
 8007b52:	683b      	ldr	r3, [r7, #0]
 8007b54:	681b      	ldr	r3, [r3, #0]
 8007b56:	4a33      	ldr	r2, [pc, #204]	; (8007c24 <HAL_ADC_AnalogWDGConfig+0x414>)
 8007b58:	4293      	cmp	r3, r2
 8007b5a:	d118      	bne.n	8007b8e <HAL_ADC_AnalogWDGConfig+0x37e>
  {
    /* Shift the offset with respect to the selected ADC resolution:        */
    /* Thresholds have to be left-aligned on bit 11, the LSB (right bits)   */
    /* are set to 0.                                                        */
    tmpAWDHighThresholdShifted = ADC_AWD1THRESHOLD_SHIFT_RESOLUTION(hadc, AnalogWDGConfig->HighThreshold);
 8007b5c:	683b      	ldr	r3, [r7, #0]
 8007b5e:	691a      	ldr	r2, [r3, #16]
 8007b60:	687b      	ldr	r3, [r7, #4]
 8007b62:	681b      	ldr	r3, [r3, #0]
 8007b64:	68db      	ldr	r3, [r3, #12]
 8007b66:	08db      	lsrs	r3, r3, #3
 8007b68:	f003 0303 	and.w	r3, r3, #3
 8007b6c:	005b      	lsls	r3, r3, #1
 8007b6e:	fa02 f303 	lsl.w	r3, r2, r3
 8007b72:	637b      	str	r3, [r7, #52]	; 0x34
    tmpAWDLowThresholdShifted  = ADC_AWD1THRESHOLD_SHIFT_RESOLUTION(hadc, AnalogWDGConfig->LowThreshold);
 8007b74:	683b      	ldr	r3, [r7, #0]
 8007b76:	695a      	ldr	r2, [r3, #20]
 8007b78:	687b      	ldr	r3, [r7, #4]
 8007b7a:	681b      	ldr	r3, [r3, #0]
 8007b7c:	68db      	ldr	r3, [r3, #12]
 8007b7e:	08db      	lsrs	r3, r3, #3
 8007b80:	f003 0303 	and.w	r3, r3, #3
 8007b84:	005b      	lsls	r3, r3, #1
 8007b86:	fa02 f303 	lsl.w	r3, r2, r3
 8007b8a:	633b      	str	r3, [r7, #48]	; 0x30
 8007b8c:	e035      	b.n	8007bfa <HAL_ADC_AnalogWDGConfig+0x3ea>
  else
  {
    /* Shift the offset with respect to the selected ADC resolution:        */
    /* Thresholds have to be left-aligned on bit 7, the LSB (right bits)    */
    /* are set to 0.                                                        */
    tmpAWDHighThresholdShifted = ADC_AWD23THRESHOLD_SHIFT_RESOLUTION(hadc, AnalogWDGConfig->HighThreshold);
 8007b8e:	687b      	ldr	r3, [r7, #4]
 8007b90:	681b      	ldr	r3, [r3, #0]
 8007b92:	68db      	ldr	r3, [r3, #12]
 8007b94:	f003 0318 	and.w	r3, r3, #24
 8007b98:	2b18      	cmp	r3, #24
 8007b9a:	d00f      	beq.n	8007bbc <HAL_ADC_AnalogWDGConfig+0x3ac>
 8007b9c:	683b      	ldr	r3, [r7, #0]
 8007b9e:	691a      	ldr	r2, [r3, #16]
 8007ba0:	687b      	ldr	r3, [r7, #4]
 8007ba2:	681b      	ldr	r3, [r3, #0]
 8007ba4:	68db      	ldr	r3, [r3, #12]
 8007ba6:	08db      	lsrs	r3, r3, #3
 8007ba8:	f003 0303 	and.w	r3, r3, #3
 8007bac:	f1c3 0302 	rsb	r3, r3, #2
 8007bb0:	005b      	lsls	r3, r3, #1
 8007bb2:	f003 031e 	and.w	r3, r3, #30
 8007bb6:	fa22 f303 	lsr.w	r3, r2, r3
 8007bba:	e002      	b.n	8007bc2 <HAL_ADC_AnalogWDGConfig+0x3b2>
 8007bbc:	683b      	ldr	r3, [r7, #0]
 8007bbe:	691b      	ldr	r3, [r3, #16]
 8007bc0:	009b      	lsls	r3, r3, #2
 8007bc2:	637b      	str	r3, [r7, #52]	; 0x34
    tmpAWDLowThresholdShifted  = ADC_AWD23THRESHOLD_SHIFT_RESOLUTION(hadc, AnalogWDGConfig->LowThreshold);
 8007bc4:	687b      	ldr	r3, [r7, #4]
 8007bc6:	681b      	ldr	r3, [r3, #0]
 8007bc8:	68db      	ldr	r3, [r3, #12]
 8007bca:	f003 0318 	and.w	r3, r3, #24
 8007bce:	2b18      	cmp	r3, #24
 8007bd0:	d00f      	beq.n	8007bf2 <HAL_ADC_AnalogWDGConfig+0x3e2>
 8007bd2:	683b      	ldr	r3, [r7, #0]
 8007bd4:	695a      	ldr	r2, [r3, #20]
 8007bd6:	687b      	ldr	r3, [r7, #4]
 8007bd8:	681b      	ldr	r3, [r3, #0]
 8007bda:	68db      	ldr	r3, [r3, #12]
 8007bdc:	08db      	lsrs	r3, r3, #3
 8007bde:	f003 0303 	and.w	r3, r3, #3
 8007be2:	f1c3 0302 	rsb	r3, r3, #2
 8007be6:	005b      	lsls	r3, r3, #1
 8007be8:	f003 031e 	and.w	r3, r3, #30
 8007bec:	fa22 f303 	lsr.w	r3, r2, r3
 8007bf0:	e002      	b.n	8007bf8 <HAL_ADC_AnalogWDGConfig+0x3e8>
 8007bf2:	683b      	ldr	r3, [r7, #0]
 8007bf4:	695b      	ldr	r3, [r3, #20]
 8007bf6:	009b      	lsls	r3, r3, #2
 8007bf8:	633b      	str	r3, [r7, #48]	; 0x30
  }

  /* Set ADC analog watchdog thresholds value of both thresholds high and low */
  LL_ADC_ConfigAnalogWDThresholds(hadc->Instance, AnalogWDGConfig->WatchdogNumber, tmpAWDHighThresholdShifted,
 8007bfa:	687b      	ldr	r3, [r7, #4]
 8007bfc:	6818      	ldr	r0, [r3, #0]
 8007bfe:	683b      	ldr	r3, [r7, #0]
 8007c00:	6819      	ldr	r1, [r3, #0]
 8007c02:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007c04:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8007c06:	f7fe fa9c 	bl	8006142 <LL_ADC_ConfigAnalogWDThresholds>
                                  tmpAWDLowThresholdShifted);

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8007c0a:	687b      	ldr	r3, [r7, #4]
 8007c0c:	2200      	movs	r2, #0
 8007c0e:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

  /* Return function status */
  return tmp_hal_status;
 8007c12:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
}
 8007c16:	4618      	mov	r0, r3
 8007c18:	3738      	adds	r7, #56	; 0x38
 8007c1a:	46bd      	mov	sp, r7
 8007c1c:	bd80      	pop	{r7, pc}
 8007c1e:	bf00      	nop
 8007c20:	0017ffff 	.word	0x0017ffff
 8007c24:	7dc00000 	.word	0x7dc00000

08007c28 <ADC_ConversionStop>:
  *            @arg @ref ADC_INJECTED_GROUP          ADC injected conversion type.
  *            @arg @ref ADC_REGULAR_INJECTED_GROUP  ADC regular and injected conversion type.
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_ConversionStop(ADC_HandleTypeDef *hadc, uint32_t ConversionGroup)
{
 8007c28:	b580      	push	{r7, lr}
 8007c2a:	b088      	sub	sp, #32
 8007c2c:	af00      	add	r7, sp, #0
 8007c2e:	6078      	str	r0, [r7, #4]
 8007c30:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  uint32_t Conversion_Timeout_CPU_cycles = 0UL;
 8007c32:	2300      	movs	r3, #0
 8007c34:	61fb      	str	r3, [r7, #28]
  uint32_t conversion_group_reassigned = ConversionGroup;
 8007c36:	683b      	ldr	r3, [r7, #0]
 8007c38:	61bb      	str	r3, [r7, #24]
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_CONVERSION_GROUP(ConversionGroup));

  /* Verification if ADC is not already stopped (on regular and injected      */
  /* groups) to bypass this function if not needed.                           */
  tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8007c3a:	687b      	ldr	r3, [r7, #4]
 8007c3c:	681b      	ldr	r3, [r3, #0]
 8007c3e:	4618      	mov	r0, r3
 8007c40:	f7fe fb81 	bl	8006346 <LL_ADC_REG_IsConversionOngoing>
 8007c44:	6138      	str	r0, [r7, #16]
  tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 8007c46:	687b      	ldr	r3, [r7, #4]
 8007c48:	681b      	ldr	r3, [r3, #0]
 8007c4a:	4618      	mov	r0, r3
 8007c4c:	f7fe fba2 	bl	8006394 <LL_ADC_INJ_IsConversionOngoing>
 8007c50:	60f8      	str	r0, [r7, #12]
  if ((tmp_adc_is_conversion_on_going_regular != 0UL)
 8007c52:	693b      	ldr	r3, [r7, #16]
 8007c54:	2b00      	cmp	r3, #0
 8007c56:	d103      	bne.n	8007c60 <ADC_ConversionStop+0x38>
      || (tmp_adc_is_conversion_on_going_injected != 0UL)
 8007c58:	68fb      	ldr	r3, [r7, #12]
 8007c5a:	2b00      	cmp	r3, #0
 8007c5c:	f000 8098 	beq.w	8007d90 <ADC_ConversionStop+0x168>
    /* auto-delay mode.                                                       */
    /* In auto-injection mode, regular group stop ADC_CR_ADSTP is used (not   */
    /* injected group stop ADC_CR_JADSTP).                                    */
    /* Procedure to be followed: Wait until JEOS=1, clear JEOS, set ADSTP=1   */
    /* (see reference manual).                                                */
    if (((hadc->Instance->CFGR & ADC_CFGR_JAUTO) != 0UL)
 8007c60:	687b      	ldr	r3, [r7, #4]
 8007c62:	681b      	ldr	r3, [r3, #0]
 8007c64:	68db      	ldr	r3, [r3, #12]
 8007c66:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8007c6a:	2b00      	cmp	r3, #0
 8007c6c:	d02a      	beq.n	8007cc4 <ADC_ConversionStop+0x9c>
        && (hadc->Init.ContinuousConvMode == ENABLE)
 8007c6e:	687b      	ldr	r3, [r7, #4]
 8007c70:	7f5b      	ldrb	r3, [r3, #29]
 8007c72:	2b01      	cmp	r3, #1
 8007c74:	d126      	bne.n	8007cc4 <ADC_ConversionStop+0x9c>
        && (hadc->Init.LowPowerAutoWait == ENABLE)
 8007c76:	687b      	ldr	r3, [r7, #4]
 8007c78:	7f1b      	ldrb	r3, [r3, #28]
 8007c7a:	2b01      	cmp	r3, #1
 8007c7c:	d122      	bne.n	8007cc4 <ADC_ConversionStop+0x9c>
       )
    {
      /* Use stop of regular group */
      conversion_group_reassigned = ADC_REGULAR_GROUP;
 8007c7e:	2301      	movs	r3, #1
 8007c80:	61bb      	str	r3, [r7, #24]

      /* Wait until JEOS=1 (maximum Timeout: 4 injected conversions) */
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS) == 0UL)
 8007c82:	e014      	b.n	8007cae <ADC_ConversionStop+0x86>
      {
        if (Conversion_Timeout_CPU_cycles >= (ADC_CONVERSION_TIME_MAX_CPU_CYCLES * 4UL))
 8007c84:	69fb      	ldr	r3, [r7, #28]
 8007c86:	4a45      	ldr	r2, [pc, #276]	; (8007d9c <ADC_ConversionStop+0x174>)
 8007c88:	4293      	cmp	r3, r2
 8007c8a:	d90d      	bls.n	8007ca8 <ADC_ConversionStop+0x80>
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007c8c:	687b      	ldr	r3, [r7, #4]
 8007c8e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8007c90:	f043 0210 	orr.w	r2, r3, #16
 8007c94:	687b      	ldr	r3, [r7, #4]
 8007c96:	65da      	str	r2, [r3, #92]	; 0x5c

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8007c98:	687b      	ldr	r3, [r7, #4]
 8007c9a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8007c9c:	f043 0201 	orr.w	r2, r3, #1
 8007ca0:	687b      	ldr	r3, [r7, #4]
 8007ca2:	661a      	str	r2, [r3, #96]	; 0x60

          return HAL_ERROR;
 8007ca4:	2301      	movs	r3, #1
 8007ca6:	e074      	b.n	8007d92 <ADC_ConversionStop+0x16a>
        }
        Conversion_Timeout_CPU_cycles ++;
 8007ca8:	69fb      	ldr	r3, [r7, #28]
 8007caa:	3301      	adds	r3, #1
 8007cac:	61fb      	str	r3, [r7, #28]
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS) == 0UL)
 8007cae:	687b      	ldr	r3, [r7, #4]
 8007cb0:	681b      	ldr	r3, [r3, #0]
 8007cb2:	681b      	ldr	r3, [r3, #0]
 8007cb4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8007cb8:	2b40      	cmp	r3, #64	; 0x40
 8007cba:	d1e3      	bne.n	8007c84 <ADC_ConversionStop+0x5c>
      }

      /* Clear JEOS */
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOS);
 8007cbc:	687b      	ldr	r3, [r7, #4]
 8007cbe:	681b      	ldr	r3, [r3, #0]
 8007cc0:	2240      	movs	r2, #64	; 0x40
 8007cc2:	601a      	str	r2, [r3, #0]
    }

    /* Stop potential conversion on going on ADC group regular */
    if (conversion_group_reassigned != ADC_INJECTED_GROUP)
 8007cc4:	69bb      	ldr	r3, [r7, #24]
 8007cc6:	2b02      	cmp	r3, #2
 8007cc8:	d014      	beq.n	8007cf4 <ADC_ConversionStop+0xcc>
    {
      /* Software is allowed to set ADSTP only when ADSTART=1 and ADDIS=0 */
      if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) != 0UL)
 8007cca:	687b      	ldr	r3, [r7, #4]
 8007ccc:	681b      	ldr	r3, [r3, #0]
 8007cce:	4618      	mov	r0, r3
 8007cd0:	f7fe fb39 	bl	8006346 <LL_ADC_REG_IsConversionOngoing>
 8007cd4:	4603      	mov	r3, r0
 8007cd6:	2b00      	cmp	r3, #0
 8007cd8:	d00c      	beq.n	8007cf4 <ADC_ConversionStop+0xcc>
      {
        if (LL_ADC_IsDisableOngoing(hadc->Instance) == 0UL)
 8007cda:	687b      	ldr	r3, [r7, #4]
 8007cdc:	681b      	ldr	r3, [r3, #0]
 8007cde:	4618      	mov	r0, r3
 8007ce0:	f7fe faf6 	bl	80062d0 <LL_ADC_IsDisableOngoing>
 8007ce4:	4603      	mov	r3, r0
 8007ce6:	2b00      	cmp	r3, #0
 8007ce8:	d104      	bne.n	8007cf4 <ADC_ConversionStop+0xcc>
        {
          /* Stop ADC group regular conversion */
          LL_ADC_REG_StopConversion(hadc->Instance);
 8007cea:	687b      	ldr	r3, [r7, #4]
 8007cec:	681b      	ldr	r3, [r3, #0]
 8007cee:	4618      	mov	r0, r3
 8007cf0:	f7fe fb15 	bl	800631e <LL_ADC_REG_StopConversion>
        }
      }
    }

    /* Stop potential conversion on going on ADC group injected */
    if (conversion_group_reassigned != ADC_REGULAR_GROUP)
 8007cf4:	69bb      	ldr	r3, [r7, #24]
 8007cf6:	2b01      	cmp	r3, #1
 8007cf8:	d014      	beq.n	8007d24 <ADC_ConversionStop+0xfc>
    {
      /* Software is allowed to set JADSTP only when JADSTART=1 and ADDIS=0 */
      if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) != 0UL)
 8007cfa:	687b      	ldr	r3, [r7, #4]
 8007cfc:	681b      	ldr	r3, [r3, #0]
 8007cfe:	4618      	mov	r0, r3
 8007d00:	f7fe fb48 	bl	8006394 <LL_ADC_INJ_IsConversionOngoing>
 8007d04:	4603      	mov	r3, r0
 8007d06:	2b00      	cmp	r3, #0
 8007d08:	d00c      	beq.n	8007d24 <ADC_ConversionStop+0xfc>
      {
        if (LL_ADC_IsDisableOngoing(hadc->Instance) == 0UL)
 8007d0a:	687b      	ldr	r3, [r7, #4]
 8007d0c:	681b      	ldr	r3, [r3, #0]
 8007d0e:	4618      	mov	r0, r3
 8007d10:	f7fe fade 	bl	80062d0 <LL_ADC_IsDisableOngoing>
 8007d14:	4603      	mov	r3, r0
 8007d16:	2b00      	cmp	r3, #0
 8007d18:	d104      	bne.n	8007d24 <ADC_ConversionStop+0xfc>
        {
          /* Stop ADC group injected conversion */
          LL_ADC_INJ_StopConversion(hadc->Instance);
 8007d1a:	687b      	ldr	r3, [r7, #4]
 8007d1c:	681b      	ldr	r3, [r3, #0]
 8007d1e:	4618      	mov	r0, r3
 8007d20:	f7fe fb24 	bl	800636c <LL_ADC_INJ_StopConversion>
        }
      }
    }

    /* Selection of start and stop bits with respect to the regular or injected group */
    switch (conversion_group_reassigned)
 8007d24:	69bb      	ldr	r3, [r7, #24]
 8007d26:	2b02      	cmp	r3, #2
 8007d28:	d005      	beq.n	8007d36 <ADC_ConversionStop+0x10e>
 8007d2a:	69bb      	ldr	r3, [r7, #24]
 8007d2c:	2b03      	cmp	r3, #3
 8007d2e:	d105      	bne.n	8007d3c <ADC_ConversionStop+0x114>
    {
      case ADC_REGULAR_INJECTED_GROUP:
        tmp_ADC_CR_ADSTART_JADSTART = (ADC_CR_ADSTART | ADC_CR_JADSTART);
 8007d30:	230c      	movs	r3, #12
 8007d32:	617b      	str	r3, [r7, #20]
        break;
 8007d34:	e005      	b.n	8007d42 <ADC_ConversionStop+0x11a>
      case ADC_INJECTED_GROUP:
        tmp_ADC_CR_ADSTART_JADSTART = ADC_CR_JADSTART;
 8007d36:	2308      	movs	r3, #8
 8007d38:	617b      	str	r3, [r7, #20]
        break;
 8007d3a:	e002      	b.n	8007d42 <ADC_ConversionStop+0x11a>
      /* Case ADC_REGULAR_GROUP only*/
      default:
        tmp_ADC_CR_ADSTART_JADSTART = ADC_CR_ADSTART;
 8007d3c:	2304      	movs	r3, #4
 8007d3e:	617b      	str	r3, [r7, #20]
        break;
 8007d40:	bf00      	nop
    }

    /* Wait for conversion effectively stopped */
    tickstart = HAL_GetTick();
 8007d42:	f7fe f807 	bl	8005d54 <HAL_GetTick>
 8007d46:	60b8      	str	r0, [r7, #8]

    while ((hadc->Instance->CR & tmp_ADC_CR_ADSTART_JADSTART) != 0UL)
 8007d48:	e01b      	b.n	8007d82 <ADC_ConversionStop+0x15a>
    {
      if ((HAL_GetTick() - tickstart) > ADC_STOP_CONVERSION_TIMEOUT)
 8007d4a:	f7fe f803 	bl	8005d54 <HAL_GetTick>
 8007d4e:	4602      	mov	r2, r0
 8007d50:	68bb      	ldr	r3, [r7, #8]
 8007d52:	1ad3      	subs	r3, r2, r3
 8007d54:	2b05      	cmp	r3, #5
 8007d56:	d914      	bls.n	8007d82 <ADC_ConversionStop+0x15a>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if ((hadc->Instance->CR & tmp_ADC_CR_ADSTART_JADSTART) != 0UL)
 8007d58:	687b      	ldr	r3, [r7, #4]
 8007d5a:	681b      	ldr	r3, [r3, #0]
 8007d5c:	689a      	ldr	r2, [r3, #8]
 8007d5e:	697b      	ldr	r3, [r7, #20]
 8007d60:	4013      	ands	r3, r2
 8007d62:	2b00      	cmp	r3, #0
 8007d64:	d00d      	beq.n	8007d82 <ADC_ConversionStop+0x15a>
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007d66:	687b      	ldr	r3, [r7, #4]
 8007d68:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8007d6a:	f043 0210 	orr.w	r2, r3, #16
 8007d6e:	687b      	ldr	r3, [r7, #4]
 8007d70:	65da      	str	r2, [r3, #92]	; 0x5c

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8007d72:	687b      	ldr	r3, [r7, #4]
 8007d74:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8007d76:	f043 0201 	orr.w	r2, r3, #1
 8007d7a:	687b      	ldr	r3, [r7, #4]
 8007d7c:	661a      	str	r2, [r3, #96]	; 0x60

          return HAL_ERROR;
 8007d7e:	2301      	movs	r3, #1
 8007d80:	e007      	b.n	8007d92 <ADC_ConversionStop+0x16a>
    while ((hadc->Instance->CR & tmp_ADC_CR_ADSTART_JADSTART) != 0UL)
 8007d82:	687b      	ldr	r3, [r7, #4]
 8007d84:	681b      	ldr	r3, [r3, #0]
 8007d86:	689a      	ldr	r2, [r3, #8]
 8007d88:	697b      	ldr	r3, [r7, #20]
 8007d8a:	4013      	ands	r3, r2
 8007d8c:	2b00      	cmp	r3, #0
 8007d8e:	d1dc      	bne.n	8007d4a <ADC_ConversionStop+0x122>
    }

  }

  /* Return HAL status */
  return HAL_OK;
 8007d90:	2300      	movs	r3, #0
}
 8007d92:	4618      	mov	r0, r3
 8007d94:	3720      	adds	r7, #32
 8007d96:	46bd      	mov	sp, r7
 8007d98:	bd80      	pop	{r7, pc}
 8007d9a:	bf00      	nop
 8007d9c:	a33fffff 	.word	0xa33fffff

08007da0 <ADC_Enable>:
  *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef *hadc)
{
 8007da0:	b580      	push	{r7, lr}
 8007da2:	b084      	sub	sp, #16
 8007da4:	af00      	add	r7, sp, #0
 8007da6:	6078      	str	r0, [r7, #4]

  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8007da8:	687b      	ldr	r3, [r7, #4]
 8007daa:	681b      	ldr	r3, [r3, #0]
 8007dac:	4618      	mov	r0, r3
 8007dae:	f7fe fa7c 	bl	80062aa <LL_ADC_IsEnabled>
 8007db2:	4603      	mov	r3, r0
 8007db4:	2b00      	cmp	r3, #0
 8007db6:	d14d      	bne.n	8007e54 <ADC_Enable+0xb4>
  {
    /* Check if conditions to enable the ADC are fulfilled */
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_JADSTP | ADC_CR_ADSTP | ADC_CR_JADSTART | ADC_CR_ADSTART
 8007db8:	687b      	ldr	r3, [r7, #4]
 8007dba:	681b      	ldr	r3, [r3, #0]
 8007dbc:	689a      	ldr	r2, [r3, #8]
 8007dbe:	4b28      	ldr	r3, [pc, #160]	; (8007e60 <ADC_Enable+0xc0>)
 8007dc0:	4013      	ands	r3, r2
 8007dc2:	2b00      	cmp	r3, #0
 8007dc4:	d00d      	beq.n	8007de2 <ADC_Enable+0x42>
                               | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
    {
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007dc6:	687b      	ldr	r3, [r7, #4]
 8007dc8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8007dca:	f043 0210 	orr.w	r2, r3, #16
 8007dce:	687b      	ldr	r3, [r7, #4]
 8007dd0:	65da      	str	r2, [r3, #92]	; 0x5c

      /* Set ADC error code to ADC peripheral internal error */
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8007dd2:	687b      	ldr	r3, [r7, #4]
 8007dd4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8007dd6:	f043 0201 	orr.w	r2, r3, #1
 8007dda:	687b      	ldr	r3, [r7, #4]
 8007ddc:	661a      	str	r2, [r3, #96]	; 0x60

      return HAL_ERROR;
 8007dde:	2301      	movs	r3, #1
 8007de0:	e039      	b.n	8007e56 <ADC_Enable+0xb6>
    }

    /* Enable the ADC peripheral */
    LL_ADC_Enable(hadc->Instance);
 8007de2:	687b      	ldr	r3, [r7, #4]
 8007de4:	681b      	ldr	r3, [r3, #0]
 8007de6:	4618      	mov	r0, r3
 8007de8:	f7fe fa37 	bl	800625a <LL_ADC_Enable>

    /* Wait for ADC effectively enabled */
    tickstart = HAL_GetTick();
 8007dec:	f7fd ffb2 	bl	8005d54 <HAL_GetTick>
 8007df0:	60f8      	str	r0, [r7, #12]

    while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 8007df2:	e028      	b.n	8007e46 <ADC_Enable+0xa6>
          The workaround is to continue setting ADEN until ADRDY is becomes 1.
          Additionally, ADC_ENABLE_TIMEOUT is defined to encompass this
          4 ADC clock cycle duration */
      /* Note: Test of ADC enabled required due to hardware constraint to     */
      /*       not enable ADC if already enabled.                             */
      if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8007df4:	687b      	ldr	r3, [r7, #4]
 8007df6:	681b      	ldr	r3, [r3, #0]
 8007df8:	4618      	mov	r0, r3
 8007dfa:	f7fe fa56 	bl	80062aa <LL_ADC_IsEnabled>
 8007dfe:	4603      	mov	r3, r0
 8007e00:	2b00      	cmp	r3, #0
 8007e02:	d104      	bne.n	8007e0e <ADC_Enable+0x6e>
      {
        LL_ADC_Enable(hadc->Instance);
 8007e04:	687b      	ldr	r3, [r7, #4]
 8007e06:	681b      	ldr	r3, [r3, #0]
 8007e08:	4618      	mov	r0, r3
 8007e0a:	f7fe fa26 	bl	800625a <LL_ADC_Enable>
      }

      if ((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 8007e0e:	f7fd ffa1 	bl	8005d54 <HAL_GetTick>
 8007e12:	4602      	mov	r2, r0
 8007e14:	68fb      	ldr	r3, [r7, #12]
 8007e16:	1ad3      	subs	r3, r2, r3
 8007e18:	2b02      	cmp	r3, #2
 8007e1a:	d914      	bls.n	8007e46 <ADC_Enable+0xa6>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 8007e1c:	687b      	ldr	r3, [r7, #4]
 8007e1e:	681b      	ldr	r3, [r3, #0]
 8007e20:	681b      	ldr	r3, [r3, #0]
 8007e22:	f003 0301 	and.w	r3, r3, #1
 8007e26:	2b01      	cmp	r3, #1
 8007e28:	d00d      	beq.n	8007e46 <ADC_Enable+0xa6>
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007e2a:	687b      	ldr	r3, [r7, #4]
 8007e2c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8007e2e:	f043 0210 	orr.w	r2, r3, #16
 8007e32:	687b      	ldr	r3, [r7, #4]
 8007e34:	65da      	str	r2, [r3, #92]	; 0x5c

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8007e36:	687b      	ldr	r3, [r7, #4]
 8007e38:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8007e3a:	f043 0201 	orr.w	r2, r3, #1
 8007e3e:	687b      	ldr	r3, [r7, #4]
 8007e40:	661a      	str	r2, [r3, #96]	; 0x60

          return HAL_ERROR;
 8007e42:	2301      	movs	r3, #1
 8007e44:	e007      	b.n	8007e56 <ADC_Enable+0xb6>
    while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 8007e46:	687b      	ldr	r3, [r7, #4]
 8007e48:	681b      	ldr	r3, [r3, #0]
 8007e4a:	681b      	ldr	r3, [r3, #0]
 8007e4c:	f003 0301 	and.w	r3, r3, #1
 8007e50:	2b01      	cmp	r3, #1
 8007e52:	d1cf      	bne.n	8007df4 <ADC_Enable+0x54>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 8007e54:	2300      	movs	r3, #0
}
 8007e56:	4618      	mov	r0, r3
 8007e58:	3710      	adds	r7, #16
 8007e5a:	46bd      	mov	sp, r7
 8007e5c:	bd80      	pop	{r7, pc}
 8007e5e:	bf00      	nop
 8007e60:	8000003f 	.word	0x8000003f

08007e64 <ADC_Disable>:
  *         stopped.
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Disable(ADC_HandleTypeDef *hadc)
{
 8007e64:	b580      	push	{r7, lr}
 8007e66:	b084      	sub	sp, #16
 8007e68:	af00      	add	r7, sp, #0
 8007e6a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
 8007e6c:	687b      	ldr	r3, [r7, #4]
 8007e6e:	681b      	ldr	r3, [r3, #0]
 8007e70:	4618      	mov	r0, r3
 8007e72:	f7fe fa2d 	bl	80062d0 <LL_ADC_IsDisableOngoing>
 8007e76:	60f8      	str	r0, [r7, #12]

  /* Verification if ADC is not already disabled:                             */
  /* Note: forbidden to disable ADC (set bit ADC_CR_ADDIS) if ADC is already  */
  /*       disabled.                                                          */
  if ((LL_ADC_IsEnabled(hadc->Instance) != 0UL)
 8007e78:	687b      	ldr	r3, [r7, #4]
 8007e7a:	681b      	ldr	r3, [r3, #0]
 8007e7c:	4618      	mov	r0, r3
 8007e7e:	f7fe fa14 	bl	80062aa <LL_ADC_IsEnabled>
 8007e82:	4603      	mov	r3, r0
 8007e84:	2b00      	cmp	r3, #0
 8007e86:	d047      	beq.n	8007f18 <ADC_Disable+0xb4>
      && (tmp_adc_is_disable_on_going == 0UL)
 8007e88:	68fb      	ldr	r3, [r7, #12]
 8007e8a:	2b00      	cmp	r3, #0
 8007e8c:	d144      	bne.n	8007f18 <ADC_Disable+0xb4>
     )
  {
    /* Check if conditions to disable the ADC are fulfilled */
    if ((hadc->Instance->CR & (ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
 8007e8e:	687b      	ldr	r3, [r7, #4]
 8007e90:	681b      	ldr	r3, [r3, #0]
 8007e92:	689b      	ldr	r3, [r3, #8]
 8007e94:	f003 030d 	and.w	r3, r3, #13
 8007e98:	2b01      	cmp	r3, #1
 8007e9a:	d10c      	bne.n	8007eb6 <ADC_Disable+0x52>
    {
      /* Disable the ADC peripheral */
      LL_ADC_Disable(hadc->Instance);
 8007e9c:	687b      	ldr	r3, [r7, #4]
 8007e9e:	681b      	ldr	r3, [r3, #0]
 8007ea0:	4618      	mov	r0, r3
 8007ea2:	f7fe f9ee 	bl	8006282 <LL_ADC_Disable>
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
 8007ea6:	687b      	ldr	r3, [r7, #4]
 8007ea8:	681b      	ldr	r3, [r3, #0]
 8007eaa:	2203      	movs	r2, #3
 8007eac:	601a      	str	r2, [r3, #0]
      return HAL_ERROR;
    }

    /* Wait for ADC effectively disabled */
    /* Get tick count */
    tickstart = HAL_GetTick();
 8007eae:	f7fd ff51 	bl	8005d54 <HAL_GetTick>
 8007eb2:	60b8      	str	r0, [r7, #8]

    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 8007eb4:	e029      	b.n	8007f0a <ADC_Disable+0xa6>
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007eb6:	687b      	ldr	r3, [r7, #4]
 8007eb8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8007eba:	f043 0210 	orr.w	r2, r3, #16
 8007ebe:	687b      	ldr	r3, [r7, #4]
 8007ec0:	65da      	str	r2, [r3, #92]	; 0x5c
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8007ec2:	687b      	ldr	r3, [r7, #4]
 8007ec4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8007ec6:	f043 0201 	orr.w	r2, r3, #1
 8007eca:	687b      	ldr	r3, [r7, #4]
 8007ecc:	661a      	str	r2, [r3, #96]	; 0x60
      return HAL_ERROR;
 8007ece:	2301      	movs	r3, #1
 8007ed0:	e023      	b.n	8007f1a <ADC_Disable+0xb6>
    {
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 8007ed2:	f7fd ff3f 	bl	8005d54 <HAL_GetTick>
 8007ed6:	4602      	mov	r2, r0
 8007ed8:	68bb      	ldr	r3, [r7, #8]
 8007eda:	1ad3      	subs	r3, r2, r3
 8007edc:	2b02      	cmp	r3, #2
 8007ede:	d914      	bls.n	8007f0a <ADC_Disable+0xa6>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 8007ee0:	687b      	ldr	r3, [r7, #4]
 8007ee2:	681b      	ldr	r3, [r3, #0]
 8007ee4:	689b      	ldr	r3, [r3, #8]
 8007ee6:	f003 0301 	and.w	r3, r3, #1
 8007eea:	2b00      	cmp	r3, #0
 8007eec:	d00d      	beq.n	8007f0a <ADC_Disable+0xa6>
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007eee:	687b      	ldr	r3, [r7, #4]
 8007ef0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8007ef2:	f043 0210 	orr.w	r2, r3, #16
 8007ef6:	687b      	ldr	r3, [r7, #4]
 8007ef8:	65da      	str	r2, [r3, #92]	; 0x5c

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8007efa:	687b      	ldr	r3, [r7, #4]
 8007efc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8007efe:	f043 0201 	orr.w	r2, r3, #1
 8007f02:	687b      	ldr	r3, [r7, #4]
 8007f04:	661a      	str	r2, [r3, #96]	; 0x60

          return HAL_ERROR;
 8007f06:	2301      	movs	r3, #1
 8007f08:	e007      	b.n	8007f1a <ADC_Disable+0xb6>
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 8007f0a:	687b      	ldr	r3, [r7, #4]
 8007f0c:	681b      	ldr	r3, [r3, #0]
 8007f0e:	689b      	ldr	r3, [r3, #8]
 8007f10:	f003 0301 	and.w	r3, r3, #1
 8007f14:	2b00      	cmp	r3, #0
 8007f16:	d1dc      	bne.n	8007ed2 <ADC_Disable+0x6e>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 8007f18:	2300      	movs	r3, #0
}
 8007f1a:	4618      	mov	r0, r3
 8007f1c:	3710      	adds	r7, #16
 8007f1e:	46bd      	mov	sp, r7
 8007f20:	bd80      	pop	{r7, pc}

08007f22 <ADC_DMAConvCplt>:
  * @brief  DMA transfer complete callback.
  * @param hdma pointer to DMA handle.
  * @retval None
  */
void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma)
{
 8007f22:	b580      	push	{r7, lr}
 8007f24:	b084      	sub	sp, #16
 8007f26:	af00      	add	r7, sp, #0
 8007f28:	6078      	str	r0, [r7, #4]
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8007f2a:	687b      	ldr	r3, [r7, #4]
 8007f2c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8007f2e:	60fb      	str	r3, [r7, #12]

  /* Update state machine on conversion status if not in error state */
  if ((hadc->State & (HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA)) == 0UL)
 8007f30:	68fb      	ldr	r3, [r7, #12]
 8007f32:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8007f34:	f003 0350 	and.w	r3, r3, #80	; 0x50
 8007f38:	2b00      	cmp	r3, #0
 8007f3a:	d14b      	bne.n	8007fd4 <ADC_DMAConvCplt+0xb2>
  {
    /* Set ADC state */
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 8007f3c:	68fb      	ldr	r3, [r7, #12]
 8007f3e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8007f40:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 8007f44:	68fb      	ldr	r3, [r7, #12]
 8007f46:	65da      	str	r2, [r3, #92]	; 0x5c

    /* Determine whether any further conversion upcoming on group regular     */
    /* by external trigger, continuous mode or scan sequence on going         */
    /* to disable interruption.                                               */
    /* Is it the end of the regular sequence ? */
    if ((hadc->Instance->ISR & ADC_FLAG_EOS) != 0UL)
 8007f48:	68fb      	ldr	r3, [r7, #12]
 8007f4a:	681b      	ldr	r3, [r3, #0]
 8007f4c:	681b      	ldr	r3, [r3, #0]
 8007f4e:	f003 0308 	and.w	r3, r3, #8
 8007f52:	2b00      	cmp	r3, #0
 8007f54:	d021      	beq.n	8007f9a <ADC_DMAConvCplt+0x78>
    {
      /* Are conversions software-triggered ? */
      if (LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance) != 0UL)
 8007f56:	68fb      	ldr	r3, [r7, #12]
 8007f58:	681b      	ldr	r3, [r3, #0]
 8007f5a:	4618      	mov	r0, r3
 8007f5c:	f7fe f81e 	bl	8005f9c <LL_ADC_REG_IsTriggerSourceSWStart>
 8007f60:	4603      	mov	r3, r0
 8007f62:	2b00      	cmp	r3, #0
 8007f64:	d032      	beq.n	8007fcc <ADC_DMAConvCplt+0xaa>
      {
        /* Is CONT bit set ? */
        if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_CONT) == 0UL)
 8007f66:	68fb      	ldr	r3, [r7, #12]
 8007f68:	681b      	ldr	r3, [r3, #0]
 8007f6a:	68db      	ldr	r3, [r3, #12]
 8007f6c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8007f70:	2b00      	cmp	r3, #0
 8007f72:	d12b      	bne.n	8007fcc <ADC_DMAConvCplt+0xaa>
        {
          /* CONT bit is not set, no more conversions expected */
          CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
 8007f74:	68fb      	ldr	r3, [r7, #12]
 8007f76:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8007f78:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 8007f7c:	68fb      	ldr	r3, [r7, #12]
 8007f7e:	65da      	str	r2, [r3, #92]	; 0x5c
          if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
 8007f80:	68fb      	ldr	r3, [r7, #12]
 8007f82:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8007f84:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8007f88:	2b00      	cmp	r3, #0
 8007f8a:	d11f      	bne.n	8007fcc <ADC_DMAConvCplt+0xaa>
          {
            SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8007f8c:	68fb      	ldr	r3, [r7, #12]
 8007f8e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8007f90:	f043 0201 	orr.w	r2, r3, #1
 8007f94:	68fb      	ldr	r3, [r7, #12]
 8007f96:	65da      	str	r2, [r3, #92]	; 0x5c
 8007f98:	e018      	b.n	8007fcc <ADC_DMAConvCplt+0xaa>
    }
    else
    {
      /* DMA End of Transfer interrupt was triggered but conversions sequence
         is not over. If DMACFG is set to 0, conversions are stopped. */
      if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_DMACFG) == 0UL)
 8007f9a:	68fb      	ldr	r3, [r7, #12]
 8007f9c:	681b      	ldr	r3, [r3, #0]
 8007f9e:	68db      	ldr	r3, [r3, #12]
 8007fa0:	f003 0302 	and.w	r3, r3, #2
 8007fa4:	2b00      	cmp	r3, #0
 8007fa6:	d111      	bne.n	8007fcc <ADC_DMAConvCplt+0xaa>
      {
        /* DMACFG bit is not set, conversions are stopped. */
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
 8007fa8:	68fb      	ldr	r3, [r7, #12]
 8007faa:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8007fac:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 8007fb0:	68fb      	ldr	r3, [r7, #12]
 8007fb2:	65da      	str	r2, [r3, #92]	; 0x5c
        if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
 8007fb4:	68fb      	ldr	r3, [r7, #12]
 8007fb6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8007fb8:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8007fbc:	2b00      	cmp	r3, #0
 8007fbe:	d105      	bne.n	8007fcc <ADC_DMAConvCplt+0xaa>
        {
          SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8007fc0:	68fb      	ldr	r3, [r7, #12]
 8007fc2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8007fc4:	f043 0201 	orr.w	r2, r3, #1
 8007fc8:	68fb      	ldr	r3, [r7, #12]
 8007fca:	65da      	str	r2, [r3, #92]	; 0x5c

    /* Conversion complete callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->ConvCpltCallback(hadc);
#else
    HAL_ADC_ConvCpltCallback(hadc);
 8007fcc:	68f8      	ldr	r0, [r7, #12]
 8007fce:	f7fc fe51 	bl	8004c74 <HAL_ADC_ConvCpltCallback>
    {
      /* Call ADC DMA error callback */
      hadc->DMA_Handle->XferErrorCallback(hdma);
    }
  }
}
 8007fd2:	e00e      	b.n	8007ff2 <ADC_DMAConvCplt+0xd0>
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) != 0UL)
 8007fd4:	68fb      	ldr	r3, [r7, #12]
 8007fd6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8007fd8:	f003 0310 	and.w	r3, r3, #16
 8007fdc:	2b00      	cmp	r3, #0
 8007fde:	d003      	beq.n	8007fe8 <ADC_DMAConvCplt+0xc6>
      HAL_ADC_ErrorCallback(hadc);
 8007fe0:	68f8      	ldr	r0, [r7, #12]
 8007fe2:	f7fe ffcb 	bl	8006f7c <HAL_ADC_ErrorCallback>
}
 8007fe6:	e004      	b.n	8007ff2 <ADC_DMAConvCplt+0xd0>
      hadc->DMA_Handle->XferErrorCallback(hdma);
 8007fe8:	68fb      	ldr	r3, [r7, #12]
 8007fea:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007fec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007fee:	6878      	ldr	r0, [r7, #4]
 8007ff0:	4798      	blx	r3
}
 8007ff2:	bf00      	nop
 8007ff4:	3710      	adds	r7, #16
 8007ff6:	46bd      	mov	sp, r7
 8007ff8:	bd80      	pop	{r7, pc}

08007ffa <ADC_DMAHalfConvCplt>:
  * @brief  DMA half transfer complete callback.
  * @param hdma pointer to DMA handle.
  * @retval None
  */
void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)
{
 8007ffa:	b580      	push	{r7, lr}
 8007ffc:	b084      	sub	sp, #16
 8007ffe:	af00      	add	r7, sp, #0
 8008000:	6078      	str	r0, [r7, #4]
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8008002:	687b      	ldr	r3, [r7, #4]
 8008004:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008006:	60fb      	str	r3, [r7, #12]

  /* Half conversion callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ConvHalfCpltCallback(hadc);
#else
  HAL_ADC_ConvHalfCpltCallback(hadc);
 8008008:	68f8      	ldr	r0, [r7, #12]
 800800a:	f7fc fe29 	bl	8004c60 <HAL_ADC_ConvHalfCpltCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
 800800e:	bf00      	nop
 8008010:	3710      	adds	r7, #16
 8008012:	46bd      	mov	sp, r7
 8008014:	bd80      	pop	{r7, pc}

08008016 <ADC_DMAError>:
  * @brief  DMA error callback.
  * @param hdma pointer to DMA handle.
  * @retval None
  */
void ADC_DMAError(DMA_HandleTypeDef *hdma)
{
 8008016:	b580      	push	{r7, lr}
 8008018:	b084      	sub	sp, #16
 800801a:	af00      	add	r7, sp, #0
 800801c:	6078      	str	r0, [r7, #4]
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800801e:	687b      	ldr	r3, [r7, #4]
 8008020:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008022:	60fb      	str	r3, [r7, #12]

  /* Set ADC state */
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
 8008024:	68fb      	ldr	r3, [r7, #12]
 8008026:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8008028:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 800802c:	68fb      	ldr	r3, [r7, #12]
 800802e:	65da      	str	r2, [r3, #92]	; 0x5c

  /* Set ADC error code to DMA error */
  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
 8008030:	68fb      	ldr	r3, [r7, #12]
 8008032:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8008034:	f043 0204 	orr.w	r2, r3, #4
 8008038:	68fb      	ldr	r3, [r7, #12]
 800803a:	661a      	str	r2, [r3, #96]	; 0x60

  /* Error callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ErrorCallback(hadc);
#else
  HAL_ADC_ErrorCallback(hadc);
 800803c:	68f8      	ldr	r0, [r7, #12]
 800803e:	f7fe ff9d 	bl	8006f7c <HAL_ADC_ErrorCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
 8008042:	bf00      	nop
 8008044:	3710      	adds	r7, #16
 8008046:	46bd      	mov	sp, r7
 8008048:	bd80      	pop	{r7, pc}

0800804a <LL_ADC_IsEnabled>:
{
 800804a:	b480      	push	{r7}
 800804c:	b083      	sub	sp, #12
 800804e:	af00      	add	r7, sp, #0
 8008050:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8008052:	687b      	ldr	r3, [r7, #4]
 8008054:	689b      	ldr	r3, [r3, #8]
 8008056:	f003 0301 	and.w	r3, r3, #1
 800805a:	2b01      	cmp	r3, #1
 800805c:	d101      	bne.n	8008062 <LL_ADC_IsEnabled+0x18>
 800805e:	2301      	movs	r3, #1
 8008060:	e000      	b.n	8008064 <LL_ADC_IsEnabled+0x1a>
 8008062:	2300      	movs	r3, #0
}
 8008064:	4618      	mov	r0, r3
 8008066:	370c      	adds	r7, #12
 8008068:	46bd      	mov	sp, r7
 800806a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800806e:	4770      	bx	lr

08008070 <LL_ADC_StartCalibration>:
{
 8008070:	b480      	push	{r7}
 8008072:	b083      	sub	sp, #12
 8008074:	af00      	add	r7, sp, #0
 8008076:	6078      	str	r0, [r7, #4]
 8008078:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCx->CR,
 800807a:	687b      	ldr	r3, [r7, #4]
 800807c:	689b      	ldr	r3, [r3, #8]
 800807e:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
 8008082:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8008086:	683a      	ldr	r2, [r7, #0]
 8008088:	f002 4280 	and.w	r2, r2, #1073741824	; 0x40000000
 800808c:	4313      	orrs	r3, r2
 800808e:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 8008092:	687b      	ldr	r3, [r7, #4]
 8008094:	609a      	str	r2, [r3, #8]
}
 8008096:	bf00      	nop
 8008098:	370c      	adds	r7, #12
 800809a:	46bd      	mov	sp, r7
 800809c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80080a0:	4770      	bx	lr

080080a2 <LL_ADC_IsCalibrationOnGoing>:
{
 80080a2:	b480      	push	{r7}
 80080a4:	b083      	sub	sp, #12
 80080a6:	af00      	add	r7, sp, #0
 80080a8:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 80080aa:	687b      	ldr	r3, [r7, #4]
 80080ac:	689b      	ldr	r3, [r3, #8]
 80080ae:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 80080b2:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80080b6:	d101      	bne.n	80080bc <LL_ADC_IsCalibrationOnGoing+0x1a>
 80080b8:	2301      	movs	r3, #1
 80080ba:	e000      	b.n	80080be <LL_ADC_IsCalibrationOnGoing+0x1c>
 80080bc:	2300      	movs	r3, #0
}
 80080be:	4618      	mov	r0, r3
 80080c0:	370c      	adds	r7, #12
 80080c2:	46bd      	mov	sp, r7
 80080c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80080c8:	4770      	bx	lr

080080ca <LL_ADC_REG_IsConversionOngoing>:
{
 80080ca:	b480      	push	{r7}
 80080cc:	b083      	sub	sp, #12
 80080ce:	af00      	add	r7, sp, #0
 80080d0:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80080d2:	687b      	ldr	r3, [r7, #4]
 80080d4:	689b      	ldr	r3, [r3, #8]
 80080d6:	f003 0304 	and.w	r3, r3, #4
 80080da:	2b04      	cmp	r3, #4
 80080dc:	d101      	bne.n	80080e2 <LL_ADC_REG_IsConversionOngoing+0x18>
 80080de:	2301      	movs	r3, #1
 80080e0:	e000      	b.n	80080e4 <LL_ADC_REG_IsConversionOngoing+0x1a>
 80080e2:	2300      	movs	r3, #0
}
 80080e4:	4618      	mov	r0, r3
 80080e6:	370c      	adds	r7, #12
 80080e8:	46bd      	mov	sp, r7
 80080ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80080ee:	4770      	bx	lr

080080f0 <HAL_ADCEx_Calibration_Start>:
  *           @arg @ref ADC_SINGLE_ENDED       Channel in mode input single ended
  *           @arg @ref ADC_DIFFERENTIAL_ENDED Channel in mode input differential ended
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc, uint32_t SingleDiff)
{
 80080f0:	b580      	push	{r7, lr}
 80080f2:	b084      	sub	sp, #16
 80080f4:	af00      	add	r7, sp, #0
 80080f6:	6078      	str	r0, [r7, #4]
 80080f8:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status;
  __IO uint32_t wait_loop_index = 0UL;
 80080fa:	2300      	movs	r3, #0
 80080fc:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));

  /* Process locked */
  __HAL_LOCK(hadc);
 80080fe:	687b      	ldr	r3, [r7, #4]
 8008100:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 8008104:	2b01      	cmp	r3, #1
 8008106:	d101      	bne.n	800810c <HAL_ADCEx_Calibration_Start+0x1c>
 8008108:	2302      	movs	r3, #2
 800810a:	e04d      	b.n	80081a8 <HAL_ADCEx_Calibration_Start+0xb8>
 800810c:	687b      	ldr	r3, [r7, #4]
 800810e:	2201      	movs	r2, #1
 8008110:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

  /* Calibration prerequisite: ADC must be disabled. */

  /* Disable the ADC (if not already disabled) */
  tmp_hal_status = ADC_Disable(hadc);
 8008114:	6878      	ldr	r0, [r7, #4]
 8008116:	f7ff fea5 	bl	8007e64 <ADC_Disable>
 800811a:	4603      	mov	r3, r0
 800811c:	73fb      	strb	r3, [r7, #15]

  /* Check if ADC is effectively disabled */
  if (tmp_hal_status == HAL_OK)
 800811e:	7bfb      	ldrb	r3, [r7, #15]
 8008120:	2b00      	cmp	r3, #0
 8008122:	d136      	bne.n	8008192 <HAL_ADCEx_Calibration_Start+0xa2>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8008124:	687b      	ldr	r3, [r7, #4]
 8008126:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8008128:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 800812c:	f023 0302 	bic.w	r3, r3, #2
 8008130:	f043 0202 	orr.w	r2, r3, #2
 8008134:	687b      	ldr	r3, [r7, #4]
 8008136:	65da      	str	r2, [r3, #92]	; 0x5c
                      HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
                      HAL_ADC_STATE_BUSY_INTERNAL);

    /* Start ADC calibration in mode single-ended or differential */
    LL_ADC_StartCalibration(hadc->Instance, SingleDiff);
 8008138:	687b      	ldr	r3, [r7, #4]
 800813a:	681b      	ldr	r3, [r3, #0]
 800813c:	6839      	ldr	r1, [r7, #0]
 800813e:	4618      	mov	r0, r3
 8008140:	f7ff ff96 	bl	8008070 <LL_ADC_StartCalibration>

    /* Wait for calibration completion */
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
 8008144:	e014      	b.n	8008170 <HAL_ADCEx_Calibration_Start+0x80>
    {
      wait_loop_index++;
 8008146:	68bb      	ldr	r3, [r7, #8]
 8008148:	3301      	adds	r3, #1
 800814a:	60bb      	str	r3, [r7, #8]
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
 800814c:	68bb      	ldr	r3, [r7, #8]
 800814e:	4a18      	ldr	r2, [pc, #96]	; (80081b0 <HAL_ADCEx_Calibration_Start+0xc0>)
 8008150:	4293      	cmp	r3, r2
 8008152:	d90d      	bls.n	8008170 <HAL_ADCEx_Calibration_Start+0x80>
      {
        /* Update ADC state machine to error */
        ADC_STATE_CLR_SET(hadc->State,
 8008154:	687b      	ldr	r3, [r7, #4]
 8008156:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8008158:	f023 0312 	bic.w	r3, r3, #18
 800815c:	f043 0210 	orr.w	r2, r3, #16
 8008160:	687b      	ldr	r3, [r7, #4]
 8008162:	65da      	str	r2, [r3, #92]	; 0x5c
                          HAL_ADC_STATE_BUSY_INTERNAL,
                          HAL_ADC_STATE_ERROR_INTERNAL);

        /* Process unlocked */
        __HAL_UNLOCK(hadc);
 8008164:	687b      	ldr	r3, [r7, #4]
 8008166:	2200      	movs	r2, #0
 8008168:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

        return HAL_ERROR;
 800816c:	2301      	movs	r3, #1
 800816e:	e01b      	b.n	80081a8 <HAL_ADCEx_Calibration_Start+0xb8>
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
 8008170:	687b      	ldr	r3, [r7, #4]
 8008172:	681b      	ldr	r3, [r3, #0]
 8008174:	4618      	mov	r0, r3
 8008176:	f7ff ff94 	bl	80080a2 <LL_ADC_IsCalibrationOnGoing>
 800817a:	4603      	mov	r3, r0
 800817c:	2b00      	cmp	r3, #0
 800817e:	d1e2      	bne.n	8008146 <HAL_ADCEx_Calibration_Start+0x56>
      }
    }

    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8008180:	687b      	ldr	r3, [r7, #4]
 8008182:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8008184:	f023 0303 	bic.w	r3, r3, #3
 8008188:	f043 0201 	orr.w	r2, r3, #1
 800818c:	687b      	ldr	r3, [r7, #4]
 800818e:	65da      	str	r2, [r3, #92]	; 0x5c
 8008190:	e005      	b.n	800819e <HAL_ADCEx_Calibration_Start+0xae>
                      HAL_ADC_STATE_BUSY_INTERNAL,
                      HAL_ADC_STATE_READY);
  }
  else
  {
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8008192:	687b      	ldr	r3, [r7, #4]
 8008194:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8008196:	f043 0210 	orr.w	r2, r3, #16
 800819a:	687b      	ldr	r3, [r7, #4]
 800819c:	65da      	str	r2, [r3, #92]	; 0x5c
    /* Note: No need to update variable "tmp_hal_status" here: already set    */
    /*       to state "HAL_ERROR" by function disabling the ADC.              */
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 800819e:	687b      	ldr	r3, [r7, #4]
 80081a0:	2200      	movs	r2, #0
 80081a2:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

  /* Return function status */
  return tmp_hal_status;
 80081a6:	7bfb      	ldrb	r3, [r7, #15]
}
 80081a8:	4618      	mov	r0, r3
 80081aa:	3710      	adds	r7, #16
 80081ac:	46bd      	mov	sp, r7
 80081ae:	bd80      	pop	{r7, pc}
 80081b0:	0004de01 	.word	0x0004de01

080081b4 <HAL_ADCEx_InjectedConvCpltCallback>:
  * @brief  Injected conversion complete callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef *hadc)
{
 80081b4:	b480      	push	{r7}
 80081b6:	b083      	sub	sp, #12
 80081b8:	af00      	add	r7, sp, #0
 80081ba:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_InjectedConvCpltCallback must be implemented in the user file.
  */
}
 80081bc:	bf00      	nop
 80081be:	370c      	adds	r7, #12
 80081c0:	46bd      	mov	sp, r7
 80081c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80081c6:	4770      	bx	lr

080081c8 <HAL_ADCEx_InjectedQueueOverflowCallback>:
            contexts).
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_InjectedQueueOverflowCallback(ADC_HandleTypeDef *hadc)
{
 80081c8:	b480      	push	{r7}
 80081ca:	b083      	sub	sp, #12
 80081cc:	af00      	add	r7, sp, #0
 80081ce:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_InjectedQueueOverflowCallback must be implemented in the user file.
  */
}
 80081d0:	bf00      	nop
 80081d2:	370c      	adds	r7, #12
 80081d4:	46bd      	mov	sp, r7
 80081d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80081da:	4770      	bx	lr

080081dc <HAL_ADCEx_LevelOutOfWindow3Callback>:
  * @brief  Analog watchdog 3 callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_LevelOutOfWindow3Callback(ADC_HandleTypeDef *hadc)
{
 80081dc:	b480      	push	{r7}
 80081de:	b083      	sub	sp, #12
 80081e0:	af00      	add	r7, sp, #0
 80081e2:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_LevelOutOfWindow3Callback must be implemented in the user file.
  */
}
 80081e4:	bf00      	nop
 80081e6:	370c      	adds	r7, #12
 80081e8:	46bd      	mov	sp, r7
 80081ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80081ee:	4770      	bx	lr

080081f0 <HAL_ADCEx_EndOfSamplingCallback>:
  * @brief  End Of Sampling callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_EndOfSamplingCallback(ADC_HandleTypeDef *hadc)
{
 80081f0:	b480      	push	{r7}
 80081f2:	b083      	sub	sp, #12
 80081f4:	af00      	add	r7, sp, #0
 80081f6:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_EndOfSamplingCallback must be implemented in the user file.
  */
}
 80081f8:	bf00      	nop
 80081fa:	370c      	adds	r7, #12
 80081fc:	46bd      	mov	sp, r7
 80081fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008202:	4770      	bx	lr

08008204 <HAL_ADCEx_MultiModeConfigChannel>:
  * @param hadc Master ADC handle
  * @param multimode Structure of ADC multimode configuration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef *hadc, ADC_MultiModeTypeDef *multimode)
{
 8008204:	b590      	push	{r4, r7, lr}
 8008206:	b0a1      	sub	sp, #132	; 0x84
 8008208:	af00      	add	r7, sp, #0
 800820a:	6078      	str	r0, [r7, #4]
 800820c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800820e:	2300      	movs	r3, #0
 8008210:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
    assert_param(IS_ADC_DMA_ACCESS_MULTIMODE(multimode->DMAAccessMode));
    assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8008214:	687b      	ldr	r3, [r7, #4]
 8008216:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 800821a:	2b01      	cmp	r3, #1
 800821c:	d101      	bne.n	8008222 <HAL_ADCEx_MultiModeConfigChannel+0x1e>
 800821e:	2302      	movs	r3, #2
 8008220:	e0e7      	b.n	80083f2 <HAL_ADCEx_MultiModeConfigChannel+0x1ee>
 8008222:	687b      	ldr	r3, [r7, #4]
 8008224:	2201      	movs	r2, #1
 8008226:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

  /* Temporary handle minimum initialization */
  __HAL_ADC_RESET_HANDLE_STATE(&tmphadcSlave);
 800822a:	2300      	movs	r3, #0
 800822c:	667b      	str	r3, [r7, #100]	; 0x64
  ADC_CLEAR_ERRORCODE(&tmphadcSlave);
 800822e:	2300      	movs	r3, #0
 8008230:	66bb      	str	r3, [r7, #104]	; 0x68

  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
 8008232:	687b      	ldr	r3, [r7, #4]
 8008234:	681b      	ldr	r3, [r3, #0]
 8008236:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 800823a:	d102      	bne.n	8008242 <HAL_ADCEx_MultiModeConfigChannel+0x3e>
 800823c:	4b6f      	ldr	r3, [pc, #444]	; (80083fc <HAL_ADCEx_MultiModeConfigChannel+0x1f8>)
 800823e:	60bb      	str	r3, [r7, #8]
 8008240:	e009      	b.n	8008256 <HAL_ADCEx_MultiModeConfigChannel+0x52>
 8008242:	687b      	ldr	r3, [r7, #4]
 8008244:	681b      	ldr	r3, [r3, #0]
 8008246:	4a6e      	ldr	r2, [pc, #440]	; (8008400 <HAL_ADCEx_MultiModeConfigChannel+0x1fc>)
 8008248:	4293      	cmp	r3, r2
 800824a:	d102      	bne.n	8008252 <HAL_ADCEx_MultiModeConfigChannel+0x4e>
 800824c:	4b6d      	ldr	r3, [pc, #436]	; (8008404 <HAL_ADCEx_MultiModeConfigChannel+0x200>)
 800824e:	60bb      	str	r3, [r7, #8]
 8008250:	e001      	b.n	8008256 <HAL_ADCEx_MultiModeConfigChannel+0x52>
 8008252:	2300      	movs	r3, #0
 8008254:	60bb      	str	r3, [r7, #8]

  if (tmphadcSlave.Instance == NULL)
 8008256:	68bb      	ldr	r3, [r7, #8]
 8008258:	2b00      	cmp	r3, #0
 800825a:	d10b      	bne.n	8008274 <HAL_ADCEx_MultiModeConfigChannel+0x70>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800825c:	687b      	ldr	r3, [r7, #4]
 800825e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8008260:	f043 0220 	orr.w	r2, r3, #32
 8008264:	687b      	ldr	r3, [r7, #4]
 8008266:	65da      	str	r2, [r3, #92]	; 0x5c

    /* Process unlocked */
    __HAL_UNLOCK(hadc);
 8008268:	687b      	ldr	r3, [r7, #4]
 800826a:	2200      	movs	r2, #0
 800826c:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

    return HAL_ERROR;
 8008270:	2301      	movs	r3, #1
 8008272:	e0be      	b.n	80083f2 <HAL_ADCEx_MultiModeConfigChannel+0x1ee>
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Multimode DMA configuration                                           */
  /*  - Multimode DMA mode                                                    */
  tmphadcSlave_conversion_on_going = LL_ADC_REG_IsConversionOngoing((&tmphadcSlave)->Instance);
 8008274:	68bb      	ldr	r3, [r7, #8]
 8008276:	4618      	mov	r0, r3
 8008278:	f7ff ff27 	bl	80080ca <LL_ADC_REG_IsConversionOngoing>
 800827c:	67b8      	str	r0, [r7, #120]	; 0x78
  if ((LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 800827e:	687b      	ldr	r3, [r7, #4]
 8008280:	681b      	ldr	r3, [r3, #0]
 8008282:	4618      	mov	r0, r3
 8008284:	f7ff ff21 	bl	80080ca <LL_ADC_REG_IsConversionOngoing>
 8008288:	4603      	mov	r3, r0
 800828a:	2b00      	cmp	r3, #0
 800828c:	f040 80a0 	bne.w	80083d0 <HAL_ADCEx_MultiModeConfigChannel+0x1cc>
      && (tmphadcSlave_conversion_on_going == 0UL))
 8008290:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8008292:	2b00      	cmp	r3, #0
 8008294:	f040 809c 	bne.w	80083d0 <HAL_ADCEx_MultiModeConfigChannel+0x1cc>
  {
    /* Pointer to the common control register */
    tmpADC_Common = __LL_ADC_COMMON_INSTANCE(hadc->Instance);
 8008298:	687b      	ldr	r3, [r7, #4]
 800829a:	681b      	ldr	r3, [r3, #0]
 800829c:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80082a0:	d004      	beq.n	80082ac <HAL_ADCEx_MultiModeConfigChannel+0xa8>
 80082a2:	687b      	ldr	r3, [r7, #4]
 80082a4:	681b      	ldr	r3, [r3, #0]
 80082a6:	4a55      	ldr	r2, [pc, #340]	; (80083fc <HAL_ADCEx_MultiModeConfigChannel+0x1f8>)
 80082a8:	4293      	cmp	r3, r2
 80082aa:	d101      	bne.n	80082b0 <HAL_ADCEx_MultiModeConfigChannel+0xac>
 80082ac:	4b56      	ldr	r3, [pc, #344]	; (8008408 <HAL_ADCEx_MultiModeConfigChannel+0x204>)
 80082ae:	e000      	b.n	80082b2 <HAL_ADCEx_MultiModeConfigChannel+0xae>
 80082b0:	4b56      	ldr	r3, [pc, #344]	; (800840c <HAL_ADCEx_MultiModeConfigChannel+0x208>)
 80082b2:	677b      	str	r3, [r7, #116]	; 0x74

    /* If multimode is selected, configure all multimode parameters.          */
    /* Otherwise, reset multimode parameters (can be used in case of          */
    /* transition from multimode to independent mode).                        */
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 80082b4:	683b      	ldr	r3, [r7, #0]
 80082b6:	681b      	ldr	r3, [r3, #0]
 80082b8:	2b00      	cmp	r3, #0
 80082ba:	d04b      	beq.n	8008354 <HAL_ADCEx_MultiModeConfigChannel+0x150>
    {
      MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG,
 80082bc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80082be:	689b      	ldr	r3, [r3, #8]
 80082c0:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 80082c4:	683b      	ldr	r3, [r7, #0]
 80082c6:	6859      	ldr	r1, [r3, #4]
 80082c8:	687b      	ldr	r3, [r7, #4]
 80082ca:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 80082ce:	035b      	lsls	r3, r3, #13
 80082d0:	430b      	orrs	r3, r1
 80082d2:	431a      	orrs	r2, r3
 80082d4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80082d6:	609a      	str	r2, [r3, #8]
      /*      from 1 to 10 clock cycles for 10 bits,                              */
      /*      from 1 to 8 clock cycles for 8 bits                                 */
      /*      from 1 to 6 clock cycles for 6 bits                                 */
      /*    If a higher delay is selected, it will be clipped to maximum delay    */
      /*    range                                                                 */
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 80082d8:	687b      	ldr	r3, [r7, #4]
 80082da:	681b      	ldr	r3, [r3, #0]
 80082dc:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80082e0:	d004      	beq.n	80082ec <HAL_ADCEx_MultiModeConfigChannel+0xe8>
 80082e2:	687b      	ldr	r3, [r7, #4]
 80082e4:	681b      	ldr	r3, [r3, #0]
 80082e6:	4a45      	ldr	r2, [pc, #276]	; (80083fc <HAL_ADCEx_MultiModeConfigChannel+0x1f8>)
 80082e8:	4293      	cmp	r3, r2
 80082ea:	d10f      	bne.n	800830c <HAL_ADCEx_MultiModeConfigChannel+0x108>
 80082ec:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
 80082f0:	f7ff feab 	bl	800804a <LL_ADC_IsEnabled>
 80082f4:	4604      	mov	r4, r0
 80082f6:	4841      	ldr	r0, [pc, #260]	; (80083fc <HAL_ADCEx_MultiModeConfigChannel+0x1f8>)
 80082f8:	f7ff fea7 	bl	800804a <LL_ADC_IsEnabled>
 80082fc:	4603      	mov	r3, r0
 80082fe:	4323      	orrs	r3, r4
 8008300:	2b00      	cmp	r3, #0
 8008302:	bf0c      	ite	eq
 8008304:	2301      	moveq	r3, #1
 8008306:	2300      	movne	r3, #0
 8008308:	b2db      	uxtb	r3, r3
 800830a:	e012      	b.n	8008332 <HAL_ADCEx_MultiModeConfigChannel+0x12e>
 800830c:	483c      	ldr	r0, [pc, #240]	; (8008400 <HAL_ADCEx_MultiModeConfigChannel+0x1fc>)
 800830e:	f7ff fe9c 	bl	800804a <LL_ADC_IsEnabled>
 8008312:	4604      	mov	r4, r0
 8008314:	483b      	ldr	r0, [pc, #236]	; (8008404 <HAL_ADCEx_MultiModeConfigChannel+0x200>)
 8008316:	f7ff fe98 	bl	800804a <LL_ADC_IsEnabled>
 800831a:	4603      	mov	r3, r0
 800831c:	431c      	orrs	r4, r3
 800831e:	483c      	ldr	r0, [pc, #240]	; (8008410 <HAL_ADCEx_MultiModeConfigChannel+0x20c>)
 8008320:	f7ff fe93 	bl	800804a <LL_ADC_IsEnabled>
 8008324:	4603      	mov	r3, r0
 8008326:	4323      	orrs	r3, r4
 8008328:	2b00      	cmp	r3, #0
 800832a:	bf0c      	ite	eq
 800832c:	2301      	moveq	r3, #1
 800832e:	2300      	movne	r3, #0
 8008330:	b2db      	uxtb	r3, r3
 8008332:	2b00      	cmp	r3, #0
 8008334:	d056      	beq.n	80083e4 <HAL_ADCEx_MultiModeConfigChannel+0x1e0>
      {
        MODIFY_REG(tmpADC_Common->CCR,
 8008336:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8008338:	689b      	ldr	r3, [r3, #8]
 800833a:	f423 6371 	bic.w	r3, r3, #3856	; 0xf10
 800833e:	f023 030f 	bic.w	r3, r3, #15
 8008342:	683a      	ldr	r2, [r7, #0]
 8008344:	6811      	ldr	r1, [r2, #0]
 8008346:	683a      	ldr	r2, [r7, #0]
 8008348:	6892      	ldr	r2, [r2, #8]
 800834a:	430a      	orrs	r2, r1
 800834c:	431a      	orrs	r2, r3
 800834e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8008350:	609a      	str	r2, [r3, #8]
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 8008352:	e047      	b.n	80083e4 <HAL_ADCEx_MultiModeConfigChannel+0x1e0>
                  );
      }
    }
    else /* ADC_MODE_INDEPENDENT */
    {
      CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG);
 8008354:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8008356:	689b      	ldr	r3, [r3, #8]
 8008358:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 800835c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800835e:	609a      	str	r2, [r3, #8]

      /* Parameters that can be updated only when ADC is disabled:                */
      /*  - Multimode mode selection                                              */
      /*  - Multimode delay                                                       */
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8008360:	687b      	ldr	r3, [r7, #4]
 8008362:	681b      	ldr	r3, [r3, #0]
 8008364:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8008368:	d004      	beq.n	8008374 <HAL_ADCEx_MultiModeConfigChannel+0x170>
 800836a:	687b      	ldr	r3, [r7, #4]
 800836c:	681b      	ldr	r3, [r3, #0]
 800836e:	4a23      	ldr	r2, [pc, #140]	; (80083fc <HAL_ADCEx_MultiModeConfigChannel+0x1f8>)
 8008370:	4293      	cmp	r3, r2
 8008372:	d10f      	bne.n	8008394 <HAL_ADCEx_MultiModeConfigChannel+0x190>
 8008374:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
 8008378:	f7ff fe67 	bl	800804a <LL_ADC_IsEnabled>
 800837c:	4604      	mov	r4, r0
 800837e:	481f      	ldr	r0, [pc, #124]	; (80083fc <HAL_ADCEx_MultiModeConfigChannel+0x1f8>)
 8008380:	f7ff fe63 	bl	800804a <LL_ADC_IsEnabled>
 8008384:	4603      	mov	r3, r0
 8008386:	4323      	orrs	r3, r4
 8008388:	2b00      	cmp	r3, #0
 800838a:	bf0c      	ite	eq
 800838c:	2301      	moveq	r3, #1
 800838e:	2300      	movne	r3, #0
 8008390:	b2db      	uxtb	r3, r3
 8008392:	e012      	b.n	80083ba <HAL_ADCEx_MultiModeConfigChannel+0x1b6>
 8008394:	481a      	ldr	r0, [pc, #104]	; (8008400 <HAL_ADCEx_MultiModeConfigChannel+0x1fc>)
 8008396:	f7ff fe58 	bl	800804a <LL_ADC_IsEnabled>
 800839a:	4604      	mov	r4, r0
 800839c:	4819      	ldr	r0, [pc, #100]	; (8008404 <HAL_ADCEx_MultiModeConfigChannel+0x200>)
 800839e:	f7ff fe54 	bl	800804a <LL_ADC_IsEnabled>
 80083a2:	4603      	mov	r3, r0
 80083a4:	431c      	orrs	r4, r3
 80083a6:	481a      	ldr	r0, [pc, #104]	; (8008410 <HAL_ADCEx_MultiModeConfigChannel+0x20c>)
 80083a8:	f7ff fe4f 	bl	800804a <LL_ADC_IsEnabled>
 80083ac:	4603      	mov	r3, r0
 80083ae:	4323      	orrs	r3, r4
 80083b0:	2b00      	cmp	r3, #0
 80083b2:	bf0c      	ite	eq
 80083b4:	2301      	moveq	r3, #1
 80083b6:	2300      	movne	r3, #0
 80083b8:	b2db      	uxtb	r3, r3
 80083ba:	2b00      	cmp	r3, #0
 80083bc:	d012      	beq.n	80083e4 <HAL_ADCEx_MultiModeConfigChannel+0x1e0>
      {
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
 80083be:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80083c0:	689b      	ldr	r3, [r3, #8]
 80083c2:	f423 6371 	bic.w	r3, r3, #3856	; 0xf10
 80083c6:	f023 030f 	bic.w	r3, r3, #15
 80083ca:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 80083cc:	6093      	str	r3, [r2, #8]
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 80083ce:	e009      	b.n	80083e4 <HAL_ADCEx_MultiModeConfigChannel+0x1e0>
  /* If one of the ADC sharing the same common group is enabled, no update    */
  /* could be done on neither of the multimode structure parameters.          */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80083d0:	687b      	ldr	r3, [r7, #4]
 80083d2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80083d4:	f043 0220 	orr.w	r2, r3, #32
 80083d8:	687b      	ldr	r3, [r7, #4]
 80083da:	65da      	str	r2, [r3, #92]	; 0x5c

    tmp_hal_status = HAL_ERROR;
 80083dc:	2301      	movs	r3, #1
 80083de:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
 80083e2:	e000      	b.n	80083e6 <HAL_ADCEx_MultiModeConfigChannel+0x1e2>
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 80083e4:	bf00      	nop
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80083e6:	687b      	ldr	r3, [r7, #4]
 80083e8:	2200      	movs	r2, #0
 80083ea:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

  /* Return function status */
  return tmp_hal_status;
 80083ee:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
}
 80083f2:	4618      	mov	r0, r3
 80083f4:	3784      	adds	r7, #132	; 0x84
 80083f6:	46bd      	mov	sp, r7
 80083f8:	bd90      	pop	{r4, r7, pc}
 80083fa:	bf00      	nop
 80083fc:	50000100 	.word	0x50000100
 8008400:	50000400 	.word	0x50000400
 8008404:	50000500 	.word	0x50000500
 8008408:	50000300 	.word	0x50000300
 800840c:	50000700 	.word	0x50000700
 8008410:	50000600 	.word	0x50000600

08008414 <__NVIC_SetPriorityGrouping>:
{
 8008414:	b480      	push	{r7}
 8008416:	b085      	sub	sp, #20
 8008418:	af00      	add	r7, sp, #0
 800841a:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800841c:	687b      	ldr	r3, [r7, #4]
 800841e:	f003 0307 	and.w	r3, r3, #7
 8008422:	60fb      	str	r3, [r7, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8008424:	4b0c      	ldr	r3, [pc, #48]	; (8008458 <__NVIC_SetPriorityGrouping+0x44>)
 8008426:	68db      	ldr	r3, [r3, #12]
 8008428:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800842a:	68ba      	ldr	r2, [r7, #8]
 800842c:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8008430:	4013      	ands	r3, r2
 8008432:	60bb      	str	r3, [r7, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8008434:	68fb      	ldr	r3, [r7, #12]
 8008436:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8008438:	68bb      	ldr	r3, [r7, #8]
 800843a:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800843c:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8008440:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8008444:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8008446:	4a04      	ldr	r2, [pc, #16]	; (8008458 <__NVIC_SetPriorityGrouping+0x44>)
 8008448:	68bb      	ldr	r3, [r7, #8]
 800844a:	60d3      	str	r3, [r2, #12]
}
 800844c:	bf00      	nop
 800844e:	3714      	adds	r7, #20
 8008450:	46bd      	mov	sp, r7
 8008452:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008456:	4770      	bx	lr
 8008458:	e000ed00 	.word	0xe000ed00

0800845c <__NVIC_GetPriorityGrouping>:
{
 800845c:	b480      	push	{r7}
 800845e:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8008460:	4b04      	ldr	r3, [pc, #16]	; (8008474 <__NVIC_GetPriorityGrouping+0x18>)
 8008462:	68db      	ldr	r3, [r3, #12]
 8008464:	0a1b      	lsrs	r3, r3, #8
 8008466:	f003 0307 	and.w	r3, r3, #7
}
 800846a:	4618      	mov	r0, r3
 800846c:	46bd      	mov	sp, r7
 800846e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008472:	4770      	bx	lr
 8008474:	e000ed00 	.word	0xe000ed00

08008478 <__NVIC_EnableIRQ>:
{
 8008478:	b480      	push	{r7}
 800847a:	b083      	sub	sp, #12
 800847c:	af00      	add	r7, sp, #0
 800847e:	4603      	mov	r3, r0
 8008480:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8008482:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8008486:	2b00      	cmp	r3, #0
 8008488:	db0b      	blt.n	80084a2 <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800848a:	79fb      	ldrb	r3, [r7, #7]
 800848c:	f003 021f 	and.w	r2, r3, #31
 8008490:	4907      	ldr	r1, [pc, #28]	; (80084b0 <__NVIC_EnableIRQ+0x38>)
 8008492:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8008496:	095b      	lsrs	r3, r3, #5
 8008498:	2001      	movs	r0, #1
 800849a:	fa00 f202 	lsl.w	r2, r0, r2
 800849e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80084a2:	bf00      	nop
 80084a4:	370c      	adds	r7, #12
 80084a6:	46bd      	mov	sp, r7
 80084a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80084ac:	4770      	bx	lr
 80084ae:	bf00      	nop
 80084b0:	e000e100 	.word	0xe000e100

080084b4 <__NVIC_SetPriority>:
{
 80084b4:	b480      	push	{r7}
 80084b6:	b083      	sub	sp, #12
 80084b8:	af00      	add	r7, sp, #0
 80084ba:	4603      	mov	r3, r0
 80084bc:	6039      	str	r1, [r7, #0]
 80084be:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80084c0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80084c4:	2b00      	cmp	r3, #0
 80084c6:	db0a      	blt.n	80084de <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80084c8:	683b      	ldr	r3, [r7, #0]
 80084ca:	b2da      	uxtb	r2, r3
 80084cc:	490c      	ldr	r1, [pc, #48]	; (8008500 <__NVIC_SetPriority+0x4c>)
 80084ce:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80084d2:	0112      	lsls	r2, r2, #4
 80084d4:	b2d2      	uxtb	r2, r2
 80084d6:	440b      	add	r3, r1
 80084d8:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 80084dc:	e00a      	b.n	80084f4 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80084de:	683b      	ldr	r3, [r7, #0]
 80084e0:	b2da      	uxtb	r2, r3
 80084e2:	4908      	ldr	r1, [pc, #32]	; (8008504 <__NVIC_SetPriority+0x50>)
 80084e4:	79fb      	ldrb	r3, [r7, #7]
 80084e6:	f003 030f 	and.w	r3, r3, #15
 80084ea:	3b04      	subs	r3, #4
 80084ec:	0112      	lsls	r2, r2, #4
 80084ee:	b2d2      	uxtb	r2, r2
 80084f0:	440b      	add	r3, r1
 80084f2:	761a      	strb	r2, [r3, #24]
}
 80084f4:	bf00      	nop
 80084f6:	370c      	adds	r7, #12
 80084f8:	46bd      	mov	sp, r7
 80084fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80084fe:	4770      	bx	lr
 8008500:	e000e100 	.word	0xe000e100
 8008504:	e000ed00 	.word	0xe000ed00

08008508 <NVIC_EncodePriority>:
{
 8008508:	b480      	push	{r7}
 800850a:	b089      	sub	sp, #36	; 0x24
 800850c:	af00      	add	r7, sp, #0
 800850e:	60f8      	str	r0, [r7, #12]
 8008510:	60b9      	str	r1, [r7, #8]
 8008512:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8008514:	68fb      	ldr	r3, [r7, #12]
 8008516:	f003 0307 	and.w	r3, r3, #7
 800851a:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800851c:	69fb      	ldr	r3, [r7, #28]
 800851e:	f1c3 0307 	rsb	r3, r3, #7
 8008522:	2b04      	cmp	r3, #4
 8008524:	bf28      	it	cs
 8008526:	2304      	movcs	r3, #4
 8008528:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800852a:	69fb      	ldr	r3, [r7, #28]
 800852c:	3304      	adds	r3, #4
 800852e:	2b06      	cmp	r3, #6
 8008530:	d902      	bls.n	8008538 <NVIC_EncodePriority+0x30>
 8008532:	69fb      	ldr	r3, [r7, #28]
 8008534:	3b03      	subs	r3, #3
 8008536:	e000      	b.n	800853a <NVIC_EncodePriority+0x32>
 8008538:	2300      	movs	r3, #0
 800853a:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800853c:	f04f 32ff 	mov.w	r2, #4294967295
 8008540:	69bb      	ldr	r3, [r7, #24]
 8008542:	fa02 f303 	lsl.w	r3, r2, r3
 8008546:	43da      	mvns	r2, r3
 8008548:	68bb      	ldr	r3, [r7, #8]
 800854a:	401a      	ands	r2, r3
 800854c:	697b      	ldr	r3, [r7, #20]
 800854e:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8008550:	f04f 31ff 	mov.w	r1, #4294967295
 8008554:	697b      	ldr	r3, [r7, #20]
 8008556:	fa01 f303 	lsl.w	r3, r1, r3
 800855a:	43d9      	mvns	r1, r3
 800855c:	687b      	ldr	r3, [r7, #4]
 800855e:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8008560:	4313      	orrs	r3, r2
}
 8008562:	4618      	mov	r0, r3
 8008564:	3724      	adds	r7, #36	; 0x24
 8008566:	46bd      	mov	sp, r7
 8008568:	f85d 7b04 	ldr.w	r7, [sp], #4
 800856c:	4770      	bx	lr
	...

08008570 <SysTick_Config>:
{
 8008570:	b580      	push	{r7, lr}
 8008572:	b082      	sub	sp, #8
 8008574:	af00      	add	r7, sp, #0
 8008576:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8008578:	687b      	ldr	r3, [r7, #4]
 800857a:	3b01      	subs	r3, #1
 800857c:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8008580:	d301      	bcc.n	8008586 <SysTick_Config+0x16>
    return (1UL);                                                   /* Reload value impossible */
 8008582:	2301      	movs	r3, #1
 8008584:	e00f      	b.n	80085a6 <SysTick_Config+0x36>
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8008586:	4a0a      	ldr	r2, [pc, #40]	; (80085b0 <SysTick_Config+0x40>)
 8008588:	687b      	ldr	r3, [r7, #4]
 800858a:	3b01      	subs	r3, #1
 800858c:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 800858e:	210f      	movs	r1, #15
 8008590:	f04f 30ff 	mov.w	r0, #4294967295
 8008594:	f7ff ff8e 	bl	80084b4 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8008598:	4b05      	ldr	r3, [pc, #20]	; (80085b0 <SysTick_Config+0x40>)
 800859a:	2200      	movs	r2, #0
 800859c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800859e:	4b04      	ldr	r3, [pc, #16]	; (80085b0 <SysTick_Config+0x40>)
 80085a0:	2207      	movs	r2, #7
 80085a2:	601a      	str	r2, [r3, #0]
  return (0UL);                                                     /* Function successful */
 80085a4:	2300      	movs	r3, #0
}
 80085a6:	4618      	mov	r0, r3
 80085a8:	3708      	adds	r7, #8
 80085aa:	46bd      	mov	sp, r7
 80085ac:	bd80      	pop	{r7, pc}
 80085ae:	bf00      	nop
 80085b0:	e000e010 	.word	0xe000e010

080085b4 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80085b4:	b580      	push	{r7, lr}
 80085b6:	b082      	sub	sp, #8
 80085b8:	af00      	add	r7, sp, #0
 80085ba:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 80085bc:	6878      	ldr	r0, [r7, #4]
 80085be:	f7ff ff29 	bl	8008414 <__NVIC_SetPriorityGrouping>
}
 80085c2:	bf00      	nop
 80085c4:	3708      	adds	r7, #8
 80085c6:	46bd      	mov	sp, r7
 80085c8:	bd80      	pop	{r7, pc}

080085ca <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80085ca:	b580      	push	{r7, lr}
 80085cc:	b086      	sub	sp, #24
 80085ce:	af00      	add	r7, sp, #0
 80085d0:	4603      	mov	r3, r0
 80085d2:	60b9      	str	r1, [r7, #8]
 80085d4:	607a      	str	r2, [r7, #4]
 80085d6:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 80085d8:	f7ff ff40 	bl	800845c <__NVIC_GetPriorityGrouping>
 80085dc:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 80085de:	687a      	ldr	r2, [r7, #4]
 80085e0:	68b9      	ldr	r1, [r7, #8]
 80085e2:	6978      	ldr	r0, [r7, #20]
 80085e4:	f7ff ff90 	bl	8008508 <NVIC_EncodePriority>
 80085e8:	4602      	mov	r2, r0
 80085ea:	f997 300f 	ldrsb.w	r3, [r7, #15]
 80085ee:	4611      	mov	r1, r2
 80085f0:	4618      	mov	r0, r3
 80085f2:	f7ff ff5f 	bl	80084b4 <__NVIC_SetPriority>
}
 80085f6:	bf00      	nop
 80085f8:	3718      	adds	r7, #24
 80085fa:	46bd      	mov	sp, r7
 80085fc:	bd80      	pop	{r7, pc}

080085fe <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32g4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80085fe:	b580      	push	{r7, lr}
 8008600:	b082      	sub	sp, #8
 8008602:	af00      	add	r7, sp, #0
 8008604:	4603      	mov	r3, r0
 8008606:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8008608:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800860c:	4618      	mov	r0, r3
 800860e:	f7ff ff33 	bl	8008478 <__NVIC_EnableIRQ>
}
 8008612:	bf00      	nop
 8008614:	3708      	adds	r7, #8
 8008616:	46bd      	mov	sp, r7
 8008618:	bd80      	pop	{r7, pc}

0800861a <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800861a:	b580      	push	{r7, lr}
 800861c:	b082      	sub	sp, #8
 800861e:	af00      	add	r7, sp, #0
 8008620:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8008622:	6878      	ldr	r0, [r7, #4]
 8008624:	f7ff ffa4 	bl	8008570 <SysTick_Config>
 8008628:	4603      	mov	r3, r0
}
 800862a:	4618      	mov	r0, r3
 800862c:	3708      	adds	r7, #8
 800862e:	46bd      	mov	sp, r7
 8008630:	bd80      	pop	{r7, pc}

08008632 <HAL_DAC_Init>:
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DAC_Init(DAC_HandleTypeDef *hdac)
{
 8008632:	b580      	push	{r7, lr}
 8008634:	b082      	sub	sp, #8
 8008636:	af00      	add	r7, sp, #0
 8008638:	6078      	str	r0, [r7, #4]
  /* Check DAC handle */
  if (hdac == NULL)
 800863a:	687b      	ldr	r3, [r7, #4]
 800863c:	2b00      	cmp	r3, #0
 800863e:	d101      	bne.n	8008644 <HAL_DAC_Init+0x12>
  {
    return HAL_ERROR;
 8008640:	2301      	movs	r3, #1
 8008642:	e014      	b.n	800866e <HAL_DAC_Init+0x3c>
  }
  /* Check the parameters */
  assert_param(IS_DAC_ALL_INSTANCE(hdac->Instance));

  if (hdac->State == HAL_DAC_STATE_RESET)
 8008644:	687b      	ldr	r3, [r7, #4]
 8008646:	791b      	ldrb	r3, [r3, #4]
 8008648:	b2db      	uxtb	r3, r3
 800864a:	2b00      	cmp	r3, #0
 800864c:	d105      	bne.n	800865a <HAL_DAC_Init+0x28>
      hdac->MspInitCallback             = HAL_DAC_MspInit;
    }
#endif /* USE_HAL_DAC_REGISTER_CALLBACKS */

    /* Allocate lock resource and initialize it */
    hdac->Lock = HAL_UNLOCKED;
 800864e:	687b      	ldr	r3, [r7, #4]
 8008650:	2200      	movs	r2, #0
 8008652:	715a      	strb	r2, [r3, #5]
#if (USE_HAL_DAC_REGISTER_CALLBACKS == 1)
    /* Init the low level hardware */
    hdac->MspInitCallback(hdac);
#else
    /* Init the low level hardware */
    HAL_DAC_MspInit(hdac);
 8008654:	6878      	ldr	r0, [r7, #4]
 8008656:	f7f8 ff45 	bl	80014e4 <HAL_DAC_MspInit>
#endif /* USE_HAL_DAC_REGISTER_CALLBACKS */
  }

  /* Initialize the DAC state*/
  hdac->State = HAL_DAC_STATE_BUSY;
 800865a:	687b      	ldr	r3, [r7, #4]
 800865c:	2202      	movs	r2, #2
 800865e:	711a      	strb	r2, [r3, #4]

  /* Set DAC error code to none */
  hdac->ErrorCode = HAL_DAC_ERROR_NONE;
 8008660:	687b      	ldr	r3, [r7, #4]
 8008662:	2200      	movs	r2, #0
 8008664:	611a      	str	r2, [r3, #16]

  /* Initialize the DAC state*/
  hdac->State = HAL_DAC_STATE_READY;
 8008666:	687b      	ldr	r3, [r7, #4]
 8008668:	2201      	movs	r2, #1
 800866a:	711a      	strb	r2, [r3, #4]

  /* Return function status */
  return HAL_OK;
 800866c:	2300      	movs	r3, #0
}
 800866e:	4618      	mov	r0, r3
 8008670:	3708      	adds	r7, #8
 8008672:	46bd      	mov	sp, r7
 8008674:	bd80      	pop	{r7, pc}

08008676 <HAL_DAC_Start>:
  *         (1) On this STM32 series, parameter not available on all instances.
  *             Refer to device datasheet for channels availability.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DAC_Start(DAC_HandleTypeDef *hdac, uint32_t Channel)
{
 8008676:	b580      	push	{r7, lr}
 8008678:	b082      	sub	sp, #8
 800867a:	af00      	add	r7, sp, #0
 800867c:	6078      	str	r0, [r7, #4]
 800867e:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(hdac->Instance, Channel));

  /* Process locked */
  __HAL_LOCK(hdac);
 8008680:	687b      	ldr	r3, [r7, #4]
 8008682:	795b      	ldrb	r3, [r3, #5]
 8008684:	2b01      	cmp	r3, #1
 8008686:	d101      	bne.n	800868c <HAL_DAC_Start+0x16>
 8008688:	2302      	movs	r3, #2
 800868a:	e043      	b.n	8008714 <HAL_DAC_Start+0x9e>
 800868c:	687b      	ldr	r3, [r7, #4]
 800868e:	2201      	movs	r2, #1
 8008690:	715a      	strb	r2, [r3, #5]

  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_BUSY;
 8008692:	687b      	ldr	r3, [r7, #4]
 8008694:	2202      	movs	r2, #2
 8008696:	711a      	strb	r2, [r3, #4]

  /* Enable the Peripheral */
  __HAL_DAC_ENABLE(hdac, Channel);
 8008698:	687b      	ldr	r3, [r7, #4]
 800869a:	681b      	ldr	r3, [r3, #0]
 800869c:	6819      	ldr	r1, [r3, #0]
 800869e:	683b      	ldr	r3, [r7, #0]
 80086a0:	f003 0310 	and.w	r3, r3, #16
 80086a4:	2201      	movs	r2, #1
 80086a6:	409a      	lsls	r2, r3
 80086a8:	687b      	ldr	r3, [r7, #4]
 80086aa:	681b      	ldr	r3, [r3, #0]
 80086ac:	430a      	orrs	r2, r1
 80086ae:	601a      	str	r2, [r3, #0]
  /* Ensure minimum wait before using peripheral after enabling it */
  HAL_Delay(1);
 80086b0:	2001      	movs	r0, #1
 80086b2:	f7fd fb5b 	bl	8005d6c <HAL_Delay>

  if (Channel == DAC_CHANNEL_1)
 80086b6:	683b      	ldr	r3, [r7, #0]
 80086b8:	2b00      	cmp	r3, #0
 80086ba:	d10f      	bne.n	80086dc <HAL_DAC_Start+0x66>
  {
    /* Check if software trigger enabled */
    if ((hdac->Instance->CR & (DAC_CR_TEN1 | DAC_CR_TSEL1)) == DAC_TRIGGER_SOFTWARE)
 80086bc:	687b      	ldr	r3, [r7, #4]
 80086be:	681b      	ldr	r3, [r3, #0]
 80086c0:	681b      	ldr	r3, [r3, #0]
 80086c2:	f003 033e 	and.w	r3, r3, #62	; 0x3e
 80086c6:	2b02      	cmp	r3, #2
 80086c8:	d11d      	bne.n	8008706 <HAL_DAC_Start+0x90>
    {
      /* Enable the selected DAC software conversion */
      SET_BIT(hdac->Instance->SWTRIGR, DAC_SWTRIGR_SWTRIG1);
 80086ca:	687b      	ldr	r3, [r7, #4]
 80086cc:	681b      	ldr	r3, [r3, #0]
 80086ce:	685a      	ldr	r2, [r3, #4]
 80086d0:	687b      	ldr	r3, [r7, #4]
 80086d2:	681b      	ldr	r3, [r3, #0]
 80086d4:	f042 0201 	orr.w	r2, r2, #1
 80086d8:	605a      	str	r2, [r3, #4]
 80086da:	e014      	b.n	8008706 <HAL_DAC_Start+0x90>
  }

  else
  {
    /* Check if software trigger enabled */
    if ((hdac->Instance->CR & (DAC_CR_TEN2 | DAC_CR_TSEL2)) == (DAC_TRIGGER_SOFTWARE << (Channel & 0x10UL)))
 80086dc:	687b      	ldr	r3, [r7, #4]
 80086de:	681b      	ldr	r3, [r3, #0]
 80086e0:	681b      	ldr	r3, [r3, #0]
 80086e2:	f403 1278 	and.w	r2, r3, #4063232	; 0x3e0000
 80086e6:	683b      	ldr	r3, [r7, #0]
 80086e8:	f003 0310 	and.w	r3, r3, #16
 80086ec:	2102      	movs	r1, #2
 80086ee:	fa01 f303 	lsl.w	r3, r1, r3
 80086f2:	429a      	cmp	r2, r3
 80086f4:	d107      	bne.n	8008706 <HAL_DAC_Start+0x90>
    {
      /* Enable the selected DAC software conversion*/
      SET_BIT(hdac->Instance->SWTRIGR, DAC_SWTRIGR_SWTRIG2);
 80086f6:	687b      	ldr	r3, [r7, #4]
 80086f8:	681b      	ldr	r3, [r3, #0]
 80086fa:	685a      	ldr	r2, [r3, #4]
 80086fc:	687b      	ldr	r3, [r7, #4]
 80086fe:	681b      	ldr	r3, [r3, #0]
 8008700:	f042 0202 	orr.w	r2, r2, #2
 8008704:	605a      	str	r2, [r3, #4]
    }
  }


  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_READY;
 8008706:	687b      	ldr	r3, [r7, #4]
 8008708:	2201      	movs	r2, #1
 800870a:	711a      	strb	r2, [r3, #4]

  /* Process unlocked */
  __HAL_UNLOCK(hdac);
 800870c:	687b      	ldr	r3, [r7, #4]
 800870e:	2200      	movs	r2, #0
 8008710:	715a      	strb	r2, [r3, #5]

  /* Return function status */
  return HAL_OK;
 8008712:	2300      	movs	r3, #0
}
 8008714:	4618      	mov	r0, r3
 8008716:	3708      	adds	r7, #8
 8008718:	46bd      	mov	sp, r7
 800871a:	bd80      	pop	{r7, pc}

0800871c <HAL_DAC_Start_DMA>:
  *            @arg DAC_ALIGN_12B_R: 12bit right data alignment selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DAC_Start_DMA(DAC_HandleTypeDef *hdac, uint32_t Channel, uint32_t *pData, uint32_t Length,
                                    uint32_t Alignment)
{
 800871c:	b580      	push	{r7, lr}
 800871e:	b086      	sub	sp, #24
 8008720:	af00      	add	r7, sp, #0
 8008722:	60f8      	str	r0, [r7, #12]
 8008724:	60b9      	str	r1, [r7, #8]
 8008726:	607a      	str	r2, [r7, #4]
 8008728:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tmpreg = 0U;
 800872a:	2300      	movs	r3, #0
 800872c:	613b      	str	r3, [r7, #16]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(hdac->Instance, Channel));
  assert_param(IS_DAC_ALIGN(Alignment));

  /* Process locked */
  __HAL_LOCK(hdac);
 800872e:	68fb      	ldr	r3, [r7, #12]
 8008730:	795b      	ldrb	r3, [r3, #5]
 8008732:	2b01      	cmp	r3, #1
 8008734:	d101      	bne.n	800873a <HAL_DAC_Start_DMA+0x1e>
 8008736:	2302      	movs	r3, #2
 8008738:	e0ae      	b.n	8008898 <HAL_DAC_Start_DMA+0x17c>
 800873a:	68fb      	ldr	r3, [r7, #12]
 800873c:	2201      	movs	r2, #1
 800873e:	715a      	strb	r2, [r3, #5]

  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_BUSY;
 8008740:	68fb      	ldr	r3, [r7, #12]
 8008742:	2202      	movs	r2, #2
 8008744:	711a      	strb	r2, [r3, #4]

  if (Channel == DAC_CHANNEL_1)
 8008746:	68bb      	ldr	r3, [r7, #8]
 8008748:	2b00      	cmp	r3, #0
 800874a:	d12f      	bne.n	80087ac <HAL_DAC_Start_DMA+0x90>
  {
    /* Set the DMA transfer complete callback for channel1 */
    hdac->DMA_Handle1->XferCpltCallback = DAC_DMAConvCpltCh1;
 800874c:	68fb      	ldr	r3, [r7, #12]
 800874e:	689b      	ldr	r3, [r3, #8]
 8008750:	4a53      	ldr	r2, [pc, #332]	; (80088a0 <HAL_DAC_Start_DMA+0x184>)
 8008752:	62da      	str	r2, [r3, #44]	; 0x2c

    /* Set the DMA half transfer complete callback for channel1 */
    hdac->DMA_Handle1->XferHalfCpltCallback = DAC_DMAHalfConvCpltCh1;
 8008754:	68fb      	ldr	r3, [r7, #12]
 8008756:	689b      	ldr	r3, [r3, #8]
 8008758:	4a52      	ldr	r2, [pc, #328]	; (80088a4 <HAL_DAC_Start_DMA+0x188>)
 800875a:	631a      	str	r2, [r3, #48]	; 0x30

    /* Set the DMA error callback for channel1 */
    hdac->DMA_Handle1->XferErrorCallback = DAC_DMAErrorCh1;
 800875c:	68fb      	ldr	r3, [r7, #12]
 800875e:	689b      	ldr	r3, [r3, #8]
 8008760:	4a51      	ldr	r2, [pc, #324]	; (80088a8 <HAL_DAC_Start_DMA+0x18c>)
 8008762:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable the selected DAC channel1 DMA request */
    SET_BIT(hdac->Instance->CR, DAC_CR_DMAEN1);
 8008764:	68fb      	ldr	r3, [r7, #12]
 8008766:	681b      	ldr	r3, [r3, #0]
 8008768:	681a      	ldr	r2, [r3, #0]
 800876a:	68fb      	ldr	r3, [r7, #12]
 800876c:	681b      	ldr	r3, [r3, #0]
 800876e:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8008772:	601a      	str	r2, [r3, #0]

    /* Case of use of channel 1 */
    switch (Alignment)
 8008774:	6a3b      	ldr	r3, [r7, #32]
 8008776:	2b08      	cmp	r3, #8
 8008778:	d013      	beq.n	80087a2 <HAL_DAC_Start_DMA+0x86>
 800877a:	6a3b      	ldr	r3, [r7, #32]
 800877c:	2b08      	cmp	r3, #8
 800877e:	d845      	bhi.n	800880c <HAL_DAC_Start_DMA+0xf0>
 8008780:	6a3b      	ldr	r3, [r7, #32]
 8008782:	2b00      	cmp	r3, #0
 8008784:	d003      	beq.n	800878e <HAL_DAC_Start_DMA+0x72>
 8008786:	6a3b      	ldr	r3, [r7, #32]
 8008788:	2b04      	cmp	r3, #4
 800878a:	d005      	beq.n	8008798 <HAL_DAC_Start_DMA+0x7c>
      case DAC_ALIGN_8B_R:
        /* Get DHR8R1 address */
        tmpreg = (uint32_t)&hdac->Instance->DHR8R1;
        break;
      default:
        break;
 800878c:	e03e      	b.n	800880c <HAL_DAC_Start_DMA+0xf0>
        tmpreg = (uint32_t)&hdac->Instance->DHR12R1;
 800878e:	68fb      	ldr	r3, [r7, #12]
 8008790:	681b      	ldr	r3, [r3, #0]
 8008792:	3308      	adds	r3, #8
 8008794:	613b      	str	r3, [r7, #16]
        break;
 8008796:	e03c      	b.n	8008812 <HAL_DAC_Start_DMA+0xf6>
        tmpreg = (uint32_t)&hdac->Instance->DHR12L1;
 8008798:	68fb      	ldr	r3, [r7, #12]
 800879a:	681b      	ldr	r3, [r3, #0]
 800879c:	330c      	adds	r3, #12
 800879e:	613b      	str	r3, [r7, #16]
        break;
 80087a0:	e037      	b.n	8008812 <HAL_DAC_Start_DMA+0xf6>
        tmpreg = (uint32_t)&hdac->Instance->DHR8R1;
 80087a2:	68fb      	ldr	r3, [r7, #12]
 80087a4:	681b      	ldr	r3, [r3, #0]
 80087a6:	3310      	adds	r3, #16
 80087a8:	613b      	str	r3, [r7, #16]
        break;
 80087aa:	e032      	b.n	8008812 <HAL_DAC_Start_DMA+0xf6>
  }

  else
  {
    /* Set the DMA transfer complete callback for channel2 */
    hdac->DMA_Handle2->XferCpltCallback = DAC_DMAConvCpltCh2;
 80087ac:	68fb      	ldr	r3, [r7, #12]
 80087ae:	68db      	ldr	r3, [r3, #12]
 80087b0:	4a3e      	ldr	r2, [pc, #248]	; (80088ac <HAL_DAC_Start_DMA+0x190>)
 80087b2:	62da      	str	r2, [r3, #44]	; 0x2c

    /* Set the DMA half transfer complete callback for channel2 */
    hdac->DMA_Handle2->XferHalfCpltCallback = DAC_DMAHalfConvCpltCh2;
 80087b4:	68fb      	ldr	r3, [r7, #12]
 80087b6:	68db      	ldr	r3, [r3, #12]
 80087b8:	4a3d      	ldr	r2, [pc, #244]	; (80088b0 <HAL_DAC_Start_DMA+0x194>)
 80087ba:	631a      	str	r2, [r3, #48]	; 0x30

    /* Set the DMA error callback for channel2 */
    hdac->DMA_Handle2->XferErrorCallback = DAC_DMAErrorCh2;
 80087bc:	68fb      	ldr	r3, [r7, #12]
 80087be:	68db      	ldr	r3, [r3, #12]
 80087c0:	4a3c      	ldr	r2, [pc, #240]	; (80088b4 <HAL_DAC_Start_DMA+0x198>)
 80087c2:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable the selected DAC channel2 DMA request */
    SET_BIT(hdac->Instance->CR, DAC_CR_DMAEN2);
 80087c4:	68fb      	ldr	r3, [r7, #12]
 80087c6:	681b      	ldr	r3, [r3, #0]
 80087c8:	681a      	ldr	r2, [r3, #0]
 80087ca:	68fb      	ldr	r3, [r7, #12]
 80087cc:	681b      	ldr	r3, [r3, #0]
 80087ce:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80087d2:	601a      	str	r2, [r3, #0]

    /* Case of use of channel 2 */
    switch (Alignment)
 80087d4:	6a3b      	ldr	r3, [r7, #32]
 80087d6:	2b08      	cmp	r3, #8
 80087d8:	d013      	beq.n	8008802 <HAL_DAC_Start_DMA+0xe6>
 80087da:	6a3b      	ldr	r3, [r7, #32]
 80087dc:	2b08      	cmp	r3, #8
 80087de:	d817      	bhi.n	8008810 <HAL_DAC_Start_DMA+0xf4>
 80087e0:	6a3b      	ldr	r3, [r7, #32]
 80087e2:	2b00      	cmp	r3, #0
 80087e4:	d003      	beq.n	80087ee <HAL_DAC_Start_DMA+0xd2>
 80087e6:	6a3b      	ldr	r3, [r7, #32]
 80087e8:	2b04      	cmp	r3, #4
 80087ea:	d005      	beq.n	80087f8 <HAL_DAC_Start_DMA+0xdc>
      case DAC_ALIGN_8B_R:
        /* Get DHR8R2 address */
        tmpreg = (uint32_t)&hdac->Instance->DHR8R2;
        break;
      default:
        break;
 80087ec:	e010      	b.n	8008810 <HAL_DAC_Start_DMA+0xf4>
        tmpreg = (uint32_t)&hdac->Instance->DHR12R2;
 80087ee:	68fb      	ldr	r3, [r7, #12]
 80087f0:	681b      	ldr	r3, [r3, #0]
 80087f2:	3314      	adds	r3, #20
 80087f4:	613b      	str	r3, [r7, #16]
        break;
 80087f6:	e00c      	b.n	8008812 <HAL_DAC_Start_DMA+0xf6>
        tmpreg = (uint32_t)&hdac->Instance->DHR12L2;
 80087f8:	68fb      	ldr	r3, [r7, #12]
 80087fa:	681b      	ldr	r3, [r3, #0]
 80087fc:	3318      	adds	r3, #24
 80087fe:	613b      	str	r3, [r7, #16]
        break;
 8008800:	e007      	b.n	8008812 <HAL_DAC_Start_DMA+0xf6>
        tmpreg = (uint32_t)&hdac->Instance->DHR8R2;
 8008802:	68fb      	ldr	r3, [r7, #12]
 8008804:	681b      	ldr	r3, [r3, #0]
 8008806:	331c      	adds	r3, #28
 8008808:	613b      	str	r3, [r7, #16]
        break;
 800880a:	e002      	b.n	8008812 <HAL_DAC_Start_DMA+0xf6>
        break;
 800880c:	bf00      	nop
 800880e:	e000      	b.n	8008812 <HAL_DAC_Start_DMA+0xf6>
        break;
 8008810:	bf00      	nop
    }
  }


  /* Enable the DMA channel */
  if (Channel == DAC_CHANNEL_1)
 8008812:	68bb      	ldr	r3, [r7, #8]
 8008814:	2b00      	cmp	r3, #0
 8008816:	d111      	bne.n	800883c <HAL_DAC_Start_DMA+0x120>
  {
    /* Enable the DAC DMA underrun interrupt */
    __HAL_DAC_ENABLE_IT(hdac, DAC_IT_DMAUDR1);
 8008818:	68fb      	ldr	r3, [r7, #12]
 800881a:	681b      	ldr	r3, [r3, #0]
 800881c:	681a      	ldr	r2, [r3, #0]
 800881e:	68fb      	ldr	r3, [r7, #12]
 8008820:	681b      	ldr	r3, [r3, #0]
 8008822:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8008826:	601a      	str	r2, [r3, #0]

    /* Enable the DMA channel */
    status = HAL_DMA_Start_IT(hdac->DMA_Handle1, (uint32_t)pData, tmpreg, Length);
 8008828:	68fb      	ldr	r3, [r7, #12]
 800882a:	6898      	ldr	r0, [r3, #8]
 800882c:	6879      	ldr	r1, [r7, #4]
 800882e:	683b      	ldr	r3, [r7, #0]
 8008830:	693a      	ldr	r2, [r7, #16]
 8008832:	f000 fb61 	bl	8008ef8 <HAL_DMA_Start_IT>
 8008836:	4603      	mov	r3, r0
 8008838:	75fb      	strb	r3, [r7, #23]
 800883a:	e010      	b.n	800885e <HAL_DAC_Start_DMA+0x142>
  }

  else
  {
    /* Enable the DAC DMA underrun interrupt */
    __HAL_DAC_ENABLE_IT(hdac, DAC_IT_DMAUDR2);
 800883c:	68fb      	ldr	r3, [r7, #12]
 800883e:	681b      	ldr	r3, [r3, #0]
 8008840:	681a      	ldr	r2, [r3, #0]
 8008842:	68fb      	ldr	r3, [r7, #12]
 8008844:	681b      	ldr	r3, [r3, #0]
 8008846:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 800884a:	601a      	str	r2, [r3, #0]

    /* Enable the DMA channel */
    status = HAL_DMA_Start_IT(hdac->DMA_Handle2, (uint32_t)pData, tmpreg, Length);
 800884c:	68fb      	ldr	r3, [r7, #12]
 800884e:	68d8      	ldr	r0, [r3, #12]
 8008850:	6879      	ldr	r1, [r7, #4]
 8008852:	683b      	ldr	r3, [r7, #0]
 8008854:	693a      	ldr	r2, [r7, #16]
 8008856:	f000 fb4f 	bl	8008ef8 <HAL_DMA_Start_IT>
 800885a:	4603      	mov	r3, r0
 800885c:	75fb      	strb	r3, [r7, #23]
  }


  /* Process Unlocked */
  __HAL_UNLOCK(hdac);
 800885e:	68fb      	ldr	r3, [r7, #12]
 8008860:	2200      	movs	r2, #0
 8008862:	715a      	strb	r2, [r3, #5]

  if (status == HAL_OK)
 8008864:	7dfb      	ldrb	r3, [r7, #23]
 8008866:	2b00      	cmp	r3, #0
 8008868:	d10f      	bne.n	800888a <HAL_DAC_Start_DMA+0x16e>
  {
    /* Enable the Peripheral */
    __HAL_DAC_ENABLE(hdac, Channel);
 800886a:	68fb      	ldr	r3, [r7, #12]
 800886c:	681b      	ldr	r3, [r3, #0]
 800886e:	6819      	ldr	r1, [r3, #0]
 8008870:	68bb      	ldr	r3, [r7, #8]
 8008872:	f003 0310 	and.w	r3, r3, #16
 8008876:	2201      	movs	r2, #1
 8008878:	409a      	lsls	r2, r3
 800887a:	68fb      	ldr	r3, [r7, #12]
 800887c:	681b      	ldr	r3, [r3, #0]
 800887e:	430a      	orrs	r2, r1
 8008880:	601a      	str	r2, [r3, #0]
    /* Ensure minimum wait before using peripheral after enabling it */
    HAL_Delay(1);
 8008882:	2001      	movs	r0, #1
 8008884:	f7fd fa72 	bl	8005d6c <HAL_Delay>
 8008888:	e005      	b.n	8008896 <HAL_DAC_Start_DMA+0x17a>
  }
  else
  {
    hdac->ErrorCode |= HAL_DAC_ERROR_DMA;
 800888a:	68fb      	ldr	r3, [r7, #12]
 800888c:	691b      	ldr	r3, [r3, #16]
 800888e:	f043 0204 	orr.w	r2, r3, #4
 8008892:	68fb      	ldr	r3, [r7, #12]
 8008894:	611a      	str	r2, [r3, #16]
  }

  /* Return function status */
  return status;
 8008896:	7dfb      	ldrb	r3, [r7, #23]
}
 8008898:	4618      	mov	r0, r3
 800889a:	3718      	adds	r7, #24
 800889c:	46bd      	mov	sp, r7
 800889e:	bd80      	pop	{r7, pc}
 80088a0:	08008c95 	.word	0x08008c95
 80088a4:	08008cb7 	.word	0x08008cb7
 80088a8:	08008cd3 	.word	0x08008cd3
 80088ac:	08008d3d 	.word	0x08008d3d
 80088b0:	08008d5f 	.word	0x08008d5f
 80088b4:	08008d7b 	.word	0x08008d7b

080088b8 <HAL_DAC_SetValue>:
  *            @arg DAC_ALIGN_12B_R: 12bit right data alignment selected
  * @param  Data Data to be loaded in the selected data holding register.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DAC_SetValue(DAC_HandleTypeDef *hdac, uint32_t Channel, uint32_t Alignment, uint32_t Data)
{
 80088b8:	b480      	push	{r7}
 80088ba:	b087      	sub	sp, #28
 80088bc:	af00      	add	r7, sp, #0
 80088be:	60f8      	str	r0, [r7, #12]
 80088c0:	60b9      	str	r1, [r7, #8]
 80088c2:	607a      	str	r2, [r7, #4]
 80088c4:	603b      	str	r3, [r7, #0]
  __IO uint32_t tmp = 0UL;
 80088c6:	2300      	movs	r3, #0
 80088c8:	617b      	str	r3, [r7, #20]

  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(hdac->Instance, Channel));
  assert_param(IS_DAC_ALIGN(Alignment));
  /* In case DMA Double data mode is activated, DATA range is almost full uin32_t one: no check */
  if ((hdac->Instance->MCR & (DAC_MCR_DMADOUBLE1 << (Channel & 0x10UL))) == 0UL)
 80088ca:	68fb      	ldr	r3, [r7, #12]
 80088cc:	681b      	ldr	r3, [r3, #0]
 80088ce:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  {
    assert_param(IS_DAC_DATA(Data));
  }

  tmp = (uint32_t)hdac->Instance;
 80088d0:	68fb      	ldr	r3, [r7, #12]
 80088d2:	681b      	ldr	r3, [r3, #0]
 80088d4:	617b      	str	r3, [r7, #20]
  if (Channel == DAC_CHANNEL_1)
 80088d6:	68bb      	ldr	r3, [r7, #8]
 80088d8:	2b00      	cmp	r3, #0
 80088da:	d105      	bne.n	80088e8 <HAL_DAC_SetValue+0x30>
  {
    tmp += DAC_DHR12R1_ALIGNMENT(Alignment);
 80088dc:	697a      	ldr	r2, [r7, #20]
 80088de:	687b      	ldr	r3, [r7, #4]
 80088e0:	4413      	add	r3, r2
 80088e2:	3308      	adds	r3, #8
 80088e4:	617b      	str	r3, [r7, #20]
 80088e6:	e004      	b.n	80088f2 <HAL_DAC_SetValue+0x3a>
  }

  else
  {
    tmp += DAC_DHR12R2_ALIGNMENT(Alignment);
 80088e8:	697a      	ldr	r2, [r7, #20]
 80088ea:	687b      	ldr	r3, [r7, #4]
 80088ec:	4413      	add	r3, r2
 80088ee:	3314      	adds	r3, #20
 80088f0:	617b      	str	r3, [r7, #20]
  }


  /* Set the DAC channel selected data holding register */
  *(__IO uint32_t *) tmp = Data;
 80088f2:	697b      	ldr	r3, [r7, #20]
 80088f4:	461a      	mov	r2, r3
 80088f6:	683b      	ldr	r3, [r7, #0]
 80088f8:	6013      	str	r3, [r2, #0]

  /* Return function status */
  return HAL_OK;
 80088fa:	2300      	movs	r3, #0
}
 80088fc:	4618      	mov	r0, r3
 80088fe:	371c      	adds	r7, #28
 8008900:	46bd      	mov	sp, r7
 8008902:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008906:	4770      	bx	lr

08008908 <HAL_DAC_ConvCpltCallbackCh1>:
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */
__weak void HAL_DAC_ConvCpltCallbackCh1(DAC_HandleTypeDef *hdac)
{
 8008908:	b480      	push	{r7}
 800890a:	b083      	sub	sp, #12
 800890c:	af00      	add	r7, sp, #0
 800890e:	6078      	str	r0, [r7, #4]
  UNUSED(hdac);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_DAC_ConvCpltCallbackCh1 could be implemented in the user file
   */
}
 8008910:	bf00      	nop
 8008912:	370c      	adds	r7, #12
 8008914:	46bd      	mov	sp, r7
 8008916:	f85d 7b04 	ldr.w	r7, [sp], #4
 800891a:	4770      	bx	lr

0800891c <HAL_DAC_ConvHalfCpltCallbackCh1>:
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */
__weak void HAL_DAC_ConvHalfCpltCallbackCh1(DAC_HandleTypeDef *hdac)
{
 800891c:	b480      	push	{r7}
 800891e:	b083      	sub	sp, #12
 8008920:	af00      	add	r7, sp, #0
 8008922:	6078      	str	r0, [r7, #4]
  UNUSED(hdac);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_DAC_ConvHalfCpltCallbackCh1 could be implemented in the user file
   */
}
 8008924:	bf00      	nop
 8008926:	370c      	adds	r7, #12
 8008928:	46bd      	mov	sp, r7
 800892a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800892e:	4770      	bx	lr

08008930 <HAL_DAC_ErrorCallbackCh1>:
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */
__weak void HAL_DAC_ErrorCallbackCh1(DAC_HandleTypeDef *hdac)
{
 8008930:	b480      	push	{r7}
 8008932:	b083      	sub	sp, #12
 8008934:	af00      	add	r7, sp, #0
 8008936:	6078      	str	r0, [r7, #4]
  UNUSED(hdac);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_DAC_ErrorCallbackCh1 could be implemented in the user file
   */
}
 8008938:	bf00      	nop
 800893a:	370c      	adds	r7, #12
 800893c:	46bd      	mov	sp, r7
 800893e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008942:	4770      	bx	lr

08008944 <HAL_DAC_ConfigChannel>:
  *         (1) On this STM32 series, parameter not available on all instances.
  *             Refer to device datasheet for channels availability.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DAC_ConfigChannel(DAC_HandleTypeDef *hdac, DAC_ChannelConfTypeDef *sConfig, uint32_t Channel)
{
 8008944:	b580      	push	{r7, lr}
 8008946:	b08a      	sub	sp, #40	; 0x28
 8008948:	af00      	add	r7, sp, #0
 800894a:	60f8      	str	r0, [r7, #12]
 800894c:	60b9      	str	r1, [r7, #8]
 800894e:	607a      	str	r2, [r7, #4]
  assert_param(IS_DAC_CHANNEL(hdac->Instance, Channel));
  assert_param(IS_FUNCTIONAL_STATE(sConfig->DAC_DMADoubleDataMode));
  assert_param(IS_FUNCTIONAL_STATE(sConfig->DAC_SignedFormat));

  /* Process locked */
  __HAL_LOCK(hdac);
 8008950:	68fb      	ldr	r3, [r7, #12]
 8008952:	795b      	ldrb	r3, [r3, #5]
 8008954:	2b01      	cmp	r3, #1
 8008956:	d101      	bne.n	800895c <HAL_DAC_ConfigChannel+0x18>
 8008958:	2302      	movs	r3, #2
 800895a:	e192      	b.n	8008c82 <HAL_DAC_ConfigChannel+0x33e>
 800895c:	68fb      	ldr	r3, [r7, #12]
 800895e:	2201      	movs	r2, #1
 8008960:	715a      	strb	r2, [r3, #5]

  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_BUSY;
 8008962:	68fb      	ldr	r3, [r7, #12]
 8008964:	2202      	movs	r2, #2
 8008966:	711a      	strb	r2, [r3, #4]

  /* Sample and hold configuration */
  if (sConfig->DAC_SampleAndHold == DAC_SAMPLEANDHOLD_ENABLE)
 8008968:	68bb      	ldr	r3, [r7, #8]
 800896a:	689b      	ldr	r3, [r3, #8]
 800896c:	2b04      	cmp	r3, #4
 800896e:	d174      	bne.n	8008a5a <HAL_DAC_ConfigChannel+0x116>
  {
    /* Get timeout */
    tickstart = HAL_GetTick();
 8008970:	f7fd f9f0 	bl	8005d54 <HAL_GetTick>
 8008974:	61f8      	str	r0, [r7, #28]

    if (Channel == DAC_CHANNEL_1)
 8008976:	687b      	ldr	r3, [r7, #4]
 8008978:	2b00      	cmp	r3, #0
 800897a:	d134      	bne.n	80089e6 <HAL_DAC_ConfigChannel+0xa2>
    {
      /* SHSR1 can be written when BWST1 is cleared */
      while (((hdac->Instance->SR) & DAC_SR_BWST1) != 0UL)
 800897c:	e011      	b.n	80089a2 <HAL_DAC_ConfigChannel+0x5e>
      {
        /* Check for the Timeout */
        if ((HAL_GetTick() - tickstart) > TIMEOUT_DAC_CALIBCONFIG)
 800897e:	f7fd f9e9 	bl	8005d54 <HAL_GetTick>
 8008982:	4602      	mov	r2, r0
 8008984:	69fb      	ldr	r3, [r7, #28]
 8008986:	1ad3      	subs	r3, r2, r3
 8008988:	2b01      	cmp	r3, #1
 800898a:	d90a      	bls.n	80089a2 <HAL_DAC_ConfigChannel+0x5e>
        {
          /* Update error code */
          SET_BIT(hdac->ErrorCode, HAL_DAC_ERROR_TIMEOUT);
 800898c:	68fb      	ldr	r3, [r7, #12]
 800898e:	691b      	ldr	r3, [r3, #16]
 8008990:	f043 0208 	orr.w	r2, r3, #8
 8008994:	68fb      	ldr	r3, [r7, #12]
 8008996:	611a      	str	r2, [r3, #16]

          /* Change the DMA state */
          hdac->State = HAL_DAC_STATE_TIMEOUT;
 8008998:	68fb      	ldr	r3, [r7, #12]
 800899a:	2203      	movs	r2, #3
 800899c:	711a      	strb	r2, [r3, #4]

          return HAL_TIMEOUT;
 800899e:	2303      	movs	r3, #3
 80089a0:	e16f      	b.n	8008c82 <HAL_DAC_ConfigChannel+0x33e>
      while (((hdac->Instance->SR) & DAC_SR_BWST1) != 0UL)
 80089a2:	68fb      	ldr	r3, [r7, #12]
 80089a4:	681b      	ldr	r3, [r3, #0]
 80089a6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80089a8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80089ac:	2b00      	cmp	r3, #0
 80089ae:	d1e6      	bne.n	800897e <HAL_DAC_ConfigChannel+0x3a>
        }
      }
      HAL_Delay(1);
 80089b0:	2001      	movs	r0, #1
 80089b2:	f7fd f9db 	bl	8005d6c <HAL_Delay>
      hdac->Instance->SHSR1 = sConfig->DAC_SampleAndHoldConfig.DAC_SampleTime;
 80089b6:	68fb      	ldr	r3, [r7, #12]
 80089b8:	681b      	ldr	r3, [r3, #0]
 80089ba:	68ba      	ldr	r2, [r7, #8]
 80089bc:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80089be:	641a      	str	r2, [r3, #64]	; 0x40
 80089c0:	e01e      	b.n	8008a00 <HAL_DAC_ConfigChannel+0xbc>
    {
      /* SHSR2 can be written when BWST2 is cleared */
      while (((hdac->Instance->SR) & DAC_SR_BWST2) != 0UL)
      {
        /* Check for the Timeout */
        if ((HAL_GetTick() - tickstart) > TIMEOUT_DAC_CALIBCONFIG)
 80089c2:	f7fd f9c7 	bl	8005d54 <HAL_GetTick>
 80089c6:	4602      	mov	r2, r0
 80089c8:	69fb      	ldr	r3, [r7, #28]
 80089ca:	1ad3      	subs	r3, r2, r3
 80089cc:	2b01      	cmp	r3, #1
 80089ce:	d90a      	bls.n	80089e6 <HAL_DAC_ConfigChannel+0xa2>
        {
          /* Update error code */
          SET_BIT(hdac->ErrorCode, HAL_DAC_ERROR_TIMEOUT);
 80089d0:	68fb      	ldr	r3, [r7, #12]
 80089d2:	691b      	ldr	r3, [r3, #16]
 80089d4:	f043 0208 	orr.w	r2, r3, #8
 80089d8:	68fb      	ldr	r3, [r7, #12]
 80089da:	611a      	str	r2, [r3, #16]

          /* Change the DMA state */
          hdac->State = HAL_DAC_STATE_TIMEOUT;
 80089dc:	68fb      	ldr	r3, [r7, #12]
 80089de:	2203      	movs	r2, #3
 80089e0:	711a      	strb	r2, [r3, #4]

          return HAL_TIMEOUT;
 80089e2:	2303      	movs	r3, #3
 80089e4:	e14d      	b.n	8008c82 <HAL_DAC_ConfigChannel+0x33e>
      while (((hdac->Instance->SR) & DAC_SR_BWST2) != 0UL)
 80089e6:	68fb      	ldr	r3, [r7, #12]
 80089e8:	681b      	ldr	r3, [r3, #0]
 80089ea:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80089ec:	2b00      	cmp	r3, #0
 80089ee:	dbe8      	blt.n	80089c2 <HAL_DAC_ConfigChannel+0x7e>
        }
      }
      HAL_Delay(1U);
 80089f0:	2001      	movs	r0, #1
 80089f2:	f7fd f9bb 	bl	8005d6c <HAL_Delay>
      hdac->Instance->SHSR2 = sConfig->DAC_SampleAndHoldConfig.DAC_SampleTime;
 80089f6:	68fb      	ldr	r3, [r7, #12]
 80089f8:	681b      	ldr	r3, [r3, #0]
 80089fa:	68ba      	ldr	r2, [r7, #8]
 80089fc:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80089fe:	645a      	str	r2, [r3, #68]	; 0x44
    }


    /* HoldTime */
    MODIFY_REG(hdac->Instance->SHHR, DAC_SHHR_THOLD1 << (Channel & 0x10UL),
 8008a00:	68fb      	ldr	r3, [r7, #12]
 8008a02:	681b      	ldr	r3, [r3, #0]
 8008a04:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8008a06:	687b      	ldr	r3, [r7, #4]
 8008a08:	f003 0310 	and.w	r3, r3, #16
 8008a0c:	f240 31ff 	movw	r1, #1023	; 0x3ff
 8008a10:	fa01 f303 	lsl.w	r3, r1, r3
 8008a14:	43db      	mvns	r3, r3
 8008a16:	ea02 0103 	and.w	r1, r2, r3
 8008a1a:	68bb      	ldr	r3, [r7, #8]
 8008a1c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8008a1e:	687b      	ldr	r3, [r7, #4]
 8008a20:	f003 0310 	and.w	r3, r3, #16
 8008a24:	409a      	lsls	r2, r3
 8008a26:	68fb      	ldr	r3, [r7, #12]
 8008a28:	681b      	ldr	r3, [r3, #0]
 8008a2a:	430a      	orrs	r2, r1
 8008a2c:	649a      	str	r2, [r3, #72]	; 0x48
               (sConfig->DAC_SampleAndHoldConfig.DAC_HoldTime) << (Channel & 0x10UL));
    /* RefreshTime */
    MODIFY_REG(hdac->Instance->SHRR, DAC_SHRR_TREFRESH1 << (Channel & 0x10UL),
 8008a2e:	68fb      	ldr	r3, [r7, #12]
 8008a30:	681b      	ldr	r3, [r3, #0]
 8008a32:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8008a34:	687b      	ldr	r3, [r7, #4]
 8008a36:	f003 0310 	and.w	r3, r3, #16
 8008a3a:	21ff      	movs	r1, #255	; 0xff
 8008a3c:	fa01 f303 	lsl.w	r3, r1, r3
 8008a40:	43db      	mvns	r3, r3
 8008a42:	ea02 0103 	and.w	r1, r2, r3
 8008a46:	68bb      	ldr	r3, [r7, #8]
 8008a48:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8008a4a:	687b      	ldr	r3, [r7, #4]
 8008a4c:	f003 0310 	and.w	r3, r3, #16
 8008a50:	409a      	lsls	r2, r3
 8008a52:	68fb      	ldr	r3, [r7, #12]
 8008a54:	681b      	ldr	r3, [r3, #0]
 8008a56:	430a      	orrs	r2, r1
 8008a58:	64da      	str	r2, [r3, #76]	; 0x4c
               (sConfig->DAC_SampleAndHoldConfig.DAC_RefreshTime) << (Channel & 0x10UL));
  }

  if (sConfig->DAC_UserTrimming == DAC_TRIMMING_USER)
 8008a5a:	68bb      	ldr	r3, [r7, #8]
 8008a5c:	69db      	ldr	r3, [r3, #28]
 8008a5e:	2b01      	cmp	r3, #1
 8008a60:	d11d      	bne.n	8008a9e <HAL_DAC_ConfigChannel+0x15a>
    /* USER TRIMMING */
  {
    /* Get the DAC CCR value */
    tmpreg1 = hdac->Instance->CCR;
 8008a62:	68fb      	ldr	r3, [r7, #12]
 8008a64:	681b      	ldr	r3, [r3, #0]
 8008a66:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8008a68:	627b      	str	r3, [r7, #36]	; 0x24
    /* Clear trimming value */
    tmpreg1 &= ~(((uint32_t)(DAC_CCR_OTRIM1)) << (Channel & 0x10UL));
 8008a6a:	687b      	ldr	r3, [r7, #4]
 8008a6c:	f003 0310 	and.w	r3, r3, #16
 8008a70:	221f      	movs	r2, #31
 8008a72:	fa02 f303 	lsl.w	r3, r2, r3
 8008a76:	43db      	mvns	r3, r3
 8008a78:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008a7a:	4013      	ands	r3, r2
 8008a7c:	627b      	str	r3, [r7, #36]	; 0x24
    /* Configure for the selected trimming offset */
    tmpreg2 = sConfig->DAC_TrimmingValue;
 8008a7e:	68bb      	ldr	r3, [r7, #8]
 8008a80:	6a1b      	ldr	r3, [r3, #32]
 8008a82:	61bb      	str	r3, [r7, #24]
    /* Calculate CCR register value depending on DAC_Channel */
    tmpreg1 |= tmpreg2 << (Channel & 0x10UL);
 8008a84:	687b      	ldr	r3, [r7, #4]
 8008a86:	f003 0310 	and.w	r3, r3, #16
 8008a8a:	69ba      	ldr	r2, [r7, #24]
 8008a8c:	fa02 f303 	lsl.w	r3, r2, r3
 8008a90:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008a92:	4313      	orrs	r3, r2
 8008a94:	627b      	str	r3, [r7, #36]	; 0x24
    /* Write to DAC CCR */
    hdac->Instance->CCR = tmpreg1;
 8008a96:	68fb      	ldr	r3, [r7, #12]
 8008a98:	681b      	ldr	r3, [r3, #0]
 8008a9a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008a9c:	639a      	str	r2, [r3, #56]	; 0x38
  }
  /* else factory trimming is used (factory setting are available at reset)*/
  /* SW Nothing has nothing to do */

  /* Get the DAC MCR value */
  tmpreg1 = hdac->Instance->MCR;
 8008a9e:	68fb      	ldr	r3, [r7, #12]
 8008aa0:	681b      	ldr	r3, [r3, #0]
 8008aa2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8008aa4:	627b      	str	r3, [r7, #36]	; 0x24
  /* Clear DAC_MCR_MODEx bits */
  tmpreg1 &= ~(((uint32_t)(DAC_MCR_MODE1)) << (Channel & 0x10UL));
 8008aa6:	687b      	ldr	r3, [r7, #4]
 8008aa8:	f003 0310 	and.w	r3, r3, #16
 8008aac:	2207      	movs	r2, #7
 8008aae:	fa02 f303 	lsl.w	r3, r2, r3
 8008ab2:	43db      	mvns	r3, r3
 8008ab4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008ab6:	4013      	ands	r3, r2
 8008ab8:	627b      	str	r3, [r7, #36]	; 0x24
  /* Configure for the selected DAC channel: mode, buffer output & on chip peripheral connect */
  if (sConfig->DAC_ConnectOnChipPeripheral == DAC_CHIPCONNECT_EXTERNAL)
 8008aba:	68bb      	ldr	r3, [r7, #8]
 8008abc:	699b      	ldr	r3, [r3, #24]
 8008abe:	2b01      	cmp	r3, #1
 8008ac0:	d102      	bne.n	8008ac8 <HAL_DAC_ConfigChannel+0x184>
  {
    connectOnChip = 0x00000000UL;
 8008ac2:	2300      	movs	r3, #0
 8008ac4:	623b      	str	r3, [r7, #32]
 8008ac6:	e00f      	b.n	8008ae8 <HAL_DAC_ConfigChannel+0x1a4>
  }
  else if (sConfig->DAC_ConnectOnChipPeripheral == DAC_CHIPCONNECT_INTERNAL)
 8008ac8:	68bb      	ldr	r3, [r7, #8]
 8008aca:	699b      	ldr	r3, [r3, #24]
 8008acc:	2b02      	cmp	r3, #2
 8008ace:	d102      	bne.n	8008ad6 <HAL_DAC_ConfigChannel+0x192>
  {
    connectOnChip = DAC_MCR_MODE1_0;
 8008ad0:	2301      	movs	r3, #1
 8008ad2:	623b      	str	r3, [r7, #32]
 8008ad4:	e008      	b.n	8008ae8 <HAL_DAC_ConfigChannel+0x1a4>
  }
  else /* (sConfig->DAC_ConnectOnChipPeripheral == DAC_CHIPCONNECT_BOTH) */
  {
    if (sConfig->DAC_OutputBuffer == DAC_OUTPUTBUFFER_ENABLE)
 8008ad6:	68bb      	ldr	r3, [r7, #8]
 8008ad8:	695b      	ldr	r3, [r3, #20]
 8008ada:	2b00      	cmp	r3, #0
 8008adc:	d102      	bne.n	8008ae4 <HAL_DAC_ConfigChannel+0x1a0>
    {
      connectOnChip = DAC_MCR_MODE1_0;
 8008ade:	2301      	movs	r3, #1
 8008ae0:	623b      	str	r3, [r7, #32]
 8008ae2:	e001      	b.n	8008ae8 <HAL_DAC_ConfigChannel+0x1a4>
    }
    else
    {
      connectOnChip = 0x00000000UL;
 8008ae4:	2300      	movs	r3, #0
 8008ae6:	623b      	str	r3, [r7, #32]
    }
  }
  tmpreg2 = (sConfig->DAC_SampleAndHold | sConfig->DAC_OutputBuffer | connectOnChip);
 8008ae8:	68bb      	ldr	r3, [r7, #8]
 8008aea:	689a      	ldr	r2, [r3, #8]
 8008aec:	68bb      	ldr	r3, [r7, #8]
 8008aee:	695b      	ldr	r3, [r3, #20]
 8008af0:	4313      	orrs	r3, r2
 8008af2:	6a3a      	ldr	r2, [r7, #32]
 8008af4:	4313      	orrs	r3, r2
 8008af6:	61bb      	str	r3, [r7, #24]
  /* Clear DAC_MCR_DMADOUBLEx */
  tmpreg1 &= ~(((uint32_t)(DAC_MCR_DMADOUBLE1)) << (Channel & 0x10UL));
 8008af8:	687b      	ldr	r3, [r7, #4]
 8008afa:	f003 0310 	and.w	r3, r3, #16
 8008afe:	f44f 7280 	mov.w	r2, #256	; 0x100
 8008b02:	fa02 f303 	lsl.w	r3, r2, r3
 8008b06:	43db      	mvns	r3, r3
 8008b08:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008b0a:	4013      	ands	r3, r2
 8008b0c:	627b      	str	r3, [r7, #36]	; 0x24
  /* Configure for the selected DAC channel: DMA double data mode */
  tmpreg2 |= (sConfig->DAC_DMADoubleDataMode == ENABLE) ? DAC_MCR_DMADOUBLE1 : 0UL;
 8008b0e:	68bb      	ldr	r3, [r7, #8]
 8008b10:	791b      	ldrb	r3, [r3, #4]
 8008b12:	2b01      	cmp	r3, #1
 8008b14:	d102      	bne.n	8008b1c <HAL_DAC_ConfigChannel+0x1d8>
 8008b16:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008b1a:	e000      	b.n	8008b1e <HAL_DAC_ConfigChannel+0x1da>
 8008b1c:	2300      	movs	r3, #0
 8008b1e:	69ba      	ldr	r2, [r7, #24]
 8008b20:	4313      	orrs	r3, r2
 8008b22:	61bb      	str	r3, [r7, #24]
  /* Clear DAC_MCR_SINFORMATx */
  tmpreg1 &= ~(((uint32_t)(DAC_MCR_SINFORMAT1)) << (Channel & 0x10UL));
 8008b24:	687b      	ldr	r3, [r7, #4]
 8008b26:	f003 0310 	and.w	r3, r3, #16
 8008b2a:	f44f 7200 	mov.w	r2, #512	; 0x200
 8008b2e:	fa02 f303 	lsl.w	r3, r2, r3
 8008b32:	43db      	mvns	r3, r3
 8008b34:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008b36:	4013      	ands	r3, r2
 8008b38:	627b      	str	r3, [r7, #36]	; 0x24
  /* Configure for the selected DAC channel: Signed format */
  tmpreg2 |= (sConfig->DAC_SignedFormat == ENABLE) ? DAC_MCR_SINFORMAT1 : 0UL;
 8008b3a:	68bb      	ldr	r3, [r7, #8]
 8008b3c:	795b      	ldrb	r3, [r3, #5]
 8008b3e:	2b01      	cmp	r3, #1
 8008b40:	d102      	bne.n	8008b48 <HAL_DAC_ConfigChannel+0x204>
 8008b42:	f44f 7300 	mov.w	r3, #512	; 0x200
 8008b46:	e000      	b.n	8008b4a <HAL_DAC_ConfigChannel+0x206>
 8008b48:	2300      	movs	r3, #0
 8008b4a:	69ba      	ldr	r2, [r7, #24]
 8008b4c:	4313      	orrs	r3, r2
 8008b4e:	61bb      	str	r3, [r7, #24]
  /* Clear DAC_MCR_HFSEL bits */
  tmpreg1 &= ~(DAC_MCR_HFSEL);
 8008b50:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008b52:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8008b56:	627b      	str	r3, [r7, #36]	; 0x24
  /* Configure for both DAC channels: high frequency mode */
  if (DAC_HIGH_FREQUENCY_INTERFACE_MODE_AUTOMATIC == sConfig->DAC_HighFrequency)
 8008b58:	68bb      	ldr	r3, [r7, #8]
 8008b5a:	681b      	ldr	r3, [r3, #0]
 8008b5c:	2b02      	cmp	r3, #2
 8008b5e:	d114      	bne.n	8008b8a <HAL_DAC_ConfigChannel+0x246>
  {
    hclkfreq = HAL_RCC_GetHCLKFreq();
 8008b60:	f001 ff34 	bl	800a9cc <HAL_RCC_GetHCLKFreq>
 8008b64:	6178      	str	r0, [r7, #20]
    if (hclkfreq > HFSEL_ENABLE_THRESHOLD_160MHZ)
 8008b66:	697b      	ldr	r3, [r7, #20]
 8008b68:	4a48      	ldr	r2, [pc, #288]	; (8008c8c <HAL_DAC_ConfigChannel+0x348>)
 8008b6a:	4293      	cmp	r3, r2
 8008b6c:	d904      	bls.n	8008b78 <HAL_DAC_ConfigChannel+0x234>
    {
      tmpreg1 |= DAC_HIGH_FREQUENCY_INTERFACE_MODE_ABOVE_160MHZ;
 8008b6e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008b70:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8008b74:	627b      	str	r3, [r7, #36]	; 0x24
 8008b76:	e00f      	b.n	8008b98 <HAL_DAC_ConfigChannel+0x254>
    }
    else if (hclkfreq > HFSEL_ENABLE_THRESHOLD_80MHZ)
 8008b78:	697b      	ldr	r3, [r7, #20]
 8008b7a:	4a45      	ldr	r2, [pc, #276]	; (8008c90 <HAL_DAC_ConfigChannel+0x34c>)
 8008b7c:	4293      	cmp	r3, r2
 8008b7e:	d90a      	bls.n	8008b96 <HAL_DAC_ConfigChannel+0x252>
    {
      tmpreg1 |= DAC_HIGH_FREQUENCY_INTERFACE_MODE_ABOVE_80MHZ;
 8008b80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008b82:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8008b86:	627b      	str	r3, [r7, #36]	; 0x24
 8008b88:	e006      	b.n	8008b98 <HAL_DAC_ConfigChannel+0x254>
      tmpreg1 |= DAC_HIGH_FREQUENCY_INTERFACE_MODE_DISABLE;
    }
  }
  else
  {
    tmpreg1 |= sConfig->DAC_HighFrequency;
 8008b8a:	68bb      	ldr	r3, [r7, #8]
 8008b8c:	681b      	ldr	r3, [r3, #0]
 8008b8e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008b90:	4313      	orrs	r3, r2
 8008b92:	627b      	str	r3, [r7, #36]	; 0x24
 8008b94:	e000      	b.n	8008b98 <HAL_DAC_ConfigChannel+0x254>
      tmpreg1 |= DAC_HIGH_FREQUENCY_INTERFACE_MODE_DISABLE;
 8008b96:	bf00      	nop
  }
  /* Calculate MCR register value depending on DAC_Channel */
  tmpreg1 |= tmpreg2 << (Channel & 0x10UL);
 8008b98:	687b      	ldr	r3, [r7, #4]
 8008b9a:	f003 0310 	and.w	r3, r3, #16
 8008b9e:	69ba      	ldr	r2, [r7, #24]
 8008ba0:	fa02 f303 	lsl.w	r3, r2, r3
 8008ba4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008ba6:	4313      	orrs	r3, r2
 8008ba8:	627b      	str	r3, [r7, #36]	; 0x24
  /* Write to DAC MCR */
  hdac->Instance->MCR = tmpreg1;
 8008baa:	68fb      	ldr	r3, [r7, #12]
 8008bac:	681b      	ldr	r3, [r3, #0]
 8008bae:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008bb0:	63da      	str	r2, [r3, #60]	; 0x3c

  /* DAC in normal operating mode hence clear DAC_CR_CENx bit */
  CLEAR_BIT(hdac->Instance->CR, DAC_CR_CEN1 << (Channel & 0x10UL));
 8008bb2:	68fb      	ldr	r3, [r7, #12]
 8008bb4:	681b      	ldr	r3, [r3, #0]
 8008bb6:	6819      	ldr	r1, [r3, #0]
 8008bb8:	687b      	ldr	r3, [r7, #4]
 8008bba:	f003 0310 	and.w	r3, r3, #16
 8008bbe:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8008bc2:	fa02 f303 	lsl.w	r3, r2, r3
 8008bc6:	43da      	mvns	r2, r3
 8008bc8:	68fb      	ldr	r3, [r7, #12]
 8008bca:	681b      	ldr	r3, [r3, #0]
 8008bcc:	400a      	ands	r2, r1
 8008bce:	601a      	str	r2, [r3, #0]

  /* Get the DAC CR value */
  tmpreg1 = hdac->Instance->CR;
 8008bd0:	68fb      	ldr	r3, [r7, #12]
 8008bd2:	681b      	ldr	r3, [r3, #0]
 8008bd4:	681b      	ldr	r3, [r3, #0]
 8008bd6:	627b      	str	r3, [r7, #36]	; 0x24
  /* Clear TENx, TSELx, WAVEx and MAMPx bits */
  tmpreg1 &= ~(((uint32_t)(DAC_CR_MAMP1 | DAC_CR_WAVE1 | DAC_CR_TSEL1 | DAC_CR_TEN1)) << (Channel & 0x10UL));
 8008bd8:	687b      	ldr	r3, [r7, #4]
 8008bda:	f003 0310 	and.w	r3, r3, #16
 8008bde:	f640 72fe 	movw	r2, #4094	; 0xffe
 8008be2:	fa02 f303 	lsl.w	r3, r2, r3
 8008be6:	43db      	mvns	r3, r3
 8008be8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008bea:	4013      	ands	r3, r2
 8008bec:	627b      	str	r3, [r7, #36]	; 0x24
  /* Configure for the selected DAC channel: trigger */
  /* Set TSELx and TENx bits according to DAC_Trigger value */
  tmpreg2 = sConfig->DAC_Trigger;
 8008bee:	68bb      	ldr	r3, [r7, #8]
 8008bf0:	68db      	ldr	r3, [r3, #12]
 8008bf2:	61bb      	str	r3, [r7, #24]
  /* Calculate CR register value depending on DAC_Channel */
  tmpreg1 |= tmpreg2 << (Channel & 0x10UL);
 8008bf4:	687b      	ldr	r3, [r7, #4]
 8008bf6:	f003 0310 	and.w	r3, r3, #16
 8008bfa:	69ba      	ldr	r2, [r7, #24]
 8008bfc:	fa02 f303 	lsl.w	r3, r2, r3
 8008c00:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008c02:	4313      	orrs	r3, r2
 8008c04:	627b      	str	r3, [r7, #36]	; 0x24
  /* Write to DAC CR */
  hdac->Instance->CR = tmpreg1;
 8008c06:	68fb      	ldr	r3, [r7, #12]
 8008c08:	681b      	ldr	r3, [r3, #0]
 8008c0a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008c0c:	601a      	str	r2, [r3, #0]
  /* Disable wave generation */
  CLEAR_BIT(hdac->Instance->CR, (DAC_CR_WAVE1 << (Channel & 0x10UL)));
 8008c0e:	68fb      	ldr	r3, [r7, #12]
 8008c10:	681b      	ldr	r3, [r3, #0]
 8008c12:	6819      	ldr	r1, [r3, #0]
 8008c14:	687b      	ldr	r3, [r7, #4]
 8008c16:	f003 0310 	and.w	r3, r3, #16
 8008c1a:	22c0      	movs	r2, #192	; 0xc0
 8008c1c:	fa02 f303 	lsl.w	r3, r2, r3
 8008c20:	43da      	mvns	r2, r3
 8008c22:	68fb      	ldr	r3, [r7, #12]
 8008c24:	681b      	ldr	r3, [r3, #0]
 8008c26:	400a      	ands	r2, r1
 8008c28:	601a      	str	r2, [r3, #0]

  /* Set STRSTTRIGSELx and STINCTRIGSELx bits according to DAC_Trigger & DAC_Trigger2 values */
  tmpreg2 = ((sConfig->DAC_Trigger & DAC_CR_TSEL1) >> DAC_CR_TSEL1_Pos) << DAC_STMODR_STRSTTRIGSEL1_Pos;
 8008c2a:	68bb      	ldr	r3, [r7, #8]
 8008c2c:	68db      	ldr	r3, [r3, #12]
 8008c2e:	089b      	lsrs	r3, r3, #2
 8008c30:	f003 030f 	and.w	r3, r3, #15
 8008c34:	61bb      	str	r3, [r7, #24]
  tmpreg2 |= ((sConfig->DAC_Trigger2 & DAC_CR_TSEL1) >> DAC_CR_TSEL1_Pos) << DAC_STMODR_STINCTRIGSEL1_Pos;
 8008c36:	68bb      	ldr	r3, [r7, #8]
 8008c38:	691b      	ldr	r3, [r3, #16]
 8008c3a:	089b      	lsrs	r3, r3, #2
 8008c3c:	021b      	lsls	r3, r3, #8
 8008c3e:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8008c42:	69ba      	ldr	r2, [r7, #24]
 8008c44:	4313      	orrs	r3, r2
 8008c46:	61bb      	str	r3, [r7, #24]
  /* Modify STMODR register value depending on DAC_Channel */
  MODIFY_REG(hdac->Instance->STMODR, (DAC_STMODR_STINCTRIGSEL1 | DAC_STMODR_STRSTTRIGSEL1) << (Channel & 0x10UL), tmpreg2 << (Channel & 0x10UL));
 8008c48:	68fb      	ldr	r3, [r7, #12]
 8008c4a:	681b      	ldr	r3, [r3, #0]
 8008c4c:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8008c4e:	687b      	ldr	r3, [r7, #4]
 8008c50:	f003 0310 	and.w	r3, r3, #16
 8008c54:	f640 710f 	movw	r1, #3855	; 0xf0f
 8008c58:	fa01 f303 	lsl.w	r3, r1, r3
 8008c5c:	43db      	mvns	r3, r3
 8008c5e:	ea02 0103 	and.w	r1, r2, r3
 8008c62:	687b      	ldr	r3, [r7, #4]
 8008c64:	f003 0310 	and.w	r3, r3, #16
 8008c68:	69ba      	ldr	r2, [r7, #24]
 8008c6a:	409a      	lsls	r2, r3
 8008c6c:	68fb      	ldr	r3, [r7, #12]
 8008c6e:	681b      	ldr	r3, [r3, #0]
 8008c70:	430a      	orrs	r2, r1
 8008c72:	661a      	str	r2, [r3, #96]	; 0x60
  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_READY;
 8008c74:	68fb      	ldr	r3, [r7, #12]
 8008c76:	2201      	movs	r2, #1
 8008c78:	711a      	strb	r2, [r3, #4]

  /* Process unlocked */
  __HAL_UNLOCK(hdac);
 8008c7a:	68fb      	ldr	r3, [r7, #12]
 8008c7c:	2200      	movs	r2, #0
 8008c7e:	715a      	strb	r2, [r3, #5]

  /* Return function status */
  return HAL_OK;
 8008c80:	2300      	movs	r3, #0
}
 8008c82:	4618      	mov	r0, r3
 8008c84:	3728      	adds	r7, #40	; 0x28
 8008c86:	46bd      	mov	sp, r7
 8008c88:	bd80      	pop	{r7, pc}
 8008c8a:	bf00      	nop
 8008c8c:	09896800 	.word	0x09896800
 8008c90:	04c4b400 	.word	0x04c4b400

08008c94 <DAC_DMAConvCpltCh1>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
void DAC_DMAConvCpltCh1(DMA_HandleTypeDef *hdma)
{
 8008c94:	b580      	push	{r7, lr}
 8008c96:	b084      	sub	sp, #16
 8008c98:	af00      	add	r7, sp, #0
 8008c9a:	6078      	str	r0, [r7, #4]
  DAC_HandleTypeDef *hdac = (DAC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8008c9c:	687b      	ldr	r3, [r7, #4]
 8008c9e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008ca0:	60fb      	str	r3, [r7, #12]

#if (USE_HAL_DAC_REGISTER_CALLBACKS == 1)
  hdac->ConvCpltCallbackCh1(hdac);
#else
  HAL_DAC_ConvCpltCallbackCh1(hdac);
 8008ca2:	68f8      	ldr	r0, [r7, #12]
 8008ca4:	f7ff fe30 	bl	8008908 <HAL_DAC_ConvCpltCallbackCh1>
#endif /* USE_HAL_DAC_REGISTER_CALLBACKS */

  hdac->State = HAL_DAC_STATE_READY;
 8008ca8:	68fb      	ldr	r3, [r7, #12]
 8008caa:	2201      	movs	r2, #1
 8008cac:	711a      	strb	r2, [r3, #4]
}
 8008cae:	bf00      	nop
 8008cb0:	3710      	adds	r7, #16
 8008cb2:	46bd      	mov	sp, r7
 8008cb4:	bd80      	pop	{r7, pc}

08008cb6 <DAC_DMAHalfConvCpltCh1>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
void DAC_DMAHalfConvCpltCh1(DMA_HandleTypeDef *hdma)
{
 8008cb6:	b580      	push	{r7, lr}
 8008cb8:	b084      	sub	sp, #16
 8008cba:	af00      	add	r7, sp, #0
 8008cbc:	6078      	str	r0, [r7, #4]
  DAC_HandleTypeDef *hdac = (DAC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8008cbe:	687b      	ldr	r3, [r7, #4]
 8008cc0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008cc2:	60fb      	str	r3, [r7, #12]
  /* Conversion complete callback */
#if (USE_HAL_DAC_REGISTER_CALLBACKS == 1)
  hdac->ConvHalfCpltCallbackCh1(hdac);
#else
  HAL_DAC_ConvHalfCpltCallbackCh1(hdac);
 8008cc4:	68f8      	ldr	r0, [r7, #12]
 8008cc6:	f7ff fe29 	bl	800891c <HAL_DAC_ConvHalfCpltCallbackCh1>
#endif  /* USE_HAL_DAC_REGISTER_CALLBACKS */
}
 8008cca:	bf00      	nop
 8008ccc:	3710      	adds	r7, #16
 8008cce:	46bd      	mov	sp, r7
 8008cd0:	bd80      	pop	{r7, pc}

08008cd2 <DAC_DMAErrorCh1>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
void DAC_DMAErrorCh1(DMA_HandleTypeDef *hdma)
{
 8008cd2:	b580      	push	{r7, lr}
 8008cd4:	b084      	sub	sp, #16
 8008cd6:	af00      	add	r7, sp, #0
 8008cd8:	6078      	str	r0, [r7, #4]
  DAC_HandleTypeDef *hdac = (DAC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8008cda:	687b      	ldr	r3, [r7, #4]
 8008cdc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008cde:	60fb      	str	r3, [r7, #12]

  /* Set DAC error code to DMA error */
  hdac->ErrorCode |= HAL_DAC_ERROR_DMA;
 8008ce0:	68fb      	ldr	r3, [r7, #12]
 8008ce2:	691b      	ldr	r3, [r3, #16]
 8008ce4:	f043 0204 	orr.w	r2, r3, #4
 8008ce8:	68fb      	ldr	r3, [r7, #12]
 8008cea:	611a      	str	r2, [r3, #16]

#if (USE_HAL_DAC_REGISTER_CALLBACKS == 1)
  hdac->ErrorCallbackCh1(hdac);
#else
  HAL_DAC_ErrorCallbackCh1(hdac);
 8008cec:	68f8      	ldr	r0, [r7, #12]
 8008cee:	f7ff fe1f 	bl	8008930 <HAL_DAC_ErrorCallbackCh1>
#endif /* USE_HAL_DAC_REGISTER_CALLBACKS */

  hdac->State = HAL_DAC_STATE_READY;
 8008cf2:	68fb      	ldr	r3, [r7, #12]
 8008cf4:	2201      	movs	r2, #1
 8008cf6:	711a      	strb	r2, [r3, #4]
}
 8008cf8:	bf00      	nop
 8008cfa:	3710      	adds	r7, #16
 8008cfc:	46bd      	mov	sp, r7
 8008cfe:	bd80      	pop	{r7, pc}

08008d00 <HAL_DACEx_ConvCpltCallbackCh2>:
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */
__weak void HAL_DACEx_ConvCpltCallbackCh2(DAC_HandleTypeDef *hdac)
{
 8008d00:	b480      	push	{r7}
 8008d02:	b083      	sub	sp, #12
 8008d04:	af00      	add	r7, sp, #0
 8008d06:	6078      	str	r0, [r7, #4]
  UNUSED(hdac);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_DACEx_ConvCpltCallbackCh2 could be implemented in the user file
   */
}
 8008d08:	bf00      	nop
 8008d0a:	370c      	adds	r7, #12
 8008d0c:	46bd      	mov	sp, r7
 8008d0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d12:	4770      	bx	lr

08008d14 <HAL_DACEx_ConvHalfCpltCallbackCh2>:
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */
__weak void HAL_DACEx_ConvHalfCpltCallbackCh2(DAC_HandleTypeDef *hdac)
{
 8008d14:	b480      	push	{r7}
 8008d16:	b083      	sub	sp, #12
 8008d18:	af00      	add	r7, sp, #0
 8008d1a:	6078      	str	r0, [r7, #4]
  UNUSED(hdac);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_DACEx_ConvHalfCpltCallbackCh2 could be implemented in the user file
   */
}
 8008d1c:	bf00      	nop
 8008d1e:	370c      	adds	r7, #12
 8008d20:	46bd      	mov	sp, r7
 8008d22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d26:	4770      	bx	lr

08008d28 <HAL_DACEx_ErrorCallbackCh2>:
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */
__weak void HAL_DACEx_ErrorCallbackCh2(DAC_HandleTypeDef *hdac)
{
 8008d28:	b480      	push	{r7}
 8008d2a:	b083      	sub	sp, #12
 8008d2c:	af00      	add	r7, sp, #0
 8008d2e:	6078      	str	r0, [r7, #4]
  UNUSED(hdac);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_DACEx_ErrorCallbackCh2 could be implemented in the user file
   */
}
 8008d30:	bf00      	nop
 8008d32:	370c      	adds	r7, #12
 8008d34:	46bd      	mov	sp, r7
 8008d36:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d3a:	4770      	bx	lr

08008d3c <DAC_DMAConvCpltCh2>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
void DAC_DMAConvCpltCh2(DMA_HandleTypeDef *hdma)
{
 8008d3c:	b580      	push	{r7, lr}
 8008d3e:	b084      	sub	sp, #16
 8008d40:	af00      	add	r7, sp, #0
 8008d42:	6078      	str	r0, [r7, #4]
  DAC_HandleTypeDef *hdac = (DAC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8008d44:	687b      	ldr	r3, [r7, #4]
 8008d46:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008d48:	60fb      	str	r3, [r7, #12]

#if (USE_HAL_DAC_REGISTER_CALLBACKS == 1)
  hdac->ConvCpltCallbackCh2(hdac);
#else
  HAL_DACEx_ConvCpltCallbackCh2(hdac);
 8008d4a:	68f8      	ldr	r0, [r7, #12]
 8008d4c:	f7ff ffd8 	bl	8008d00 <HAL_DACEx_ConvCpltCallbackCh2>
#endif /* USE_HAL_DAC_REGISTER_CALLBACKS */

  hdac->State = HAL_DAC_STATE_READY;
 8008d50:	68fb      	ldr	r3, [r7, #12]
 8008d52:	2201      	movs	r2, #1
 8008d54:	711a      	strb	r2, [r3, #4]
}
 8008d56:	bf00      	nop
 8008d58:	3710      	adds	r7, #16
 8008d5a:	46bd      	mov	sp, r7
 8008d5c:	bd80      	pop	{r7, pc}

08008d5e <DAC_DMAHalfConvCpltCh2>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
void DAC_DMAHalfConvCpltCh2(DMA_HandleTypeDef *hdma)
{
 8008d5e:	b580      	push	{r7, lr}
 8008d60:	b084      	sub	sp, #16
 8008d62:	af00      	add	r7, sp, #0
 8008d64:	6078      	str	r0, [r7, #4]
  DAC_HandleTypeDef *hdac = (DAC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8008d66:	687b      	ldr	r3, [r7, #4]
 8008d68:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008d6a:	60fb      	str	r3, [r7, #12]
  /* Conversion complete callback */
#if (USE_HAL_DAC_REGISTER_CALLBACKS == 1)
  hdac->ConvHalfCpltCallbackCh2(hdac);
#else
  HAL_DACEx_ConvHalfCpltCallbackCh2(hdac);
 8008d6c:	68f8      	ldr	r0, [r7, #12]
 8008d6e:	f7ff ffd1 	bl	8008d14 <HAL_DACEx_ConvHalfCpltCallbackCh2>
#endif /* USE_HAL_DAC_REGISTER_CALLBACKS */
}
 8008d72:	bf00      	nop
 8008d74:	3710      	adds	r7, #16
 8008d76:	46bd      	mov	sp, r7
 8008d78:	bd80      	pop	{r7, pc}

08008d7a <DAC_DMAErrorCh2>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
void DAC_DMAErrorCh2(DMA_HandleTypeDef *hdma)
{
 8008d7a:	b580      	push	{r7, lr}
 8008d7c:	b084      	sub	sp, #16
 8008d7e:	af00      	add	r7, sp, #0
 8008d80:	6078      	str	r0, [r7, #4]
  DAC_HandleTypeDef *hdac = (DAC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8008d82:	687b      	ldr	r3, [r7, #4]
 8008d84:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008d86:	60fb      	str	r3, [r7, #12]

  /* Set DAC error code to DMA error */
  hdac->ErrorCode |= HAL_DAC_ERROR_DMA;
 8008d88:	68fb      	ldr	r3, [r7, #12]
 8008d8a:	691b      	ldr	r3, [r3, #16]
 8008d8c:	f043 0204 	orr.w	r2, r3, #4
 8008d90:	68fb      	ldr	r3, [r7, #12]
 8008d92:	611a      	str	r2, [r3, #16]

#if (USE_HAL_DAC_REGISTER_CALLBACKS == 1)
  hdac->ErrorCallbackCh2(hdac);
#else
  HAL_DACEx_ErrorCallbackCh2(hdac);
 8008d94:	68f8      	ldr	r0, [r7, #12]
 8008d96:	f7ff ffc7 	bl	8008d28 <HAL_DACEx_ErrorCallbackCh2>
#endif /* USE_HAL_DAC_REGISTER_CALLBACKS */

  hdac->State = HAL_DAC_STATE_READY;
 8008d9a:	68fb      	ldr	r3, [r7, #12]
 8008d9c:	2201      	movs	r2, #1
 8008d9e:	711a      	strb	r2, [r3, #4]
}
 8008da0:	bf00      	nop
 8008da2:	3710      	adds	r7, #16
 8008da4:	46bd      	mov	sp, r7
 8008da6:	bd80      	pop	{r7, pc}

08008da8 <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 8008da8:	b580      	push	{r7, lr}
 8008daa:	b084      	sub	sp, #16
 8008dac:	af00      	add	r7, sp, #0
 8008dae:	6078      	str	r0, [r7, #4]
  uint32_t tmp;

  /* Check the DMA handle allocation */
  if (hdma == NULL)
 8008db0:	687b      	ldr	r3, [r7, #4]
 8008db2:	2b00      	cmp	r3, #0
 8008db4:	d101      	bne.n	8008dba <HAL_DMA_Init+0x12>
  {
    return HAL_ERROR;
 8008db6:	2301      	movs	r3, #1
 8008db8:	e08d      	b.n	8008ed6 <HAL_DMA_Init+0x12e>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  assert_param(IS_DMA_ALL_REQUEST(hdma->Init.Request));

  /* Compute the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8008dba:	687b      	ldr	r3, [r7, #4]
 8008dbc:	681b      	ldr	r3, [r3, #0]
 8008dbe:	461a      	mov	r2, r3
 8008dc0:	4b47      	ldr	r3, [pc, #284]	; (8008ee0 <HAL_DMA_Init+0x138>)
 8008dc2:	429a      	cmp	r2, r3
 8008dc4:	d80f      	bhi.n	8008de6 <HAL_DMA_Init+0x3e>
  {
    /* DMA1 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 8008dc6:	687b      	ldr	r3, [r7, #4]
 8008dc8:	681b      	ldr	r3, [r3, #0]
 8008dca:	461a      	mov	r2, r3
 8008dcc:	4b45      	ldr	r3, [pc, #276]	; (8008ee4 <HAL_DMA_Init+0x13c>)
 8008dce:	4413      	add	r3, r2
 8008dd0:	4a45      	ldr	r2, [pc, #276]	; (8008ee8 <HAL_DMA_Init+0x140>)
 8008dd2:	fba2 2303 	umull	r2, r3, r2, r3
 8008dd6:	091b      	lsrs	r3, r3, #4
 8008dd8:	009a      	lsls	r2, r3, #2
 8008dda:	687b      	ldr	r3, [r7, #4]
 8008ddc:	645a      	str	r2, [r3, #68]	; 0x44
    hdma->DmaBaseAddress = DMA1;
 8008dde:	687b      	ldr	r3, [r7, #4]
 8008de0:	4a42      	ldr	r2, [pc, #264]	; (8008eec <HAL_DMA_Init+0x144>)
 8008de2:	641a      	str	r2, [r3, #64]	; 0x40
 8008de4:	e00e      	b.n	8008e04 <HAL_DMA_Init+0x5c>
  }
  else
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
 8008de6:	687b      	ldr	r3, [r7, #4]
 8008de8:	681b      	ldr	r3, [r3, #0]
 8008dea:	461a      	mov	r2, r3
 8008dec:	4b40      	ldr	r3, [pc, #256]	; (8008ef0 <HAL_DMA_Init+0x148>)
 8008dee:	4413      	add	r3, r2
 8008df0:	4a3d      	ldr	r2, [pc, #244]	; (8008ee8 <HAL_DMA_Init+0x140>)
 8008df2:	fba2 2303 	umull	r2, r3, r2, r3
 8008df6:	091b      	lsrs	r3, r3, #4
 8008df8:	009a      	lsls	r2, r3, #2
 8008dfa:	687b      	ldr	r3, [r7, #4]
 8008dfc:	645a      	str	r2, [r3, #68]	; 0x44
    hdma->DmaBaseAddress = DMA2;
 8008dfe:	687b      	ldr	r3, [r7, #4]
 8008e00:	4a3c      	ldr	r2, [pc, #240]	; (8008ef4 <HAL_DMA_Init+0x14c>)
 8008e02:	641a      	str	r2, [r3, #64]	; 0x40
  }

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8008e04:	687b      	ldr	r3, [r7, #4]
 8008e06:	2202      	movs	r2, #2
 8008e08:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
 8008e0c:	687b      	ldr	r3, [r7, #4]
 8008e0e:	681b      	ldr	r3, [r3, #0]
 8008e10:	681b      	ldr	r3, [r3, #0]
 8008e12:	60fb      	str	r3, [r7, #12]

  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR and MEM2MEM bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
 8008e14:	68fb      	ldr	r3, [r7, #12]
 8008e16:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
 8008e1a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8008e1e:	60fb      	str	r3, [r7, #12]
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   |
                      DMA_CCR_DIR   | DMA_CCR_MEM2MEM));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8008e20:	687b      	ldr	r3, [r7, #4]
 8008e22:	689a      	ldr	r2, [r3, #8]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8008e24:	687b      	ldr	r3, [r7, #4]
 8008e26:	68db      	ldr	r3, [r3, #12]
  tmp |=  hdma->Init.Direction        |
 8008e28:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8008e2a:	687b      	ldr	r3, [r7, #4]
 8008e2c:	691b      	ldr	r3, [r3, #16]
 8008e2e:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8008e30:	687b      	ldr	r3, [r7, #4]
 8008e32:	695b      	ldr	r3, [r3, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8008e34:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8008e36:	687b      	ldr	r3, [r7, #4]
 8008e38:	699b      	ldr	r3, [r3, #24]
 8008e3a:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 8008e3c:	687b      	ldr	r3, [r7, #4]
 8008e3e:	69db      	ldr	r3, [r3, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8008e40:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 8008e42:	687b      	ldr	r3, [r7, #4]
 8008e44:	6a1b      	ldr	r3, [r3, #32]
 8008e46:	4313      	orrs	r3, r2
  tmp |=  hdma->Init.Direction        |
 8008e48:	68fa      	ldr	r2, [r7, #12]
 8008e4a:	4313      	orrs	r3, r2
 8008e4c:	60fb      	str	r3, [r7, #12]

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;
 8008e4e:	687b      	ldr	r3, [r7, #4]
 8008e50:	681b      	ldr	r3, [r3, #0]
 8008e52:	68fa      	ldr	r2, [r7, #12]
 8008e54:	601a      	str	r2, [r3, #0]

  /* Initialize parameters for DMAMUX channel :
     DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask
  */
  DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 8008e56:	6878      	ldr	r0, [r7, #4]
 8008e58:	f000 fa76 	bl	8009348 <DMA_CalcDMAMUXChannelBaseAndMask>

  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 8008e5c:	687b      	ldr	r3, [r7, #4]
 8008e5e:	689b      	ldr	r3, [r3, #8]
 8008e60:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8008e64:	d102      	bne.n	8008e6c <HAL_DMA_Init+0xc4>
  {
    /* if memory to memory force the request to 0*/
    hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 8008e66:	687b      	ldr	r3, [r7, #4]
 8008e68:	2200      	movs	r2, #0
 8008e6a:	605a      	str	r2, [r3, #4]
  }

  /* Set peripheral request  to DMAMUX channel */
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 8008e6c:	687b      	ldr	r3, [r7, #4]
 8008e6e:	685a      	ldr	r2, [r3, #4]
 8008e70:	687b      	ldr	r3, [r7, #4]
 8008e72:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008e74:	b2d2      	uxtb	r2, r2
 8008e76:	601a      	str	r2, [r3, #0]

  /* Clear the DMAMUX synchro overrun flag */
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8008e78:	687b      	ldr	r3, [r7, #4]
 8008e7a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8008e7c:	687a      	ldr	r2, [r7, #4]
 8008e7e:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8008e80:	605a      	str	r2, [r3, #4]

  if (((hdma->Init.Request >  0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 8008e82:	687b      	ldr	r3, [r7, #4]
 8008e84:	685b      	ldr	r3, [r3, #4]
 8008e86:	2b00      	cmp	r3, #0
 8008e88:	d010      	beq.n	8008eac <HAL_DMA_Init+0x104>
 8008e8a:	687b      	ldr	r3, [r7, #4]
 8008e8c:	685b      	ldr	r3, [r3, #4]
 8008e8e:	2b04      	cmp	r3, #4
 8008e90:	d80c      	bhi.n	8008eac <HAL_DMA_Init+0x104>
  {
    /* Initialize parameters for DMAMUX request generator :
       DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask
    */
    DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
 8008e92:	6878      	ldr	r0, [r7, #4]
 8008e94:	f000 fa96 	bl	80093c4 <DMA_CalcDMAMUXRequestGenBaseAndMask>

    /* Reset the DMAMUX request generator register*/
    hdma->DMAmuxRequestGen->RGCR = 0U;
 8008e98:	687b      	ldr	r3, [r7, #4]
 8008e9a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8008e9c:	2200      	movs	r2, #0
 8008e9e:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX request generator overrun flag */
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8008ea0:	687b      	ldr	r3, [r7, #4]
 8008ea2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8008ea4:	687a      	ldr	r2, [r7, #4]
 8008ea6:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8008ea8:	605a      	str	r2, [r3, #4]
 8008eaa:	e008      	b.n	8008ebe <HAL_DMA_Init+0x116>
  }
  else
  {
    hdma->DMAmuxRequestGen = 0U;
 8008eac:	687b      	ldr	r3, [r7, #4]
 8008eae:	2200      	movs	r2, #0
 8008eb0:	655a      	str	r2, [r3, #84]	; 0x54
    hdma->DMAmuxRequestGenStatus = 0U;
 8008eb2:	687b      	ldr	r3, [r7, #4]
 8008eb4:	2200      	movs	r2, #0
 8008eb6:	659a      	str	r2, [r3, #88]	; 0x58
    hdma->DMAmuxRequestGenStatusMask = 0U;
 8008eb8:	687b      	ldr	r3, [r7, #4]
 8008eba:	2200      	movs	r2, #0
 8008ebc:	65da      	str	r2, [r3, #92]	; 0x5c
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8008ebe:	687b      	ldr	r3, [r7, #4]
 8008ec0:	2200      	movs	r2, #0
 8008ec2:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Initialize the DMA state*/
  hdma->State  = HAL_DMA_STATE_READY;
 8008ec4:	687b      	ldr	r3, [r7, #4]
 8008ec6:	2201      	movs	r2, #1
 8008ec8:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

  /* Allocate lock resource and initialize it */
  hdma->Lock = HAL_UNLOCKED;
 8008ecc:	687b      	ldr	r3, [r7, #4]
 8008ece:	2200      	movs	r2, #0
 8008ed0:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  return HAL_OK;
 8008ed4:	2300      	movs	r3, #0
}
 8008ed6:	4618      	mov	r0, r3
 8008ed8:	3710      	adds	r7, #16
 8008eda:	46bd      	mov	sp, r7
 8008edc:	bd80      	pop	{r7, pc}
 8008ede:	bf00      	nop
 8008ee0:	40020407 	.word	0x40020407
 8008ee4:	bffdfff8 	.word	0xbffdfff8
 8008ee8:	cccccccd 	.word	0xcccccccd
 8008eec:	40020000 	.word	0x40020000
 8008ef0:	bffdfbf8 	.word	0xbffdfbf8
 8008ef4:	40020400 	.word	0x40020400

08008ef8 <HAL_DMA_Start_IT>:
  * @param  DataLength The length of data to be transferred from source to destination (up to 256Kbytes-1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress,
                                   uint32_t DataLength)
{
 8008ef8:	b580      	push	{r7, lr}
 8008efa:	b086      	sub	sp, #24
 8008efc:	af00      	add	r7, sp, #0
 8008efe:	60f8      	str	r0, [r7, #12]
 8008f00:	60b9      	str	r1, [r7, #8]
 8008f02:	607a      	str	r2, [r7, #4]
 8008f04:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8008f06:	2300      	movs	r3, #0
 8008f08:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Process locked */
  __HAL_LOCK(hdma);
 8008f0a:	68fb      	ldr	r3, [r7, #12]
 8008f0c:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8008f10:	2b01      	cmp	r3, #1
 8008f12:	d101      	bne.n	8008f18 <HAL_DMA_Start_IT+0x20>
 8008f14:	2302      	movs	r3, #2
 8008f16:	e066      	b.n	8008fe6 <HAL_DMA_Start_IT+0xee>
 8008f18:	68fb      	ldr	r3, [r7, #12]
 8008f1a:	2201      	movs	r2, #1
 8008f1c:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  if (HAL_DMA_STATE_READY == hdma->State)
 8008f20:	68fb      	ldr	r3, [r7, #12]
 8008f22:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8008f26:	b2db      	uxtb	r3, r3
 8008f28:	2b01      	cmp	r3, #1
 8008f2a:	d155      	bne.n	8008fd8 <HAL_DMA_Start_IT+0xe0>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 8008f2c:	68fb      	ldr	r3, [r7, #12]
 8008f2e:	2202      	movs	r2, #2
 8008f30:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8008f34:	68fb      	ldr	r3, [r7, #12]
 8008f36:	2200      	movs	r2, #0
 8008f38:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
 8008f3a:	68fb      	ldr	r3, [r7, #12]
 8008f3c:	681b      	ldr	r3, [r3, #0]
 8008f3e:	681a      	ldr	r2, [r3, #0]
 8008f40:	68fb      	ldr	r3, [r7, #12]
 8008f42:	681b      	ldr	r3, [r3, #0]
 8008f44:	f022 0201 	bic.w	r2, r2, #1
 8008f48:	601a      	str	r2, [r3, #0]

    /* Configure the source, destination address and the data length & clear flags*/
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 8008f4a:	683b      	ldr	r3, [r7, #0]
 8008f4c:	687a      	ldr	r2, [r7, #4]
 8008f4e:	68b9      	ldr	r1, [r7, #8]
 8008f50:	68f8      	ldr	r0, [r7, #12]
 8008f52:	f000 f9bb 	bl	80092cc <DMA_SetConfig>

    /* Enable the transfer complete interrupt */
    /* Enable the transfer Error interrupt */
    if (NULL != hdma->XferHalfCpltCallback)
 8008f56:	68fb      	ldr	r3, [r7, #12]
 8008f58:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008f5a:	2b00      	cmp	r3, #0
 8008f5c:	d008      	beq.n	8008f70 <HAL_DMA_Start_IT+0x78>
    {
      /* Enable the Half transfer complete interrupt as well */
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8008f5e:	68fb      	ldr	r3, [r7, #12]
 8008f60:	681b      	ldr	r3, [r3, #0]
 8008f62:	681a      	ldr	r2, [r3, #0]
 8008f64:	68fb      	ldr	r3, [r7, #12]
 8008f66:	681b      	ldr	r3, [r3, #0]
 8008f68:	f042 020e 	orr.w	r2, r2, #14
 8008f6c:	601a      	str	r2, [r3, #0]
 8008f6e:	e00f      	b.n	8008f90 <HAL_DMA_Start_IT+0x98>
    }
    else
    {
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8008f70:	68fb      	ldr	r3, [r7, #12]
 8008f72:	681b      	ldr	r3, [r3, #0]
 8008f74:	681a      	ldr	r2, [r3, #0]
 8008f76:	68fb      	ldr	r3, [r7, #12]
 8008f78:	681b      	ldr	r3, [r3, #0]
 8008f7a:	f022 0204 	bic.w	r2, r2, #4
 8008f7e:	601a      	str	r2, [r3, #0]
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 8008f80:	68fb      	ldr	r3, [r7, #12]
 8008f82:	681b      	ldr	r3, [r3, #0]
 8008f84:	681a      	ldr	r2, [r3, #0]
 8008f86:	68fb      	ldr	r3, [r7, #12]
 8008f88:	681b      	ldr	r3, [r3, #0]
 8008f8a:	f042 020a 	orr.w	r2, r2, #10
 8008f8e:	601a      	str	r2, [r3, #0]
    }

    /* Check if DMAMUX Synchronization is enabled*/
    if ((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
 8008f90:	68fb      	ldr	r3, [r7, #12]
 8008f92:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008f94:	681b      	ldr	r3, [r3, #0]
 8008f96:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8008f9a:	2b00      	cmp	r3, #0
 8008f9c:	d007      	beq.n	8008fae <HAL_DMA_Start_IT+0xb6>
    {
      /* Enable DMAMUX sync overrun IT*/
      hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
 8008f9e:	68fb      	ldr	r3, [r7, #12]
 8008fa0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008fa2:	681a      	ldr	r2, [r3, #0]
 8008fa4:	68fb      	ldr	r3, [r7, #12]
 8008fa6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008fa8:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8008fac:	601a      	str	r2, [r3, #0]
    }

    if (hdma->DMAmuxRequestGen != 0U)
 8008fae:	68fb      	ldr	r3, [r7, #12]
 8008fb0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8008fb2:	2b00      	cmp	r3, #0
 8008fb4:	d007      	beq.n	8008fc6 <HAL_DMA_Start_IT+0xce>
    {
      /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/
      /* enable the request gen overrun IT*/
      hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
 8008fb6:	68fb      	ldr	r3, [r7, #12]
 8008fb8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8008fba:	681a      	ldr	r2, [r3, #0]
 8008fbc:	68fb      	ldr	r3, [r7, #12]
 8008fbe:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8008fc0:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8008fc4:	601a      	str	r2, [r3, #0]
    }

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
 8008fc6:	68fb      	ldr	r3, [r7, #12]
 8008fc8:	681b      	ldr	r3, [r3, #0]
 8008fca:	681a      	ldr	r2, [r3, #0]
 8008fcc:	68fb      	ldr	r3, [r7, #12]
 8008fce:	681b      	ldr	r3, [r3, #0]
 8008fd0:	f042 0201 	orr.w	r2, r2, #1
 8008fd4:	601a      	str	r2, [r3, #0]
 8008fd6:	e005      	b.n	8008fe4 <HAL_DMA_Start_IT+0xec>
  }
  else
  {
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8008fd8:	68fb      	ldr	r3, [r7, #12]
 8008fda:	2200      	movs	r2, #0
 8008fdc:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    /* Remain BUSY */
    status = HAL_BUSY;
 8008fe0:	2302      	movs	r3, #2
 8008fe2:	75fb      	strb	r3, [r7, #23]
  }
  return status;
 8008fe4:	7dfb      	ldrb	r3, [r7, #23]
}
 8008fe6:	4618      	mov	r0, r3
 8008fe8:	3718      	adds	r7, #24
 8008fea:	46bd      	mov	sp, r7
 8008fec:	bd80      	pop	{r7, pc}

08008fee <HAL_DMA_Abort>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
    * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
 8008fee:	b480      	push	{r7}
 8008ff0:	b085      	sub	sp, #20
 8008ff2:	af00      	add	r7, sp, #0
 8008ff4:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8008ff6:	2300      	movs	r3, #0
 8008ff8:	73fb      	strb	r3, [r7, #15]

  if(hdma->State != HAL_DMA_STATE_BUSY)
 8008ffa:	687b      	ldr	r3, [r7, #4]
 8008ffc:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8009000:	b2db      	uxtb	r3, r3
 8009002:	2b02      	cmp	r3, #2
 8009004:	d005      	beq.n	8009012 <HAL_DMA_Abort+0x24>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8009006:	687b      	ldr	r3, [r7, #4]
 8009008:	2204      	movs	r2, #4
 800900a:	63da      	str	r2, [r3, #60]	; 0x3c

    status = HAL_ERROR;
 800900c:	2301      	movs	r3, #1
 800900e:	73fb      	strb	r3, [r7, #15]
 8009010:	e037      	b.n	8009082 <HAL_DMA_Abort+0x94>
  }
  else
  {
     /* Disable DMA IT */
     __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8009012:	687b      	ldr	r3, [r7, #4]
 8009014:	681b      	ldr	r3, [r3, #0]
 8009016:	681a      	ldr	r2, [r3, #0]
 8009018:	687b      	ldr	r3, [r7, #4]
 800901a:	681b      	ldr	r3, [r3, #0]
 800901c:	f022 020e 	bic.w	r2, r2, #14
 8009020:	601a      	str	r2, [r3, #0]
     
     /* disable the DMAMUX sync overrun IT*/
     hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8009022:	687b      	ldr	r3, [r7, #4]
 8009024:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009026:	681a      	ldr	r2, [r3, #0]
 8009028:	687b      	ldr	r3, [r7, #4]
 800902a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800902c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8009030:	601a      	str	r2, [r3, #0]
     
     /* Disable the channel */
     __HAL_DMA_DISABLE(hdma);
 8009032:	687b      	ldr	r3, [r7, #4]
 8009034:	681b      	ldr	r3, [r3, #0]
 8009036:	681a      	ldr	r2, [r3, #0]
 8009038:	687b      	ldr	r3, [r7, #4]
 800903a:	681b      	ldr	r3, [r3, #0]
 800903c:	f022 0201 	bic.w	r2, r2, #1
 8009040:	601a      	str	r2, [r3, #0]
     
     /* Clear all flags */
     hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1FU));
 8009042:	687b      	ldr	r3, [r7, #4]
 8009044:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009046:	f003 021f 	and.w	r2, r3, #31
 800904a:	687b      	ldr	r3, [r7, #4]
 800904c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800904e:	2101      	movs	r1, #1
 8009050:	fa01 f202 	lsl.w	r2, r1, r2
 8009054:	605a      	str	r2, [r3, #4]
     
     /* Clear the DMAMUX synchro overrun flag */
     hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8009056:	687b      	ldr	r3, [r7, #4]
 8009058:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800905a:	687a      	ldr	r2, [r7, #4]
 800905c:	6d12      	ldr	r2, [r2, #80]	; 0x50
 800905e:	605a      	str	r2, [r3, #4]
     
     if (hdma->DMAmuxRequestGen != 0U)
 8009060:	687b      	ldr	r3, [r7, #4]
 8009062:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009064:	2b00      	cmp	r3, #0
 8009066:	d00c      	beq.n	8009082 <HAL_DMA_Abort+0x94>
     {
       /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/
       /* disable the request gen overrun IT*/
       hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 8009068:	687b      	ldr	r3, [r7, #4]
 800906a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800906c:	681a      	ldr	r2, [r3, #0]
 800906e:	687b      	ldr	r3, [r7, #4]
 8009070:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009072:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8009076:	601a      	str	r2, [r3, #0]
     
       /* Clear the DMAMUX request generator overrun flag */
       hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8009078:	687b      	ldr	r3, [r7, #4]
 800907a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800907c:	687a      	ldr	r2, [r7, #4]
 800907e:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8009080:	605a      	str	r2, [r3, #4]
     }
  }  
  /* Change the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 8009082:	687b      	ldr	r3, [r7, #4]
 8009084:	2201      	movs	r2, #1
 8009086:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

  /* Process Unlocked */
  __HAL_UNLOCK(hdma);
 800908a:	687b      	ldr	r3, [r7, #4]
 800908c:	2200      	movs	r2, #0
 800908e:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  return status;
 8009092:	7bfb      	ldrb	r3, [r7, #15]
}
 8009094:	4618      	mov	r0, r3
 8009096:	3714      	adds	r7, #20
 8009098:	46bd      	mov	sp, r7
 800909a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800909e:	4770      	bx	lr

080090a0 <HAL_DMA_Abort_IT>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 80090a0:	b580      	push	{r7, lr}
 80090a2:	b084      	sub	sp, #16
 80090a4:	af00      	add	r7, sp, #0
 80090a6:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 80090a8:	2300      	movs	r3, #0
 80090aa:	73fb      	strb	r3, [r7, #15]

  if (HAL_DMA_STATE_BUSY != hdma->State)
 80090ac:	687b      	ldr	r3, [r7, #4]
 80090ae:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 80090b2:	b2db      	uxtb	r3, r3
 80090b4:	2b02      	cmp	r3, #2
 80090b6:	d00d      	beq.n	80090d4 <HAL_DMA_Abort_IT+0x34>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80090b8:	687b      	ldr	r3, [r7, #4]
 80090ba:	2204      	movs	r2, #4
 80090bc:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 80090be:	687b      	ldr	r3, [r7, #4]
 80090c0:	2201      	movs	r2, #1
 80090c2:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 80090c6:	687b      	ldr	r3, [r7, #4]
 80090c8:	2200      	movs	r2, #0
 80090ca:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    status = HAL_ERROR;
 80090ce:	2301      	movs	r3, #1
 80090d0:	73fb      	strb	r3, [r7, #15]
 80090d2:	e047      	b.n	8009164 <HAL_DMA_Abort_IT+0xc4>
  }
  else
  {
    /* Disable DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80090d4:	687b      	ldr	r3, [r7, #4]
 80090d6:	681b      	ldr	r3, [r3, #0]
 80090d8:	681a      	ldr	r2, [r3, #0]
 80090da:	687b      	ldr	r3, [r7, #4]
 80090dc:	681b      	ldr	r3, [r3, #0]
 80090de:	f022 020e 	bic.w	r2, r2, #14
 80090e2:	601a      	str	r2, [r3, #0]

    /* Disable the channel */
    __HAL_DMA_DISABLE(hdma);
 80090e4:	687b      	ldr	r3, [r7, #4]
 80090e6:	681b      	ldr	r3, [r3, #0]
 80090e8:	681a      	ldr	r2, [r3, #0]
 80090ea:	687b      	ldr	r3, [r7, #4]
 80090ec:	681b      	ldr	r3, [r3, #0]
 80090ee:	f022 0201 	bic.w	r2, r2, #1
 80090f2:	601a      	str	r2, [r3, #0]

    /* disable the DMAMUX sync overrun IT*/
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 80090f4:	687b      	ldr	r3, [r7, #4]
 80090f6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80090f8:	681a      	ldr	r2, [r3, #0]
 80090fa:	687b      	ldr	r3, [r7, #4]
 80090fc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80090fe:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8009102:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1FU));
 8009104:	687b      	ldr	r3, [r7, #4]
 8009106:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009108:	f003 021f 	and.w	r2, r3, #31
 800910c:	687b      	ldr	r3, [r7, #4]
 800910e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009110:	2101      	movs	r1, #1
 8009112:	fa01 f202 	lsl.w	r2, r1, r2
 8009116:	605a      	str	r2, [r3, #4]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8009118:	687b      	ldr	r3, [r7, #4]
 800911a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800911c:	687a      	ldr	r2, [r7, #4]
 800911e:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8009120:	605a      	str	r2, [r3, #4]

    if (hdma->DMAmuxRequestGen != 0U)
 8009122:	687b      	ldr	r3, [r7, #4]
 8009124:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009126:	2b00      	cmp	r3, #0
 8009128:	d00c      	beq.n	8009144 <HAL_DMA_Abort_IT+0xa4>
    {
      /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/
      /* disable the request gen overrun IT*/
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 800912a:	687b      	ldr	r3, [r7, #4]
 800912c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800912e:	681a      	ldr	r2, [r3, #0]
 8009130:	687b      	ldr	r3, [r7, #4]
 8009132:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009134:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8009138:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 800913a:	687b      	ldr	r3, [r7, #4]
 800913c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800913e:	687a      	ldr	r2, [r7, #4]
 8009140:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8009142:	605a      	str	r2, [r3, #4]
    }

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 8009144:	687b      	ldr	r3, [r7, #4]
 8009146:	2201      	movs	r2, #1
 8009148:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 800914c:	687b      	ldr	r3, [r7, #4]
 800914e:	2200      	movs	r2, #0
 8009150:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    /* Call User Abort callback */
    if (hdma->XferAbortCallback != NULL)
 8009154:	687b      	ldr	r3, [r7, #4]
 8009156:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009158:	2b00      	cmp	r3, #0
 800915a:	d003      	beq.n	8009164 <HAL_DMA_Abort_IT+0xc4>
    {
      hdma->XferAbortCallback(hdma);
 800915c:	687b      	ldr	r3, [r7, #4]
 800915e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009160:	6878      	ldr	r0, [r7, #4]
 8009162:	4798      	blx	r3
    }
  }
  return status;
 8009164:	7bfb      	ldrb	r3, [r7, #15]
}
 8009166:	4618      	mov	r0, r3
 8009168:	3710      	adds	r7, #16
 800916a:	46bd      	mov	sp, r7
 800916c:	bd80      	pop	{r7, pc}

0800916e <HAL_DMA_IRQHandler>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 800916e:	b580      	push	{r7, lr}
 8009170:	b084      	sub	sp, #16
 8009172:	af00      	add	r7, sp, #0
 8009174:	6078      	str	r0, [r7, #4]
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 8009176:	687b      	ldr	r3, [r7, #4]
 8009178:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800917a:	681b      	ldr	r3, [r3, #0]
 800917c:	60fb      	str	r3, [r7, #12]
  uint32_t source_it = hdma->Instance->CCR;
 800917e:	687b      	ldr	r3, [r7, #4]
 8009180:	681b      	ldr	r3, [r3, #0]
 8009182:	681b      	ldr	r3, [r3, #0]
 8009184:	60bb      	str	r3, [r7, #8]

  /* Half Transfer Complete Interrupt management ******************************/
  if ((0U != (flag_it & ((uint32_t)DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1FU)))) && (0U != (source_it & DMA_IT_HT)))
 8009186:	687b      	ldr	r3, [r7, #4]
 8009188:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800918a:	f003 031f 	and.w	r3, r3, #31
 800918e:	2204      	movs	r2, #4
 8009190:	409a      	lsls	r2, r3
 8009192:	68fb      	ldr	r3, [r7, #12]
 8009194:	4013      	ands	r3, r2
 8009196:	2b00      	cmp	r3, #0
 8009198:	d026      	beq.n	80091e8 <HAL_DMA_IRQHandler+0x7a>
 800919a:	68bb      	ldr	r3, [r7, #8]
 800919c:	f003 0304 	and.w	r3, r3, #4
 80091a0:	2b00      	cmp	r3, #0
 80091a2:	d021      	beq.n	80091e8 <HAL_DMA_IRQHandler+0x7a>
  {
    /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
    if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 80091a4:	687b      	ldr	r3, [r7, #4]
 80091a6:	681b      	ldr	r3, [r3, #0]
 80091a8:	681b      	ldr	r3, [r3, #0]
 80091aa:	f003 0320 	and.w	r3, r3, #32
 80091ae:	2b00      	cmp	r3, #0
 80091b0:	d107      	bne.n	80091c2 <HAL_DMA_IRQHandler+0x54>
    {
      /* Disable the half transfer interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 80091b2:	687b      	ldr	r3, [r7, #4]
 80091b4:	681b      	ldr	r3, [r3, #0]
 80091b6:	681a      	ldr	r2, [r3, #0]
 80091b8:	687b      	ldr	r3, [r7, #4]
 80091ba:	681b      	ldr	r3, [r3, #0]
 80091bc:	f022 0204 	bic.w	r2, r2, #4
 80091c0:	601a      	str	r2, [r3, #0]
    }
    /* Clear the half transfer complete flag */
    hdma->DmaBaseAddress->IFCR = ((uint32_t)DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1FU));
 80091c2:	687b      	ldr	r3, [r7, #4]
 80091c4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80091c6:	f003 021f 	and.w	r2, r3, #31
 80091ca:	687b      	ldr	r3, [r7, #4]
 80091cc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80091ce:	2104      	movs	r1, #4
 80091d0:	fa01 f202 	lsl.w	r2, r1, r2
 80091d4:	605a      	str	r2, [r3, #4]

    /* DMA peripheral state is not updated in Half Transfer */
    /* but in Transfer Complete case */

    if (hdma->XferHalfCpltCallback != NULL)
 80091d6:	687b      	ldr	r3, [r7, #4]
 80091d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80091da:	2b00      	cmp	r3, #0
 80091dc:	d071      	beq.n	80092c2 <HAL_DMA_IRQHandler+0x154>
    {
      /* Half transfer callback */
      hdma->XferHalfCpltCallback(hdma);
 80091de:	687b      	ldr	r3, [r7, #4]
 80091e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80091e2:	6878      	ldr	r0, [r7, #4]
 80091e4:	4798      	blx	r3
    if (hdma->XferHalfCpltCallback != NULL)
 80091e6:	e06c      	b.n	80092c2 <HAL_DMA_IRQHandler+0x154>
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  else if ((0U != (flag_it & ((uint32_t)DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1FU))))
 80091e8:	687b      	ldr	r3, [r7, #4]
 80091ea:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80091ec:	f003 031f 	and.w	r3, r3, #31
 80091f0:	2202      	movs	r2, #2
 80091f2:	409a      	lsls	r2, r3
 80091f4:	68fb      	ldr	r3, [r7, #12]
 80091f6:	4013      	ands	r3, r2
 80091f8:	2b00      	cmp	r3, #0
 80091fa:	d02e      	beq.n	800925a <HAL_DMA_IRQHandler+0xec>
           && (0U != (source_it & DMA_IT_TC)))
 80091fc:	68bb      	ldr	r3, [r7, #8]
 80091fe:	f003 0302 	and.w	r3, r3, #2
 8009202:	2b00      	cmp	r3, #0
 8009204:	d029      	beq.n	800925a <HAL_DMA_IRQHandler+0xec>
  {
    if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8009206:	687b      	ldr	r3, [r7, #4]
 8009208:	681b      	ldr	r3, [r3, #0]
 800920a:	681b      	ldr	r3, [r3, #0]
 800920c:	f003 0320 	and.w	r3, r3, #32
 8009210:	2b00      	cmp	r3, #0
 8009212:	d10b      	bne.n	800922c <HAL_DMA_IRQHandler+0xbe>
    {
      /* Disable the transfer complete and error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 8009214:	687b      	ldr	r3, [r7, #4]
 8009216:	681b      	ldr	r3, [r3, #0]
 8009218:	681a      	ldr	r2, [r3, #0]
 800921a:	687b      	ldr	r3, [r7, #4]
 800921c:	681b      	ldr	r3, [r3, #0]
 800921e:	f022 020a 	bic.w	r2, r2, #10
 8009222:	601a      	str	r2, [r3, #0]

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 8009224:	687b      	ldr	r3, [r7, #4]
 8009226:	2201      	movs	r2, #1
 8009228:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
    }
    /* Clear the transfer complete flag */
    hdma->DmaBaseAddress->IFCR = ((uint32_t)DMA_ISR_TCIF1 << (hdma->ChannelIndex & 0x1FU));
 800922c:	687b      	ldr	r3, [r7, #4]
 800922e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009230:	f003 021f 	and.w	r2, r3, #31
 8009234:	687b      	ldr	r3, [r7, #4]
 8009236:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009238:	2102      	movs	r1, #2
 800923a:	fa01 f202 	lsl.w	r2, r1, r2
 800923e:	605a      	str	r2, [r3, #4]

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8009240:	687b      	ldr	r3, [r7, #4]
 8009242:	2200      	movs	r2, #0
 8009244:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    if (hdma->XferCpltCallback != NULL)
 8009248:	687b      	ldr	r3, [r7, #4]
 800924a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800924c:	2b00      	cmp	r3, #0
 800924e:	d038      	beq.n	80092c2 <HAL_DMA_IRQHandler+0x154>
    {
      /* Transfer complete callback */
      hdma->XferCpltCallback(hdma);
 8009250:	687b      	ldr	r3, [r7, #4]
 8009252:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009254:	6878      	ldr	r0, [r7, #4]
 8009256:	4798      	blx	r3
    if (hdma->XferCpltCallback != NULL)
 8009258:	e033      	b.n	80092c2 <HAL_DMA_IRQHandler+0x154>
    }
  }
  /* Transfer Error Interrupt management **************************************/
  else if ((0U != (flag_it & ((uint32_t)DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1FU))))
 800925a:	687b      	ldr	r3, [r7, #4]
 800925c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800925e:	f003 031f 	and.w	r3, r3, #31
 8009262:	2208      	movs	r2, #8
 8009264:	409a      	lsls	r2, r3
 8009266:	68fb      	ldr	r3, [r7, #12]
 8009268:	4013      	ands	r3, r2
 800926a:	2b00      	cmp	r3, #0
 800926c:	d02a      	beq.n	80092c4 <HAL_DMA_IRQHandler+0x156>
           && (0U != (source_it & DMA_IT_TE)))
 800926e:	68bb      	ldr	r3, [r7, #8]
 8009270:	f003 0308 	and.w	r3, r3, #8
 8009274:	2b00      	cmp	r3, #0
 8009276:	d025      	beq.n	80092c4 <HAL_DMA_IRQHandler+0x156>
  {
    /* When a DMA transfer error occurs */
    /* A hardware clear of its EN bits is performed */
    /* Disable ALL DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8009278:	687b      	ldr	r3, [r7, #4]
 800927a:	681b      	ldr	r3, [r3, #0]
 800927c:	681a      	ldr	r2, [r3, #0]
 800927e:	687b      	ldr	r3, [r7, #4]
 8009280:	681b      	ldr	r3, [r3, #0]
 8009282:	f022 020e 	bic.w	r2, r2, #14
 8009286:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = ((uint32_t)DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1FU));
 8009288:	687b      	ldr	r3, [r7, #4]
 800928a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800928c:	f003 021f 	and.w	r2, r3, #31
 8009290:	687b      	ldr	r3, [r7, #4]
 8009292:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009294:	2101      	movs	r1, #1
 8009296:	fa01 f202 	lsl.w	r2, r1, r2
 800929a:	605a      	str	r2, [r3, #4]

    /* Update error code */
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 800929c:	687b      	ldr	r3, [r7, #4]
 800929e:	2201      	movs	r2, #1
 80092a0:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 80092a2:	687b      	ldr	r3, [r7, #4]
 80092a4:	2201      	movs	r2, #1
 80092a6:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 80092aa:	687b      	ldr	r3, [r7, #4]
 80092ac:	2200      	movs	r2, #0
 80092ae:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    if (hdma->XferErrorCallback != NULL)
 80092b2:	687b      	ldr	r3, [r7, #4]
 80092b4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80092b6:	2b00      	cmp	r3, #0
 80092b8:	d004      	beq.n	80092c4 <HAL_DMA_IRQHandler+0x156>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 80092ba:	687b      	ldr	r3, [r7, #4]
 80092bc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80092be:	6878      	ldr	r0, [r7, #4]
 80092c0:	4798      	blx	r3
  }
  else
  {
    /* Nothing To Do */
  }
  return;
 80092c2:	bf00      	nop
 80092c4:	bf00      	nop
}
 80092c6:	3710      	adds	r7, #16
 80092c8:	46bd      	mov	sp, r7
 80092ca:	bd80      	pop	{r7, pc}

080092cc <DMA_SetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 80092cc:	b480      	push	{r7}
 80092ce:	b085      	sub	sp, #20
 80092d0:	af00      	add	r7, sp, #0
 80092d2:	60f8      	str	r0, [r7, #12]
 80092d4:	60b9      	str	r1, [r7, #8]
 80092d6:	607a      	str	r2, [r7, #4]
 80092d8:	603b      	str	r3, [r7, #0]
  /* Clear the DMAMUX synchro overrun flag */
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 80092da:	68fb      	ldr	r3, [r7, #12]
 80092dc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80092de:	68fa      	ldr	r2, [r7, #12]
 80092e0:	6d12      	ldr	r2, [r2, #80]	; 0x50
 80092e2:	605a      	str	r2, [r3, #4]

  if (hdma->DMAmuxRequestGen != 0U)
 80092e4:	68fb      	ldr	r3, [r7, #12]
 80092e6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80092e8:	2b00      	cmp	r3, #0
 80092ea:	d004      	beq.n	80092f6 <DMA_SetConfig+0x2a>
  {
    /* Clear the DMAMUX request generator overrun flag */
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 80092ec:	68fb      	ldr	r3, [r7, #12]
 80092ee:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80092f0:	68fa      	ldr	r2, [r7, #12]
 80092f2:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 80092f4:	605a      	str	r2, [r3, #4]
  }

  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1FU));
 80092f6:	68fb      	ldr	r3, [r7, #12]
 80092f8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80092fa:	f003 021f 	and.w	r2, r3, #31
 80092fe:	68fb      	ldr	r3, [r7, #12]
 8009300:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009302:	2101      	movs	r1, #1
 8009304:	fa01 f202 	lsl.w	r2, r1, r2
 8009308:	605a      	str	r2, [r3, #4]

  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;
 800930a:	68fb      	ldr	r3, [r7, #12]
 800930c:	681b      	ldr	r3, [r3, #0]
 800930e:	683a      	ldr	r2, [r7, #0]
 8009310:	605a      	str	r2, [r3, #4]

  /* Memory to Peripheral */
  if ((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8009312:	68fb      	ldr	r3, [r7, #12]
 8009314:	689b      	ldr	r3, [r3, #8]
 8009316:	2b10      	cmp	r3, #16
 8009318:	d108      	bne.n	800932c <DMA_SetConfig+0x60>
  {
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;
 800931a:	68fb      	ldr	r3, [r7, #12]
 800931c:	681b      	ldr	r3, [r3, #0]
 800931e:	687a      	ldr	r2, [r7, #4]
 8009320:	609a      	str	r2, [r3, #8]

    /* Configure DMA Channel source address */
    hdma->Instance->CMAR = SrcAddress;
 8009322:	68fb      	ldr	r3, [r7, #12]
 8009324:	681b      	ldr	r3, [r3, #0]
 8009326:	68ba      	ldr	r2, [r7, #8]
 8009328:	60da      	str	r2, [r3, #12]
    hdma->Instance->CPAR = SrcAddress;

    /* Configure DMA Channel destination address */
    hdma->Instance->CMAR = DstAddress;
  }
}
 800932a:	e007      	b.n	800933c <DMA_SetConfig+0x70>
    hdma->Instance->CPAR = SrcAddress;
 800932c:	68fb      	ldr	r3, [r7, #12]
 800932e:	681b      	ldr	r3, [r3, #0]
 8009330:	68ba      	ldr	r2, [r7, #8]
 8009332:	609a      	str	r2, [r3, #8]
    hdma->Instance->CMAR = DstAddress;
 8009334:	68fb      	ldr	r3, [r7, #12]
 8009336:	681b      	ldr	r3, [r3, #0]
 8009338:	687a      	ldr	r2, [r7, #4]
 800933a:	60da      	str	r2, [r3, #12]
}
 800933c:	bf00      	nop
 800933e:	3714      	adds	r7, #20
 8009340:	46bd      	mov	sp, r7
 8009342:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009346:	4770      	bx	lr

08009348 <DMA_CalcDMAMUXChannelBaseAndMask>:
  * @param  hdma        pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval None
  */
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
 8009348:	b480      	push	{r7}
 800934a:	b087      	sub	sp, #28
 800934c:	af00      	add	r7, sp, #0
 800934e:	6078      	str	r0, [r7, #4]
  uint32_t dmamux_base_addr;
  uint32_t channel_number;
  DMAMUX_Channel_TypeDef *DMAMUX1_ChannelBase;

  /* check if instance is not outside the DMA channel range */
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 8009350:	687b      	ldr	r3, [r7, #4]
 8009352:	681b      	ldr	r3, [r3, #0]
 8009354:	461a      	mov	r2, r3
 8009356:	4b16      	ldr	r3, [pc, #88]	; (80093b0 <DMA_CalcDMAMUXChannelBaseAndMask+0x68>)
 8009358:	429a      	cmp	r2, r3
 800935a:	d802      	bhi.n	8009362 <DMA_CalcDMAMUXChannelBaseAndMask+0x1a>
  {
    /* DMA1 */
    DMAMUX1_ChannelBase = DMAMUX1_Channel0;
 800935c:	4b15      	ldr	r3, [pc, #84]	; (80093b4 <DMA_CalcDMAMUXChannelBaseAndMask+0x6c>)
 800935e:	617b      	str	r3, [r7, #20]
 8009360:	e001      	b.n	8009366 <DMA_CalcDMAMUXChannelBaseAndMask+0x1e>
  }
  else
  {
    /* DMA2 */
#if defined (STM32G471xx) || defined (STM32G473xx) || defined (STM32G474xx) || defined (STM32G483xx) || defined (STM32G484xx) || defined (STM32G491xx) || defined (STM32G4A1xx)
    DMAMUX1_ChannelBase = DMAMUX1_Channel8;
 8009362:	4b15      	ldr	r3, [pc, #84]	; (80093b8 <DMA_CalcDMAMUXChannelBaseAndMask+0x70>)
 8009364:	617b      	str	r3, [r7, #20]
    DMAMUX1_ChannelBase = DMAMUX1_Channel6;
#else
    DMAMUX1_ChannelBase = DMAMUX1_Channel7;
#endif /* STM32G4x1xx) */
  }
  dmamux_base_addr = (uint32_t)DMAMUX1_ChannelBase;
 8009366:	697b      	ldr	r3, [r7, #20]
 8009368:	613b      	str	r3, [r7, #16]
  channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 800936a:	687b      	ldr	r3, [r7, #4]
 800936c:	681b      	ldr	r3, [r3, #0]
 800936e:	b2db      	uxtb	r3, r3
 8009370:	3b08      	subs	r3, #8
 8009372:	4a12      	ldr	r2, [pc, #72]	; (80093bc <DMA_CalcDMAMUXChannelBaseAndMask+0x74>)
 8009374:	fba2 2303 	umull	r2, r3, r2, r3
 8009378:	091b      	lsrs	r3, r3, #4
 800937a:	60fb      	str	r3, [r7, #12]
  hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)(uint32_t)(dmamux_base_addr + ((hdma->ChannelIndex >> 2U) * ((uint32_t)DMAMUX1_Channel1 - (uint32_t)DMAMUX1_Channel0)));
 800937c:	687b      	ldr	r3, [r7, #4]
 800937e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009380:	089b      	lsrs	r3, r3, #2
 8009382:	009a      	lsls	r2, r3, #2
 8009384:	693b      	ldr	r3, [r7, #16]
 8009386:	4413      	add	r3, r2
 8009388:	461a      	mov	r2, r3
 800938a:	687b      	ldr	r3, [r7, #4]
 800938c:	649a      	str	r2, [r3, #72]	; 0x48
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 800938e:	687b      	ldr	r3, [r7, #4]
 8009390:	4a0b      	ldr	r2, [pc, #44]	; (80093c0 <DMA_CalcDMAMUXChannelBaseAndMask+0x78>)
 8009392:	64da      	str	r2, [r3, #76]	; 0x4c
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 8009394:	68fb      	ldr	r3, [r7, #12]
 8009396:	f003 031f 	and.w	r3, r3, #31
 800939a:	2201      	movs	r2, #1
 800939c:	409a      	lsls	r2, r3
 800939e:	687b      	ldr	r3, [r7, #4]
 80093a0:	651a      	str	r2, [r3, #80]	; 0x50
}
 80093a2:	bf00      	nop
 80093a4:	371c      	adds	r7, #28
 80093a6:	46bd      	mov	sp, r7
 80093a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80093ac:	4770      	bx	lr
 80093ae:	bf00      	nop
 80093b0:	40020407 	.word	0x40020407
 80093b4:	40020800 	.word	0x40020800
 80093b8:	40020820 	.word	0x40020820
 80093bc:	cccccccd 	.word	0xcccccccd
 80093c0:	40020880 	.word	0x40020880

080093c4 <DMA_CalcDMAMUXRequestGenBaseAndMask>:
  *                     the configuration information for the specified DMA Channel.
  * @retval None
  */

static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
 80093c4:	b480      	push	{r7}
 80093c6:	b085      	sub	sp, #20
 80093c8:	af00      	add	r7, sp, #0
 80093ca:	6078      	str	r0, [r7, #4]
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;
 80093cc:	687b      	ldr	r3, [r7, #4]
 80093ce:	685b      	ldr	r3, [r3, #4]
 80093d0:	b2db      	uxtb	r3, r3
 80093d2:	60fb      	str	r3, [r7, #12]

  /* DMA Channels are connected to DMAMUX1 request generator blocks*/
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 80093d4:	68fa      	ldr	r2, [r7, #12]
 80093d6:	4b0b      	ldr	r3, [pc, #44]	; (8009404 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x40>)
 80093d8:	4413      	add	r3, r2
 80093da:	009b      	lsls	r3, r3, #2
 80093dc:	461a      	mov	r2, r3
 80093de:	687b      	ldr	r3, [r7, #4]
 80093e0:	655a      	str	r2, [r3, #84]	; 0x54

  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 80093e2:	687b      	ldr	r3, [r7, #4]
 80093e4:	4a08      	ldr	r2, [pc, #32]	; (8009408 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x44>)
 80093e6:	659a      	str	r2, [r3, #88]	; 0x58

  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x1FU);
 80093e8:	68fb      	ldr	r3, [r7, #12]
 80093ea:	3b01      	subs	r3, #1
 80093ec:	f003 031f 	and.w	r3, r3, #31
 80093f0:	2201      	movs	r2, #1
 80093f2:	409a      	lsls	r2, r3
 80093f4:	687b      	ldr	r3, [r7, #4]
 80093f6:	65da      	str	r2, [r3, #92]	; 0x5c
}
 80093f8:	bf00      	nop
 80093fa:	3714      	adds	r7, #20
 80093fc:	46bd      	mov	sp, r7
 80093fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009402:	4770      	bx	lr
 8009404:	1000823f 	.word	0x1000823f
 8009408:	40020940 	.word	0x40020940

0800940c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800940c:	b480      	push	{r7}
 800940e:	b087      	sub	sp, #28
 8009410:	af00      	add	r7, sp, #0
 8009412:	6078      	str	r0, [r7, #4]
 8009414:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
 8009416:	2300      	movs	r3, #0
 8009418:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0U)
 800941a:	e15a      	b.n	80096d2 <HAL_GPIO_Init+0x2c6>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 800941c:	683b      	ldr	r3, [r7, #0]
 800941e:	681a      	ldr	r2, [r3, #0]
 8009420:	2101      	movs	r1, #1
 8009422:	697b      	ldr	r3, [r7, #20]
 8009424:	fa01 f303 	lsl.w	r3, r1, r3
 8009428:	4013      	ands	r3, r2
 800942a:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
 800942c:	68fb      	ldr	r3, [r7, #12]
 800942e:	2b00      	cmp	r3, #0
 8009430:	f000 814c 	beq.w	80096cc <HAL_GPIO_Init+0x2c0>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 8009434:	683b      	ldr	r3, [r7, #0]
 8009436:	685b      	ldr	r3, [r3, #4]
 8009438:	f003 0303 	and.w	r3, r3, #3
 800943c:	2b01      	cmp	r3, #1
 800943e:	d005      	beq.n	800944c <HAL_GPIO_Init+0x40>
         ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8009440:	683b      	ldr	r3, [r7, #0]
 8009442:	685b      	ldr	r3, [r3, #4]
 8009444:	f003 0303 	and.w	r3, r3, #3
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 8009448:	2b02      	cmp	r3, #2
 800944a:	d130      	bne.n	80094ae <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 800944c:	687b      	ldr	r3, [r7, #4]
 800944e:	689b      	ldr	r3, [r3, #8]
 8009450:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8009452:	697b      	ldr	r3, [r7, #20]
 8009454:	005b      	lsls	r3, r3, #1
 8009456:	2203      	movs	r2, #3
 8009458:	fa02 f303 	lsl.w	r3, r2, r3
 800945c:	43db      	mvns	r3, r3
 800945e:	693a      	ldr	r2, [r7, #16]
 8009460:	4013      	ands	r3, r2
 8009462:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8009464:	683b      	ldr	r3, [r7, #0]
 8009466:	68da      	ldr	r2, [r3, #12]
 8009468:	697b      	ldr	r3, [r7, #20]
 800946a:	005b      	lsls	r3, r3, #1
 800946c:	fa02 f303 	lsl.w	r3, r2, r3
 8009470:	693a      	ldr	r2, [r7, #16]
 8009472:	4313      	orrs	r3, r2
 8009474:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 8009476:	687b      	ldr	r3, [r7, #4]
 8009478:	693a      	ldr	r2, [r7, #16]
 800947a:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 800947c:	687b      	ldr	r3, [r7, #4]
 800947e:	685b      	ldr	r3, [r3, #4]
 8009480:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8009482:	2201      	movs	r2, #1
 8009484:	697b      	ldr	r3, [r7, #20]
 8009486:	fa02 f303 	lsl.w	r3, r2, r3
 800948a:	43db      	mvns	r3, r3
 800948c:	693a      	ldr	r2, [r7, #16]
 800948e:	4013      	ands	r3, r2
 8009490:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8009492:	683b      	ldr	r3, [r7, #0]
 8009494:	685b      	ldr	r3, [r3, #4]
 8009496:	091b      	lsrs	r3, r3, #4
 8009498:	f003 0201 	and.w	r2, r3, #1
 800949c:	697b      	ldr	r3, [r7, #20]
 800949e:	fa02 f303 	lsl.w	r3, r2, r3
 80094a2:	693a      	ldr	r2, [r7, #16]
 80094a4:	4313      	orrs	r3, r2
 80094a6:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 80094a8:	687b      	ldr	r3, [r7, #4]
 80094aa:	693a      	ldr	r2, [r7, #16]
 80094ac:	605a      	str	r2, [r3, #4]
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 80094ae:	683b      	ldr	r3, [r7, #0]
 80094b0:	685b      	ldr	r3, [r3, #4]
 80094b2:	f003 0303 	and.w	r3, r3, #3
 80094b6:	2b03      	cmp	r3, #3
 80094b8:	d017      	beq.n	80094ea <HAL_GPIO_Init+0xde>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
 80094ba:	687b      	ldr	r3, [r7, #4]
 80094bc:	68db      	ldr	r3, [r3, #12]
 80094be:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 80094c0:	697b      	ldr	r3, [r7, #20]
 80094c2:	005b      	lsls	r3, r3, #1
 80094c4:	2203      	movs	r2, #3
 80094c6:	fa02 f303 	lsl.w	r3, r2, r3
 80094ca:	43db      	mvns	r3, r3
 80094cc:	693a      	ldr	r2, [r7, #16]
 80094ce:	4013      	ands	r3, r2
 80094d0:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 80094d2:	683b      	ldr	r3, [r7, #0]
 80094d4:	689a      	ldr	r2, [r3, #8]
 80094d6:	697b      	ldr	r3, [r7, #20]
 80094d8:	005b      	lsls	r3, r3, #1
 80094da:	fa02 f303 	lsl.w	r3, r2, r3
 80094de:	693a      	ldr	r2, [r7, #16]
 80094e0:	4313      	orrs	r3, r2
 80094e2:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
 80094e4:	687b      	ldr	r3, [r7, #4]
 80094e6:	693a      	ldr	r2, [r7, #16]
 80094e8:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80094ea:	683b      	ldr	r3, [r7, #0]
 80094ec:	685b      	ldr	r3, [r3, #4]
 80094ee:	f003 0303 	and.w	r3, r3, #3
 80094f2:	2b02      	cmp	r3, #2
 80094f4:	d123      	bne.n	800953e <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 80094f6:	697b      	ldr	r3, [r7, #20]
 80094f8:	08da      	lsrs	r2, r3, #3
 80094fa:	687b      	ldr	r3, [r7, #4]
 80094fc:	3208      	adds	r2, #8
 80094fe:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8009502:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8009504:	697b      	ldr	r3, [r7, #20]
 8009506:	f003 0307 	and.w	r3, r3, #7
 800950a:	009b      	lsls	r3, r3, #2
 800950c:	220f      	movs	r2, #15
 800950e:	fa02 f303 	lsl.w	r3, r2, r3
 8009512:	43db      	mvns	r3, r3
 8009514:	693a      	ldr	r2, [r7, #16]
 8009516:	4013      	ands	r3, r2
 8009518:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 800951a:	683b      	ldr	r3, [r7, #0]
 800951c:	691a      	ldr	r2, [r3, #16]
 800951e:	697b      	ldr	r3, [r7, #20]
 8009520:	f003 0307 	and.w	r3, r3, #7
 8009524:	009b      	lsls	r3, r3, #2
 8009526:	fa02 f303 	lsl.w	r3, r2, r3
 800952a:	693a      	ldr	r2, [r7, #16]
 800952c:	4313      	orrs	r3, r2
 800952e:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3U] = temp;
 8009530:	697b      	ldr	r3, [r7, #20]
 8009532:	08da      	lsrs	r2, r3, #3
 8009534:	687b      	ldr	r3, [r7, #4]
 8009536:	3208      	adds	r2, #8
 8009538:	6939      	ldr	r1, [r7, #16]
 800953a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800953e:	687b      	ldr	r3, [r7, #4]
 8009540:	681b      	ldr	r3, [r3, #0]
 8009542:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8009544:	697b      	ldr	r3, [r7, #20]
 8009546:	005b      	lsls	r3, r3, #1
 8009548:	2203      	movs	r2, #3
 800954a:	fa02 f303 	lsl.w	r3, r2, r3
 800954e:	43db      	mvns	r3, r3
 8009550:	693a      	ldr	r2, [r7, #16]
 8009552:	4013      	ands	r3, r2
 8009554:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8009556:	683b      	ldr	r3, [r7, #0]
 8009558:	685b      	ldr	r3, [r3, #4]
 800955a:	f003 0203 	and.w	r2, r3, #3
 800955e:	697b      	ldr	r3, [r7, #20]
 8009560:	005b      	lsls	r3, r3, #1
 8009562:	fa02 f303 	lsl.w	r3, r2, r3
 8009566:	693a      	ldr	r2, [r7, #16]
 8009568:	4313      	orrs	r3, r2
 800956a:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 800956c:	687b      	ldr	r3, [r7, #4]
 800956e:	693a      	ldr	r2, [r7, #16]
 8009570:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 8009572:	683b      	ldr	r3, [r7, #0]
 8009574:	685b      	ldr	r3, [r3, #4]
 8009576:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 800957a:	2b00      	cmp	r3, #0
 800957c:	f000 80a6 	beq.w	80096cc <HAL_GPIO_Init+0x2c0>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8009580:	4b5b      	ldr	r3, [pc, #364]	; (80096f0 <HAL_GPIO_Init+0x2e4>)
 8009582:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8009584:	4a5a      	ldr	r2, [pc, #360]	; (80096f0 <HAL_GPIO_Init+0x2e4>)
 8009586:	f043 0301 	orr.w	r3, r3, #1
 800958a:	6613      	str	r3, [r2, #96]	; 0x60
 800958c:	4b58      	ldr	r3, [pc, #352]	; (80096f0 <HAL_GPIO_Init+0x2e4>)
 800958e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8009590:	f003 0301 	and.w	r3, r3, #1
 8009594:	60bb      	str	r3, [r7, #8]
 8009596:	68bb      	ldr	r3, [r7, #8]

        temp = SYSCFG->EXTICR[position >> 2U];
 8009598:	4a56      	ldr	r2, [pc, #344]	; (80096f4 <HAL_GPIO_Init+0x2e8>)
 800959a:	697b      	ldr	r3, [r7, #20]
 800959c:	089b      	lsrs	r3, r3, #2
 800959e:	3302      	adds	r3, #2
 80095a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80095a4:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 80095a6:	697b      	ldr	r3, [r7, #20]
 80095a8:	f003 0303 	and.w	r3, r3, #3
 80095ac:	009b      	lsls	r3, r3, #2
 80095ae:	220f      	movs	r2, #15
 80095b0:	fa02 f303 	lsl.w	r3, r2, r3
 80095b4:	43db      	mvns	r3, r3
 80095b6:	693a      	ldr	r2, [r7, #16]
 80095b8:	4013      	ands	r3, r2
 80095ba:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80095bc:	687b      	ldr	r3, [r7, #4]
 80095be:	f1b3 4f90 	cmp.w	r3, #1207959552	; 0x48000000
 80095c2:	d01f      	beq.n	8009604 <HAL_GPIO_Init+0x1f8>
 80095c4:	687b      	ldr	r3, [r7, #4]
 80095c6:	4a4c      	ldr	r2, [pc, #304]	; (80096f8 <HAL_GPIO_Init+0x2ec>)
 80095c8:	4293      	cmp	r3, r2
 80095ca:	d019      	beq.n	8009600 <HAL_GPIO_Init+0x1f4>
 80095cc:	687b      	ldr	r3, [r7, #4]
 80095ce:	4a4b      	ldr	r2, [pc, #300]	; (80096fc <HAL_GPIO_Init+0x2f0>)
 80095d0:	4293      	cmp	r3, r2
 80095d2:	d013      	beq.n	80095fc <HAL_GPIO_Init+0x1f0>
 80095d4:	687b      	ldr	r3, [r7, #4]
 80095d6:	4a4a      	ldr	r2, [pc, #296]	; (8009700 <HAL_GPIO_Init+0x2f4>)
 80095d8:	4293      	cmp	r3, r2
 80095da:	d00d      	beq.n	80095f8 <HAL_GPIO_Init+0x1ec>
 80095dc:	687b      	ldr	r3, [r7, #4]
 80095de:	4a49      	ldr	r2, [pc, #292]	; (8009704 <HAL_GPIO_Init+0x2f8>)
 80095e0:	4293      	cmp	r3, r2
 80095e2:	d007      	beq.n	80095f4 <HAL_GPIO_Init+0x1e8>
 80095e4:	687b      	ldr	r3, [r7, #4]
 80095e6:	4a48      	ldr	r2, [pc, #288]	; (8009708 <HAL_GPIO_Init+0x2fc>)
 80095e8:	4293      	cmp	r3, r2
 80095ea:	d101      	bne.n	80095f0 <HAL_GPIO_Init+0x1e4>
 80095ec:	2305      	movs	r3, #5
 80095ee:	e00a      	b.n	8009606 <HAL_GPIO_Init+0x1fa>
 80095f0:	2306      	movs	r3, #6
 80095f2:	e008      	b.n	8009606 <HAL_GPIO_Init+0x1fa>
 80095f4:	2304      	movs	r3, #4
 80095f6:	e006      	b.n	8009606 <HAL_GPIO_Init+0x1fa>
 80095f8:	2303      	movs	r3, #3
 80095fa:	e004      	b.n	8009606 <HAL_GPIO_Init+0x1fa>
 80095fc:	2302      	movs	r3, #2
 80095fe:	e002      	b.n	8009606 <HAL_GPIO_Init+0x1fa>
 8009600:	2301      	movs	r3, #1
 8009602:	e000      	b.n	8009606 <HAL_GPIO_Init+0x1fa>
 8009604:	2300      	movs	r3, #0
 8009606:	697a      	ldr	r2, [r7, #20]
 8009608:	f002 0203 	and.w	r2, r2, #3
 800960c:	0092      	lsls	r2, r2, #2
 800960e:	4093      	lsls	r3, r2
 8009610:	693a      	ldr	r2, [r7, #16]
 8009612:	4313      	orrs	r3, r2
 8009614:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2U] = temp;
 8009616:	4937      	ldr	r1, [pc, #220]	; (80096f4 <HAL_GPIO_Init+0x2e8>)
 8009618:	697b      	ldr	r3, [r7, #20]
 800961a:	089b      	lsrs	r3, r3, #2
 800961c:	3302      	adds	r3, #2
 800961e:	693a      	ldr	r2, [r7, #16]
 8009620:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8009624:	4b39      	ldr	r3, [pc, #228]	; (800970c <HAL_GPIO_Init+0x300>)
 8009626:	689b      	ldr	r3, [r3, #8]
 8009628:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 800962a:	68fb      	ldr	r3, [r7, #12]
 800962c:	43db      	mvns	r3, r3
 800962e:	693a      	ldr	r2, [r7, #16]
 8009630:	4013      	ands	r3, r2
 8009632:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 8009634:	683b      	ldr	r3, [r7, #0]
 8009636:	685b      	ldr	r3, [r3, #4]
 8009638:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800963c:	2b00      	cmp	r3, #0
 800963e:	d003      	beq.n	8009648 <HAL_GPIO_Init+0x23c>
        {
          temp |= iocurrent;
 8009640:	693a      	ldr	r2, [r7, #16]
 8009642:	68fb      	ldr	r3, [r7, #12]
 8009644:	4313      	orrs	r3, r2
 8009646:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
 8009648:	4a30      	ldr	r2, [pc, #192]	; (800970c <HAL_GPIO_Init+0x300>)
 800964a:	693b      	ldr	r3, [r7, #16]
 800964c:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR1;
 800964e:	4b2f      	ldr	r3, [pc, #188]	; (800970c <HAL_GPIO_Init+0x300>)
 8009650:	68db      	ldr	r3, [r3, #12]
 8009652:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8009654:	68fb      	ldr	r3, [r7, #12]
 8009656:	43db      	mvns	r3, r3
 8009658:	693a      	ldr	r2, [r7, #16]
 800965a:	4013      	ands	r3, r2
 800965c:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 800965e:	683b      	ldr	r3, [r7, #0]
 8009660:	685b      	ldr	r3, [r3, #4]
 8009662:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8009666:	2b00      	cmp	r3, #0
 8009668:	d003      	beq.n	8009672 <HAL_GPIO_Init+0x266>
        {
          temp |= iocurrent;
 800966a:	693a      	ldr	r2, [r7, #16]
 800966c:	68fb      	ldr	r3, [r7, #12]
 800966e:	4313      	orrs	r3, r2
 8009670:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
 8009672:	4a26      	ldr	r2, [pc, #152]	; (800970c <HAL_GPIO_Init+0x300>)
 8009674:	693b      	ldr	r3, [r7, #16]
 8009676:	60d3      	str	r3, [r2, #12]

        temp = EXTI->EMR1;
 8009678:	4b24      	ldr	r3, [pc, #144]	; (800970c <HAL_GPIO_Init+0x300>)
 800967a:	685b      	ldr	r3, [r3, #4]
 800967c:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 800967e:	68fb      	ldr	r3, [r7, #12]
 8009680:	43db      	mvns	r3, r3
 8009682:	693a      	ldr	r2, [r7, #16]
 8009684:	4013      	ands	r3, r2
 8009686:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8009688:	683b      	ldr	r3, [r7, #0]
 800968a:	685b      	ldr	r3, [r3, #4]
 800968c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8009690:	2b00      	cmp	r3, #0
 8009692:	d003      	beq.n	800969c <HAL_GPIO_Init+0x290>
        {
          temp |= iocurrent;
 8009694:	693a      	ldr	r2, [r7, #16]
 8009696:	68fb      	ldr	r3, [r7, #12]
 8009698:	4313      	orrs	r3, r2
 800969a:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
 800969c:	4a1b      	ldr	r2, [pc, #108]	; (800970c <HAL_GPIO_Init+0x300>)
 800969e:	693b      	ldr	r3, [r7, #16]
 80096a0:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 80096a2:	4b1a      	ldr	r3, [pc, #104]	; (800970c <HAL_GPIO_Init+0x300>)
 80096a4:	681b      	ldr	r3, [r3, #0]
 80096a6:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 80096a8:	68fb      	ldr	r3, [r7, #12]
 80096aa:	43db      	mvns	r3, r3
 80096ac:	693a      	ldr	r2, [r7, #16]
 80096ae:	4013      	ands	r3, r2
 80096b0:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 80096b2:	683b      	ldr	r3, [r7, #0]
 80096b4:	685b      	ldr	r3, [r3, #4]
 80096b6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80096ba:	2b00      	cmp	r3, #0
 80096bc:	d003      	beq.n	80096c6 <HAL_GPIO_Init+0x2ba>
        {
          temp |= iocurrent;
 80096be:	693a      	ldr	r2, [r7, #16]
 80096c0:	68fb      	ldr	r3, [r7, #12]
 80096c2:	4313      	orrs	r3, r2
 80096c4:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
 80096c6:	4a11      	ldr	r2, [pc, #68]	; (800970c <HAL_GPIO_Init+0x300>)
 80096c8:	693b      	ldr	r3, [r7, #16]
 80096ca:	6013      	str	r3, [r2, #0]
      }
    }

    position++;
 80096cc:	697b      	ldr	r3, [r7, #20]
 80096ce:	3301      	adds	r3, #1
 80096d0:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0U)
 80096d2:	683b      	ldr	r3, [r7, #0]
 80096d4:	681a      	ldr	r2, [r3, #0]
 80096d6:	697b      	ldr	r3, [r7, #20]
 80096d8:	fa22 f303 	lsr.w	r3, r2, r3
 80096dc:	2b00      	cmp	r3, #0
 80096de:	f47f ae9d 	bne.w	800941c <HAL_GPIO_Init+0x10>
  }
}
 80096e2:	bf00      	nop
 80096e4:	bf00      	nop
 80096e6:	371c      	adds	r7, #28
 80096e8:	46bd      	mov	sp, r7
 80096ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80096ee:	4770      	bx	lr
 80096f0:	40021000 	.word	0x40021000
 80096f4:	40010000 	.word	0x40010000
 80096f8:	48000400 	.word	0x48000400
 80096fc:	48000800 	.word	0x48000800
 8009700:	48000c00 	.word	0x48000c00
 8009704:	48001000 	.word	0x48001000
 8009708:	48001400 	.word	0x48001400
 800970c:	40010400 	.word	0x40010400

08009710 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8009710:	b480      	push	{r7}
 8009712:	b083      	sub	sp, #12
 8009714:	af00      	add	r7, sp, #0
 8009716:	6078      	str	r0, [r7, #4]
 8009718:	460b      	mov	r3, r1
 800971a:	807b      	strh	r3, [r7, #2]
 800971c:	4613      	mov	r3, r2
 800971e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8009720:	787b      	ldrb	r3, [r7, #1]
 8009722:	2b00      	cmp	r3, #0
 8009724:	d003      	beq.n	800972e <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8009726:	887a      	ldrh	r2, [r7, #2]
 8009728:	687b      	ldr	r3, [r7, #4]
 800972a:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 800972c:	e002      	b.n	8009734 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 800972e:	887a      	ldrh	r2, [r7, #2]
 8009730:	687b      	ldr	r3, [r7, #4]
 8009732:	629a      	str	r2, [r3, #40]	; 0x28
}
 8009734:	bf00      	nop
 8009736:	370c      	adds	r7, #12
 8009738:	46bd      	mov	sp, r7
 800973a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800973e:	4770      	bx	lr

08009740 <HAL_OPAMP_Init>:
  *         To unlock the configuration, perform a system reset.
  * @param  hopamp OPAMP handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OPAMP_Init(OPAMP_HandleTypeDef *hopamp)
{
 8009740:	b580      	push	{r7, lr}
 8009742:	b084      	sub	sp, #16
 8009744:	af00      	add	r7, sp, #0
 8009746:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8009748:	2300      	movs	r3, #0
 800974a:	73fb      	strb	r3, [r7, #15]

  /* Check the OPAMP handle allocation and lock status */
  /* Init not allowed if calibration is ongoing */
  if (hopamp == NULL)
 800974c:	687b      	ldr	r3, [r7, #4]
 800974e:	2b00      	cmp	r3, #0
 8009750:	d101      	bne.n	8009756 <HAL_OPAMP_Init+0x16>
  {
    return HAL_ERROR;
 8009752:	2301      	movs	r3, #1
 8009754:	e0bb      	b.n	80098ce <HAL_OPAMP_Init+0x18e>
  }
  else if (hopamp->State == HAL_OPAMP_STATE_BUSYLOCKED)
 8009756:	687b      	ldr	r3, [r7, #4]
 8009758:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 800975c:	b2db      	uxtb	r3, r3
 800975e:	2b05      	cmp	r3, #5
 8009760:	d101      	bne.n	8009766 <HAL_OPAMP_Init+0x26>
  {
    return HAL_ERROR;
 8009762:	2301      	movs	r3, #1
 8009764:	e0b3      	b.n	80098ce <HAL_OPAMP_Init+0x18e>
  }
  else if (hopamp->State == HAL_OPAMP_STATE_CALIBBUSY)
 8009766:	687b      	ldr	r3, [r7, #4]
 8009768:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 800976c:	b2db      	uxtb	r3, r3
 800976e:	2b02      	cmp	r3, #2
 8009770:	d101      	bne.n	8009776 <HAL_OPAMP_Init+0x36>
  {
    return HAL_ERROR;
 8009772:	2301      	movs	r3, #1
 8009774:	e0ab      	b.n	80098ce <HAL_OPAMP_Init+0x18e>
      assert_param(IS_OPAMP_TRIMMINGVALUE(hopamp->Init.TrimmingValueP));
      assert_param(IS_OPAMP_TRIMMINGVALUE(hopamp->Init.TrimmingValueN));
    }

    /* Init SYSCFG and the low level hardware to access opamp */
    __HAL_RCC_SYSCFG_CLK_ENABLE();
 8009776:	4b58      	ldr	r3, [pc, #352]	; (80098d8 <HAL_OPAMP_Init+0x198>)
 8009778:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800977a:	4a57      	ldr	r2, [pc, #348]	; (80098d8 <HAL_OPAMP_Init+0x198>)
 800977c:	f043 0301 	orr.w	r3, r3, #1
 8009780:	6613      	str	r3, [r2, #96]	; 0x60
 8009782:	4b55      	ldr	r3, [pc, #340]	; (80098d8 <HAL_OPAMP_Init+0x198>)
 8009784:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8009786:	f003 0301 	and.w	r3, r3, #1
 800978a:	60bb      	str	r3, [r7, #8]
 800978c:	68bb      	ldr	r3, [r7, #8]

    if (hopamp->State == HAL_OPAMP_STATE_RESET)
 800978e:	687b      	ldr	r3, [r7, #4]
 8009790:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 8009794:	b2db      	uxtb	r3, r3
 8009796:	2b00      	cmp	r3, #0
 8009798:	d103      	bne.n	80097a2 <HAL_OPAMP_Init+0x62>
    {
      /* Allocate lock resource and initialize it */
      hopamp->Lock = HAL_UNLOCKED;
 800979a:	687b      	ldr	r3, [r7, #4]
 800979c:	2200      	movs	r2, #0
 800979e:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

#if (USE_HAL_OPAMP_REGISTER_CALLBACKS == 1)
    hopamp->MspInitCallback(hopamp);
#else
    /* Call MSP init function */
    HAL_OPAMP_MspInit(hopamp);
 80097a2:	6878      	ldr	r0, [r7, #4]
 80097a4:	f7fa fec8 	bl	8004538 <HAL_OPAMP_MspInit>

    /* check if OPAMP_PGA_MODE & in Follower mode */
    /*   - InvertingInput                         */
    /* is Not Applicable                          */

    if ((hopamp->Init.Mode == OPAMP_PGA_MODE) || (hopamp->Init.Mode == OPAMP_FOLLOWER_MODE))
 80097a8:	687b      	ldr	r3, [r7, #4]
 80097aa:	689b      	ldr	r3, [r3, #8]
 80097ac:	2b40      	cmp	r3, #64	; 0x40
 80097ae:	d003      	beq.n	80097b8 <HAL_OPAMP_Init+0x78>
 80097b0:	687b      	ldr	r3, [r7, #4]
 80097b2:	689b      	ldr	r3, [r3, #8]
 80097b4:	2b60      	cmp	r3, #96	; 0x60
 80097b6:	d133      	bne.n	8009820 <HAL_OPAMP_Init+0xe0>
    {
      /* Update User Trim config first to be able to modify trimming value afterwards */
      MODIFY_REG(hopamp->Instance->CSR,
 80097b8:	687b      	ldr	r3, [r7, #4]
 80097ba:	681b      	ldr	r3, [r3, #0]
 80097bc:	681b      	ldr	r3, [r3, #0]
 80097be:	f023 0110 	bic.w	r1, r3, #16
 80097c2:	687b      	ldr	r3, [r7, #4]
 80097c4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80097c6:	687b      	ldr	r3, [r7, #4]
 80097c8:	681b      	ldr	r3, [r3, #0]
 80097ca:	430a      	orrs	r2, r1
 80097cc:	601a      	str	r2, [r3, #0]
                 OPAMP_CSR_USERTRIM,
                 hopamp->Init.UserTrimming);
      MODIFY_REG(hopamp->Instance->CSR,
 80097ce:	687b      	ldr	r3, [r7, #4]
 80097d0:	681b      	ldr	r3, [r3, #0]
 80097d2:	681a      	ldr	r2, [r3, #0]
 80097d4:	4b41      	ldr	r3, [pc, #260]	; (80098dc <HAL_OPAMP_Init+0x19c>)
 80097d6:	4013      	ands	r3, r2
 80097d8:	687a      	ldr	r2, [r7, #4]
 80097da:	6851      	ldr	r1, [r2, #4]
 80097dc:	687a      	ldr	r2, [r7, #4]
 80097de:	6892      	ldr	r2, [r2, #8]
 80097e0:	4311      	orrs	r1, r2
 80097e2:	687a      	ldr	r2, [r7, #4]
 80097e4:	6912      	ldr	r2, [r2, #16]
 80097e6:	430a      	orrs	r2, r1
 80097e8:	6879      	ldr	r1, [r7, #4]
 80097ea:	7d09      	ldrb	r1, [r1, #20]
 80097ec:	2901      	cmp	r1, #1
 80097ee:	d102      	bne.n	80097f6 <HAL_OPAMP_Init+0xb6>
 80097f0:	f44f 7180 	mov.w	r1, #256	; 0x100
 80097f4:	e000      	b.n	80097f8 <HAL_OPAMP_Init+0xb8>
 80097f6:	2100      	movs	r1, #0
 80097f8:	4311      	orrs	r1, r2
 80097fa:	687a      	ldr	r2, [r7, #4]
 80097fc:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80097fe:	4311      	orrs	r1, r2
 8009800:	687a      	ldr	r2, [r7, #4]
 8009802:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8009804:	4311      	orrs	r1, r2
 8009806:	687a      	ldr	r2, [r7, #4]
 8009808:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800980a:	04d2      	lsls	r2, r2, #19
 800980c:	4311      	orrs	r1, r2
 800980e:	687a      	ldr	r2, [r7, #4]
 8009810:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8009812:	0612      	lsls	r2, r2, #24
 8009814:	4311      	orrs	r1, r2
 8009816:	687a      	ldr	r2, [r7, #4]
 8009818:	6812      	ldr	r2, [r2, #0]
 800981a:	430b      	orrs	r3, r1
 800981c:	6013      	str	r3, [r2, #0]
 800981e:	e035      	b.n	800988c <HAL_OPAMP_Init+0x14c>
                 (hopamp->Init.TrimmingValueN << OPAMP_INPUT_INVERTING));
    }
    else /* OPAMP_STANDALONE_MODE */
    {
      /* Update User Trim config first to be able to modify trimming value afterwards */
      MODIFY_REG(hopamp->Instance->CSR,
 8009820:	687b      	ldr	r3, [r7, #4]
 8009822:	681b      	ldr	r3, [r3, #0]
 8009824:	681b      	ldr	r3, [r3, #0]
 8009826:	f023 0110 	bic.w	r1, r3, #16
 800982a:	687b      	ldr	r3, [r7, #4]
 800982c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800982e:	687b      	ldr	r3, [r7, #4]
 8009830:	681b      	ldr	r3, [r3, #0]
 8009832:	430a      	orrs	r2, r1
 8009834:	601a      	str	r2, [r3, #0]
                 OPAMP_CSR_USERTRIM,
                 hopamp->Init.UserTrimming);
      MODIFY_REG(hopamp->Instance->CSR,
 8009836:	687b      	ldr	r3, [r7, #4]
 8009838:	681b      	ldr	r3, [r3, #0]
 800983a:	681a      	ldr	r2, [r3, #0]
 800983c:	4b27      	ldr	r3, [pc, #156]	; (80098dc <HAL_OPAMP_Init+0x19c>)
 800983e:	4013      	ands	r3, r2
 8009840:	687a      	ldr	r2, [r7, #4]
 8009842:	6851      	ldr	r1, [r2, #4]
 8009844:	687a      	ldr	r2, [r7, #4]
 8009846:	6892      	ldr	r2, [r2, #8]
 8009848:	4311      	orrs	r1, r2
 800984a:	687a      	ldr	r2, [r7, #4]
 800984c:	68d2      	ldr	r2, [r2, #12]
 800984e:	4311      	orrs	r1, r2
 8009850:	687a      	ldr	r2, [r7, #4]
 8009852:	6912      	ldr	r2, [r2, #16]
 8009854:	430a      	orrs	r2, r1
 8009856:	6879      	ldr	r1, [r7, #4]
 8009858:	7d09      	ldrb	r1, [r1, #20]
 800985a:	2901      	cmp	r1, #1
 800985c:	d102      	bne.n	8009864 <HAL_OPAMP_Init+0x124>
 800985e:	f44f 7180 	mov.w	r1, #256	; 0x100
 8009862:	e000      	b.n	8009866 <HAL_OPAMP_Init+0x126>
 8009864:	2100      	movs	r1, #0
 8009866:	4311      	orrs	r1, r2
 8009868:	687a      	ldr	r2, [r7, #4]
 800986a:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800986c:	4311      	orrs	r1, r2
 800986e:	687a      	ldr	r2, [r7, #4]
 8009870:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8009872:	4311      	orrs	r1, r2
 8009874:	687a      	ldr	r2, [r7, #4]
 8009876:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8009878:	04d2      	lsls	r2, r2, #19
 800987a:	4311      	orrs	r1, r2
 800987c:	687a      	ldr	r2, [r7, #4]
 800987e:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8009880:	0612      	lsls	r2, r2, #24
 8009882:	4311      	orrs	r1, r2
 8009884:	687a      	ldr	r2, [r7, #4]
 8009886:	6812      	ldr	r2, [r2, #0]
 8009888:	430b      	orrs	r3, r1
 800988a:	6013      	str	r3, [r2, #0]
                 hopamp->Init.PgaGain |
                 (hopamp->Init.TrimmingValueP << OPAMP_INPUT_NONINVERTING) |
                 (hopamp->Init.TrimmingValueN << OPAMP_INPUT_INVERTING));
    }

    if ((READ_BIT(hopamp->Instance->TCMR, OPAMP_TCMR_LOCK)) == 0UL)
 800988c:	687b      	ldr	r3, [r7, #4]
 800988e:	681b      	ldr	r3, [r3, #0]
 8009890:	699b      	ldr	r3, [r3, #24]
 8009892:	2b00      	cmp	r3, #0
 8009894:	db10      	blt.n	80098b8 <HAL_OPAMP_Init+0x178>
    {
      MODIFY_REG(hopamp->Instance->TCMR,
 8009896:	687b      	ldr	r3, [r7, #4]
 8009898:	681b      	ldr	r3, [r3, #0]
 800989a:	699b      	ldr	r3, [r3, #24]
 800989c:	f023 013f 	bic.w	r1, r3, #63	; 0x3f
 80098a0:	687b      	ldr	r3, [r7, #4]
 80098a2:	699a      	ldr	r2, [r3, #24]
 80098a4:	687b      	ldr	r3, [r7, #4]
 80098a6:	69db      	ldr	r3, [r3, #28]
 80098a8:	431a      	orrs	r2, r3
 80098aa:	687b      	ldr	r3, [r7, #4]
 80098ac:	6a1b      	ldr	r3, [r3, #32]
 80098ae:	431a      	orrs	r2, r3
 80098b0:	687b      	ldr	r3, [r7, #4]
 80098b2:	681b      	ldr	r3, [r3, #0]
 80098b4:	430a      	orrs	r2, r1
 80098b6:	619a      	str	r2, [r3, #24]
                 hopamp->Init.InvertingInputSecondary  |
                 hopamp->Init.NonInvertingInputSecondary);
    }

    /* Update the OPAMP state*/
    if (hopamp->State == HAL_OPAMP_STATE_RESET)
 80098b8:	687b      	ldr	r3, [r7, #4]
 80098ba:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 80098be:	b2db      	uxtb	r3, r3
 80098c0:	2b00      	cmp	r3, #0
 80098c2:	d103      	bne.n	80098cc <HAL_OPAMP_Init+0x18c>
    {
      /* From RESET state to READY State */
      hopamp->State = HAL_OPAMP_STATE_READY;
 80098c4:	687b      	ldr	r3, [r7, #4]
 80098c6:	2201      	movs	r2, #1
 80098c8:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
    }
    /* else: remain in READY or BUSY state (no update) */

    return status;
 80098cc:	7bfb      	ldrb	r3, [r7, #15]
  }
}
 80098ce:	4618      	mov	r0, r3
 80098d0:	3710      	adds	r7, #16
 80098d2:	46bd      	mov	sp, r7
 80098d4:	bd80      	pop	{r7, pc}
 80098d6:	bf00      	nop
 80098d8:	40021000 	.word	0x40021000
 80098dc:	e0003e11 	.word	0xe0003e11

080098e0 <HAL_OPAMP_Start>:
  * @param  hopamp OPAMP handle
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_OPAMP_Start(OPAMP_HandleTypeDef *hopamp)
{
 80098e0:	b480      	push	{r7}
 80098e2:	b085      	sub	sp, #20
 80098e4:	af00      	add	r7, sp, #0
 80098e6:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 80098e8:	2300      	movs	r3, #0
 80098ea:	73fb      	strb	r3, [r7, #15]

  /* Check the OPAMP handle allocation */
  /* Check if OPAMP locked */
  if (hopamp == NULL)
 80098ec:	687b      	ldr	r3, [r7, #4]
 80098ee:	2b00      	cmp	r3, #0
 80098f0:	d102      	bne.n	80098f8 <HAL_OPAMP_Start+0x18>
  {
    status = HAL_ERROR;
 80098f2:	2301      	movs	r3, #1
 80098f4:	73fb      	strb	r3, [r7, #15]
 80098f6:	e01d      	b.n	8009934 <HAL_OPAMP_Start+0x54>
  }
  else if (hopamp->State == HAL_OPAMP_STATE_BUSYLOCKED)
 80098f8:	687b      	ldr	r3, [r7, #4]
 80098fa:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 80098fe:	b2db      	uxtb	r3, r3
 8009900:	2b05      	cmp	r3, #5
 8009902:	d102      	bne.n	800990a <HAL_OPAMP_Start+0x2a>
  {
    status = HAL_ERROR;
 8009904:	2301      	movs	r3, #1
 8009906:	73fb      	strb	r3, [r7, #15]
 8009908:	e014      	b.n	8009934 <HAL_OPAMP_Start+0x54>
  else
  {
    /* Check the parameter */
    assert_param(IS_OPAMP_ALL_INSTANCE(hopamp->Instance));

    if (hopamp->State == HAL_OPAMP_STATE_READY)
 800990a:	687b      	ldr	r3, [r7, #4]
 800990c:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 8009910:	b2db      	uxtb	r3, r3
 8009912:	2b01      	cmp	r3, #1
 8009914:	d10c      	bne.n	8009930 <HAL_OPAMP_Start+0x50>
    {
      /* Enable the selected opamp */
      SET_BIT(hopamp->Instance->CSR, OPAMP_CSR_OPAMPxEN);
 8009916:	687b      	ldr	r3, [r7, #4]
 8009918:	681b      	ldr	r3, [r3, #0]
 800991a:	681a      	ldr	r2, [r3, #0]
 800991c:	687b      	ldr	r3, [r7, #4]
 800991e:	681b      	ldr	r3, [r3, #0]
 8009920:	f042 0201 	orr.w	r2, r2, #1
 8009924:	601a      	str	r2, [r3, #0]

      /* Update the OPAMP state*/
      /* From HAL_OPAMP_STATE_READY to HAL_OPAMP_STATE_BUSY */
      hopamp->State = HAL_OPAMP_STATE_BUSY;
 8009926:	687b      	ldr	r3, [r7, #4]
 8009928:	2204      	movs	r2, #4
 800992a:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
 800992e:	e001      	b.n	8009934 <HAL_OPAMP_Start+0x54>
    }
    else
    {
      status = HAL_ERROR;
 8009930:	2301      	movs	r3, #1
 8009932:	73fb      	strb	r3, [r7, #15]
    }


  }
  return status;
 8009934:	7bfb      	ldrb	r3, [r7, #15]
}
 8009936:	4618      	mov	r0, r3
 8009938:	3714      	adds	r7, #20
 800993a:	46bd      	mov	sp, r7
 800993c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009940:	4770      	bx	lr
	...

08009944 <HAL_PWREx_ControlVoltageScaling>:
  *        cleared before returning the status. If the flag is not cleared within
  *        50 microseconds, HAL_TIMEOUT status is reported.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
 8009944:	b480      	push	{r7}
 8009946:	b085      	sub	sp, #20
 8009948:	af00      	add	r7, sp, #0
 800994a:	6078      	str	r0, [r7, #4]
  uint32_t wait_loop_index;

  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));

  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
 800994c:	687b      	ldr	r3, [r7, #4]
 800994e:	2b00      	cmp	r3, #0
 8009950:	d141      	bne.n	80099d6 <HAL_PWREx_ControlVoltageScaling+0x92>
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8009952:	4b4b      	ldr	r3, [pc, #300]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8009954:	681b      	ldr	r3, [r3, #0]
 8009956:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 800995a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800995e:	d131      	bne.n	80099c4 <HAL_PWREx_ControlVoltageScaling+0x80>
    {
      /* Make sure Range 1 Boost is enabled */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8009960:	4b47      	ldr	r3, [pc, #284]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8009962:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8009966:	4a46      	ldr	r2, [pc, #280]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8009968:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800996c:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80

      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8009970:	4b43      	ldr	r3, [pc, #268]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8009972:	681b      	ldr	r3, [r3, #0]
 8009974:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8009978:	4a41      	ldr	r2, [pc, #260]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 800997a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800997e:	6013      	str	r3, [r2, #0]

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8009980:	4b40      	ldr	r3, [pc, #256]	; (8009a84 <HAL_PWREx_ControlVoltageScaling+0x140>)
 8009982:	681b      	ldr	r3, [r3, #0]
 8009984:	2232      	movs	r2, #50	; 0x32
 8009986:	fb02 f303 	mul.w	r3, r2, r3
 800998a:	4a3f      	ldr	r2, [pc, #252]	; (8009a88 <HAL_PWREx_ControlVoltageScaling+0x144>)
 800998c:	fba2 2303 	umull	r2, r3, r2, r3
 8009990:	0c9b      	lsrs	r3, r3, #18
 8009992:	3301      	adds	r3, #1
 8009994:	60fb      	str	r3, [r7, #12]
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8009996:	e002      	b.n	800999e <HAL_PWREx_ControlVoltageScaling+0x5a>
      {
        wait_loop_index--;
 8009998:	68fb      	ldr	r3, [r7, #12]
 800999a:	3b01      	subs	r3, #1
 800999c:	60fb      	str	r3, [r7, #12]
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 800999e:	4b38      	ldr	r3, [pc, #224]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 80099a0:	695b      	ldr	r3, [r3, #20]
 80099a2:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80099a6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80099aa:	d102      	bne.n	80099b2 <HAL_PWREx_ControlVoltageScaling+0x6e>
 80099ac:	68fb      	ldr	r3, [r7, #12]
 80099ae:	2b00      	cmp	r3, #0
 80099b0:	d1f2      	bne.n	8009998 <HAL_PWREx_ControlVoltageScaling+0x54>
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 80099b2:	4b33      	ldr	r3, [pc, #204]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 80099b4:	695b      	ldr	r3, [r3, #20]
 80099b6:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80099ba:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80099be:	d158      	bne.n	8009a72 <HAL_PWREx_ControlVoltageScaling+0x12e>
      {
        return HAL_TIMEOUT;
 80099c0:	2303      	movs	r3, #3
 80099c2:	e057      	b.n	8009a74 <HAL_PWREx_ControlVoltageScaling+0x130>
    }
    /* If current range is range 1 normal or boost mode */
    else
    {
      /* Enable Range 1 Boost (no issue if bit already reset) */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 80099c4:	4b2e      	ldr	r3, [pc, #184]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 80099c6:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80099ca:	4a2d      	ldr	r2, [pc, #180]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 80099cc:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80099d0:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
 80099d4:	e04d      	b.n	8009a72 <HAL_PWREx_ControlVoltageScaling+0x12e>
    }
  }
  else if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 80099d6:	687b      	ldr	r3, [r7, #4]
 80099d8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80099dc:	d141      	bne.n	8009a62 <HAL_PWREx_ControlVoltageScaling+0x11e>
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 80099de:	4b28      	ldr	r3, [pc, #160]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 80099e0:	681b      	ldr	r3, [r3, #0]
 80099e2:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 80099e6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80099ea:	d131      	bne.n	8009a50 <HAL_PWREx_ControlVoltageScaling+0x10c>
    {
      /* Make sure Range 1 Boost is disabled */
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 80099ec:	4b24      	ldr	r3, [pc, #144]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 80099ee:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80099f2:	4a23      	ldr	r2, [pc, #140]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 80099f4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80099f8:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80

      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 80099fc:	4b20      	ldr	r3, [pc, #128]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 80099fe:	681b      	ldr	r3, [r3, #0]
 8009a00:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8009a04:	4a1e      	ldr	r2, [pc, #120]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8009a06:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8009a0a:	6013      	str	r3, [r2, #0]

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8009a0c:	4b1d      	ldr	r3, [pc, #116]	; (8009a84 <HAL_PWREx_ControlVoltageScaling+0x140>)
 8009a0e:	681b      	ldr	r3, [r3, #0]
 8009a10:	2232      	movs	r2, #50	; 0x32
 8009a12:	fb02 f303 	mul.w	r3, r2, r3
 8009a16:	4a1c      	ldr	r2, [pc, #112]	; (8009a88 <HAL_PWREx_ControlVoltageScaling+0x144>)
 8009a18:	fba2 2303 	umull	r2, r3, r2, r3
 8009a1c:	0c9b      	lsrs	r3, r3, #18
 8009a1e:	3301      	adds	r3, #1
 8009a20:	60fb      	str	r3, [r7, #12]
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8009a22:	e002      	b.n	8009a2a <HAL_PWREx_ControlVoltageScaling+0xe6>
      {
        wait_loop_index--;
 8009a24:	68fb      	ldr	r3, [r7, #12]
 8009a26:	3b01      	subs	r3, #1
 8009a28:	60fb      	str	r3, [r7, #12]
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8009a2a:	4b15      	ldr	r3, [pc, #84]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8009a2c:	695b      	ldr	r3, [r3, #20]
 8009a2e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8009a32:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8009a36:	d102      	bne.n	8009a3e <HAL_PWREx_ControlVoltageScaling+0xfa>
 8009a38:	68fb      	ldr	r3, [r7, #12]
 8009a3a:	2b00      	cmp	r3, #0
 8009a3c:	d1f2      	bne.n	8009a24 <HAL_PWREx_ControlVoltageScaling+0xe0>
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 8009a3e:	4b10      	ldr	r3, [pc, #64]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8009a40:	695b      	ldr	r3, [r3, #20]
 8009a42:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8009a46:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8009a4a:	d112      	bne.n	8009a72 <HAL_PWREx_ControlVoltageScaling+0x12e>
      {
        return HAL_TIMEOUT;
 8009a4c:	2303      	movs	r3, #3
 8009a4e:	e011      	b.n	8009a74 <HAL_PWREx_ControlVoltageScaling+0x130>
    }
     /* If current range is range 1 normal or boost mode */
    else
    {
      /* Disable Range 1 Boost (no issue if bit already set) */
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8009a50:	4b0b      	ldr	r3, [pc, #44]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8009a52:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8009a56:	4a0a      	ldr	r2, [pc, #40]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8009a58:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8009a5c:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
 8009a60:	e007      	b.n	8009a72 <HAL_PWREx_ControlVoltageScaling+0x12e>
    }
  }
  else
  {
    /* Set Range 2 */
    MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 8009a62:	4b07      	ldr	r3, [pc, #28]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8009a64:	681b      	ldr	r3, [r3, #0]
 8009a66:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8009a6a:	4a05      	ldr	r2, [pc, #20]	; (8009a80 <HAL_PWREx_ControlVoltageScaling+0x13c>)
 8009a6c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8009a70:	6013      	str	r3, [r2, #0]
    /* No need to wait for VOSF to be cleared for this transition */
    /* PWR_CR5_R1MODE bit setting has no effect in Range 2        */
  }

  return HAL_OK;
 8009a72:	2300      	movs	r3, #0
}
 8009a74:	4618      	mov	r0, r3
 8009a76:	3714      	adds	r7, #20
 8009a78:	46bd      	mov	sp, r7
 8009a7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a7e:	4770      	bx	lr
 8009a80:	40007000 	.word	0x40007000
 8009a84:	20000008 	.word	0x20000008
 8009a88:	431bde83 	.word	0x431bde83

08009a8c <HAL_QSPI_Init>:
  *        in the QSPI_InitTypeDef and initialize the associated handle.
  * @param hqspi : QSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Init(QSPI_HandleTypeDef *hqspi)
{
 8009a8c:	b580      	push	{r7, lr}
 8009a8e:	b086      	sub	sp, #24
 8009a90:	af02      	add	r7, sp, #8
 8009a92:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 8009a94:	f7fc f95e 	bl	8005d54 <HAL_GetTick>
 8009a98:	60f8      	str	r0, [r7, #12]

  /* Check the QSPI handle allocation */
  if(hqspi == NULL)
 8009a9a:	687b      	ldr	r3, [r7, #4]
 8009a9c:	2b00      	cmp	r3, #0
 8009a9e:	d101      	bne.n	8009aa4 <HAL_QSPI_Init+0x18>
  {
    return HAL_ERROR;
 8009aa0:	2301      	movs	r3, #1
 8009aa2:	e069      	b.n	8009b78 <HAL_QSPI_Init+0xec>
  if (hqspi->Init.DualFlash != QSPI_DUALFLASH_ENABLE )
  {
    assert_param(IS_QSPI_FLASH_ID(hqspi->Init.FlashID));
  }

  if(hqspi->State == HAL_QSPI_STATE_RESET)
 8009aa4:	687b      	ldr	r3, [r7, #4]
 8009aa6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8009aaa:	b2db      	uxtb	r3, r3
 8009aac:	2b00      	cmp	r3, #0
 8009aae:	d10b      	bne.n	8009ac8 <HAL_QSPI_Init+0x3c>
  {
    /* Allocate lock resource and initialize it */
    hqspi->Lock = HAL_UNLOCKED;
 8009ab0:	687b      	ldr	r3, [r7, #4]
 8009ab2:	2200      	movs	r2, #0
 8009ab4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init the low level hardware */
    hqspi->MspInitCallback(hqspi);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_QSPI_MspInit(hqspi);
 8009ab8:	6878      	ldr	r0, [r7, #4]
 8009aba:	f7fa fe39 	bl	8004730 <HAL_QSPI_MspInit>
#endif

    /* Configure the default timeout for the QSPI memory access */
    HAL_QSPI_SetTimeout(hqspi, HAL_QSPI_TIMEOUT_DEFAULT_VALUE);
 8009abe:	f241 3188 	movw	r1, #5000	; 0x1388
 8009ac2:	6878      	ldr	r0, [r7, #4]
 8009ac4:	f000 fa54 	bl	8009f70 <HAL_QSPI_SetTimeout>
  }

  /* Configure QSPI FIFO Threshold */
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
 8009ac8:	687b      	ldr	r3, [r7, #4]
 8009aca:	681b      	ldr	r3, [r3, #0]
 8009acc:	681b      	ldr	r3, [r3, #0]
 8009ace:	f423 6170 	bic.w	r1, r3, #3840	; 0xf00
 8009ad2:	687b      	ldr	r3, [r7, #4]
 8009ad4:	689b      	ldr	r3, [r3, #8]
 8009ad6:	3b01      	subs	r3, #1
 8009ad8:	021a      	lsls	r2, r3, #8
 8009ada:	687b      	ldr	r3, [r7, #4]
 8009adc:	681b      	ldr	r3, [r3, #0]
 8009ade:	430a      	orrs	r2, r1
 8009ae0:	601a      	str	r2, [r3, #0]
             ((hqspi->Init.FifoThreshold - 1U) << QUADSPI_CR_FTHRES_Pos));

  /* Wait till BUSY flag reset */
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 8009ae2:	687b      	ldr	r3, [r7, #4]
 8009ae4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009ae6:	9300      	str	r3, [sp, #0]
 8009ae8:	68fb      	ldr	r3, [r7, #12]
 8009aea:	2200      	movs	r2, #0
 8009aec:	2120      	movs	r1, #32
 8009aee:	6878      	ldr	r0, [r7, #4]
 8009af0:	f000 fa7f 	bl	8009ff2 <QSPI_WaitFlagStateUntilTimeout>
 8009af4:	4603      	mov	r3, r0
 8009af6:	72fb      	strb	r3, [r7, #11]

  if(status == HAL_OK)
 8009af8:	7afb      	ldrb	r3, [r7, #11]
 8009afa:	2b00      	cmp	r3, #0
 8009afc:	d137      	bne.n	8009b6e <HAL_QSPI_Init+0xe2>
  {
    /* Configure QSPI Clock Prescaler and Sample Shift */
    MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM),
 8009afe:	687b      	ldr	r3, [r7, #4]
 8009b00:	681b      	ldr	r3, [r3, #0]
 8009b02:	681b      	ldr	r3, [r3, #0]
 8009b04:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8009b08:	f023 03d0 	bic.w	r3, r3, #208	; 0xd0
 8009b0c:	687a      	ldr	r2, [r7, #4]
 8009b0e:	6852      	ldr	r2, [r2, #4]
 8009b10:	0611      	lsls	r1, r2, #24
 8009b12:	687a      	ldr	r2, [r7, #4]
 8009b14:	68d2      	ldr	r2, [r2, #12]
 8009b16:	4311      	orrs	r1, r2
 8009b18:	687a      	ldr	r2, [r7, #4]
 8009b1a:	69d2      	ldr	r2, [r2, #28]
 8009b1c:	4311      	orrs	r1, r2
 8009b1e:	687a      	ldr	r2, [r7, #4]
 8009b20:	6a12      	ldr	r2, [r2, #32]
 8009b22:	4311      	orrs	r1, r2
 8009b24:	687a      	ldr	r2, [r7, #4]
 8009b26:	6812      	ldr	r2, [r2, #0]
 8009b28:	430b      	orrs	r3, r1
 8009b2a:	6013      	str	r3, [r2, #0]
               ((hqspi->Init.ClockPrescaler << QUADSPI_CR_PRESCALER_Pos) |
                hqspi->Init.SampleShifting  | hqspi->Init.FlashID | hqspi->Init.DualFlash));

    /* Configure QSPI Flash Size, CS High Time and Clock Mode */
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
 8009b2c:	687b      	ldr	r3, [r7, #4]
 8009b2e:	681b      	ldr	r3, [r3, #0]
 8009b30:	685a      	ldr	r2, [r3, #4]
 8009b32:	4b13      	ldr	r3, [pc, #76]	; (8009b80 <HAL_QSPI_Init+0xf4>)
 8009b34:	4013      	ands	r3, r2
 8009b36:	687a      	ldr	r2, [r7, #4]
 8009b38:	6912      	ldr	r2, [r2, #16]
 8009b3a:	0411      	lsls	r1, r2, #16
 8009b3c:	687a      	ldr	r2, [r7, #4]
 8009b3e:	6952      	ldr	r2, [r2, #20]
 8009b40:	4311      	orrs	r1, r2
 8009b42:	687a      	ldr	r2, [r7, #4]
 8009b44:	6992      	ldr	r2, [r2, #24]
 8009b46:	4311      	orrs	r1, r2
 8009b48:	687a      	ldr	r2, [r7, #4]
 8009b4a:	6812      	ldr	r2, [r2, #0]
 8009b4c:	430b      	orrs	r3, r1
 8009b4e:	6053      	str	r3, [r2, #4]
               ((hqspi->Init.FlashSize << QUADSPI_DCR_FSIZE_Pos) |
                hqspi->Init.ChipSelectHighTime | hqspi->Init.ClockMode));

    /* Enable the QSPI peripheral */
    __HAL_QSPI_ENABLE(hqspi);
 8009b50:	687b      	ldr	r3, [r7, #4]
 8009b52:	681b      	ldr	r3, [r3, #0]
 8009b54:	681a      	ldr	r2, [r3, #0]
 8009b56:	687b      	ldr	r3, [r7, #4]
 8009b58:	681b      	ldr	r3, [r3, #0]
 8009b5a:	f042 0201 	orr.w	r2, r2, #1
 8009b5e:	601a      	str	r2, [r3, #0]

    /* Set QSPI error code to none */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 8009b60:	687b      	ldr	r3, [r7, #4]
 8009b62:	2200      	movs	r2, #0
 8009b64:	645a      	str	r2, [r3, #68]	; 0x44

    /* Initialize the QSPI state */
    hqspi->State = HAL_QSPI_STATE_READY;
 8009b66:	687b      	ldr	r3, [r7, #4]
 8009b68:	2201      	movs	r2, #1
 8009b6a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  }

  /* Release Lock */
  __HAL_UNLOCK(hqspi);
 8009b6e:	687b      	ldr	r3, [r7, #4]
 8009b70:	2200      	movs	r2, #0
 8009b72:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
 8009b76:	7afb      	ldrb	r3, [r7, #11]
}
 8009b78:	4618      	mov	r0, r3
 8009b7a:	3710      	adds	r7, #16
 8009b7c:	46bd      	mov	sp, r7
 8009b7e:	bd80      	pop	{r7, pc}
 8009b80:	ffe0f8fe 	.word	0xffe0f8fe

08009b84 <HAL_QSPI_IRQHandler>:
  * @brief Handle QSPI interrupt request.
  * @param hqspi : QSPI handle
  * @retval None
  */
void HAL_QSPI_IRQHandler(QSPI_HandleTypeDef *hqspi)
{
 8009b84:	b580      	push	{r7, lr}
 8009b86:	b086      	sub	sp, #24
 8009b88:	af00      	add	r7, sp, #0
 8009b8a:	6078      	str	r0, [r7, #4]
  __IO uint32_t *data_reg;
  uint32_t flag = READ_REG(hqspi->Instance->SR);
 8009b8c:	687b      	ldr	r3, [r7, #4]
 8009b8e:	681b      	ldr	r3, [r3, #0]
 8009b90:	689b      	ldr	r3, [r3, #8]
 8009b92:	617b      	str	r3, [r7, #20]
  uint32_t itsource = READ_REG(hqspi->Instance->CR);
 8009b94:	687b      	ldr	r3, [r7, #4]
 8009b96:	681b      	ldr	r3, [r3, #0]
 8009b98:	681b      	ldr	r3, [r3, #0]
 8009b9a:	613b      	str	r3, [r7, #16]

  /* QSPI Fifo Threshold interrupt occurred ----------------------------------*/
  if(((flag & QSPI_FLAG_FT) != 0U) && ((itsource & QSPI_IT_FT) != 0U))
 8009b9c:	697b      	ldr	r3, [r7, #20]
 8009b9e:	f003 0304 	and.w	r3, r3, #4
 8009ba2:	2b00      	cmp	r3, #0
 8009ba4:	d064      	beq.n	8009c70 <HAL_QSPI_IRQHandler+0xec>
 8009ba6:	693b      	ldr	r3, [r7, #16]
 8009ba8:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8009bac:	2b00      	cmp	r3, #0
 8009bae:	d05f      	beq.n	8009c70 <HAL_QSPI_IRQHandler+0xec>
  {
    data_reg = &hqspi->Instance->DR;
 8009bb0:	687b      	ldr	r3, [r7, #4]
 8009bb2:	681b      	ldr	r3, [r3, #0]
 8009bb4:	3320      	adds	r3, #32
 8009bb6:	60fb      	str	r3, [r7, #12]

    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
 8009bb8:	687b      	ldr	r3, [r7, #4]
 8009bba:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8009bbe:	b2db      	uxtb	r3, r3
 8009bc0:	2b12      	cmp	r3, #18
 8009bc2:	d125      	bne.n	8009c10 <HAL_QSPI_IRQHandler+0x8c>
    {
      /* Transmission process */
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
 8009bc4:	e01c      	b.n	8009c00 <HAL_QSPI_IRQHandler+0x7c>
      {
        if (hqspi->TxXferCount > 0U)
 8009bc6:	687b      	ldr	r3, [r7, #4]
 8009bc8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009bca:	2b00      	cmp	r3, #0
 8009bcc:	d00f      	beq.n	8009bee <HAL_QSPI_IRQHandler+0x6a>
        {
          /* Fill the FIFO until the threshold is reached */
          *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
 8009bce:	687b      	ldr	r3, [r7, #4]
 8009bd0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009bd2:	781a      	ldrb	r2, [r3, #0]
 8009bd4:	68fb      	ldr	r3, [r7, #12]
 8009bd6:	701a      	strb	r2, [r3, #0]
          hqspi->pTxBuffPtr++;
 8009bd8:	687b      	ldr	r3, [r7, #4]
 8009bda:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009bdc:	1c5a      	adds	r2, r3, #1
 8009bde:	687b      	ldr	r3, [r7, #4]
 8009be0:	625a      	str	r2, [r3, #36]	; 0x24
          hqspi->TxXferCount--;
 8009be2:	687b      	ldr	r3, [r7, #4]
 8009be4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009be6:	1e5a      	subs	r2, r3, #1
 8009be8:	687b      	ldr	r3, [r7, #4]
 8009bea:	62da      	str	r2, [r3, #44]	; 0x2c
 8009bec:	e008      	b.n	8009c00 <HAL_QSPI_IRQHandler+0x7c>
        }
        else
        {
          /* No more data available for the transfer */
          /* Disable the QSPI FIFO Threshold Interrupt */
          __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_FT);
 8009bee:	687b      	ldr	r3, [r7, #4]
 8009bf0:	681b      	ldr	r3, [r3, #0]
 8009bf2:	681a      	ldr	r2, [r3, #0]
 8009bf4:	687b      	ldr	r3, [r7, #4]
 8009bf6:	681b      	ldr	r3, [r3, #0]
 8009bf8:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8009bfc:	601a      	str	r2, [r3, #0]
          break;
 8009bfe:	e033      	b.n	8009c68 <HAL_QSPI_IRQHandler+0xe4>
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
 8009c00:	687b      	ldr	r3, [r7, #4]
 8009c02:	681b      	ldr	r3, [r3, #0]
 8009c04:	689b      	ldr	r3, [r3, #8]
 8009c06:	f003 0304 	and.w	r3, r3, #4
 8009c0a:	2b00      	cmp	r3, #0
 8009c0c:	d1db      	bne.n	8009bc6 <HAL_QSPI_IRQHandler+0x42>
 8009c0e:	e02b      	b.n	8009c68 <HAL_QSPI_IRQHandler+0xe4>
        }
      }
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
 8009c10:	687b      	ldr	r3, [r7, #4]
 8009c12:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8009c16:	b2db      	uxtb	r3, r3
 8009c18:	2b22      	cmp	r3, #34	; 0x22
 8009c1a:	d125      	bne.n	8009c68 <HAL_QSPI_IRQHandler+0xe4>
    {
      /* Receiving Process */
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
 8009c1c:	e01d      	b.n	8009c5a <HAL_QSPI_IRQHandler+0xd6>
      {
        if (hqspi->RxXferCount > 0U)
 8009c1e:	687b      	ldr	r3, [r7, #4]
 8009c20:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009c22:	2b00      	cmp	r3, #0
 8009c24:	d010      	beq.n	8009c48 <HAL_QSPI_IRQHandler+0xc4>
        {
          /* Read the FIFO until the threshold is reached */
          *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
 8009c26:	687b      	ldr	r3, [r7, #4]
 8009c28:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009c2a:	68fa      	ldr	r2, [r7, #12]
 8009c2c:	7812      	ldrb	r2, [r2, #0]
 8009c2e:	b2d2      	uxtb	r2, r2
 8009c30:	701a      	strb	r2, [r3, #0]
          hqspi->pRxBuffPtr++;
 8009c32:	687b      	ldr	r3, [r7, #4]
 8009c34:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009c36:	1c5a      	adds	r2, r3, #1
 8009c38:	687b      	ldr	r3, [r7, #4]
 8009c3a:	631a      	str	r2, [r3, #48]	; 0x30
          hqspi->RxXferCount--;
 8009c3c:	687b      	ldr	r3, [r7, #4]
 8009c3e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009c40:	1e5a      	subs	r2, r3, #1
 8009c42:	687b      	ldr	r3, [r7, #4]
 8009c44:	639a      	str	r2, [r3, #56]	; 0x38
 8009c46:	e008      	b.n	8009c5a <HAL_QSPI_IRQHandler+0xd6>
        }
        else
        {
          /* All data have been received for the transfer */
          /* Disable the QSPI FIFO Threshold Interrupt */
          __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_FT);
 8009c48:	687b      	ldr	r3, [r7, #4]
 8009c4a:	681b      	ldr	r3, [r3, #0]
 8009c4c:	681a      	ldr	r2, [r3, #0]
 8009c4e:	687b      	ldr	r3, [r7, #4]
 8009c50:	681b      	ldr	r3, [r3, #0]
 8009c52:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8009c56:	601a      	str	r2, [r3, #0]
          break;
 8009c58:	e006      	b.n	8009c68 <HAL_QSPI_IRQHandler+0xe4>
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
 8009c5a:	687b      	ldr	r3, [r7, #4]
 8009c5c:	681b      	ldr	r3, [r3, #0]
 8009c5e:	689b      	ldr	r3, [r3, #8]
 8009c60:	f003 0304 	and.w	r3, r3, #4
 8009c64:	2b00      	cmp	r3, #0
 8009c66:	d1da      	bne.n	8009c1e <HAL_QSPI_IRQHandler+0x9a>

    /* FIFO Threshold callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->FifoThresholdCallback(hqspi);
#else
    HAL_QSPI_FifoThresholdCallback(hqspi);
 8009c68:	6878      	ldr	r0, [r7, #4]
 8009c6a:	f000 f963 	bl	8009f34 <HAL_QSPI_FifoThresholdCallback>
 8009c6e:	e13c      	b.n	8009eea <HAL_QSPI_IRQHandler+0x366>
#endif
  }

  /* QSPI Transfer Complete interrupt occurred -------------------------------*/
  else if(((flag & QSPI_FLAG_TC) != 0U) && ((itsource & QSPI_IT_TC) != 0U))
 8009c70:	697b      	ldr	r3, [r7, #20]
 8009c72:	f003 0302 	and.w	r3, r3, #2
 8009c76:	2b00      	cmp	r3, #0
 8009c78:	f000 80b0 	beq.w	8009ddc <HAL_QSPI_IRQHandler+0x258>
 8009c7c:	693b      	ldr	r3, [r7, #16]
 8009c7e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8009c82:	2b00      	cmp	r3, #0
 8009c84:	f000 80aa 	beq.w	8009ddc <HAL_QSPI_IRQHandler+0x258>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TC);
 8009c88:	687b      	ldr	r3, [r7, #4]
 8009c8a:	681b      	ldr	r3, [r3, #0]
 8009c8c:	2202      	movs	r2, #2
 8009c8e:	60da      	str	r2, [r3, #12]

    /* Disable the QSPI FIFO Threshold, Transfer Error and Transfer complete Interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
 8009c90:	687b      	ldr	r3, [r7, #4]
 8009c92:	681b      	ldr	r3, [r3, #0]
 8009c94:	681a      	ldr	r2, [r3, #0]
 8009c96:	687b      	ldr	r3, [r7, #4]
 8009c98:	681b      	ldr	r3, [r3, #0]
 8009c9a:	f422 22e0 	bic.w	r2, r2, #458752	; 0x70000
 8009c9e:	601a      	str	r2, [r3, #0]

    /* Transfer complete callback */
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
 8009ca0:	687b      	ldr	r3, [r7, #4]
 8009ca2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8009ca6:	b2db      	uxtb	r3, r3
 8009ca8:	2b12      	cmp	r3, #18
 8009caa:	d120      	bne.n	8009cee <HAL_QSPI_IRQHandler+0x16a>
    {
      if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
 8009cac:	687b      	ldr	r3, [r7, #4]
 8009cae:	681b      	ldr	r3, [r3, #0]
 8009cb0:	681b      	ldr	r3, [r3, #0]
 8009cb2:	f003 0304 	and.w	r3, r3, #4
 8009cb6:	2b00      	cmp	r3, #0
 8009cb8:	d011      	beq.n	8009cde <HAL_QSPI_IRQHandler+0x15a>
      {
        /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
        CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
 8009cba:	687b      	ldr	r3, [r7, #4]
 8009cbc:	681b      	ldr	r3, [r3, #0]
 8009cbe:	681a      	ldr	r2, [r3, #0]
 8009cc0:	687b      	ldr	r3, [r7, #4]
 8009cc2:	681b      	ldr	r3, [r3, #0]
 8009cc4:	f022 0204 	bic.w	r2, r2, #4
 8009cc8:	601a      	str	r2, [r3, #0]

        /* Disable the DMA channel */
        __HAL_DMA_DISABLE(hqspi->hdma);
 8009cca:	687b      	ldr	r3, [r7, #4]
 8009ccc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8009cce:	681b      	ldr	r3, [r3, #0]
 8009cd0:	681a      	ldr	r2, [r3, #0]
 8009cd2:	687b      	ldr	r3, [r7, #4]
 8009cd4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8009cd6:	681b      	ldr	r3, [r3, #0]
 8009cd8:	f022 0201 	bic.w	r2, r2, #1
 8009cdc:	601a      	str	r2, [r3, #0]
      }


      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
 8009cde:	687b      	ldr	r3, [r7, #4]
 8009ce0:	2201      	movs	r2, #1
 8009ce2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* TX Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->TxCpltCallback(hqspi);
#else
      HAL_QSPI_TxCpltCallback(hqspi);
 8009ce6:	6878      	ldr	r0, [r7, #4]
 8009ce8:	f7fa fcd6 	bl	8004698 <HAL_QSPI_TxCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
 8009cec:	e0fa      	b.n	8009ee4 <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
 8009cee:	687b      	ldr	r3, [r7, #4]
 8009cf0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8009cf4:	b2db      	uxtb	r3, r3
 8009cf6:	2b22      	cmp	r3, #34	; 0x22
 8009cf8:	d143      	bne.n	8009d82 <HAL_QSPI_IRQHandler+0x1fe>
    {
      if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
 8009cfa:	687b      	ldr	r3, [r7, #4]
 8009cfc:	681b      	ldr	r3, [r3, #0]
 8009cfe:	681b      	ldr	r3, [r3, #0]
 8009d00:	f003 0304 	and.w	r3, r3, #4
 8009d04:	2b00      	cmp	r3, #0
 8009d06:	d012      	beq.n	8009d2e <HAL_QSPI_IRQHandler+0x1aa>
      {
        /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
        CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
 8009d08:	687b      	ldr	r3, [r7, #4]
 8009d0a:	681b      	ldr	r3, [r3, #0]
 8009d0c:	681a      	ldr	r2, [r3, #0]
 8009d0e:	687b      	ldr	r3, [r7, #4]
 8009d10:	681b      	ldr	r3, [r3, #0]
 8009d12:	f022 0204 	bic.w	r2, r2, #4
 8009d16:	601a      	str	r2, [r3, #0]

        /* Disable the DMA channel */
        __HAL_DMA_DISABLE(hqspi->hdma);
 8009d18:	687b      	ldr	r3, [r7, #4]
 8009d1a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8009d1c:	681b      	ldr	r3, [r3, #0]
 8009d1e:	681a      	ldr	r2, [r3, #0]
 8009d20:	687b      	ldr	r3, [r7, #4]
 8009d22:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8009d24:	681b      	ldr	r3, [r3, #0]
 8009d26:	f022 0201 	bic.w	r2, r2, #1
 8009d2a:	601a      	str	r2, [r3, #0]
 8009d2c:	e021      	b.n	8009d72 <HAL_QSPI_IRQHandler+0x1ee>
      }
      else
      {
        data_reg = &hqspi->Instance->DR;
 8009d2e:	687b      	ldr	r3, [r7, #4]
 8009d30:	681b      	ldr	r3, [r3, #0]
 8009d32:	3320      	adds	r3, #32
 8009d34:	60fb      	str	r3, [r7, #12]
        while(READ_BIT(hqspi->Instance->SR, QUADSPI_SR_FLEVEL) != 0U)
 8009d36:	e013      	b.n	8009d60 <HAL_QSPI_IRQHandler+0x1dc>
        {
          if (hqspi->RxXferCount > 0U)
 8009d38:	687b      	ldr	r3, [r7, #4]
 8009d3a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009d3c:	2b00      	cmp	r3, #0
 8009d3e:	d017      	beq.n	8009d70 <HAL_QSPI_IRQHandler+0x1ec>
          {
            /* Read the last data received in the FIFO until it is empty */
            *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
 8009d40:	687b      	ldr	r3, [r7, #4]
 8009d42:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009d44:	68fa      	ldr	r2, [r7, #12]
 8009d46:	7812      	ldrb	r2, [r2, #0]
 8009d48:	b2d2      	uxtb	r2, r2
 8009d4a:	701a      	strb	r2, [r3, #0]
            hqspi->pRxBuffPtr++;
 8009d4c:	687b      	ldr	r3, [r7, #4]
 8009d4e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009d50:	1c5a      	adds	r2, r3, #1
 8009d52:	687b      	ldr	r3, [r7, #4]
 8009d54:	631a      	str	r2, [r3, #48]	; 0x30
            hqspi->RxXferCount--;
 8009d56:	687b      	ldr	r3, [r7, #4]
 8009d58:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009d5a:	1e5a      	subs	r2, r3, #1
 8009d5c:	687b      	ldr	r3, [r7, #4]
 8009d5e:	639a      	str	r2, [r3, #56]	; 0x38
        while(READ_BIT(hqspi->Instance->SR, QUADSPI_SR_FLEVEL) != 0U)
 8009d60:	687b      	ldr	r3, [r7, #4]
 8009d62:	681b      	ldr	r3, [r3, #0]
 8009d64:	689b      	ldr	r3, [r3, #8]
 8009d66:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
 8009d6a:	2b00      	cmp	r3, #0
 8009d6c:	d1e4      	bne.n	8009d38 <HAL_QSPI_IRQHandler+0x1b4>
 8009d6e:	e000      	b.n	8009d72 <HAL_QSPI_IRQHandler+0x1ee>
          }
          else
          {
            /* All data have been received for the transfer */
            break;
 8009d70:	bf00      	nop
        }
      }


      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
 8009d72:	687b      	ldr	r3, [r7, #4]
 8009d74:	2201      	movs	r2, #1
 8009d76:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* RX Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->RxCpltCallback(hqspi);
#else
      HAL_QSPI_RxCpltCallback(hqspi);
 8009d7a:	6878      	ldr	r0, [r7, #4]
 8009d7c:	f7fa fc9c 	bl	80046b8 <HAL_QSPI_RxCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
 8009d80:	e0b0      	b.n	8009ee4 <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY)
 8009d82:	687b      	ldr	r3, [r7, #4]
 8009d84:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8009d88:	b2db      	uxtb	r3, r3
 8009d8a:	2b02      	cmp	r3, #2
 8009d8c:	d107      	bne.n	8009d9e <HAL_QSPI_IRQHandler+0x21a>
    {
      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
 8009d8e:	687b      	ldr	r3, [r7, #4]
 8009d90:	2201      	movs	r2, #1
 8009d92:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Command Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->CmdCpltCallback(hqspi);
#else
      HAL_QSPI_CmdCpltCallback(hqspi);
 8009d96:	6878      	ldr	r0, [r7, #4]
 8009d98:	f000 f8c2 	bl	8009f20 <HAL_QSPI_CmdCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
 8009d9c:	e0a2      	b.n	8009ee4 <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_ABORT)
 8009d9e:	687b      	ldr	r3, [r7, #4]
 8009da0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8009da4:	b2db      	uxtb	r3, r3
 8009da6:	2b08      	cmp	r3, #8
 8009da8:	f040 809c 	bne.w	8009ee4 <HAL_QSPI_IRQHandler+0x360>
    {
      /* Reset functional mode configuration to indirect write mode by default */
      CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);
 8009dac:	687b      	ldr	r3, [r7, #4]
 8009dae:	681b      	ldr	r3, [r3, #0]
 8009db0:	695a      	ldr	r2, [r3, #20]
 8009db2:	687b      	ldr	r3, [r7, #4]
 8009db4:	681b      	ldr	r3, [r3, #0]
 8009db6:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 8009dba:	615a      	str	r2, [r3, #20]

      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
 8009dbc:	687b      	ldr	r3, [r7, #4]
 8009dbe:	2201      	movs	r2, #1
 8009dc0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      if (hqspi->ErrorCode == HAL_QSPI_ERROR_NONE)
 8009dc4:	687b      	ldr	r3, [r7, #4]
 8009dc6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009dc8:	2b00      	cmp	r3, #0
 8009dca:	d103      	bne.n	8009dd4 <HAL_QSPI_IRQHandler+0x250>

        /* Abort Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->AbortCpltCallback(hqspi);
#else
        HAL_QSPI_AbortCpltCallback(hqspi);
 8009dcc:	6878      	ldr	r0, [r7, #4]
 8009dce:	f000 f89d 	bl	8009f0c <HAL_QSPI_AbortCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
 8009dd2:	e087      	b.n	8009ee4 <HAL_QSPI_IRQHandler+0x360>

        /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->ErrorCallback(hqspi);
#else
        HAL_QSPI_ErrorCallback(hqspi);
 8009dd4:	6878      	ldr	r0, [r7, #4]
 8009dd6:	f000 f88f 	bl	8009ef8 <HAL_QSPI_ErrorCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
 8009dda:	e083      	b.n	8009ee4 <HAL_QSPI_IRQHandler+0x360>
     /* Nothing to do */
    }
  }

  /* QSPI Status Match interrupt occurred ------------------------------------*/
  else if(((flag & QSPI_FLAG_SM) != 0U) && ((itsource & QSPI_IT_SM) != 0U))
 8009ddc:	697b      	ldr	r3, [r7, #20]
 8009dde:	f003 0308 	and.w	r3, r3, #8
 8009de2:	2b00      	cmp	r3, #0
 8009de4:	d01f      	beq.n	8009e26 <HAL_QSPI_IRQHandler+0x2a2>
 8009de6:	693b      	ldr	r3, [r7, #16]
 8009de8:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8009dec:	2b00      	cmp	r3, #0
 8009dee:	d01a      	beq.n	8009e26 <HAL_QSPI_IRQHandler+0x2a2>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_SM);
 8009df0:	687b      	ldr	r3, [r7, #4]
 8009df2:	681b      	ldr	r3, [r3, #0]
 8009df4:	2208      	movs	r2, #8
 8009df6:	60da      	str	r2, [r3, #12]

    /* Check if the automatic poll mode stop is activated */
    if(READ_BIT(hqspi->Instance->CR, QUADSPI_CR_APMS) != 0U)
 8009df8:	687b      	ldr	r3, [r7, #4]
 8009dfa:	681b      	ldr	r3, [r3, #0]
 8009dfc:	681b      	ldr	r3, [r3, #0]
 8009dfe:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8009e02:	2b00      	cmp	r3, #0
 8009e04:	d00b      	beq.n	8009e1e <HAL_QSPI_IRQHandler+0x29a>
    {
      /* Disable the QSPI Transfer Error and Status Match Interrupts */
      __HAL_QSPI_DISABLE_IT(hqspi, (QSPI_IT_SM | QSPI_IT_TE));
 8009e06:	687b      	ldr	r3, [r7, #4]
 8009e08:	681b      	ldr	r3, [r3, #0]
 8009e0a:	681a      	ldr	r2, [r3, #0]
 8009e0c:	687b      	ldr	r3, [r7, #4]
 8009e0e:	681b      	ldr	r3, [r3, #0]
 8009e10:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
 8009e14:	601a      	str	r2, [r3, #0]

      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
 8009e16:	687b      	ldr	r3, [r7, #4]
 8009e18:	2201      	movs	r2, #1
 8009e1a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Status match callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->StatusMatchCallback(hqspi);
#else
    HAL_QSPI_StatusMatchCallback(hqspi);
 8009e1e:	6878      	ldr	r0, [r7, #4]
 8009e20:	f000 f892 	bl	8009f48 <HAL_QSPI_StatusMatchCallback>
 8009e24:	e061      	b.n	8009eea <HAL_QSPI_IRQHandler+0x366>
#endif
  }

  /* QSPI Transfer Error interrupt occurred ----------------------------------*/
  else if(((flag & QSPI_FLAG_TE) != 0U) && ((itsource & QSPI_IT_TE) != 0U))
 8009e26:	697b      	ldr	r3, [r7, #20]
 8009e28:	f003 0301 	and.w	r3, r3, #1
 8009e2c:	2b00      	cmp	r3, #0
 8009e2e:	d047      	beq.n	8009ec0 <HAL_QSPI_IRQHandler+0x33c>
 8009e30:	693b      	ldr	r3, [r7, #16]
 8009e32:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8009e36:	2b00      	cmp	r3, #0
 8009e38:	d042      	beq.n	8009ec0 <HAL_QSPI_IRQHandler+0x33c>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TE);
 8009e3a:	687b      	ldr	r3, [r7, #4]
 8009e3c:	681b      	ldr	r3, [r3, #0]
 8009e3e:	2201      	movs	r2, #1
 8009e40:	60da      	str	r2, [r3, #12]

    /* Disable all the QSPI Interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_SM | QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
 8009e42:	687b      	ldr	r3, [r7, #4]
 8009e44:	681b      	ldr	r3, [r3, #0]
 8009e46:	681a      	ldr	r2, [r3, #0]
 8009e48:	687b      	ldr	r3, [r7, #4]
 8009e4a:	681b      	ldr	r3, [r3, #0]
 8009e4c:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
 8009e50:	601a      	str	r2, [r3, #0]

    /* Set error code */
    hqspi->ErrorCode |= HAL_QSPI_ERROR_TRANSFER;
 8009e52:	687b      	ldr	r3, [r7, #4]
 8009e54:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009e56:	f043 0202 	orr.w	r2, r3, #2
 8009e5a:	687b      	ldr	r3, [r7, #4]
 8009e5c:	645a      	str	r2, [r3, #68]	; 0x44

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
 8009e5e:	687b      	ldr	r3, [r7, #4]
 8009e60:	681b      	ldr	r3, [r3, #0]
 8009e62:	681b      	ldr	r3, [r3, #0]
 8009e64:	f003 0304 	and.w	r3, r3, #4
 8009e68:	2b00      	cmp	r3, #0
 8009e6a:	d021      	beq.n	8009eb0 <HAL_QSPI_IRQHandler+0x32c>
    {
      /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
 8009e6c:	687b      	ldr	r3, [r7, #4]
 8009e6e:	681b      	ldr	r3, [r3, #0]
 8009e70:	681a      	ldr	r2, [r3, #0]
 8009e72:	687b      	ldr	r3, [r7, #4]
 8009e74:	681b      	ldr	r3, [r3, #0]
 8009e76:	f022 0204 	bic.w	r2, r2, #4
 8009e7a:	601a      	str	r2, [r3, #0]

      /* Disable the DMA channel */
      hqspi->hdma->XferAbortCallback = QSPI_DMAAbortCplt;
 8009e7c:	687b      	ldr	r3, [r7, #4]
 8009e7e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8009e80:	4a1c      	ldr	r2, [pc, #112]	; (8009ef4 <HAL_QSPI_IRQHandler+0x370>)
 8009e82:	639a      	str	r2, [r3, #56]	; 0x38
      if (HAL_DMA_Abort_IT(hqspi->hdma) != HAL_OK)
 8009e84:	687b      	ldr	r3, [r7, #4]
 8009e86:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8009e88:	4618      	mov	r0, r3
 8009e8a:	f7ff f909 	bl	80090a0 <HAL_DMA_Abort_IT>
 8009e8e:	4603      	mov	r3, r0
 8009e90:	2b00      	cmp	r3, #0
 8009e92:	d029      	beq.n	8009ee8 <HAL_QSPI_IRQHandler+0x364>
      {
        /* Set error code to DMA */
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
 8009e94:	687b      	ldr	r3, [r7, #4]
 8009e96:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009e98:	f043 0204 	orr.w	r2, r3, #4
 8009e9c:	687b      	ldr	r3, [r7, #4]
 8009e9e:	645a      	str	r2, [r3, #68]	; 0x44

        /* Change state of QSPI */
        hqspi->State = HAL_QSPI_STATE_READY;
 8009ea0:	687b      	ldr	r3, [r7, #4]
 8009ea2:	2201      	movs	r2, #1
 8009ea4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->ErrorCallback(hqspi);
#else
        HAL_QSPI_ErrorCallback(hqspi);
 8009ea8:	6878      	ldr	r0, [r7, #4]
 8009eaa:	f000 f825 	bl	8009ef8 <HAL_QSPI_ErrorCallback>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
 8009eae:	e01b      	b.n	8009ee8 <HAL_QSPI_IRQHandler+0x364>
      }
    }
    else
    {
      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
 8009eb0:	687b      	ldr	r3, [r7, #4]
 8009eb2:	2201      	movs	r2, #1
 8009eb4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->ErrorCallback(hqspi);
#else
      HAL_QSPI_ErrorCallback(hqspi);
 8009eb8:	6878      	ldr	r0, [r7, #4]
 8009eba:	f000 f81d 	bl	8009ef8 <HAL_QSPI_ErrorCallback>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
 8009ebe:	e013      	b.n	8009ee8 <HAL_QSPI_IRQHandler+0x364>
#endif
    }
  }

  /* QSPI Timeout interrupt occurred -----------------------------------------*/
  else if(((flag & QSPI_FLAG_TO) != 0U) && ((itsource & QSPI_IT_TO) != 0U))
 8009ec0:	697b      	ldr	r3, [r7, #20]
 8009ec2:	f003 0310 	and.w	r3, r3, #16
 8009ec6:	2b00      	cmp	r3, #0
 8009ec8:	d00f      	beq.n	8009eea <HAL_QSPI_IRQHandler+0x366>
 8009eca:	693b      	ldr	r3, [r7, #16]
 8009ecc:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8009ed0:	2b00      	cmp	r3, #0
 8009ed2:	d00a      	beq.n	8009eea <HAL_QSPI_IRQHandler+0x366>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TO);
 8009ed4:	687b      	ldr	r3, [r7, #4]
 8009ed6:	681b      	ldr	r3, [r3, #0]
 8009ed8:	2210      	movs	r2, #16
 8009eda:	60da      	str	r2, [r3, #12]

    /* Timeout callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->TimeOutCallback(hqspi);
#else
    HAL_QSPI_TimeOutCallback(hqspi);
 8009edc:	6878      	ldr	r0, [r7, #4]
 8009ede:	f000 f83d 	bl	8009f5c <HAL_QSPI_TimeOutCallback>

   else
  {
   /* Nothing to do */
  }
}
 8009ee2:	e002      	b.n	8009eea <HAL_QSPI_IRQHandler+0x366>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
 8009ee4:	bf00      	nop
 8009ee6:	e000      	b.n	8009eea <HAL_QSPI_IRQHandler+0x366>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
 8009ee8:	bf00      	nop
}
 8009eea:	bf00      	nop
 8009eec:	3718      	adds	r7, #24
 8009eee:	46bd      	mov	sp, r7
 8009ef0:	bd80      	pop	{r7, pc}
 8009ef2:	bf00      	nop
 8009ef4:	08009f8d 	.word	0x08009f8d

08009ef8 <HAL_QSPI_ErrorCallback>:
  * @brief  Transfer Error callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_ErrorCallback(QSPI_HandleTypeDef *hqspi)
{
 8009ef8:	b480      	push	{r7}
 8009efa:	b083      	sub	sp, #12
 8009efc:	af00      	add	r7, sp, #0
 8009efe:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_ErrorCallback could be implemented in the user file
   */
}
 8009f00:	bf00      	nop
 8009f02:	370c      	adds	r7, #12
 8009f04:	46bd      	mov	sp, r7
 8009f06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009f0a:	4770      	bx	lr

08009f0c <HAL_QSPI_AbortCpltCallback>:
  * @brief  Abort completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_AbortCpltCallback(QSPI_HandleTypeDef *hqspi)
{
 8009f0c:	b480      	push	{r7}
 8009f0e:	b083      	sub	sp, #12
 8009f10:	af00      	add	r7, sp, #0
 8009f12:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_AbortCpltCallback could be implemented in the user file
   */
}
 8009f14:	bf00      	nop
 8009f16:	370c      	adds	r7, #12
 8009f18:	46bd      	mov	sp, r7
 8009f1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009f1e:	4770      	bx	lr

08009f20 <HAL_QSPI_CmdCpltCallback>:
  * @brief  Command completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_CmdCpltCallback(QSPI_HandleTypeDef *hqspi)
{
 8009f20:	b480      	push	{r7}
 8009f22:	b083      	sub	sp, #12
 8009f24:	af00      	add	r7, sp, #0
 8009f26:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_CmdCpltCallback could be implemented in the user file
   */
}
 8009f28:	bf00      	nop
 8009f2a:	370c      	adds	r7, #12
 8009f2c:	46bd      	mov	sp, r7
 8009f2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009f32:	4770      	bx	lr

08009f34 <HAL_QSPI_FifoThresholdCallback>:
  * @brief  FIFO Threshold callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_FifoThresholdCallback(QSPI_HandleTypeDef *hqspi)
{
 8009f34:	b480      	push	{r7}
 8009f36:	b083      	sub	sp, #12
 8009f38:	af00      	add	r7, sp, #0
 8009f3a:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_FIFOThresholdCallback could be implemented in the user file
   */
}
 8009f3c:	bf00      	nop
 8009f3e:	370c      	adds	r7, #12
 8009f40:	46bd      	mov	sp, r7
 8009f42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009f46:	4770      	bx	lr

08009f48 <HAL_QSPI_StatusMatchCallback>:
  * @brief  Status Match callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_StatusMatchCallback(QSPI_HandleTypeDef *hqspi)
{
 8009f48:	b480      	push	{r7}
 8009f4a:	b083      	sub	sp, #12
 8009f4c:	af00      	add	r7, sp, #0
 8009f4e:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_StatusMatchCallback could be implemented in the user file
   */
}
 8009f50:	bf00      	nop
 8009f52:	370c      	adds	r7, #12
 8009f54:	46bd      	mov	sp, r7
 8009f56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009f5a:	4770      	bx	lr

08009f5c <HAL_QSPI_TimeOutCallback>:
  * @brief  Timeout callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_TimeOutCallback(QSPI_HandleTypeDef *hqspi)
{
 8009f5c:	b480      	push	{r7}
 8009f5e:	b083      	sub	sp, #12
 8009f60:	af00      	add	r7, sp, #0
 8009f62:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_TimeOutCallback could be implemented in the user file
   */
}
 8009f64:	bf00      	nop
 8009f66:	370c      	adds	r7, #12
 8009f68:	46bd      	mov	sp, r7
 8009f6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009f6e:	4770      	bx	lr

08009f70 <HAL_QSPI_SetTimeout>:
  * @param  hqspi : QSPI handle.
  * @param  Timeout : Timeout for the QSPI memory access.
  * @retval None
  */
void HAL_QSPI_SetTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Timeout)
{
 8009f70:	b480      	push	{r7}
 8009f72:	b083      	sub	sp, #12
 8009f74:	af00      	add	r7, sp, #0
 8009f76:	6078      	str	r0, [r7, #4]
 8009f78:	6039      	str	r1, [r7, #0]
  hqspi->Timeout = Timeout;
 8009f7a:	687b      	ldr	r3, [r7, #4]
 8009f7c:	683a      	ldr	r2, [r7, #0]
 8009f7e:	649a      	str	r2, [r3, #72]	; 0x48
}
 8009f80:	bf00      	nop
 8009f82:	370c      	adds	r7, #12
 8009f84:	46bd      	mov	sp, r7
 8009f86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009f8a:	4770      	bx	lr

08009f8c <QSPI_DMAAbortCplt>:
  * @brief  DMA QSPI abort complete callback.
  * @param  hdma : DMA handle
  * @retval None
  */
static void QSPI_DMAAbortCplt(DMA_HandleTypeDef *hdma)
{
 8009f8c:	b580      	push	{r7, lr}
 8009f8e:	b084      	sub	sp, #16
 8009f90:	af00      	add	r7, sp, #0
 8009f92:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )(hdma->Parent);
 8009f94:	687b      	ldr	r3, [r7, #4]
 8009f96:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009f98:	60fb      	str	r3, [r7, #12]

  hqspi->RxXferCount = 0U;
 8009f9a:	68fb      	ldr	r3, [r7, #12]
 8009f9c:	2200      	movs	r2, #0
 8009f9e:	639a      	str	r2, [r3, #56]	; 0x38
  hqspi->TxXferCount = 0U;
 8009fa0:	68fb      	ldr	r3, [r7, #12]
 8009fa2:	2200      	movs	r2, #0
 8009fa4:	62da      	str	r2, [r3, #44]	; 0x2c

  if(hqspi->State == HAL_QSPI_STATE_ABORT)
 8009fa6:	68fb      	ldr	r3, [r7, #12]
 8009fa8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8009fac:	b2db      	uxtb	r3, r3
 8009fae:	2b08      	cmp	r3, #8
 8009fb0:	d114      	bne.n	8009fdc <QSPI_DMAAbortCplt+0x50>
  {
    /* DMA Abort called by QSPI abort */
    /* Clear interrupt */
    __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
 8009fb2:	68fb      	ldr	r3, [r7, #12]
 8009fb4:	681b      	ldr	r3, [r3, #0]
 8009fb6:	2202      	movs	r2, #2
 8009fb8:	60da      	str	r2, [r3, #12]

    /* Enable the QSPI Transfer Complete Interrupt */
    __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
 8009fba:	68fb      	ldr	r3, [r7, #12]
 8009fbc:	681b      	ldr	r3, [r3, #0]
 8009fbe:	681a      	ldr	r2, [r3, #0]
 8009fc0:	68fb      	ldr	r3, [r7, #12]
 8009fc2:	681b      	ldr	r3, [r3, #0]
 8009fc4:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8009fc8:	601a      	str	r2, [r3, #0]

    /* Configure QSPI: CR register with Abort request */
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
 8009fca:	68fb      	ldr	r3, [r7, #12]
 8009fcc:	681b      	ldr	r3, [r3, #0]
 8009fce:	681a      	ldr	r2, [r3, #0]
 8009fd0:	68fb      	ldr	r3, [r7, #12]
 8009fd2:	681b      	ldr	r3, [r3, #0]
 8009fd4:	f042 0202 	orr.w	r2, r2, #2
 8009fd8:	601a      	str	r2, [r3, #0]
    hqspi->ErrorCallback(hqspi);
#else
    HAL_QSPI_ErrorCallback(hqspi);
#endif
  }
}
 8009fda:	e006      	b.n	8009fea <QSPI_DMAAbortCplt+0x5e>
    hqspi->State = HAL_QSPI_STATE_READY;
 8009fdc:	68fb      	ldr	r3, [r7, #12]
 8009fde:	2201      	movs	r2, #1
 8009fe0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    HAL_QSPI_ErrorCallback(hqspi);
 8009fe4:	68f8      	ldr	r0, [r7, #12]
 8009fe6:	f7ff ff87 	bl	8009ef8 <HAL_QSPI_ErrorCallback>
}
 8009fea:	bf00      	nop
 8009fec:	3710      	adds	r7, #16
 8009fee:	46bd      	mov	sp, r7
 8009ff0:	bd80      	pop	{r7, pc}

08009ff2 <QSPI_WaitFlagStateUntilTimeout>:
  * @param  Timeout : Duration of the timeout
  * @retval HAL status
  */
static HAL_StatusTypeDef QSPI_WaitFlagStateUntilTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
 8009ff2:	b580      	push	{r7, lr}
 8009ff4:	b084      	sub	sp, #16
 8009ff6:	af00      	add	r7, sp, #0
 8009ff8:	60f8      	str	r0, [r7, #12]
 8009ffa:	60b9      	str	r1, [r7, #8]
 8009ffc:	603b      	str	r3, [r7, #0]
 8009ffe:	4613      	mov	r3, r2
 800a000:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 800a002:	e01a      	b.n	800a03a <QSPI_WaitFlagStateUntilTimeout+0x48>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800a004:	69bb      	ldr	r3, [r7, #24]
 800a006:	f1b3 3fff 	cmp.w	r3, #4294967295
 800a00a:	d016      	beq.n	800a03a <QSPI_WaitFlagStateUntilTimeout+0x48>
    {
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800a00c:	f7fb fea2 	bl	8005d54 <HAL_GetTick>
 800a010:	4602      	mov	r2, r0
 800a012:	683b      	ldr	r3, [r7, #0]
 800a014:	1ad3      	subs	r3, r2, r3
 800a016:	69ba      	ldr	r2, [r7, #24]
 800a018:	429a      	cmp	r2, r3
 800a01a:	d302      	bcc.n	800a022 <QSPI_WaitFlagStateUntilTimeout+0x30>
 800a01c:	69bb      	ldr	r3, [r7, #24]
 800a01e:	2b00      	cmp	r3, #0
 800a020:	d10b      	bne.n	800a03a <QSPI_WaitFlagStateUntilTimeout+0x48>
      {
        hqspi->State     = HAL_QSPI_STATE_ERROR;
 800a022:	68fb      	ldr	r3, [r7, #12]
 800a024:	2204      	movs	r2, #4
 800a026:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
 800a02a:	68fb      	ldr	r3, [r7, #12]
 800a02c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a02e:	f043 0201 	orr.w	r2, r3, #1
 800a032:	68fb      	ldr	r3, [r7, #12]
 800a034:	645a      	str	r2, [r3, #68]	; 0x44

        return HAL_ERROR;
 800a036:	2301      	movs	r3, #1
 800a038:	e00e      	b.n	800a058 <QSPI_WaitFlagStateUntilTimeout+0x66>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 800a03a:	68fb      	ldr	r3, [r7, #12]
 800a03c:	681b      	ldr	r3, [r3, #0]
 800a03e:	689a      	ldr	r2, [r3, #8]
 800a040:	68bb      	ldr	r3, [r7, #8]
 800a042:	4013      	ands	r3, r2
 800a044:	2b00      	cmp	r3, #0
 800a046:	bf14      	ite	ne
 800a048:	2301      	movne	r3, #1
 800a04a:	2300      	moveq	r3, #0
 800a04c:	b2db      	uxtb	r3, r3
 800a04e:	461a      	mov	r2, r3
 800a050:	79fb      	ldrb	r3, [r7, #7]
 800a052:	429a      	cmp	r2, r3
 800a054:	d1d6      	bne.n	800a004 <QSPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
 800a056:	2300      	movs	r3, #0
}
 800a058:	4618      	mov	r0, r3
 800a05a:	3710      	adds	r7, #16
 800a05c:	46bd      	mov	sp, r7
 800a05e:	bd80      	pop	{r7, pc}

0800a060 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800a060:	b580      	push	{r7, lr}
 800a062:	b088      	sub	sp, #32
 800a064:	af00      	add	r7, sp, #0
 800a066:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t temp_sysclksrc;
  uint32_t temp_pllckcfg;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 800a068:	687b      	ldr	r3, [r7, #4]
 800a06a:	2b00      	cmp	r3, #0
 800a06c:	d101      	bne.n	800a072 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 800a06e:	2301      	movs	r3, #1
 800a070:	e306      	b.n	800a680 <HAL_RCC_OscConfig+0x620>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800a072:	687b      	ldr	r3, [r7, #4]
 800a074:	681b      	ldr	r3, [r3, #0]
 800a076:	f003 0301 	and.w	r3, r3, #1
 800a07a:	2b00      	cmp	r3, #0
 800a07c:	d075      	beq.n	800a16a <HAL_RCC_OscConfig+0x10a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800a07e:	4b97      	ldr	r3, [pc, #604]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a080:	689b      	ldr	r3, [r3, #8]
 800a082:	f003 030c 	and.w	r3, r3, #12
 800a086:	61bb      	str	r3, [r7, #24]
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 800a088:	4b94      	ldr	r3, [pc, #592]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a08a:	68db      	ldr	r3, [r3, #12]
 800a08c:	f003 0303 	and.w	r3, r3, #3
 800a090:	617b      	str	r3, [r7, #20]

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSE)) || (temp_sysclksrc == RCC_CFGR_SWS_HSE))
 800a092:	69bb      	ldr	r3, [r7, #24]
 800a094:	2b0c      	cmp	r3, #12
 800a096:	d102      	bne.n	800a09e <HAL_RCC_OscConfig+0x3e>
 800a098:	697b      	ldr	r3, [r7, #20]
 800a09a:	2b03      	cmp	r3, #3
 800a09c:	d002      	beq.n	800a0a4 <HAL_RCC_OscConfig+0x44>
 800a09e:	69bb      	ldr	r3, [r7, #24]
 800a0a0:	2b08      	cmp	r3, #8
 800a0a2:	d10b      	bne.n	800a0bc <HAL_RCC_OscConfig+0x5c>
    {
      if ((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800a0a4:	4b8d      	ldr	r3, [pc, #564]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a0a6:	681b      	ldr	r3, [r3, #0]
 800a0a8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800a0ac:	2b00      	cmp	r3, #0
 800a0ae:	d05b      	beq.n	800a168 <HAL_RCC_OscConfig+0x108>
 800a0b0:	687b      	ldr	r3, [r7, #4]
 800a0b2:	685b      	ldr	r3, [r3, #4]
 800a0b4:	2b00      	cmp	r3, #0
 800a0b6:	d157      	bne.n	800a168 <HAL_RCC_OscConfig+0x108>
      {
        return HAL_ERROR;
 800a0b8:	2301      	movs	r3, #1
 800a0ba:	e2e1      	b.n	800a680 <HAL_RCC_OscConfig+0x620>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800a0bc:	687b      	ldr	r3, [r7, #4]
 800a0be:	685b      	ldr	r3, [r3, #4]
 800a0c0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800a0c4:	d106      	bne.n	800a0d4 <HAL_RCC_OscConfig+0x74>
 800a0c6:	4b85      	ldr	r3, [pc, #532]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a0c8:	681b      	ldr	r3, [r3, #0]
 800a0ca:	4a84      	ldr	r2, [pc, #528]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a0cc:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800a0d0:	6013      	str	r3, [r2, #0]
 800a0d2:	e01d      	b.n	800a110 <HAL_RCC_OscConfig+0xb0>
 800a0d4:	687b      	ldr	r3, [r7, #4]
 800a0d6:	685b      	ldr	r3, [r3, #4]
 800a0d8:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 800a0dc:	d10c      	bne.n	800a0f8 <HAL_RCC_OscConfig+0x98>
 800a0de:	4b7f      	ldr	r3, [pc, #508]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a0e0:	681b      	ldr	r3, [r3, #0]
 800a0e2:	4a7e      	ldr	r2, [pc, #504]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a0e4:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800a0e8:	6013      	str	r3, [r2, #0]
 800a0ea:	4b7c      	ldr	r3, [pc, #496]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a0ec:	681b      	ldr	r3, [r3, #0]
 800a0ee:	4a7b      	ldr	r2, [pc, #492]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a0f0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800a0f4:	6013      	str	r3, [r2, #0]
 800a0f6:	e00b      	b.n	800a110 <HAL_RCC_OscConfig+0xb0>
 800a0f8:	4b78      	ldr	r3, [pc, #480]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a0fa:	681b      	ldr	r3, [r3, #0]
 800a0fc:	4a77      	ldr	r2, [pc, #476]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a0fe:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800a102:	6013      	str	r3, [r2, #0]
 800a104:	4b75      	ldr	r3, [pc, #468]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a106:	681b      	ldr	r3, [r3, #0]
 800a108:	4a74      	ldr	r2, [pc, #464]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a10a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800a10e:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800a110:	687b      	ldr	r3, [r7, #4]
 800a112:	685b      	ldr	r3, [r3, #4]
 800a114:	2b00      	cmp	r3, #0
 800a116:	d013      	beq.n	800a140 <HAL_RCC_OscConfig+0xe0>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800a118:	f7fb fe1c 	bl	8005d54 <HAL_GetTick>
 800a11c:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 800a11e:	e008      	b.n	800a132 <HAL_RCC_OscConfig+0xd2>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800a120:	f7fb fe18 	bl	8005d54 <HAL_GetTick>
 800a124:	4602      	mov	r2, r0
 800a126:	693b      	ldr	r3, [r7, #16]
 800a128:	1ad3      	subs	r3, r2, r3
 800a12a:	2b64      	cmp	r3, #100	; 0x64
 800a12c:	d901      	bls.n	800a132 <HAL_RCC_OscConfig+0xd2>
          {
            return HAL_TIMEOUT;
 800a12e:	2303      	movs	r3, #3
 800a130:	e2a6      	b.n	800a680 <HAL_RCC_OscConfig+0x620>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 800a132:	4b6a      	ldr	r3, [pc, #424]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a134:	681b      	ldr	r3, [r3, #0]
 800a136:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800a13a:	2b00      	cmp	r3, #0
 800a13c:	d0f0      	beq.n	800a120 <HAL_RCC_OscConfig+0xc0>
 800a13e:	e014      	b.n	800a16a <HAL_RCC_OscConfig+0x10a>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800a140:	f7fb fe08 	bl	8005d54 <HAL_GetTick>
 800a144:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 800a146:	e008      	b.n	800a15a <HAL_RCC_OscConfig+0xfa>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800a148:	f7fb fe04 	bl	8005d54 <HAL_GetTick>
 800a14c:	4602      	mov	r2, r0
 800a14e:	693b      	ldr	r3, [r7, #16]
 800a150:	1ad3      	subs	r3, r2, r3
 800a152:	2b64      	cmp	r3, #100	; 0x64
 800a154:	d901      	bls.n	800a15a <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
 800a156:	2303      	movs	r3, #3
 800a158:	e292      	b.n	800a680 <HAL_RCC_OscConfig+0x620>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 800a15a:	4b60      	ldr	r3, [pc, #384]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a15c:	681b      	ldr	r3, [r3, #0]
 800a15e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800a162:	2b00      	cmp	r3, #0
 800a164:	d1f0      	bne.n	800a148 <HAL_RCC_OscConfig+0xe8>
 800a166:	e000      	b.n	800a16a <HAL_RCC_OscConfig+0x10a>
      if ((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800a168:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800a16a:	687b      	ldr	r3, [r7, #4]
 800a16c:	681b      	ldr	r3, [r3, #0]
 800a16e:	f003 0302 	and.w	r3, r3, #2
 800a172:	2b00      	cmp	r3, #0
 800a174:	d075      	beq.n	800a262 <HAL_RCC_OscConfig+0x202>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800a176:	4b59      	ldr	r3, [pc, #356]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a178:	689b      	ldr	r3, [r3, #8]
 800a17a:	f003 030c 	and.w	r3, r3, #12
 800a17e:	61bb      	str	r3, [r7, #24]
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 800a180:	4b56      	ldr	r3, [pc, #344]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a182:	68db      	ldr	r3, [r3, #12]
 800a184:	f003 0303 	and.w	r3, r3, #3
 800a188:	617b      	str	r3, [r7, #20]
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSI)) || (temp_sysclksrc == RCC_CFGR_SWS_HSI))
 800a18a:	69bb      	ldr	r3, [r7, #24]
 800a18c:	2b0c      	cmp	r3, #12
 800a18e:	d102      	bne.n	800a196 <HAL_RCC_OscConfig+0x136>
 800a190:	697b      	ldr	r3, [r7, #20]
 800a192:	2b02      	cmp	r3, #2
 800a194:	d002      	beq.n	800a19c <HAL_RCC_OscConfig+0x13c>
 800a196:	69bb      	ldr	r3, [r7, #24]
 800a198:	2b04      	cmp	r3, #4
 800a19a:	d11f      	bne.n	800a1dc <HAL_RCC_OscConfig+0x17c>
    {
      /* When HSI is used as system clock it will not be disabled */
      if ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 800a19c:	4b4f      	ldr	r3, [pc, #316]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a19e:	681b      	ldr	r3, [r3, #0]
 800a1a0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800a1a4:	2b00      	cmp	r3, #0
 800a1a6:	d005      	beq.n	800a1b4 <HAL_RCC_OscConfig+0x154>
 800a1a8:	687b      	ldr	r3, [r7, #4]
 800a1aa:	68db      	ldr	r3, [r3, #12]
 800a1ac:	2b00      	cmp	r3, #0
 800a1ae:	d101      	bne.n	800a1b4 <HAL_RCC_OscConfig+0x154>
      {
        return HAL_ERROR;
 800a1b0:	2301      	movs	r3, #1
 800a1b2:	e265      	b.n	800a680 <HAL_RCC_OscConfig+0x620>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800a1b4:	4b49      	ldr	r3, [pc, #292]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a1b6:	685b      	ldr	r3, [r3, #4]
 800a1b8:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
 800a1bc:	687b      	ldr	r3, [r7, #4]
 800a1be:	691b      	ldr	r3, [r3, #16]
 800a1c0:	061b      	lsls	r3, r3, #24
 800a1c2:	4946      	ldr	r1, [pc, #280]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a1c4:	4313      	orrs	r3, r2
 800a1c6:	604b      	str	r3, [r1, #4]

        /* Adapt Systick interrupt period */
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
 800a1c8:	4b45      	ldr	r3, [pc, #276]	; (800a2e0 <HAL_RCC_OscConfig+0x280>)
 800a1ca:	681b      	ldr	r3, [r3, #0]
 800a1cc:	4618      	mov	r0, r3
 800a1ce:	f7fb fd75 	bl	8005cbc <HAL_InitTick>
 800a1d2:	4603      	mov	r3, r0
 800a1d4:	2b00      	cmp	r3, #0
 800a1d6:	d043      	beq.n	800a260 <HAL_RCC_OscConfig+0x200>
        {
          return HAL_ERROR;
 800a1d8:	2301      	movs	r3, #1
 800a1da:	e251      	b.n	800a680 <HAL_RCC_OscConfig+0x620>
      }
    }
    else
    {
      /* Check the HSI State */
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 800a1dc:	687b      	ldr	r3, [r7, #4]
 800a1de:	68db      	ldr	r3, [r3, #12]
 800a1e0:	2b00      	cmp	r3, #0
 800a1e2:	d023      	beq.n	800a22c <HAL_RCC_OscConfig+0x1cc>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800a1e4:	4b3d      	ldr	r3, [pc, #244]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a1e6:	681b      	ldr	r3, [r3, #0]
 800a1e8:	4a3c      	ldr	r2, [pc, #240]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a1ea:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800a1ee:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800a1f0:	f7fb fdb0 	bl	8005d54 <HAL_GetTick>
 800a1f4:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 800a1f6:	e008      	b.n	800a20a <HAL_RCC_OscConfig+0x1aa>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800a1f8:	f7fb fdac 	bl	8005d54 <HAL_GetTick>
 800a1fc:	4602      	mov	r2, r0
 800a1fe:	693b      	ldr	r3, [r7, #16]
 800a200:	1ad3      	subs	r3, r2, r3
 800a202:	2b02      	cmp	r3, #2
 800a204:	d901      	bls.n	800a20a <HAL_RCC_OscConfig+0x1aa>
          {
            return HAL_TIMEOUT;
 800a206:	2303      	movs	r3, #3
 800a208:	e23a      	b.n	800a680 <HAL_RCC_OscConfig+0x620>
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 800a20a:	4b34      	ldr	r3, [pc, #208]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a20c:	681b      	ldr	r3, [r3, #0]
 800a20e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800a212:	2b00      	cmp	r3, #0
 800a214:	d0f0      	beq.n	800a1f8 <HAL_RCC_OscConfig+0x198>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800a216:	4b31      	ldr	r3, [pc, #196]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a218:	685b      	ldr	r3, [r3, #4]
 800a21a:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
 800a21e:	687b      	ldr	r3, [r7, #4]
 800a220:	691b      	ldr	r3, [r3, #16]
 800a222:	061b      	lsls	r3, r3, #24
 800a224:	492d      	ldr	r1, [pc, #180]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a226:	4313      	orrs	r3, r2
 800a228:	604b      	str	r3, [r1, #4]
 800a22a:	e01a      	b.n	800a262 <HAL_RCC_OscConfig+0x202>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800a22c:	4b2b      	ldr	r3, [pc, #172]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a22e:	681b      	ldr	r3, [r3, #0]
 800a230:	4a2a      	ldr	r2, [pc, #168]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a232:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800a236:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800a238:	f7fb fd8c 	bl	8005d54 <HAL_GetTick>
 800a23c:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 800a23e:	e008      	b.n	800a252 <HAL_RCC_OscConfig+0x1f2>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800a240:	f7fb fd88 	bl	8005d54 <HAL_GetTick>
 800a244:	4602      	mov	r2, r0
 800a246:	693b      	ldr	r3, [r7, #16]
 800a248:	1ad3      	subs	r3, r2, r3
 800a24a:	2b02      	cmp	r3, #2
 800a24c:	d901      	bls.n	800a252 <HAL_RCC_OscConfig+0x1f2>
          {
            return HAL_TIMEOUT;
 800a24e:	2303      	movs	r3, #3
 800a250:	e216      	b.n	800a680 <HAL_RCC_OscConfig+0x620>
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 800a252:	4b22      	ldr	r3, [pc, #136]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a254:	681b      	ldr	r3, [r3, #0]
 800a256:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800a25a:	2b00      	cmp	r3, #0
 800a25c:	d1f0      	bne.n	800a240 <HAL_RCC_OscConfig+0x1e0>
 800a25e:	e000      	b.n	800a262 <HAL_RCC_OscConfig+0x202>
      if ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 800a260:	bf00      	nop
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800a262:	687b      	ldr	r3, [r7, #4]
 800a264:	681b      	ldr	r3, [r3, #0]
 800a266:	f003 0308 	and.w	r3, r3, #8
 800a26a:	2b00      	cmp	r3, #0
 800a26c:	d041      	beq.n	800a2f2 <HAL_RCC_OscConfig+0x292>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 800a26e:	687b      	ldr	r3, [r7, #4]
 800a270:	695b      	ldr	r3, [r3, #20]
 800a272:	2b00      	cmp	r3, #0
 800a274:	d01c      	beq.n	800a2b0 <HAL_RCC_OscConfig+0x250>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800a276:	4b19      	ldr	r3, [pc, #100]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a278:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800a27c:	4a17      	ldr	r2, [pc, #92]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a27e:	f043 0301 	orr.w	r3, r3, #1
 800a282:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800a286:	f7fb fd65 	bl	8005d54 <HAL_GetTick>
 800a28a:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 800a28c:	e008      	b.n	800a2a0 <HAL_RCC_OscConfig+0x240>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800a28e:	f7fb fd61 	bl	8005d54 <HAL_GetTick>
 800a292:	4602      	mov	r2, r0
 800a294:	693b      	ldr	r3, [r7, #16]
 800a296:	1ad3      	subs	r3, r2, r3
 800a298:	2b02      	cmp	r3, #2
 800a29a:	d901      	bls.n	800a2a0 <HAL_RCC_OscConfig+0x240>
        {
          return HAL_TIMEOUT;
 800a29c:	2303      	movs	r3, #3
 800a29e:	e1ef      	b.n	800a680 <HAL_RCC_OscConfig+0x620>
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 800a2a0:	4b0e      	ldr	r3, [pc, #56]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a2a2:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800a2a6:	f003 0302 	and.w	r3, r3, #2
 800a2aa:	2b00      	cmp	r3, #0
 800a2ac:	d0ef      	beq.n	800a28e <HAL_RCC_OscConfig+0x22e>
 800a2ae:	e020      	b.n	800a2f2 <HAL_RCC_OscConfig+0x292>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800a2b0:	4b0a      	ldr	r3, [pc, #40]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a2b2:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800a2b6:	4a09      	ldr	r2, [pc, #36]	; (800a2dc <HAL_RCC_OscConfig+0x27c>)
 800a2b8:	f023 0301 	bic.w	r3, r3, #1
 800a2bc:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800a2c0:	f7fb fd48 	bl	8005d54 <HAL_GetTick>
 800a2c4:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is disabled */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 800a2c6:	e00d      	b.n	800a2e4 <HAL_RCC_OscConfig+0x284>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800a2c8:	f7fb fd44 	bl	8005d54 <HAL_GetTick>
 800a2cc:	4602      	mov	r2, r0
 800a2ce:	693b      	ldr	r3, [r7, #16]
 800a2d0:	1ad3      	subs	r3, r2, r3
 800a2d2:	2b02      	cmp	r3, #2
 800a2d4:	d906      	bls.n	800a2e4 <HAL_RCC_OscConfig+0x284>
        {
          return HAL_TIMEOUT;
 800a2d6:	2303      	movs	r3, #3
 800a2d8:	e1d2      	b.n	800a680 <HAL_RCC_OscConfig+0x620>
 800a2da:	bf00      	nop
 800a2dc:	40021000 	.word	0x40021000
 800a2e0:	2000000c 	.word	0x2000000c
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 800a2e4:	4b8c      	ldr	r3, [pc, #560]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a2e6:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800a2ea:	f003 0302 	and.w	r3, r3, #2
 800a2ee:	2b00      	cmp	r3, #0
 800a2f0:	d1ea      	bne.n	800a2c8 <HAL_RCC_OscConfig+0x268>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800a2f2:	687b      	ldr	r3, [r7, #4]
 800a2f4:	681b      	ldr	r3, [r3, #0]
 800a2f6:	f003 0304 	and.w	r3, r3, #4
 800a2fa:	2b00      	cmp	r3, #0
 800a2fc:	f000 80a6 	beq.w	800a44c <HAL_RCC_OscConfig+0x3ec>
  {
    FlagStatus       pwrclkchanged = RESET;
 800a300:	2300      	movs	r3, #0
 800a302:	77fb      	strb	r3, [r7, #31]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain if necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
 800a304:	4b84      	ldr	r3, [pc, #528]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a306:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800a308:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800a30c:	2b00      	cmp	r3, #0
 800a30e:	d101      	bne.n	800a314 <HAL_RCC_OscConfig+0x2b4>
 800a310:	2301      	movs	r3, #1
 800a312:	e000      	b.n	800a316 <HAL_RCC_OscConfig+0x2b6>
 800a314:	2300      	movs	r3, #0
 800a316:	2b00      	cmp	r3, #0
 800a318:	d00d      	beq.n	800a336 <HAL_RCC_OscConfig+0x2d6>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800a31a:	4b7f      	ldr	r3, [pc, #508]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a31c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800a31e:	4a7e      	ldr	r2, [pc, #504]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a320:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800a324:	6593      	str	r3, [r2, #88]	; 0x58
 800a326:	4b7c      	ldr	r3, [pc, #496]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a328:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800a32a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800a32e:	60fb      	str	r3, [r7, #12]
 800a330:	68fb      	ldr	r3, [r7, #12]
      pwrclkchanged = SET;
 800a332:	2301      	movs	r3, #1
 800a334:	77fb      	strb	r3, [r7, #31]
    }

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800a336:	4b79      	ldr	r3, [pc, #484]	; (800a51c <HAL_RCC_OscConfig+0x4bc>)
 800a338:	681b      	ldr	r3, [r3, #0]
 800a33a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800a33e:	2b00      	cmp	r3, #0
 800a340:	d118      	bne.n	800a374 <HAL_RCC_OscConfig+0x314>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 800a342:	4b76      	ldr	r3, [pc, #472]	; (800a51c <HAL_RCC_OscConfig+0x4bc>)
 800a344:	681b      	ldr	r3, [r3, #0]
 800a346:	4a75      	ldr	r2, [pc, #468]	; (800a51c <HAL_RCC_OscConfig+0x4bc>)
 800a348:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800a34c:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800a34e:	f7fb fd01 	bl	8005d54 <HAL_GetTick>
 800a352:	6138      	str	r0, [r7, #16]

      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800a354:	e008      	b.n	800a368 <HAL_RCC_OscConfig+0x308>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800a356:	f7fb fcfd 	bl	8005d54 <HAL_GetTick>
 800a35a:	4602      	mov	r2, r0
 800a35c:	693b      	ldr	r3, [r7, #16]
 800a35e:	1ad3      	subs	r3, r2, r3
 800a360:	2b02      	cmp	r3, #2
 800a362:	d901      	bls.n	800a368 <HAL_RCC_OscConfig+0x308>
        {
          return HAL_TIMEOUT;
 800a364:	2303      	movs	r3, #3
 800a366:	e18b      	b.n	800a680 <HAL_RCC_OscConfig+0x620>
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800a368:	4b6c      	ldr	r3, [pc, #432]	; (800a51c <HAL_RCC_OscConfig+0x4bc>)
 800a36a:	681b      	ldr	r3, [r3, #0]
 800a36c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800a370:	2b00      	cmp	r3, #0
 800a372:	d0f0      	beq.n	800a356 <HAL_RCC_OscConfig+0x2f6>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800a374:	687b      	ldr	r3, [r7, #4]
 800a376:	689b      	ldr	r3, [r3, #8]
 800a378:	2b01      	cmp	r3, #1
 800a37a:	d108      	bne.n	800a38e <HAL_RCC_OscConfig+0x32e>
 800a37c:	4b66      	ldr	r3, [pc, #408]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a37e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800a382:	4a65      	ldr	r2, [pc, #404]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a384:	f043 0301 	orr.w	r3, r3, #1
 800a388:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 800a38c:	e024      	b.n	800a3d8 <HAL_RCC_OscConfig+0x378>
 800a38e:	687b      	ldr	r3, [r7, #4]
 800a390:	689b      	ldr	r3, [r3, #8]
 800a392:	2b05      	cmp	r3, #5
 800a394:	d110      	bne.n	800a3b8 <HAL_RCC_OscConfig+0x358>
 800a396:	4b60      	ldr	r3, [pc, #384]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a398:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800a39c:	4a5e      	ldr	r2, [pc, #376]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a39e:	f043 0304 	orr.w	r3, r3, #4
 800a3a2:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 800a3a6:	4b5c      	ldr	r3, [pc, #368]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a3a8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800a3ac:	4a5a      	ldr	r2, [pc, #360]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a3ae:	f043 0301 	orr.w	r3, r3, #1
 800a3b2:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 800a3b6:	e00f      	b.n	800a3d8 <HAL_RCC_OscConfig+0x378>
 800a3b8:	4b57      	ldr	r3, [pc, #348]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a3ba:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800a3be:	4a56      	ldr	r2, [pc, #344]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a3c0:	f023 0301 	bic.w	r3, r3, #1
 800a3c4:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 800a3c8:	4b53      	ldr	r3, [pc, #332]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a3ca:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800a3ce:	4a52      	ldr	r2, [pc, #328]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a3d0:	f023 0304 	bic.w	r3, r3, #4
 800a3d4:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90

    /* Check the LSE State */
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 800a3d8:	687b      	ldr	r3, [r7, #4]
 800a3da:	689b      	ldr	r3, [r3, #8]
 800a3dc:	2b00      	cmp	r3, #0
 800a3de:	d016      	beq.n	800a40e <HAL_RCC_OscConfig+0x3ae>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800a3e0:	f7fb fcb8 	bl	8005d54 <HAL_GetTick>
 800a3e4:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 800a3e6:	e00a      	b.n	800a3fe <HAL_RCC_OscConfig+0x39e>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800a3e8:	f7fb fcb4 	bl	8005d54 <HAL_GetTick>
 800a3ec:	4602      	mov	r2, r0
 800a3ee:	693b      	ldr	r3, [r7, #16]
 800a3f0:	1ad3      	subs	r3, r2, r3
 800a3f2:	f241 3288 	movw	r2, #5000	; 0x1388
 800a3f6:	4293      	cmp	r3, r2
 800a3f8:	d901      	bls.n	800a3fe <HAL_RCC_OscConfig+0x39e>
        {
          return HAL_TIMEOUT;
 800a3fa:	2303      	movs	r3, #3
 800a3fc:	e140      	b.n	800a680 <HAL_RCC_OscConfig+0x620>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 800a3fe:	4b46      	ldr	r3, [pc, #280]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a400:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800a404:	f003 0302 	and.w	r3, r3, #2
 800a408:	2b00      	cmp	r3, #0
 800a40a:	d0ed      	beq.n	800a3e8 <HAL_RCC_OscConfig+0x388>
 800a40c:	e015      	b.n	800a43a <HAL_RCC_OscConfig+0x3da>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800a40e:	f7fb fca1 	bl	8005d54 <HAL_GetTick>
 800a412:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is disabled */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 800a414:	e00a      	b.n	800a42c <HAL_RCC_OscConfig+0x3cc>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800a416:	f7fb fc9d 	bl	8005d54 <HAL_GetTick>
 800a41a:	4602      	mov	r2, r0
 800a41c:	693b      	ldr	r3, [r7, #16]
 800a41e:	1ad3      	subs	r3, r2, r3
 800a420:	f241 3288 	movw	r2, #5000	; 0x1388
 800a424:	4293      	cmp	r3, r2
 800a426:	d901      	bls.n	800a42c <HAL_RCC_OscConfig+0x3cc>
        {
          return HAL_TIMEOUT;
 800a428:	2303      	movs	r3, #3
 800a42a:	e129      	b.n	800a680 <HAL_RCC_OscConfig+0x620>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 800a42c:	4b3a      	ldr	r3, [pc, #232]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a42e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800a432:	f003 0302 	and.w	r3, r3, #2
 800a436:	2b00      	cmp	r3, #0
 800a438:	d1ed      	bne.n	800a416 <HAL_RCC_OscConfig+0x3b6>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 800a43a:	7ffb      	ldrb	r3, [r7, #31]
 800a43c:	2b01      	cmp	r3, #1
 800a43e:	d105      	bne.n	800a44c <HAL_RCC_OscConfig+0x3ec>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800a440:	4b35      	ldr	r3, [pc, #212]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a442:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800a444:	4a34      	ldr	r2, [pc, #208]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a446:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800a44a:	6593      	str	r3, [r2, #88]	; 0x58
    }
  }

  /*------------------------------ HSI48 Configuration -----------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 800a44c:	687b      	ldr	r3, [r7, #4]
 800a44e:	681b      	ldr	r3, [r3, #0]
 800a450:	f003 0320 	and.w	r3, r3, #32
 800a454:	2b00      	cmp	r3, #0
 800a456:	d03c      	beq.n	800a4d2 <HAL_RCC_OscConfig+0x472>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 800a458:	687b      	ldr	r3, [r7, #4]
 800a45a:	699b      	ldr	r3, [r3, #24]
 800a45c:	2b00      	cmp	r3, #0
 800a45e:	d01c      	beq.n	800a49a <HAL_RCC_OscConfig+0x43a>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 800a460:	4b2d      	ldr	r3, [pc, #180]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a462:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800a466:	4a2c      	ldr	r2, [pc, #176]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a468:	f043 0301 	orr.w	r3, r3, #1
 800a46c:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800a470:	f7fb fc70 	bl	8005d54 <HAL_GetTick>
 800a474:	6138      	str	r0, [r7, #16]

      /* Wait till HSI48 is ready */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 800a476:	e008      	b.n	800a48a <HAL_RCC_OscConfig+0x42a>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800a478:	f7fb fc6c 	bl	8005d54 <HAL_GetTick>
 800a47c:	4602      	mov	r2, r0
 800a47e:	693b      	ldr	r3, [r7, #16]
 800a480:	1ad3      	subs	r3, r2, r3
 800a482:	2b02      	cmp	r3, #2
 800a484:	d901      	bls.n	800a48a <HAL_RCC_OscConfig+0x42a>
        {
          return HAL_TIMEOUT;
 800a486:	2303      	movs	r3, #3
 800a488:	e0fa      	b.n	800a680 <HAL_RCC_OscConfig+0x620>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 800a48a:	4b23      	ldr	r3, [pc, #140]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a48c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800a490:	f003 0302 	and.w	r3, r3, #2
 800a494:	2b00      	cmp	r3, #0
 800a496:	d0ef      	beq.n	800a478 <HAL_RCC_OscConfig+0x418>
 800a498:	e01b      	b.n	800a4d2 <HAL_RCC_OscConfig+0x472>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
 800a49a:	4b1f      	ldr	r3, [pc, #124]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a49c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800a4a0:	4a1d      	ldr	r2, [pc, #116]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a4a2:	f023 0301 	bic.w	r3, r3, #1
 800a4a6:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800a4aa:	f7fb fc53 	bl	8005d54 <HAL_GetTick>
 800a4ae:	6138      	str	r0, [r7, #16]

      /* Wait till HSI48 is disabled */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 800a4b0:	e008      	b.n	800a4c4 <HAL_RCC_OscConfig+0x464>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800a4b2:	f7fb fc4f 	bl	8005d54 <HAL_GetTick>
 800a4b6:	4602      	mov	r2, r0
 800a4b8:	693b      	ldr	r3, [r7, #16]
 800a4ba:	1ad3      	subs	r3, r2, r3
 800a4bc:	2b02      	cmp	r3, #2
 800a4be:	d901      	bls.n	800a4c4 <HAL_RCC_OscConfig+0x464>
        {
          return HAL_TIMEOUT;
 800a4c0:	2303      	movs	r3, #3
 800a4c2:	e0dd      	b.n	800a680 <HAL_RCC_OscConfig+0x620>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 800a4c4:	4b14      	ldr	r3, [pc, #80]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a4c6:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800a4ca:	f003 0302 	and.w	r3, r3, #2
 800a4ce:	2b00      	cmp	r3, #0
 800a4d0:	d1ef      	bne.n	800a4b2 <HAL_RCC_OscConfig+0x452>

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 800a4d2:	687b      	ldr	r3, [r7, #4]
 800a4d4:	69db      	ldr	r3, [r3, #28]
 800a4d6:	2b00      	cmp	r3, #0
 800a4d8:	f000 80d1 	beq.w	800a67e <HAL_RCC_OscConfig+0x61e>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 800a4dc:	4b0e      	ldr	r3, [pc, #56]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a4de:	689b      	ldr	r3, [r3, #8]
 800a4e0:	f003 030c 	and.w	r3, r3, #12
 800a4e4:	2b0c      	cmp	r3, #12
 800a4e6:	f000 808b 	beq.w	800a600 <HAL_RCC_OscConfig+0x5a0>
    {
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 800a4ea:	687b      	ldr	r3, [r7, #4]
 800a4ec:	69db      	ldr	r3, [r3, #28]
 800a4ee:	2b02      	cmp	r3, #2
 800a4f0:	d15e      	bne.n	800a5b0 <HAL_RCC_OscConfig+0x550>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800a4f2:	4b09      	ldr	r3, [pc, #36]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a4f4:	681b      	ldr	r3, [r3, #0]
 800a4f6:	4a08      	ldr	r2, [pc, #32]	; (800a518 <HAL_RCC_OscConfig+0x4b8>)
 800a4f8:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800a4fc:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800a4fe:	f7fb fc29 	bl	8005d54 <HAL_GetTick>
 800a502:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 800a504:	e00c      	b.n	800a520 <HAL_RCC_OscConfig+0x4c0>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800a506:	f7fb fc25 	bl	8005d54 <HAL_GetTick>
 800a50a:	4602      	mov	r2, r0
 800a50c:	693b      	ldr	r3, [r7, #16]
 800a50e:	1ad3      	subs	r3, r2, r3
 800a510:	2b02      	cmp	r3, #2
 800a512:	d905      	bls.n	800a520 <HAL_RCC_OscConfig+0x4c0>
          {
            return HAL_TIMEOUT;
 800a514:	2303      	movs	r3, #3
 800a516:	e0b3      	b.n	800a680 <HAL_RCC_OscConfig+0x620>
 800a518:	40021000 	.word	0x40021000
 800a51c:	40007000 	.word	0x40007000
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 800a520:	4b59      	ldr	r3, [pc, #356]	; (800a688 <HAL_RCC_OscConfig+0x628>)
 800a522:	681b      	ldr	r3, [r3, #0]
 800a524:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800a528:	2b00      	cmp	r3, #0
 800a52a:	d1ec      	bne.n	800a506 <HAL_RCC_OscConfig+0x4a6>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800a52c:	4b56      	ldr	r3, [pc, #344]	; (800a688 <HAL_RCC_OscConfig+0x628>)
 800a52e:	68da      	ldr	r2, [r3, #12]
 800a530:	4b56      	ldr	r3, [pc, #344]	; (800a68c <HAL_RCC_OscConfig+0x62c>)
 800a532:	4013      	ands	r3, r2
 800a534:	687a      	ldr	r2, [r7, #4]
 800a536:	6a11      	ldr	r1, [r2, #32]
 800a538:	687a      	ldr	r2, [r7, #4]
 800a53a:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800a53c:	3a01      	subs	r2, #1
 800a53e:	0112      	lsls	r2, r2, #4
 800a540:	4311      	orrs	r1, r2
 800a542:	687a      	ldr	r2, [r7, #4]
 800a544:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800a546:	0212      	lsls	r2, r2, #8
 800a548:	4311      	orrs	r1, r2
 800a54a:	687a      	ldr	r2, [r7, #4]
 800a54c:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800a54e:	0852      	lsrs	r2, r2, #1
 800a550:	3a01      	subs	r2, #1
 800a552:	0552      	lsls	r2, r2, #21
 800a554:	4311      	orrs	r1, r2
 800a556:	687a      	ldr	r2, [r7, #4]
 800a558:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800a55a:	0852      	lsrs	r2, r2, #1
 800a55c:	3a01      	subs	r2, #1
 800a55e:	0652      	lsls	r2, r2, #25
 800a560:	4311      	orrs	r1, r2
 800a562:	687a      	ldr	r2, [r7, #4]
 800a564:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800a566:	06d2      	lsls	r2, r2, #27
 800a568:	430a      	orrs	r2, r1
 800a56a:	4947      	ldr	r1, [pc, #284]	; (800a688 <HAL_RCC_OscConfig+0x628>)
 800a56c:	4313      	orrs	r3, r2
 800a56e:	60cb      	str	r3, [r1, #12]
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800a570:	4b45      	ldr	r3, [pc, #276]	; (800a688 <HAL_RCC_OscConfig+0x628>)
 800a572:	681b      	ldr	r3, [r3, #0]
 800a574:	4a44      	ldr	r2, [pc, #272]	; (800a688 <HAL_RCC_OscConfig+0x628>)
 800a576:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800a57a:	6013      	str	r3, [r2, #0]

        /* Enable PLL System Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 800a57c:	4b42      	ldr	r3, [pc, #264]	; (800a688 <HAL_RCC_OscConfig+0x628>)
 800a57e:	68db      	ldr	r3, [r3, #12]
 800a580:	4a41      	ldr	r2, [pc, #260]	; (800a688 <HAL_RCC_OscConfig+0x628>)
 800a582:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800a586:	60d3      	str	r3, [r2, #12]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800a588:	f7fb fbe4 	bl	8005d54 <HAL_GetTick>
 800a58c:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800a58e:	e008      	b.n	800a5a2 <HAL_RCC_OscConfig+0x542>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800a590:	f7fb fbe0 	bl	8005d54 <HAL_GetTick>
 800a594:	4602      	mov	r2, r0
 800a596:	693b      	ldr	r3, [r7, #16]
 800a598:	1ad3      	subs	r3, r2, r3
 800a59a:	2b02      	cmp	r3, #2
 800a59c:	d901      	bls.n	800a5a2 <HAL_RCC_OscConfig+0x542>
          {
            return HAL_TIMEOUT;
 800a59e:	2303      	movs	r3, #3
 800a5a0:	e06e      	b.n	800a680 <HAL_RCC_OscConfig+0x620>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800a5a2:	4b39      	ldr	r3, [pc, #228]	; (800a688 <HAL_RCC_OscConfig+0x628>)
 800a5a4:	681b      	ldr	r3, [r3, #0]
 800a5a6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800a5aa:	2b00      	cmp	r3, #0
 800a5ac:	d0f0      	beq.n	800a590 <HAL_RCC_OscConfig+0x530>
 800a5ae:	e066      	b.n	800a67e <HAL_RCC_OscConfig+0x61e>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800a5b0:	4b35      	ldr	r3, [pc, #212]	; (800a688 <HAL_RCC_OscConfig+0x628>)
 800a5b2:	681b      	ldr	r3, [r3, #0]
 800a5b4:	4a34      	ldr	r2, [pc, #208]	; (800a688 <HAL_RCC_OscConfig+0x628>)
 800a5b6:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800a5ba:	6013      	str	r3, [r2, #0]

        /* Disable all PLL outputs to save power if no PLLs on */
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 800a5bc:	4b32      	ldr	r3, [pc, #200]	; (800a688 <HAL_RCC_OscConfig+0x628>)
 800a5be:	68db      	ldr	r3, [r3, #12]
 800a5c0:	4a31      	ldr	r2, [pc, #196]	; (800a688 <HAL_RCC_OscConfig+0x628>)
 800a5c2:	f023 0303 	bic.w	r3, r3, #3
 800a5c6:	60d3      	str	r3, [r2, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_ADCCLK);
 800a5c8:	4b2f      	ldr	r3, [pc, #188]	; (800a688 <HAL_RCC_OscConfig+0x628>)
 800a5ca:	68db      	ldr	r3, [r3, #12]
 800a5cc:	4a2e      	ldr	r2, [pc, #184]	; (800a688 <HAL_RCC_OscConfig+0x628>)
 800a5ce:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 800a5d2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800a5d6:	60d3      	str	r3, [r2, #12]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800a5d8:	f7fb fbbc 	bl	8005d54 <HAL_GetTick>
 800a5dc:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 800a5de:	e008      	b.n	800a5f2 <HAL_RCC_OscConfig+0x592>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800a5e0:	f7fb fbb8 	bl	8005d54 <HAL_GetTick>
 800a5e4:	4602      	mov	r2, r0
 800a5e6:	693b      	ldr	r3, [r7, #16]
 800a5e8:	1ad3      	subs	r3, r2, r3
 800a5ea:	2b02      	cmp	r3, #2
 800a5ec:	d901      	bls.n	800a5f2 <HAL_RCC_OscConfig+0x592>
          {
            return HAL_TIMEOUT;
 800a5ee:	2303      	movs	r3, #3
 800a5f0:	e046      	b.n	800a680 <HAL_RCC_OscConfig+0x620>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 800a5f2:	4b25      	ldr	r3, [pc, #148]	; (800a688 <HAL_RCC_OscConfig+0x628>)
 800a5f4:	681b      	ldr	r3, [r3, #0]
 800a5f6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800a5fa:	2b00      	cmp	r3, #0
 800a5fc:	d1f0      	bne.n	800a5e0 <HAL_RCC_OscConfig+0x580>
 800a5fe:	e03e      	b.n	800a67e <HAL_RCC_OscConfig+0x61e>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 800a600:	687b      	ldr	r3, [r7, #4]
 800a602:	69db      	ldr	r3, [r3, #28]
 800a604:	2b01      	cmp	r3, #1
 800a606:	d101      	bne.n	800a60c <HAL_RCC_OscConfig+0x5ac>
      {
        return HAL_ERROR;
 800a608:	2301      	movs	r3, #1
 800a60a:	e039      	b.n	800a680 <HAL_RCC_OscConfig+0x620>
      }
      else
      {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      temp_pllckcfg = RCC->PLLCFGR;
 800a60c:	4b1e      	ldr	r3, [pc, #120]	; (800a688 <HAL_RCC_OscConfig+0x628>)
 800a60e:	68db      	ldr	r3, [r3, #12]
 800a610:	617b      	str	r3, [r7, #20]
      if((READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800a612:	697b      	ldr	r3, [r7, #20]
 800a614:	f003 0203 	and.w	r2, r3, #3
 800a618:	687b      	ldr	r3, [r7, #4]
 800a61a:	6a1b      	ldr	r3, [r3, #32]
 800a61c:	429a      	cmp	r2, r3
 800a61e:	d12c      	bne.n	800a67a <HAL_RCC_OscConfig+0x61a>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLM) != (((RCC_OscInitStruct->PLL.PLLM) - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 800a620:	697b      	ldr	r3, [r7, #20]
 800a622:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 800a626:	687b      	ldr	r3, [r7, #4]
 800a628:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a62a:	3b01      	subs	r3, #1
 800a62c:	011b      	lsls	r3, r3, #4
      if((READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800a62e:	429a      	cmp	r2, r3
 800a630:	d123      	bne.n	800a67a <HAL_RCC_OscConfig+0x61a>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLN) != ((RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos)) ||
 800a632:	697b      	ldr	r3, [r7, #20]
 800a634:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
 800a638:	687b      	ldr	r3, [r7, #4]
 800a63a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a63c:	021b      	lsls	r3, r3, #8
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLM) != (((RCC_OscInitStruct->PLL.PLLM) - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 800a63e:	429a      	cmp	r2, r3
 800a640:	d11b      	bne.n	800a67a <HAL_RCC_OscConfig+0x61a>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLPDIV) != ((RCC_OscInitStruct->PLL.PLLP) << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 800a642:	697b      	ldr	r3, [r7, #20]
 800a644:	f003 4278 	and.w	r2, r3, #4160749568	; 0xf8000000
 800a648:	687b      	ldr	r3, [r7, #4]
 800a64a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a64c:	06db      	lsls	r3, r3, #27
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLN) != ((RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos)) ||
 800a64e:	429a      	cmp	r2, r3
 800a650:	d113      	bne.n	800a67a <HAL_RCC_OscConfig+0x61a>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLQ) != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 800a652:	697b      	ldr	r3, [r7, #20]
 800a654:	f403 02c0 	and.w	r2, r3, #6291456	; 0x600000
 800a658:	687b      	ldr	r3, [r7, #4]
 800a65a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a65c:	085b      	lsrs	r3, r3, #1
 800a65e:	3b01      	subs	r3, #1
 800a660:	055b      	lsls	r3, r3, #21
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLPDIV) != ((RCC_OscInitStruct->PLL.PLLP) << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 800a662:	429a      	cmp	r2, r3
 800a664:	d109      	bne.n	800a67a <HAL_RCC_OscConfig+0x61a>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLR) != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
 800a666:	697b      	ldr	r3, [r7, #20]
 800a668:	f003 62c0 	and.w	r2, r3, #100663296	; 0x6000000
 800a66c:	687b      	ldr	r3, [r7, #4]
 800a66e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a670:	085b      	lsrs	r3, r3, #1
 800a672:	3b01      	subs	r3, #1
 800a674:	065b      	lsls	r3, r3, #25
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLQ) != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 800a676:	429a      	cmp	r2, r3
 800a678:	d001      	beq.n	800a67e <HAL_RCC_OscConfig+0x61e>
      {
        return HAL_ERROR;
 800a67a:	2301      	movs	r3, #1
 800a67c:	e000      	b.n	800a680 <HAL_RCC_OscConfig+0x620>
      }
    }
  }
  }

  return HAL_OK;
 800a67e:	2300      	movs	r3, #0
}
 800a680:	4618      	mov	r0, r3
 800a682:	3720      	adds	r7, #32
 800a684:	46bd      	mov	sp, r7
 800a686:	bd80      	pop	{r7, pc}
 800a688:	40021000 	.word	0x40021000
 800a68c:	019f800c 	.word	0x019f800c

0800a690 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800a690:	b580      	push	{r7, lr}
 800a692:	b086      	sub	sp, #24
 800a694:	af00      	add	r7, sp, #0
 800a696:	6078      	str	r0, [r7, #4]
 800a698:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  uint32_t pllfreq;
  uint32_t hpre = RCC_SYSCLK_DIV1;
 800a69a:	2300      	movs	r3, #0
 800a69c:	617b      	str	r3, [r7, #20]

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 800a69e:	687b      	ldr	r3, [r7, #4]
 800a6a0:	2b00      	cmp	r3, #0
 800a6a2:	d101      	bne.n	800a6a8 <HAL_RCC_ClockConfig+0x18>
  {
    return HAL_ERROR;
 800a6a4:	2301      	movs	r3, #1
 800a6a6:	e11e      	b.n	800a8e6 <HAL_RCC_ClockConfig+0x256>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 800a6a8:	4b91      	ldr	r3, [pc, #580]	; (800a8f0 <HAL_RCC_ClockConfig+0x260>)
 800a6aa:	681b      	ldr	r3, [r3, #0]
 800a6ac:	f003 030f 	and.w	r3, r3, #15
 800a6b0:	683a      	ldr	r2, [r7, #0]
 800a6b2:	429a      	cmp	r2, r3
 800a6b4:	d910      	bls.n	800a6d8 <HAL_RCC_ClockConfig+0x48>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800a6b6:	4b8e      	ldr	r3, [pc, #568]	; (800a8f0 <HAL_RCC_ClockConfig+0x260>)
 800a6b8:	681b      	ldr	r3, [r3, #0]
 800a6ba:	f023 020f 	bic.w	r2, r3, #15
 800a6be:	498c      	ldr	r1, [pc, #560]	; (800a8f0 <HAL_RCC_ClockConfig+0x260>)
 800a6c0:	683b      	ldr	r3, [r7, #0]
 800a6c2:	4313      	orrs	r3, r2
 800a6c4:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800a6c6:	4b8a      	ldr	r3, [pc, #552]	; (800a8f0 <HAL_RCC_ClockConfig+0x260>)
 800a6c8:	681b      	ldr	r3, [r3, #0]
 800a6ca:	f003 030f 	and.w	r3, r3, #15
 800a6ce:	683a      	ldr	r2, [r7, #0]
 800a6d0:	429a      	cmp	r2, r3
 800a6d2:	d001      	beq.n	800a6d8 <HAL_RCC_ClockConfig+0x48>
    {
      return HAL_ERROR;
 800a6d4:	2301      	movs	r3, #1
 800a6d6:	e106      	b.n	800a8e6 <HAL_RCC_ClockConfig+0x256>
    }
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800a6d8:	687b      	ldr	r3, [r7, #4]
 800a6da:	681b      	ldr	r3, [r3, #0]
 800a6dc:	f003 0301 	and.w	r3, r3, #1
 800a6e0:	2b00      	cmp	r3, #0
 800a6e2:	d073      	beq.n	800a7cc <HAL_RCC_ClockConfig+0x13c>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* PLL is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800a6e4:	687b      	ldr	r3, [r7, #4]
 800a6e6:	685b      	ldr	r3, [r3, #4]
 800a6e8:	2b03      	cmp	r3, #3
 800a6ea:	d129      	bne.n	800a740 <HAL_RCC_ClockConfig+0xb0>
    {
      /* Check the PLL ready flag */
      if (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800a6ec:	4b81      	ldr	r3, [pc, #516]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a6ee:	681b      	ldr	r3, [r3, #0]
 800a6f0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800a6f4:	2b00      	cmp	r3, #0
 800a6f6:	d101      	bne.n	800a6fc <HAL_RCC_ClockConfig+0x6c>
      {
        return HAL_ERROR;
 800a6f8:	2301      	movs	r3, #1
 800a6fa:	e0f4      	b.n	800a8e6 <HAL_RCC_ClockConfig+0x256>
      }
      /* Undershoot management when selection PLL as SYSCLK source and frequency above 80Mhz */
      /* Compute target PLL output frequency */
      pllfreq = RCC_GetSysClockFreqFromPLLSource();
 800a6fc:	f000 f972 	bl	800a9e4 <RCC_GetSysClockFreqFromPLLSource>
 800a700:	6138      	str	r0, [r7, #16]

      /* Intermediate step with HCLK prescaler 2 necessary before to go over 80Mhz */
      if(pllfreq > 80000000U)
 800a702:	693b      	ldr	r3, [r7, #16]
 800a704:	4a7c      	ldr	r2, [pc, #496]	; (800a8f8 <HAL_RCC_ClockConfig+0x268>)
 800a706:	4293      	cmp	r3, r2
 800a708:	d93f      	bls.n	800a78a <HAL_RCC_ClockConfig+0xfa>
      {
        if (((READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)) ||
 800a70a:	4b7a      	ldr	r3, [pc, #488]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a70c:	689b      	ldr	r3, [r3, #8]
 800a70e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800a712:	2b00      	cmp	r3, #0
 800a714:	d009      	beq.n	800a72a <HAL_RCC_ClockConfig+0x9a>
            (((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) &&
 800a716:	687b      	ldr	r3, [r7, #4]
 800a718:	681b      	ldr	r3, [r3, #0]
 800a71a:	f003 0302 	and.w	r3, r3, #2
        if (((READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)) ||
 800a71e:	2b00      	cmp	r3, #0
 800a720:	d033      	beq.n	800a78a <HAL_RCC_ClockConfig+0xfa>
              (RCC_ClkInitStruct->AHBCLKDivider == RCC_SYSCLK_DIV1))))
 800a722:	687b      	ldr	r3, [r7, #4]
 800a724:	689b      	ldr	r3, [r3, #8]
            (((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) &&
 800a726:	2b00      	cmp	r3, #0
 800a728:	d12f      	bne.n	800a78a <HAL_RCC_ClockConfig+0xfa>
        {
          MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 800a72a:	4b72      	ldr	r3, [pc, #456]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a72c:	689b      	ldr	r3, [r3, #8]
 800a72e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800a732:	4a70      	ldr	r2, [pc, #448]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a734:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a738:	6093      	str	r3, [r2, #8]
          hpre = RCC_SYSCLK_DIV2;
 800a73a:	2380      	movs	r3, #128	; 0x80
 800a73c:	617b      	str	r3, [r7, #20]
 800a73e:	e024      	b.n	800a78a <HAL_RCC_ClockConfig+0xfa>
      }
    }
    else
    {
      /* HSE is selected as System Clock Source */
      if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800a740:	687b      	ldr	r3, [r7, #4]
 800a742:	685b      	ldr	r3, [r3, #4]
 800a744:	2b02      	cmp	r3, #2
 800a746:	d107      	bne.n	800a758 <HAL_RCC_ClockConfig+0xc8>
      {
        /* Check the HSE ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 800a748:	4b6a      	ldr	r3, [pc, #424]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a74a:	681b      	ldr	r3, [r3, #0]
 800a74c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800a750:	2b00      	cmp	r3, #0
 800a752:	d109      	bne.n	800a768 <HAL_RCC_ClockConfig+0xd8>
        {
          return HAL_ERROR;
 800a754:	2301      	movs	r3, #1
 800a756:	e0c6      	b.n	800a8e6 <HAL_RCC_ClockConfig+0x256>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 800a758:	4b66      	ldr	r3, [pc, #408]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a75a:	681b      	ldr	r3, [r3, #0]
 800a75c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800a760:	2b00      	cmp	r3, #0
 800a762:	d101      	bne.n	800a768 <HAL_RCC_ClockConfig+0xd8>
        {
          return HAL_ERROR;
 800a764:	2301      	movs	r3, #1
 800a766:	e0be      	b.n	800a8e6 <HAL_RCC_ClockConfig+0x256>
        }
      }
      /* Overshoot management when going down from PLL as SYSCLK source and frequency above 80Mhz */
      pllfreq = HAL_RCC_GetSysClockFreq();
 800a768:	f000 f8ce 	bl	800a908 <HAL_RCC_GetSysClockFreq>
 800a76c:	6138      	str	r0, [r7, #16]

      /* Intermediate step with HCLK prescaler 2 necessary before to go under 80Mhz */
      if(pllfreq > 80000000U)
 800a76e:	693b      	ldr	r3, [r7, #16]
 800a770:	4a61      	ldr	r2, [pc, #388]	; (800a8f8 <HAL_RCC_ClockConfig+0x268>)
 800a772:	4293      	cmp	r3, r2
 800a774:	d909      	bls.n	800a78a <HAL_RCC_ClockConfig+0xfa>
      {
        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 800a776:	4b5f      	ldr	r3, [pc, #380]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a778:	689b      	ldr	r3, [r3, #8]
 800a77a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800a77e:	4a5d      	ldr	r2, [pc, #372]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a780:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a784:	6093      	str	r3, [r2, #8]
        hpre = RCC_SYSCLK_DIV2;
 800a786:	2380      	movs	r3, #128	; 0x80
 800a788:	617b      	str	r3, [r7, #20]
      }

    }

    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 800a78a:	4b5a      	ldr	r3, [pc, #360]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a78c:	689b      	ldr	r3, [r3, #8]
 800a78e:	f023 0203 	bic.w	r2, r3, #3
 800a792:	687b      	ldr	r3, [r7, #4]
 800a794:	685b      	ldr	r3, [r3, #4]
 800a796:	4957      	ldr	r1, [pc, #348]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a798:	4313      	orrs	r3, r2
 800a79a:	608b      	str	r3, [r1, #8]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800a79c:	f7fb fada 	bl	8005d54 <HAL_GetTick>
 800a7a0:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800a7a2:	e00a      	b.n	800a7ba <HAL_RCC_ClockConfig+0x12a>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800a7a4:	f7fb fad6 	bl	8005d54 <HAL_GetTick>
 800a7a8:	4602      	mov	r2, r0
 800a7aa:	68fb      	ldr	r3, [r7, #12]
 800a7ac:	1ad3      	subs	r3, r2, r3
 800a7ae:	f241 3288 	movw	r2, #5000	; 0x1388
 800a7b2:	4293      	cmp	r3, r2
 800a7b4:	d901      	bls.n	800a7ba <HAL_RCC_ClockConfig+0x12a>
      {
        return HAL_TIMEOUT;
 800a7b6:	2303      	movs	r3, #3
 800a7b8:	e095      	b.n	800a8e6 <HAL_RCC_ClockConfig+0x256>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800a7ba:	4b4e      	ldr	r3, [pc, #312]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a7bc:	689b      	ldr	r3, [r3, #8]
 800a7be:	f003 020c 	and.w	r2, r3, #12
 800a7c2:	687b      	ldr	r3, [r7, #4]
 800a7c4:	685b      	ldr	r3, [r3, #4]
 800a7c6:	009b      	lsls	r3, r3, #2
 800a7c8:	429a      	cmp	r2, r3
 800a7ca:	d1eb      	bne.n	800a7a4 <HAL_RCC_ClockConfig+0x114>
      }
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800a7cc:	687b      	ldr	r3, [r7, #4]
 800a7ce:	681b      	ldr	r3, [r3, #0]
 800a7d0:	f003 0302 	and.w	r3, r3, #2
 800a7d4:	2b00      	cmp	r3, #0
 800a7d6:	d023      	beq.n	800a820 <HAL_RCC_ClockConfig+0x190>
  {
    /* Set the highest APB divider in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800a7d8:	687b      	ldr	r3, [r7, #4]
 800a7da:	681b      	ldr	r3, [r3, #0]
 800a7dc:	f003 0304 	and.w	r3, r3, #4
 800a7e0:	2b00      	cmp	r3, #0
 800a7e2:	d005      	beq.n	800a7f0 <HAL_RCC_ClockConfig+0x160>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 800a7e4:	4b43      	ldr	r3, [pc, #268]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a7e6:	689b      	ldr	r3, [r3, #8]
 800a7e8:	4a42      	ldr	r2, [pc, #264]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a7ea:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
 800a7ee:	6093      	str	r3, [r2, #8]
    }
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800a7f0:	687b      	ldr	r3, [r7, #4]
 800a7f2:	681b      	ldr	r3, [r3, #0]
 800a7f4:	f003 0308 	and.w	r3, r3, #8
 800a7f8:	2b00      	cmp	r3, #0
 800a7fa:	d007      	beq.n	800a80c <HAL_RCC_ClockConfig+0x17c>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, RCC_HCLK_DIV16);
 800a7fc:	4b3d      	ldr	r3, [pc, #244]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a7fe:	689b      	ldr	r3, [r3, #8]
 800a800:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 800a804:	4a3b      	ldr	r2, [pc, #236]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a806:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
 800a80a:	6093      	str	r3, [r2, #8]
    }

    /* Set the new HCLK clock divider */
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800a80c:	4b39      	ldr	r3, [pc, #228]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a80e:	689b      	ldr	r3, [r3, #8]
 800a810:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 800a814:	687b      	ldr	r3, [r7, #4]
 800a816:	689b      	ldr	r3, [r3, #8]
 800a818:	4936      	ldr	r1, [pc, #216]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a81a:	4313      	orrs	r3, r2
 800a81c:	608b      	str	r3, [r1, #8]
 800a81e:	e008      	b.n	800a832 <HAL_RCC_ClockConfig+0x1a2>
  }
  else
  {
    /* Is intermediate HCLK prescaler 2 applied internally, complete with HCLK prescaler 1 */
    if(hpre == RCC_SYSCLK_DIV2)
 800a820:	697b      	ldr	r3, [r7, #20]
 800a822:	2b80      	cmp	r3, #128	; 0x80
 800a824:	d105      	bne.n	800a832 <HAL_RCC_ClockConfig+0x1a2>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
 800a826:	4b33      	ldr	r3, [pc, #204]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a828:	689b      	ldr	r3, [r3, #8]
 800a82a:	4a32      	ldr	r2, [pc, #200]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a82c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800a830:	6093      	str	r3, [r2, #8]
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 800a832:	4b2f      	ldr	r3, [pc, #188]	; (800a8f0 <HAL_RCC_ClockConfig+0x260>)
 800a834:	681b      	ldr	r3, [r3, #0]
 800a836:	f003 030f 	and.w	r3, r3, #15
 800a83a:	683a      	ldr	r2, [r7, #0]
 800a83c:	429a      	cmp	r2, r3
 800a83e:	d21d      	bcs.n	800a87c <HAL_RCC_ClockConfig+0x1ec>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800a840:	4b2b      	ldr	r3, [pc, #172]	; (800a8f0 <HAL_RCC_ClockConfig+0x260>)
 800a842:	681b      	ldr	r3, [r3, #0]
 800a844:	f023 020f 	bic.w	r2, r3, #15
 800a848:	4929      	ldr	r1, [pc, #164]	; (800a8f0 <HAL_RCC_ClockConfig+0x260>)
 800a84a:	683b      	ldr	r3, [r7, #0]
 800a84c:	4313      	orrs	r3, r2
 800a84e:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by polling the FLASH_ACR register */
    tickstart = HAL_GetTick();
 800a850:	f7fb fa80 	bl	8005d54 <HAL_GetTick>
 800a854:	60f8      	str	r0, [r7, #12]

    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 800a856:	e00a      	b.n	800a86e <HAL_RCC_ClockConfig+0x1de>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800a858:	f7fb fa7c 	bl	8005d54 <HAL_GetTick>
 800a85c:	4602      	mov	r2, r0
 800a85e:	68fb      	ldr	r3, [r7, #12]
 800a860:	1ad3      	subs	r3, r2, r3
 800a862:	f241 3288 	movw	r2, #5000	; 0x1388
 800a866:	4293      	cmp	r3, r2
 800a868:	d901      	bls.n	800a86e <HAL_RCC_ClockConfig+0x1de>
      {
        return HAL_TIMEOUT;
 800a86a:	2303      	movs	r3, #3
 800a86c:	e03b      	b.n	800a8e6 <HAL_RCC_ClockConfig+0x256>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 800a86e:	4b20      	ldr	r3, [pc, #128]	; (800a8f0 <HAL_RCC_ClockConfig+0x260>)
 800a870:	681b      	ldr	r3, [r3, #0]
 800a872:	f003 030f 	and.w	r3, r3, #15
 800a876:	683a      	ldr	r2, [r7, #0]
 800a878:	429a      	cmp	r2, r3
 800a87a:	d1ed      	bne.n	800a858 <HAL_RCC_ClockConfig+0x1c8>
      }
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800a87c:	687b      	ldr	r3, [r7, #4]
 800a87e:	681b      	ldr	r3, [r3, #0]
 800a880:	f003 0304 	and.w	r3, r3, #4
 800a884:	2b00      	cmp	r3, #0
 800a886:	d008      	beq.n	800a89a <HAL_RCC_ClockConfig+0x20a>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800a888:	4b1a      	ldr	r3, [pc, #104]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a88a:	689b      	ldr	r3, [r3, #8]
 800a88c:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 800a890:	687b      	ldr	r3, [r7, #4]
 800a892:	68db      	ldr	r3, [r3, #12]
 800a894:	4917      	ldr	r1, [pc, #92]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a896:	4313      	orrs	r3, r2
 800a898:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800a89a:	687b      	ldr	r3, [r7, #4]
 800a89c:	681b      	ldr	r3, [r3, #0]
 800a89e:	f003 0308 	and.w	r3, r3, #8
 800a8a2:	2b00      	cmp	r3, #0
 800a8a4:	d009      	beq.n	800a8ba <HAL_RCC_ClockConfig+0x22a>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 800a8a6:	4b13      	ldr	r3, [pc, #76]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a8a8:	689b      	ldr	r3, [r3, #8]
 800a8aa:	f423 5260 	bic.w	r2, r3, #14336	; 0x3800
 800a8ae:	687b      	ldr	r3, [r7, #4]
 800a8b0:	691b      	ldr	r3, [r3, #16]
 800a8b2:	00db      	lsls	r3, r3, #3
 800a8b4:	490f      	ldr	r1, [pc, #60]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a8b6:	4313      	orrs	r3, r2
 800a8b8:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 800a8ba:	f000 f825 	bl	800a908 <HAL_RCC_GetSysClockFreq>
 800a8be:	4602      	mov	r2, r0
 800a8c0:	4b0c      	ldr	r3, [pc, #48]	; (800a8f4 <HAL_RCC_ClockConfig+0x264>)
 800a8c2:	689b      	ldr	r3, [r3, #8]
 800a8c4:	091b      	lsrs	r3, r3, #4
 800a8c6:	f003 030f 	and.w	r3, r3, #15
 800a8ca:	490c      	ldr	r1, [pc, #48]	; (800a8fc <HAL_RCC_ClockConfig+0x26c>)
 800a8cc:	5ccb      	ldrb	r3, [r1, r3]
 800a8ce:	f003 031f 	and.w	r3, r3, #31
 800a8d2:	fa22 f303 	lsr.w	r3, r2, r3
 800a8d6:	4a0a      	ldr	r2, [pc, #40]	; (800a900 <HAL_RCC_ClockConfig+0x270>)
 800a8d8:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(uwTickPrio);
 800a8da:	4b0a      	ldr	r3, [pc, #40]	; (800a904 <HAL_RCC_ClockConfig+0x274>)
 800a8dc:	681b      	ldr	r3, [r3, #0]
 800a8de:	4618      	mov	r0, r3
 800a8e0:	f7fb f9ec 	bl	8005cbc <HAL_InitTick>
 800a8e4:	4603      	mov	r3, r0
}
 800a8e6:	4618      	mov	r0, r3
 800a8e8:	3718      	adds	r7, #24
 800a8ea:	46bd      	mov	sp, r7
 800a8ec:	bd80      	pop	{r7, pc}
 800a8ee:	bf00      	nop
 800a8f0:	40022000 	.word	0x40022000
 800a8f4:	40021000 	.word	0x40021000
 800a8f8:	04c4b400 	.word	0x04c4b400
 800a8fc:	080224c8 	.word	0x080224c8
 800a900:	20000008 	.word	0x20000008
 800a904:	2000000c 	.word	0x2000000c

0800a908 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800a908:	b480      	push	{r7}
 800a90a:	b087      	sub	sp, #28
 800a90c:	af00      	add	r7, sp, #0
  uint32_t pllvco, pllsource, pllr, pllm;
  uint32_t sysclockfreq;

  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
 800a90e:	4b2c      	ldr	r3, [pc, #176]	; (800a9c0 <HAL_RCC_GetSysClockFreq+0xb8>)
 800a910:	689b      	ldr	r3, [r3, #8]
 800a912:	f003 030c 	and.w	r3, r3, #12
 800a916:	2b04      	cmp	r3, #4
 800a918:	d102      	bne.n	800a920 <HAL_RCC_GetSysClockFreq+0x18>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 800a91a:	4b2a      	ldr	r3, [pc, #168]	; (800a9c4 <HAL_RCC_GetSysClockFreq+0xbc>)
 800a91c:	613b      	str	r3, [r7, #16]
 800a91e:	e047      	b.n	800a9b0 <HAL_RCC_GetSysClockFreq+0xa8>
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
 800a920:	4b27      	ldr	r3, [pc, #156]	; (800a9c0 <HAL_RCC_GetSysClockFreq+0xb8>)
 800a922:	689b      	ldr	r3, [r3, #8]
 800a924:	f003 030c 	and.w	r3, r3, #12
 800a928:	2b08      	cmp	r3, #8
 800a92a:	d102      	bne.n	800a932 <HAL_RCC_GetSysClockFreq+0x2a>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
 800a92c:	4b26      	ldr	r3, [pc, #152]	; (800a9c8 <HAL_RCC_GetSysClockFreq+0xc0>)
 800a92e:	613b      	str	r3, [r7, #16]
 800a930:	e03e      	b.n	800a9b0 <HAL_RCC_GetSysClockFreq+0xa8>
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 800a932:	4b23      	ldr	r3, [pc, #140]	; (800a9c0 <HAL_RCC_GetSysClockFreq+0xb8>)
 800a934:	689b      	ldr	r3, [r3, #8]
 800a936:	f003 030c 	and.w	r3, r3, #12
 800a93a:	2b0c      	cmp	r3, #12
 800a93c:	d136      	bne.n	800a9ac <HAL_RCC_GetSysClockFreq+0xa4>
    /* PLL used as system clock  source */

    /* PLL_VCO = ((HSE_VALUE or HSI_VALUE)/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 800a93e:	4b20      	ldr	r3, [pc, #128]	; (800a9c0 <HAL_RCC_GetSysClockFreq+0xb8>)
 800a940:	68db      	ldr	r3, [r3, #12]
 800a942:	f003 0303 	and.w	r3, r3, #3
 800a946:	60fb      	str	r3, [r7, #12]
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 800a948:	4b1d      	ldr	r3, [pc, #116]	; (800a9c0 <HAL_RCC_GetSysClockFreq+0xb8>)
 800a94a:	68db      	ldr	r3, [r3, #12]
 800a94c:	091b      	lsrs	r3, r3, #4
 800a94e:	f003 030f 	and.w	r3, r3, #15
 800a952:	3301      	adds	r3, #1
 800a954:	60bb      	str	r3, [r7, #8]

    switch (pllsource)
 800a956:	68fb      	ldr	r3, [r7, #12]
 800a958:	2b03      	cmp	r3, #3
 800a95a:	d10c      	bne.n	800a976 <HAL_RCC_GetSysClockFreq+0x6e>
    {
    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 800a95c:	4a1a      	ldr	r2, [pc, #104]	; (800a9c8 <HAL_RCC_GetSysClockFreq+0xc0>)
 800a95e:	68bb      	ldr	r3, [r7, #8]
 800a960:	fbb2 f3f3 	udiv	r3, r2, r3
 800a964:	4a16      	ldr	r2, [pc, #88]	; (800a9c0 <HAL_RCC_GetSysClockFreq+0xb8>)
 800a966:	68d2      	ldr	r2, [r2, #12]
 800a968:	0a12      	lsrs	r2, r2, #8
 800a96a:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 800a96e:	fb02 f303 	mul.w	r3, r2, r3
 800a972:	617b      	str	r3, [r7, #20]
      break;
 800a974:	e00c      	b.n	800a990 <HAL_RCC_GetSysClockFreq+0x88>

    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
    default:
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 800a976:	4a13      	ldr	r2, [pc, #76]	; (800a9c4 <HAL_RCC_GetSysClockFreq+0xbc>)
 800a978:	68bb      	ldr	r3, [r7, #8]
 800a97a:	fbb2 f3f3 	udiv	r3, r2, r3
 800a97e:	4a10      	ldr	r2, [pc, #64]	; (800a9c0 <HAL_RCC_GetSysClockFreq+0xb8>)
 800a980:	68d2      	ldr	r2, [r2, #12]
 800a982:	0a12      	lsrs	r2, r2, #8
 800a984:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 800a988:	fb02 f303 	mul.w	r3, r2, r3
 800a98c:	617b      	str	r3, [r7, #20]
      break;
 800a98e:	bf00      	nop
    }
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 800a990:	4b0b      	ldr	r3, [pc, #44]	; (800a9c0 <HAL_RCC_GetSysClockFreq+0xb8>)
 800a992:	68db      	ldr	r3, [r3, #12]
 800a994:	0e5b      	lsrs	r3, r3, #25
 800a996:	f003 0303 	and.w	r3, r3, #3
 800a99a:	3301      	adds	r3, #1
 800a99c:	005b      	lsls	r3, r3, #1
 800a99e:	607b      	str	r3, [r7, #4]
    sysclockfreq = pllvco/pllr;
 800a9a0:	697a      	ldr	r2, [r7, #20]
 800a9a2:	687b      	ldr	r3, [r7, #4]
 800a9a4:	fbb2 f3f3 	udiv	r3, r2, r3
 800a9a8:	613b      	str	r3, [r7, #16]
 800a9aa:	e001      	b.n	800a9b0 <HAL_RCC_GetSysClockFreq+0xa8>
  }
  else
  {
    sysclockfreq = 0U;
 800a9ac:	2300      	movs	r3, #0
 800a9ae:	613b      	str	r3, [r7, #16]
  }

  return sysclockfreq;
 800a9b0:	693b      	ldr	r3, [r7, #16]
}
 800a9b2:	4618      	mov	r0, r3
 800a9b4:	371c      	adds	r7, #28
 800a9b6:	46bd      	mov	sp, r7
 800a9b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a9bc:	4770      	bx	lr
 800a9be:	bf00      	nop
 800a9c0:	40021000 	.word	0x40021000
 800a9c4:	00f42400 	.word	0x00f42400
 800a9c8:	016e3600 	.word	0x016e3600

0800a9cc <HAL_RCC_GetHCLKFreq>:
  *
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800a9cc:	b480      	push	{r7}
 800a9ce:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 800a9d0:	4b03      	ldr	r3, [pc, #12]	; (800a9e0 <HAL_RCC_GetHCLKFreq+0x14>)
 800a9d2:	681b      	ldr	r3, [r3, #0]
}
 800a9d4:	4618      	mov	r0, r3
 800a9d6:	46bd      	mov	sp, r7
 800a9d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a9dc:	4770      	bx	lr
 800a9de:	bf00      	nop
 800a9e0:	20000008 	.word	0x20000008

0800a9e4 <RCC_GetSysClockFreqFromPLLSource>:
/**
  * @brief  Compute SYSCLK frequency based on PLL SYSCLK source.
  * @retval SYSCLK frequency
  */
static uint32_t RCC_GetSysClockFreqFromPLLSource(void)
{
 800a9e4:	b480      	push	{r7}
 800a9e6:	b087      	sub	sp, #28
 800a9e8:	af00      	add	r7, sp, #0
  uint32_t sysclockfreq;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE/ PLLM) * PLLN
     SYSCLK = PLL_VCO / PLLR
   */
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 800a9ea:	4b1e      	ldr	r3, [pc, #120]	; (800aa64 <RCC_GetSysClockFreqFromPLLSource+0x80>)
 800a9ec:	68db      	ldr	r3, [r3, #12]
 800a9ee:	f003 0303 	and.w	r3, r3, #3
 800a9f2:	613b      	str	r3, [r7, #16]
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 800a9f4:	4b1b      	ldr	r3, [pc, #108]	; (800aa64 <RCC_GetSysClockFreqFromPLLSource+0x80>)
 800a9f6:	68db      	ldr	r3, [r3, #12]
 800a9f8:	091b      	lsrs	r3, r3, #4
 800a9fa:	f003 030f 	and.w	r3, r3, #15
 800a9fe:	3301      	adds	r3, #1
 800aa00:	60fb      	str	r3, [r7, #12]

  switch (pllsource)
 800aa02:	693b      	ldr	r3, [r7, #16]
 800aa04:	2b03      	cmp	r3, #3
 800aa06:	d10c      	bne.n	800aa22 <RCC_GetSysClockFreqFromPLLSource+0x3e>
  {
  case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
    pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 800aa08:	4a17      	ldr	r2, [pc, #92]	; (800aa68 <RCC_GetSysClockFreqFromPLLSource+0x84>)
 800aa0a:	68fb      	ldr	r3, [r7, #12]
 800aa0c:	fbb2 f3f3 	udiv	r3, r2, r3
 800aa10:	4a14      	ldr	r2, [pc, #80]	; (800aa64 <RCC_GetSysClockFreqFromPLLSource+0x80>)
 800aa12:	68d2      	ldr	r2, [r2, #12]
 800aa14:	0a12      	lsrs	r2, r2, #8
 800aa16:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 800aa1a:	fb02 f303 	mul.w	r3, r2, r3
 800aa1e:	617b      	str	r3, [r7, #20]
    break;
 800aa20:	e00c      	b.n	800aa3c <RCC_GetSysClockFreqFromPLLSource+0x58>

  case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
  default:
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 800aa22:	4a12      	ldr	r2, [pc, #72]	; (800aa6c <RCC_GetSysClockFreqFromPLLSource+0x88>)
 800aa24:	68fb      	ldr	r3, [r7, #12]
 800aa26:	fbb2 f3f3 	udiv	r3, r2, r3
 800aa2a:	4a0e      	ldr	r2, [pc, #56]	; (800aa64 <RCC_GetSysClockFreqFromPLLSource+0x80>)
 800aa2c:	68d2      	ldr	r2, [r2, #12]
 800aa2e:	0a12      	lsrs	r2, r2, #8
 800aa30:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 800aa34:	fb02 f303 	mul.w	r3, r2, r3
 800aa38:	617b      	str	r3, [r7, #20]
    break;
 800aa3a:	bf00      	nop
  }

  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 800aa3c:	4b09      	ldr	r3, [pc, #36]	; (800aa64 <RCC_GetSysClockFreqFromPLLSource+0x80>)
 800aa3e:	68db      	ldr	r3, [r3, #12]
 800aa40:	0e5b      	lsrs	r3, r3, #25
 800aa42:	f003 0303 	and.w	r3, r3, #3
 800aa46:	3301      	adds	r3, #1
 800aa48:	005b      	lsls	r3, r3, #1
 800aa4a:	60bb      	str	r3, [r7, #8]
  sysclockfreq = pllvco/pllr;
 800aa4c:	697a      	ldr	r2, [r7, #20]
 800aa4e:	68bb      	ldr	r3, [r7, #8]
 800aa50:	fbb2 f3f3 	udiv	r3, r2, r3
 800aa54:	607b      	str	r3, [r7, #4]

  return sysclockfreq;
 800aa56:	687b      	ldr	r3, [r7, #4]
}
 800aa58:	4618      	mov	r0, r3
 800aa5a:	371c      	adds	r7, #28
 800aa5c:	46bd      	mov	sp, r7
 800aa5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aa62:	4770      	bx	lr
 800aa64:	40021000 	.word	0x40021000
 800aa68:	016e3600 	.word	0x016e3600
 800aa6c:	00f42400 	.word	0x00f42400

0800aa70 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 800aa70:	b580      	push	{r7, lr}
 800aa72:	b086      	sub	sp, #24
 800aa74:	af00      	add	r7, sp, #0
 800aa76:	6078      	str	r0, [r7, #4]
  uint32_t tmpregister;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 800aa78:	2300      	movs	r3, #0
 800aa7a:	74fb      	strb	r3, [r7, #19]
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 800aa7c:	2300      	movs	r3, #0
 800aa7e:	74bb      	strb	r3, [r7, #18]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 800aa80:	687b      	ldr	r3, [r7, #4]
 800aa82:	681b      	ldr	r3, [r3, #0]
 800aa84:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800aa88:	2b00      	cmp	r3, #0
 800aa8a:	f000 8098 	beq.w	800abbe <HAL_RCCEx_PeriphCLKConfig+0x14e>
  {
    FlagStatus       pwrclkchanged = RESET;
 800aa8e:	2300      	movs	r3, #0
 800aa90:	747b      	strb	r3, [r7, #17]
    
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800aa92:	4b43      	ldr	r3, [pc, #268]	; (800aba0 <HAL_RCCEx_PeriphCLKConfig+0x130>)
 800aa94:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800aa96:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800aa9a:	2b00      	cmp	r3, #0
 800aa9c:	d10d      	bne.n	800aaba <HAL_RCCEx_PeriphCLKConfig+0x4a>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800aa9e:	4b40      	ldr	r3, [pc, #256]	; (800aba0 <HAL_RCCEx_PeriphCLKConfig+0x130>)
 800aaa0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800aaa2:	4a3f      	ldr	r2, [pc, #252]	; (800aba0 <HAL_RCCEx_PeriphCLKConfig+0x130>)
 800aaa4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800aaa8:	6593      	str	r3, [r2, #88]	; 0x58
 800aaaa:	4b3d      	ldr	r3, [pc, #244]	; (800aba0 <HAL_RCCEx_PeriphCLKConfig+0x130>)
 800aaac:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800aaae:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800aab2:	60bb      	str	r3, [r7, #8]
 800aab4:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 800aab6:	2301      	movs	r3, #1
 800aab8:	747b      	strb	r3, [r7, #17]
    }
      
    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 800aaba:	4b3a      	ldr	r3, [pc, #232]	; (800aba4 <HAL_RCCEx_PeriphCLKConfig+0x134>)
 800aabc:	681b      	ldr	r3, [r3, #0]
 800aabe:	4a39      	ldr	r2, [pc, #228]	; (800aba4 <HAL_RCCEx_PeriphCLKConfig+0x134>)
 800aac0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800aac4:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 800aac6:	f7fb f945 	bl	8005d54 <HAL_GetTick>
 800aaca:	60f8      	str	r0, [r7, #12]

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800aacc:	e009      	b.n	800aae2 <HAL_RCCEx_PeriphCLKConfig+0x72>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800aace:	f7fb f941 	bl	8005d54 <HAL_GetTick>
 800aad2:	4602      	mov	r2, r0
 800aad4:	68fb      	ldr	r3, [r7, #12]
 800aad6:	1ad3      	subs	r3, r2, r3
 800aad8:	2b02      	cmp	r3, #2
 800aada:	d902      	bls.n	800aae2 <HAL_RCCEx_PeriphCLKConfig+0x72>
      {
        ret = HAL_TIMEOUT;
 800aadc:	2303      	movs	r3, #3
 800aade:	74fb      	strb	r3, [r7, #19]
        break;
 800aae0:	e005      	b.n	800aaee <HAL_RCCEx_PeriphCLKConfig+0x7e>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800aae2:	4b30      	ldr	r3, [pc, #192]	; (800aba4 <HAL_RCCEx_PeriphCLKConfig+0x134>)
 800aae4:	681b      	ldr	r3, [r3, #0]
 800aae6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800aaea:	2b00      	cmp	r3, #0
 800aaec:	d0ef      	beq.n	800aace <HAL_RCCEx_PeriphCLKConfig+0x5e>
      }
    }

    if(ret == HAL_OK)
 800aaee:	7cfb      	ldrb	r3, [r7, #19]
 800aaf0:	2b00      	cmp	r3, #0
 800aaf2:	d159      	bne.n	800aba8 <HAL_RCCEx_PeriphCLKConfig+0x138>
    { 
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 800aaf4:	4b2a      	ldr	r3, [pc, #168]	; (800aba0 <HAL_RCCEx_PeriphCLKConfig+0x130>)
 800aaf6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800aafa:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800aafe:	617b      	str	r3, [r7, #20]
      
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 800ab00:	697b      	ldr	r3, [r7, #20]
 800ab02:	2b00      	cmp	r3, #0
 800ab04:	d01e      	beq.n	800ab44 <HAL_RCCEx_PeriphCLKConfig+0xd4>
 800ab06:	687b      	ldr	r3, [r7, #4]
 800ab08:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800ab0a:	697a      	ldr	r2, [r7, #20]
 800ab0c:	429a      	cmp	r2, r3
 800ab0e:	d019      	beq.n	800ab44 <HAL_RCCEx_PeriphCLKConfig+0xd4>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 800ab10:	4b23      	ldr	r3, [pc, #140]	; (800aba0 <HAL_RCCEx_PeriphCLKConfig+0x130>)
 800ab12:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800ab16:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800ab1a:	617b      	str	r3, [r7, #20]
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 800ab1c:	4b20      	ldr	r3, [pc, #128]	; (800aba0 <HAL_RCCEx_PeriphCLKConfig+0x130>)
 800ab1e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800ab22:	4a1f      	ldr	r2, [pc, #124]	; (800aba0 <HAL_RCCEx_PeriphCLKConfig+0x130>)
 800ab24:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800ab28:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 800ab2c:	4b1c      	ldr	r3, [pc, #112]	; (800aba0 <HAL_RCCEx_PeriphCLKConfig+0x130>)
 800ab2e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800ab32:	4a1b      	ldr	r2, [pc, #108]	; (800aba0 <HAL_RCCEx_PeriphCLKConfig+0x130>)
 800ab34:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800ab38:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
 800ab3c:	4a18      	ldr	r2, [pc, #96]	; (800aba0 <HAL_RCCEx_PeriphCLKConfig+0x130>)
 800ab3e:	697b      	ldr	r3, [r7, #20]
 800ab40:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 800ab44:	697b      	ldr	r3, [r7, #20]
 800ab46:	f003 0301 	and.w	r3, r3, #1
 800ab4a:	2b00      	cmp	r3, #0
 800ab4c:	d016      	beq.n	800ab7c <HAL_RCCEx_PeriphCLKConfig+0x10c>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800ab4e:	f7fb f901 	bl	8005d54 <HAL_GetTick>
 800ab52:	60f8      	str	r0, [r7, #12]

        /* Wait till LSE is ready */
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 800ab54:	e00b      	b.n	800ab6e <HAL_RCCEx_PeriphCLKConfig+0xfe>
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800ab56:	f7fb f8fd 	bl	8005d54 <HAL_GetTick>
 800ab5a:	4602      	mov	r2, r0
 800ab5c:	68fb      	ldr	r3, [r7, #12]
 800ab5e:	1ad3      	subs	r3, r2, r3
 800ab60:	f241 3288 	movw	r2, #5000	; 0x1388
 800ab64:	4293      	cmp	r3, r2
 800ab66:	d902      	bls.n	800ab6e <HAL_RCCEx_PeriphCLKConfig+0xfe>
          {
            ret = HAL_TIMEOUT;
 800ab68:	2303      	movs	r3, #3
 800ab6a:	74fb      	strb	r3, [r7, #19]
            break;
 800ab6c:	e006      	b.n	800ab7c <HAL_RCCEx_PeriphCLKConfig+0x10c>
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 800ab6e:	4b0c      	ldr	r3, [pc, #48]	; (800aba0 <HAL_RCCEx_PeriphCLKConfig+0x130>)
 800ab70:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800ab74:	f003 0302 	and.w	r3, r3, #2
 800ab78:	2b00      	cmp	r3, #0
 800ab7a:	d0ec      	beq.n	800ab56 <HAL_RCCEx_PeriphCLKConfig+0xe6>
          }
        }
      }
      
      if(ret == HAL_OK)
 800ab7c:	7cfb      	ldrb	r3, [r7, #19]
 800ab7e:	2b00      	cmp	r3, #0
 800ab80:	d10b      	bne.n	800ab9a <HAL_RCCEx_PeriphCLKConfig+0x12a>
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800ab82:	4b07      	ldr	r3, [pc, #28]	; (800aba0 <HAL_RCCEx_PeriphCLKConfig+0x130>)
 800ab84:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800ab88:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 800ab8c:	687b      	ldr	r3, [r7, #4]
 800ab8e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800ab90:	4903      	ldr	r1, [pc, #12]	; (800aba0 <HAL_RCCEx_PeriphCLKConfig+0x130>)
 800ab92:	4313      	orrs	r3, r2
 800ab94:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
 800ab98:	e008      	b.n	800abac <HAL_RCCEx_PeriphCLKConfig+0x13c>
      }
      else
      {
        /* set overall return value */
        status = ret;
 800ab9a:	7cfb      	ldrb	r3, [r7, #19]
 800ab9c:	74bb      	strb	r3, [r7, #18]
 800ab9e:	e005      	b.n	800abac <HAL_RCCEx_PeriphCLKConfig+0x13c>
 800aba0:	40021000 	.word	0x40021000
 800aba4:	40007000 	.word	0x40007000
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
 800aba8:	7cfb      	ldrb	r3, [r7, #19]
 800abaa:	74bb      	strb	r3, [r7, #18]
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 800abac:	7c7b      	ldrb	r3, [r7, #17]
 800abae:	2b01      	cmp	r3, #1
 800abb0:	d105      	bne.n	800abbe <HAL_RCCEx_PeriphCLKConfig+0x14e>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800abb2:	4ba7      	ldr	r3, [pc, #668]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800abb4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800abb6:	4aa6      	ldr	r2, [pc, #664]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800abb8:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800abbc:	6593      	str	r3, [r2, #88]	; 0x58
    }
  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 800abbe:	687b      	ldr	r3, [r7, #4]
 800abc0:	681b      	ldr	r3, [r3, #0]
 800abc2:	f003 0301 	and.w	r3, r3, #1
 800abc6:	2b00      	cmp	r3, #0
 800abc8:	d00a      	beq.n	800abe0 <HAL_RCCEx_PeriphCLKConfig+0x170>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 800abca:	4ba1      	ldr	r3, [pc, #644]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800abcc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800abd0:	f023 0203 	bic.w	r2, r3, #3
 800abd4:	687b      	ldr	r3, [r7, #4]
 800abd6:	685b      	ldr	r3, [r3, #4]
 800abd8:	499d      	ldr	r1, [pc, #628]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800abda:	4313      	orrs	r3, r2
 800abdc:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- USART2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 800abe0:	687b      	ldr	r3, [r7, #4]
 800abe2:	681b      	ldr	r3, [r3, #0]
 800abe4:	f003 0302 	and.w	r3, r3, #2
 800abe8:	2b00      	cmp	r3, #0
 800abea:	d00a      	beq.n	800ac02 <HAL_RCCEx_PeriphCLKConfig+0x192>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 800abec:	4b98      	ldr	r3, [pc, #608]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800abee:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800abf2:	f023 020c 	bic.w	r2, r3, #12
 800abf6:	687b      	ldr	r3, [r7, #4]
 800abf8:	689b      	ldr	r3, [r3, #8]
 800abfa:	4995      	ldr	r1, [pc, #596]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800abfc:	4313      	orrs	r3, r2
 800abfe:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- USART3 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 800ac02:	687b      	ldr	r3, [r7, #4]
 800ac04:	681b      	ldr	r3, [r3, #0]
 800ac06:	f003 0304 	and.w	r3, r3, #4
 800ac0a:	2b00      	cmp	r3, #0
 800ac0c:	d00a      	beq.n	800ac24 <HAL_RCCEx_PeriphCLKConfig+0x1b4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 800ac0e:	4b90      	ldr	r3, [pc, #576]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ac10:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800ac14:	f023 0230 	bic.w	r2, r3, #48	; 0x30
 800ac18:	687b      	ldr	r3, [r7, #4]
 800ac1a:	68db      	ldr	r3, [r3, #12]
 800ac1c:	498c      	ldr	r1, [pc, #560]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ac1e:	4313      	orrs	r3, r2
 800ac20:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

#if defined(UART4)
  /*-------------------------- UART4 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 800ac24:	687b      	ldr	r3, [r7, #4]
 800ac26:	681b      	ldr	r3, [r3, #0]
 800ac28:	f003 0308 	and.w	r3, r3, #8
 800ac2c:	2b00      	cmp	r3, #0
 800ac2e:	d00a      	beq.n	800ac46 <HAL_RCCEx_PeriphCLKConfig+0x1d6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 800ac30:	4b87      	ldr	r3, [pc, #540]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ac32:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800ac36:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
 800ac3a:	687b      	ldr	r3, [r7, #4]
 800ac3c:	691b      	ldr	r3, [r3, #16]
 800ac3e:	4984      	ldr	r1, [pc, #528]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ac40:	4313      	orrs	r3, r2
 800ac42:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
#endif /* UART4 */

#if defined(UART5)

  /*-------------------------- UART5 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 800ac46:	687b      	ldr	r3, [r7, #4]
 800ac48:	681b      	ldr	r3, [r3, #0]
 800ac4a:	f003 0310 	and.w	r3, r3, #16
 800ac4e:	2b00      	cmp	r3, #0
 800ac50:	d00a      	beq.n	800ac68 <HAL_RCCEx_PeriphCLKConfig+0x1f8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 800ac52:	4b7f      	ldr	r3, [pc, #508]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ac54:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800ac58:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 800ac5c:	687b      	ldr	r3, [r7, #4]
 800ac5e:	695b      	ldr	r3, [r3, #20]
 800ac60:	497b      	ldr	r1, [pc, #492]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ac62:	4313      	orrs	r3, r2
 800ac64:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

#endif /* UART5 */

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 800ac68:	687b      	ldr	r3, [r7, #4]
 800ac6a:	681b      	ldr	r3, [r3, #0]
 800ac6c:	f003 0320 	and.w	r3, r3, #32
 800ac70:	2b00      	cmp	r3, #0
 800ac72:	d00a      	beq.n	800ac8a <HAL_RCCEx_PeriphCLKConfig+0x21a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 800ac74:	4b76      	ldr	r3, [pc, #472]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ac76:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800ac7a:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
 800ac7e:	687b      	ldr	r3, [r7, #4]
 800ac80:	699b      	ldr	r3, [r3, #24]
 800ac82:	4973      	ldr	r1, [pc, #460]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ac84:	4313      	orrs	r3, r2
 800ac86:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800ac8a:	687b      	ldr	r3, [r7, #4]
 800ac8c:	681b      	ldr	r3, [r3, #0]
 800ac8e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ac92:	2b00      	cmp	r3, #0
 800ac94:	d00a      	beq.n	800acac <HAL_RCCEx_PeriphCLKConfig+0x23c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 800ac96:	4b6e      	ldr	r3, [pc, #440]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ac98:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800ac9c:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
 800aca0:	687b      	ldr	r3, [r7, #4]
 800aca2:	69db      	ldr	r3, [r3, #28]
 800aca4:	496a      	ldr	r1, [pc, #424]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800aca6:	4313      	orrs	r3, r2
 800aca8:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- I2C2 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 800acac:	687b      	ldr	r3, [r7, #4]
 800acae:	681b      	ldr	r3, [r3, #0]
 800acb0:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800acb4:	2b00      	cmp	r3, #0
 800acb6:	d00a      	beq.n	800acce <HAL_RCCEx_PeriphCLKConfig+0x25e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 800acb8:	4b65      	ldr	r3, [pc, #404]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800acba:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800acbe:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
 800acc2:	687b      	ldr	r3, [r7, #4]
 800acc4:	6a1b      	ldr	r3, [r3, #32]
 800acc6:	4962      	ldr	r1, [pc, #392]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800acc8:	4313      	orrs	r3, r2
 800acca:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 800acce:	687b      	ldr	r3, [r7, #4]
 800acd0:	681b      	ldr	r3, [r3, #0]
 800acd2:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800acd6:	2b00      	cmp	r3, #0
 800acd8:	d00a      	beq.n	800acf0 <HAL_RCCEx_PeriphCLKConfig+0x280>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 800acda:	4b5d      	ldr	r3, [pc, #372]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800acdc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800ace0:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 800ace4:	687b      	ldr	r3, [r7, #4]
 800ace6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ace8:	4959      	ldr	r1, [pc, #356]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800acea:	4313      	orrs	r3, r2
 800acec:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

#if defined(I2C4)  

  /*-------------------------- I2C4 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 800acf0:	687b      	ldr	r3, [r7, #4]
 800acf2:	681b      	ldr	r3, [r3, #0]
 800acf4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800acf8:	2b00      	cmp	r3, #0
 800acfa:	d00a      	beq.n	800ad12 <HAL_RCCEx_PeriphCLKConfig+0x2a2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 800acfc:	4b54      	ldr	r3, [pc, #336]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800acfe:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800ad02:	f023 0203 	bic.w	r2, r3, #3
 800ad06:	687b      	ldr	r3, [r7, #4]
 800ad08:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ad0a:	4951      	ldr	r1, [pc, #324]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ad0c:	4313      	orrs	r3, r2
 800ad0e:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
  }

#endif /* I2C4 */

  /*-------------------------- LPTIM1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 800ad12:	687b      	ldr	r3, [r7, #4]
 800ad14:	681b      	ldr	r3, [r3, #0]
 800ad16:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800ad1a:	2b00      	cmp	r3, #0
 800ad1c:	d00a      	beq.n	800ad34 <HAL_RCCEx_PeriphCLKConfig+0x2c4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 800ad1e:	4b4c      	ldr	r3, [pc, #304]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ad20:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800ad24:	f423 2240 	bic.w	r2, r3, #786432	; 0xc0000
 800ad28:	687b      	ldr	r3, [r7, #4]
 800ad2a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ad2c:	4948      	ldr	r1, [pc, #288]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ad2e:	4313      	orrs	r3, r2
 800ad30:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 800ad34:	687b      	ldr	r3, [r7, #4]
 800ad36:	681b      	ldr	r3, [r3, #0]
 800ad38:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800ad3c:	2b00      	cmp	r3, #0
 800ad3e:	d015      	beq.n	800ad6c <HAL_RCCEx_PeriphCLKConfig+0x2fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure the SAI1 interface clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 800ad40:	4b43      	ldr	r3, [pc, #268]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ad42:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800ad46:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 800ad4a:	687b      	ldr	r3, [r7, #4]
 800ad4c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ad4e:	4940      	ldr	r1, [pc, #256]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ad50:	4313      	orrs	r3, r2
 800ad52:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLL)
 800ad56:	687b      	ldr	r3, [r7, #4]
 800ad58:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ad5a:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800ad5e:	d105      	bne.n	800ad6c <HAL_RCCEx_PeriphCLKConfig+0x2fc>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800ad60:	4b3b      	ldr	r3, [pc, #236]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ad62:	68db      	ldr	r3, [r3, #12]
 800ad64:	4a3a      	ldr	r2, [pc, #232]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ad66:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800ad6a:	60d3      	str	r3, [r2, #12]
    }
  }

  /*-------------------------- I2S clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S)
 800ad6c:	687b      	ldr	r3, [r7, #4]
 800ad6e:	681b      	ldr	r3, [r3, #0]
 800ad70:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800ad74:	2b00      	cmp	r3, #0
 800ad76:	d015      	beq.n	800ada4 <HAL_RCCEx_PeriphCLKConfig+0x334>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure the I2S interface clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 800ad78:	4b35      	ldr	r3, [pc, #212]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ad7a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800ad7e:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 800ad82:	687b      	ldr	r3, [r7, #4]
 800ad84:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ad86:	4932      	ldr	r1, [pc, #200]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ad88:	4313      	orrs	r3, r2
 800ad8a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLL)
 800ad8e:	687b      	ldr	r3, [r7, #4]
 800ad90:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ad92:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800ad96:	d105      	bne.n	800ada4 <HAL_RCCEx_PeriphCLKConfig+0x334>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800ad98:	4b2d      	ldr	r3, [pc, #180]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ad9a:	68db      	ldr	r3, [r3, #12]
 800ad9c:	4a2c      	ldr	r2, [pc, #176]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ad9e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800ada2:	60d3      	str	r3, [r2, #12]
    }
  }

#if defined(FDCAN1)
  /*-------------------------- FDCAN clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 800ada4:	687b      	ldr	r3, [r7, #4]
 800ada6:	681b      	ldr	r3, [r3, #0]
 800ada8:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 800adac:	2b00      	cmp	r3, #0
 800adae:	d015      	beq.n	800addc <HAL_RCCEx_PeriphCLKConfig+0x36c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));

    /* Configure the FDCAN interface clock source */
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 800adb0:	4b27      	ldr	r3, [pc, #156]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800adb2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800adb6:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
 800adba:	687b      	ldr	r3, [r7, #4]
 800adbc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800adbe:	4924      	ldr	r1, [pc, #144]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800adc0:	4313      	orrs	r3, r2
 800adc2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    
    if(PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_PLL)
 800adc6:	687b      	ldr	r3, [r7, #4]
 800adc8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800adca:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 800adce:	d105      	bne.n	800addc <HAL_RCCEx_PeriphCLKConfig+0x36c>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800add0:	4b1f      	ldr	r3, [pc, #124]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800add2:	68db      	ldr	r3, [r3, #12]
 800add4:	4a1e      	ldr	r2, [pc, #120]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800add6:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800adda:	60d3      	str	r3, [r2, #12]
#endif /* FDCAN1 */

#if defined(USB)

  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 800addc:	687b      	ldr	r3, [r7, #4]
 800adde:	681b      	ldr	r3, [r3, #0]
 800ade0:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 800ade4:	2b00      	cmp	r3, #0
 800ade6:	d015      	beq.n	800ae14 <HAL_RCCEx_PeriphCLKConfig+0x3a4>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800ade8:	4b19      	ldr	r3, [pc, #100]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800adea:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800adee:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
 800adf2:	687b      	ldr	r3, [r7, #4]
 800adf4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800adf6:	4916      	ldr	r1, [pc, #88]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800adf8:	4313      	orrs	r3, r2
 800adfa:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 800adfe:	687b      	ldr	r3, [r7, #4]
 800ae00:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ae02:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800ae06:	d105      	bne.n	800ae14 <HAL_RCCEx_PeriphCLKConfig+0x3a4>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800ae08:	4b11      	ldr	r3, [pc, #68]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ae0a:	68db      	ldr	r3, [r3, #12]
 800ae0c:	4a10      	ldr	r2, [pc, #64]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ae0e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800ae12:	60d3      	str	r3, [r2, #12]
  }

#endif /* USB */

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 800ae14:	687b      	ldr	r3, [r7, #4]
 800ae16:	681b      	ldr	r3, [r3, #0]
 800ae18:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800ae1c:	2b00      	cmp	r3, #0
 800ae1e:	d019      	beq.n	800ae54 <HAL_RCCEx_PeriphCLKConfig+0x3e4>
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 800ae20:	4b0b      	ldr	r3, [pc, #44]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ae22:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800ae26:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
 800ae2a:	687b      	ldr	r3, [r7, #4]
 800ae2c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ae2e:	4908      	ldr	r1, [pc, #32]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ae30:	4313      	orrs	r3, r2
 800ae32:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 800ae36:	687b      	ldr	r3, [r7, #4]
 800ae38:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ae3a:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800ae3e:	d109      	bne.n	800ae54 <HAL_RCCEx_PeriphCLKConfig+0x3e4>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800ae40:	4b03      	ldr	r3, [pc, #12]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ae42:	68db      	ldr	r3, [r3, #12]
 800ae44:	4a02      	ldr	r2, [pc, #8]	; (800ae50 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ae46:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800ae4a:	60d3      	str	r3, [r2, #12]
 800ae4c:	e002      	b.n	800ae54 <HAL_RCCEx_PeriphCLKConfig+0x3e4>
 800ae4e:	bf00      	nop
 800ae50:	40021000 	.word	0x40021000
    }
  }

  /*-------------------------- ADC12 clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC12) == RCC_PERIPHCLK_ADC12)
 800ae54:	687b      	ldr	r3, [r7, #4]
 800ae56:	681b      	ldr	r3, [r3, #0]
 800ae58:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800ae5c:	2b00      	cmp	r3, #0
 800ae5e:	d015      	beq.n	800ae8c <HAL_RCCEx_PeriphCLKConfig+0x41c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADC12CLKSOURCE(PeriphClkInit->Adc12ClockSelection));

    /* Configure the ADC12 interface clock source */
    __HAL_RCC_ADC12_CONFIG(PeriphClkInit->Adc12ClockSelection);
 800ae60:	4b29      	ldr	r3, [pc, #164]	; (800af08 <HAL_RCCEx_PeriphCLKConfig+0x498>)
 800ae62:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800ae66:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
 800ae6a:	687b      	ldr	r3, [r7, #4]
 800ae6c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ae6e:	4926      	ldr	r1, [pc, #152]	; (800af08 <HAL_RCCEx_PeriphCLKConfig+0x498>)
 800ae70:	4313      	orrs	r3, r2
 800ae72:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    
    if(PeriphClkInit->Adc12ClockSelection == RCC_ADC12CLKSOURCE_PLL)
 800ae76:	687b      	ldr	r3, [r7, #4]
 800ae78:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ae7a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 800ae7e:	d105      	bne.n	800ae8c <HAL_RCCEx_PeriphCLKConfig+0x41c>
    {
      /* Enable PLLADCCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 800ae80:	4b21      	ldr	r3, [pc, #132]	; (800af08 <HAL_RCCEx_PeriphCLKConfig+0x498>)
 800ae82:	68db      	ldr	r3, [r3, #12]
 800ae84:	4a20      	ldr	r2, [pc, #128]	; (800af08 <HAL_RCCEx_PeriphCLKConfig+0x498>)
 800ae86:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800ae8a:	60d3      	str	r3, [r2, #12]
    }
  }
  
#if defined(ADC345_COMMON)
  /*-------------------------- ADC345 clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC345) == RCC_PERIPHCLK_ADC345)
 800ae8c:	687b      	ldr	r3, [r7, #4]
 800ae8e:	681b      	ldr	r3, [r3, #0]
 800ae90:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800ae94:	2b00      	cmp	r3, #0
 800ae96:	d015      	beq.n	800aec4 <HAL_RCCEx_PeriphCLKConfig+0x454>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADC345CLKSOURCE(PeriphClkInit->Adc345ClockSelection));

    /* Configure the ADC345 interface clock source */
    __HAL_RCC_ADC345_CONFIG(PeriphClkInit->Adc345ClockSelection);
 800ae98:	4b1b      	ldr	r3, [pc, #108]	; (800af08 <HAL_RCCEx_PeriphCLKConfig+0x498>)
 800ae9a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800ae9e:	f023 4240 	bic.w	r2, r3, #3221225472	; 0xc0000000
 800aea2:	687b      	ldr	r3, [r7, #4]
 800aea4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800aea6:	4918      	ldr	r1, [pc, #96]	; (800af08 <HAL_RCCEx_PeriphCLKConfig+0x498>)
 800aea8:	4313      	orrs	r3, r2
 800aeaa:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    
    if(PeriphClkInit->Adc345ClockSelection == RCC_ADC345CLKSOURCE_PLL)
 800aeae:	687b      	ldr	r3, [r7, #4]
 800aeb0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800aeb2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800aeb6:	d105      	bne.n	800aec4 <HAL_RCCEx_PeriphCLKConfig+0x454>
    {
      /* Enable PLLADCCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 800aeb8:	4b13      	ldr	r3, [pc, #76]	; (800af08 <HAL_RCCEx_PeriphCLKConfig+0x498>)
 800aeba:	68db      	ldr	r3, [r3, #12]
 800aebc:	4a12      	ldr	r2, [pc, #72]	; (800af08 <HAL_RCCEx_PeriphCLKConfig+0x498>)
 800aebe:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800aec2:	60d3      	str	r3, [r2, #12]
#endif /* ADC345_COMMON */

#if defined(QUADSPI)

  /*-------------------------- QuadSPIx clock source configuration ----------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
 800aec4:	687b      	ldr	r3, [r7, #4]
 800aec6:	681b      	ldr	r3, [r3, #0]
 800aec8:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800aecc:	2b00      	cmp	r3, #0
 800aece:	d015      	beq.n	800aefc <HAL_RCCEx_PeriphCLKConfig+0x48c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_QSPICLKSOURCE(PeriphClkInit->QspiClockSelection));

    /* Configure the QuadSPI clock source */
    __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
 800aed0:	4b0d      	ldr	r3, [pc, #52]	; (800af08 <HAL_RCCEx_PeriphCLKConfig+0x498>)
 800aed2:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800aed6:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 800aeda:	687b      	ldr	r3, [r7, #4]
 800aedc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800aede:	490a      	ldr	r1, [pc, #40]	; (800af08 <HAL_RCCEx_PeriphCLKConfig+0x498>)
 800aee0:	4313      	orrs	r3, r2
 800aee2:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c

    if(PeriphClkInit->QspiClockSelection == RCC_QSPICLKSOURCE_PLL)
 800aee6:	687b      	ldr	r3, [r7, #4]
 800aee8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800aeea:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 800aeee:	d105      	bne.n	800aefc <HAL_RCCEx_PeriphCLKConfig+0x48c>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800aef0:	4b05      	ldr	r3, [pc, #20]	; (800af08 <HAL_RCCEx_PeriphCLKConfig+0x498>)
 800aef2:	68db      	ldr	r3, [r3, #12]
 800aef4:	4a04      	ldr	r2, [pc, #16]	; (800af08 <HAL_RCCEx_PeriphCLKConfig+0x498>)
 800aef6:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800aefa:	60d3      	str	r3, [r2, #12]
    }
  }

#endif /* QUADSPI */

  return status;
 800aefc:	7cbb      	ldrb	r3, [r7, #18]
}
 800aefe:	4618      	mov	r0, r3
 800af00:	3718      	adds	r7, #24
 800af02:	46bd      	mov	sp, r7
 800af04:	bd80      	pop	{r7, pc}
 800af06:	bf00      	nop
 800af08:	40021000 	.word	0x40021000

0800af0c <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 800af0c:	b580      	push	{r7, lr}
 800af0e:	b084      	sub	sp, #16
 800af10:	af00      	add	r7, sp, #0
 800af12:	6078      	str	r0, [r7, #4]
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 800af14:	687b      	ldr	r3, [r7, #4]
 800af16:	2b00      	cmp	r3, #0
 800af18:	d101      	bne.n	800af1e <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 800af1a:	2301      	movs	r3, #1
 800af1c:	e09d      	b.n	800b05a <HAL_SPI_Init+0x14e>
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
  assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 800af1e:	687b      	ldr	r3, [r7, #4]
 800af20:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800af22:	2b00      	cmp	r3, #0
 800af24:	d108      	bne.n	800af38 <HAL_SPI_Init+0x2c>
  {
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));

    if (hspi->Init.Mode == SPI_MODE_MASTER)
 800af26:	687b      	ldr	r3, [r7, #4]
 800af28:	685b      	ldr	r3, [r3, #4]
 800af2a:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 800af2e:	d009      	beq.n	800af44 <HAL_SPI_Init+0x38>
      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    }
    else
    {
      /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 800af30:	687b      	ldr	r3, [r7, #4]
 800af32:	2200      	movs	r2, #0
 800af34:	61da      	str	r2, [r3, #28]
 800af36:	e005      	b.n	800af44 <HAL_SPI_Init+0x38>
  else
  {
    assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));

    /* Force polarity and phase to TI protocaol requirements */
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 800af38:	687b      	ldr	r3, [r7, #4]
 800af3a:	2200      	movs	r2, #0
 800af3c:	611a      	str	r2, [r3, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 800af3e:	687b      	ldr	r3, [r7, #4]
 800af40:	2200      	movs	r2, #0
 800af42:	615a      	str	r2, [r3, #20]
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800af44:	687b      	ldr	r3, [r7, #4]
 800af46:	2200      	movs	r2, #0
 800af48:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 800af4a:	687b      	ldr	r3, [r7, #4]
 800af4c:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 800af50:	b2db      	uxtb	r3, r3
 800af52:	2b00      	cmp	r3, #0
 800af54:	d106      	bne.n	800af64 <HAL_SPI_Init+0x58>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 800af56:	687b      	ldr	r3, [r7, #4]
 800af58:	2200      	movs	r2, #0
 800af5a:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 800af5e:	6878      	ldr	r0, [r7, #4]
 800af60:	f7fa fb42 	bl	80055e8 <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 800af64:	687b      	ldr	r3, [r7, #4]
 800af66:	2202      	movs	r2, #2
 800af68:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 800af6c:	687b      	ldr	r3, [r7, #4]
 800af6e:	681b      	ldr	r3, [r3, #0]
 800af70:	681a      	ldr	r2, [r3, #0]
 800af72:	687b      	ldr	r3, [r7, #4]
 800af74:	681b      	ldr	r3, [r3, #0]
 800af76:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800af7a:	601a      	str	r2, [r3, #0]

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800af7c:	687b      	ldr	r3, [r7, #4]
 800af7e:	68db      	ldr	r3, [r3, #12]
 800af80:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 800af84:	d902      	bls.n	800af8c <HAL_SPI_Init+0x80>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 800af86:	2300      	movs	r3, #0
 800af88:	60fb      	str	r3, [r7, #12]
 800af8a:	e002      	b.n	800af92 <HAL_SPI_Init+0x86>
  }
  else
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 800af8c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800af90:	60fb      	str	r3, [r7, #12]
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 800af92:	687b      	ldr	r3, [r7, #4]
 800af94:	68db      	ldr	r3, [r3, #12]
 800af96:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 800af9a:	d007      	beq.n	800afac <HAL_SPI_Init+0xa0>
 800af9c:	687b      	ldr	r3, [r7, #4]
 800af9e:	68db      	ldr	r3, [r3, #12]
 800afa0:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 800afa4:	d002      	beq.n	800afac <HAL_SPI_Init+0xa0>
  {
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800afa6:	687b      	ldr	r3, [r7, #4]
 800afa8:	2200      	movs	r2, #0
 800afaa:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 800afac:	687b      	ldr	r3, [r7, #4]
 800afae:	685b      	ldr	r3, [r3, #4]
 800afb0:	f403 7282 	and.w	r2, r3, #260	; 0x104
 800afb4:	687b      	ldr	r3, [r7, #4]
 800afb6:	689b      	ldr	r3, [r3, #8]
 800afb8:	f403 4304 	and.w	r3, r3, #33792	; 0x8400
 800afbc:	431a      	orrs	r2, r3
 800afbe:	687b      	ldr	r3, [r7, #4]
 800afc0:	691b      	ldr	r3, [r3, #16]
 800afc2:	f003 0302 	and.w	r3, r3, #2
 800afc6:	431a      	orrs	r2, r3
 800afc8:	687b      	ldr	r3, [r7, #4]
 800afca:	695b      	ldr	r3, [r3, #20]
 800afcc:	f003 0301 	and.w	r3, r3, #1
 800afd0:	431a      	orrs	r2, r3
 800afd2:	687b      	ldr	r3, [r7, #4]
 800afd4:	699b      	ldr	r3, [r3, #24]
 800afd6:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800afda:	431a      	orrs	r2, r3
 800afdc:	687b      	ldr	r3, [r7, #4]
 800afde:	69db      	ldr	r3, [r3, #28]
 800afe0:	f003 0338 	and.w	r3, r3, #56	; 0x38
 800afe4:	431a      	orrs	r2, r3
 800afe6:	687b      	ldr	r3, [r7, #4]
 800afe8:	6a1b      	ldr	r3, [r3, #32]
 800afea:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800afee:	ea42 0103 	orr.w	r1, r2, r3
 800aff2:	687b      	ldr	r3, [r7, #4]
 800aff4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800aff6:	f403 5200 	and.w	r2, r3, #8192	; 0x2000
 800affa:	687b      	ldr	r3, [r7, #4]
 800affc:	681b      	ldr	r3, [r3, #0]
 800affe:	430a      	orrs	r2, r1
 800b000:	601a      	str	r2, [r3, #0]
    }
  }
#endif /* USE_SPI_CRC */

  /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo threshold */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 800b002:	687b      	ldr	r3, [r7, #4]
 800b004:	699b      	ldr	r3, [r3, #24]
 800b006:	0c1b      	lsrs	r3, r3, #16
 800b008:	f003 0204 	and.w	r2, r3, #4
 800b00c:	687b      	ldr	r3, [r7, #4]
 800b00e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b010:	f003 0310 	and.w	r3, r3, #16
 800b014:	431a      	orrs	r2, r3
 800b016:	687b      	ldr	r3, [r7, #4]
 800b018:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800b01a:	f003 0308 	and.w	r3, r3, #8
 800b01e:	431a      	orrs	r2, r3
 800b020:	687b      	ldr	r3, [r7, #4]
 800b022:	68db      	ldr	r3, [r3, #12]
 800b024:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 800b028:	ea42 0103 	orr.w	r1, r2, r3
 800b02c:	68fb      	ldr	r3, [r7, #12]
 800b02e:	f403 5280 	and.w	r2, r3, #4096	; 0x1000
 800b032:	687b      	ldr	r3, [r7, #4]
 800b034:	681b      	ldr	r3, [r3, #0]
 800b036:	430a      	orrs	r2, r1
 800b038:	605a      	str	r2, [r3, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 800b03a:	687b      	ldr	r3, [r7, #4]
 800b03c:	681b      	ldr	r3, [r3, #0]
 800b03e:	69da      	ldr	r2, [r3, #28]
 800b040:	687b      	ldr	r3, [r7, #4]
 800b042:	681b      	ldr	r3, [r3, #0]
 800b044:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 800b048:	61da      	str	r2, [r3, #28]
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 800b04a:	687b      	ldr	r3, [r7, #4]
 800b04c:	2200      	movs	r2, #0
 800b04e:	661a      	str	r2, [r3, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 800b050:	687b      	ldr	r3, [r7, #4]
 800b052:	2201      	movs	r2, #1
 800b054:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

  return HAL_OK;
 800b058:	2300      	movs	r3, #0
}
 800b05a:	4618      	mov	r0, r3
 800b05c:	3710      	adds	r7, #16
 800b05e:	46bd      	mov	sp, r7
 800b060:	bd80      	pop	{r7, pc}

0800b062 <HAL_SPI_TransmitReceive>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
                                          uint32_t Timeout)
{
 800b062:	b580      	push	{r7, lr}
 800b064:	b08a      	sub	sp, #40	; 0x28
 800b066:	af00      	add	r7, sp, #0
 800b068:	60f8      	str	r0, [r7, #12]
 800b06a:	60b9      	str	r1, [r7, #8]
 800b06c:	607a      	str	r2, [r7, #4]
 800b06e:	807b      	strh	r3, [r7, #2]
  __IO uint8_t  *ptmpreg8;
  __IO uint8_t  tmpreg8 = 0;
#endif /* USE_SPI_CRC */

  /* Variable used to alternate Rx and Tx during transfer */
  uint32_t             txallowed = 1U;
 800b070:	2301      	movs	r3, #1
 800b072:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_StatusTypeDef    errorcode = HAL_OK;
 800b074:	2300      	movs	r3, #0
 800b076:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 800b07a:	68fb      	ldr	r3, [r7, #12]
 800b07c:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800b080:	2b01      	cmp	r3, #1
 800b082:	d101      	bne.n	800b088 <HAL_SPI_TransmitReceive+0x26>
 800b084:	2302      	movs	r3, #2
 800b086:	e1fb      	b.n	800b480 <HAL_SPI_TransmitReceive+0x41e>
 800b088:	68fb      	ldr	r3, [r7, #12]
 800b08a:	2201      	movs	r2, #1
 800b08c:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 800b090:	f7fa fe60 	bl	8005d54 <HAL_GetTick>
 800b094:	61f8      	str	r0, [r7, #28]

  /* Init temporary variables */
  tmp_state           = hspi->State;
 800b096:	68fb      	ldr	r3, [r7, #12]
 800b098:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 800b09c:	76fb      	strb	r3, [r7, #27]
  tmp_mode            = hspi->Init.Mode;
 800b09e:	68fb      	ldr	r3, [r7, #12]
 800b0a0:	685b      	ldr	r3, [r3, #4]
 800b0a2:	617b      	str	r3, [r7, #20]
  initial_TxXferCount = Size;
 800b0a4:	887b      	ldrh	r3, [r7, #2]
 800b0a6:	827b      	strh	r3, [r7, #18]
  initial_RxXferCount = Size;
 800b0a8:	887b      	ldrh	r3, [r7, #2]
 800b0aa:	823b      	strh	r3, [r7, #16]
#if (USE_SPI_CRC != 0U)
  spi_cr1             = READ_REG(hspi->Instance->CR1);
  spi_cr2             = READ_REG(hspi->Instance->CR2);
#endif /* USE_SPI_CRC */

  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 800b0ac:	7efb      	ldrb	r3, [r7, #27]
 800b0ae:	2b01      	cmp	r3, #1
 800b0b0:	d00e      	beq.n	800b0d0 <HAL_SPI_TransmitReceive+0x6e>
 800b0b2:	697b      	ldr	r3, [r7, #20]
 800b0b4:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 800b0b8:	d106      	bne.n	800b0c8 <HAL_SPI_TransmitReceive+0x66>
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 800b0ba:	68fb      	ldr	r3, [r7, #12]
 800b0bc:	689b      	ldr	r3, [r3, #8]
 800b0be:	2b00      	cmp	r3, #0
 800b0c0:	d102      	bne.n	800b0c8 <HAL_SPI_TransmitReceive+0x66>
 800b0c2:	7efb      	ldrb	r3, [r7, #27]
 800b0c4:	2b04      	cmp	r3, #4
 800b0c6:	d003      	beq.n	800b0d0 <HAL_SPI_TransmitReceive+0x6e>
  {
    errorcode = HAL_BUSY;
 800b0c8:	2302      	movs	r3, #2
 800b0ca:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    goto error;
 800b0ce:	e1cd      	b.n	800b46c <HAL_SPI_TransmitReceive+0x40a>
  }

  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 800b0d0:	68bb      	ldr	r3, [r7, #8]
 800b0d2:	2b00      	cmp	r3, #0
 800b0d4:	d005      	beq.n	800b0e2 <HAL_SPI_TransmitReceive+0x80>
 800b0d6:	687b      	ldr	r3, [r7, #4]
 800b0d8:	2b00      	cmp	r3, #0
 800b0da:	d002      	beq.n	800b0e2 <HAL_SPI_TransmitReceive+0x80>
 800b0dc:	887b      	ldrh	r3, [r7, #2]
 800b0de:	2b00      	cmp	r3, #0
 800b0e0:	d103      	bne.n	800b0ea <HAL_SPI_TransmitReceive+0x88>
  {
    errorcode = HAL_ERROR;
 800b0e2:	2301      	movs	r3, #1
 800b0e4:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    goto error;
 800b0e8:	e1c0      	b.n	800b46c <HAL_SPI_TransmitReceive+0x40a>
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 800b0ea:	68fb      	ldr	r3, [r7, #12]
 800b0ec:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 800b0f0:	b2db      	uxtb	r3, r3
 800b0f2:	2b04      	cmp	r3, #4
 800b0f4:	d003      	beq.n	800b0fe <HAL_SPI_TransmitReceive+0x9c>
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 800b0f6:	68fb      	ldr	r3, [r7, #12]
 800b0f8:	2205      	movs	r2, #5
 800b0fa:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800b0fe:	68fb      	ldr	r3, [r7, #12]
 800b100:	2200      	movs	r2, #0
 800b102:	661a      	str	r2, [r3, #96]	; 0x60
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 800b104:	68fb      	ldr	r3, [r7, #12]
 800b106:	687a      	ldr	r2, [r7, #4]
 800b108:	641a      	str	r2, [r3, #64]	; 0x40
  hspi->RxXferCount = Size;
 800b10a:	68fb      	ldr	r3, [r7, #12]
 800b10c:	887a      	ldrh	r2, [r7, #2]
 800b10e:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
  hspi->RxXferSize  = Size;
 800b112:	68fb      	ldr	r3, [r7, #12]
 800b114:	887a      	ldrh	r2, [r7, #2]
 800b116:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 800b11a:	68fb      	ldr	r3, [r7, #12]
 800b11c:	68ba      	ldr	r2, [r7, #8]
 800b11e:	639a      	str	r2, [r3, #56]	; 0x38
  hspi->TxXferCount = Size;
 800b120:	68fb      	ldr	r3, [r7, #12]
 800b122:	887a      	ldrh	r2, [r7, #2]
 800b124:	87da      	strh	r2, [r3, #62]	; 0x3e
  hspi->TxXferSize  = Size;
 800b126:	68fb      	ldr	r3, [r7, #12]
 800b128:	887a      	ldrh	r2, [r7, #2]
 800b12a:	879a      	strh	r2, [r3, #60]	; 0x3c

  /*Init field not used in handle to zero */
  hspi->RxISR       = NULL;
 800b12c:	68fb      	ldr	r3, [r7, #12]
 800b12e:	2200      	movs	r2, #0
 800b130:	64da      	str	r2, [r3, #76]	; 0x4c
  hspi->TxISR       = NULL;
 800b132:	68fb      	ldr	r3, [r7, #12]
 800b134:	2200      	movs	r2, #0
 800b136:	651a      	str	r2, [r3, #80]	; 0x50
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Set the Rx Fifo threshold */
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (initial_RxXferCount > 1U))
 800b138:	68fb      	ldr	r3, [r7, #12]
 800b13a:	68db      	ldr	r3, [r3, #12]
 800b13c:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 800b140:	d802      	bhi.n	800b148 <HAL_SPI_TransmitReceive+0xe6>
 800b142:	8a3b      	ldrh	r3, [r7, #16]
 800b144:	2b01      	cmp	r3, #1
 800b146:	d908      	bls.n	800b15a <HAL_SPI_TransmitReceive+0xf8>
  {
    /* Set fiforxthreshold according the reception data length: 16bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800b148:	68fb      	ldr	r3, [r7, #12]
 800b14a:	681b      	ldr	r3, [r3, #0]
 800b14c:	685a      	ldr	r2, [r3, #4]
 800b14e:	68fb      	ldr	r3, [r7, #12]
 800b150:	681b      	ldr	r3, [r3, #0]
 800b152:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800b156:	605a      	str	r2, [r3, #4]
 800b158:	e007      	b.n	800b16a <HAL_SPI_TransmitReceive+0x108>
  }
  else
  {
    /* Set fiforxthreshold according the reception data length: 8bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800b15a:	68fb      	ldr	r3, [r7, #12]
 800b15c:	681b      	ldr	r3, [r3, #0]
 800b15e:	685a      	ldr	r2, [r3, #4]
 800b160:	68fb      	ldr	r3, [r7, #12]
 800b162:	681b      	ldr	r3, [r3, #0]
 800b164:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800b168:	605a      	str	r2, [r3, #4]
  }

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 800b16a:	68fb      	ldr	r3, [r7, #12]
 800b16c:	681b      	ldr	r3, [r3, #0]
 800b16e:	681b      	ldr	r3, [r3, #0]
 800b170:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800b174:	2b40      	cmp	r3, #64	; 0x40
 800b176:	d007      	beq.n	800b188 <HAL_SPI_TransmitReceive+0x126>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 800b178:	68fb      	ldr	r3, [r7, #12]
 800b17a:	681b      	ldr	r3, [r3, #0]
 800b17c:	681a      	ldr	r2, [r3, #0]
 800b17e:	68fb      	ldr	r3, [r7, #12]
 800b180:	681b      	ldr	r3, [r3, #0]
 800b182:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800b186:	601a      	str	r2, [r3, #0]
  }

  /* Transmit and Receive data in 16 Bit mode */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800b188:	68fb      	ldr	r3, [r7, #12]
 800b18a:	68db      	ldr	r3, [r3, #12]
 800b18c:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 800b190:	d97c      	bls.n	800b28c <HAL_SPI_TransmitReceive+0x22a>
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 800b192:	68fb      	ldr	r3, [r7, #12]
 800b194:	685b      	ldr	r3, [r3, #4]
 800b196:	2b00      	cmp	r3, #0
 800b198:	d002      	beq.n	800b1a0 <HAL_SPI_TransmitReceive+0x13e>
 800b19a:	8a7b      	ldrh	r3, [r7, #18]
 800b19c:	2b01      	cmp	r3, #1
 800b19e:	d169      	bne.n	800b274 <HAL_SPI_TransmitReceive+0x212>
    {
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 800b1a0:	68fb      	ldr	r3, [r7, #12]
 800b1a2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b1a4:	881a      	ldrh	r2, [r3, #0]
 800b1a6:	68fb      	ldr	r3, [r7, #12]
 800b1a8:	681b      	ldr	r3, [r3, #0]
 800b1aa:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 800b1ac:	68fb      	ldr	r3, [r7, #12]
 800b1ae:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b1b0:	1c9a      	adds	r2, r3, #2
 800b1b2:	68fb      	ldr	r3, [r7, #12]
 800b1b4:	639a      	str	r2, [r3, #56]	; 0x38
      hspi->TxXferCount--;
 800b1b6:	68fb      	ldr	r3, [r7, #12]
 800b1b8:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800b1ba:	b29b      	uxth	r3, r3
 800b1bc:	3b01      	subs	r3, #1
 800b1be:	b29a      	uxth	r2, r3
 800b1c0:	68fb      	ldr	r3, [r7, #12]
 800b1c2:	87da      	strh	r2, [r3, #62]	; 0x3e
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800b1c4:	e056      	b.n	800b274 <HAL_SPI_TransmitReceive+0x212>
    {
      /* Check TXE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 800b1c6:	68fb      	ldr	r3, [r7, #12]
 800b1c8:	681b      	ldr	r3, [r3, #0]
 800b1ca:	689b      	ldr	r3, [r3, #8]
 800b1cc:	f003 0302 	and.w	r3, r3, #2
 800b1d0:	2b02      	cmp	r3, #2
 800b1d2:	d11b      	bne.n	800b20c <HAL_SPI_TransmitReceive+0x1aa>
 800b1d4:	68fb      	ldr	r3, [r7, #12]
 800b1d6:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800b1d8:	b29b      	uxth	r3, r3
 800b1da:	2b00      	cmp	r3, #0
 800b1dc:	d016      	beq.n	800b20c <HAL_SPI_TransmitReceive+0x1aa>
 800b1de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b1e0:	2b01      	cmp	r3, #1
 800b1e2:	d113      	bne.n	800b20c <HAL_SPI_TransmitReceive+0x1aa>
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 800b1e4:	68fb      	ldr	r3, [r7, #12]
 800b1e6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b1e8:	881a      	ldrh	r2, [r3, #0]
 800b1ea:	68fb      	ldr	r3, [r7, #12]
 800b1ec:	681b      	ldr	r3, [r3, #0]
 800b1ee:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 800b1f0:	68fb      	ldr	r3, [r7, #12]
 800b1f2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b1f4:	1c9a      	adds	r2, r3, #2
 800b1f6:	68fb      	ldr	r3, [r7, #12]
 800b1f8:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->TxXferCount--;
 800b1fa:	68fb      	ldr	r3, [r7, #12]
 800b1fc:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800b1fe:	b29b      	uxth	r3, r3
 800b200:	3b01      	subs	r3, #1
 800b202:	b29a      	uxth	r2, r3
 800b204:	68fb      	ldr	r3, [r7, #12]
 800b206:	87da      	strh	r2, [r3, #62]	; 0x3e
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 800b208:	2300      	movs	r3, #0
 800b20a:	627b      	str	r3, [r7, #36]	; 0x24
        }
#endif /* USE_SPI_CRC */
      }

      /* Check RXNE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 800b20c:	68fb      	ldr	r3, [r7, #12]
 800b20e:	681b      	ldr	r3, [r3, #0]
 800b210:	689b      	ldr	r3, [r3, #8]
 800b212:	f003 0301 	and.w	r3, r3, #1
 800b216:	2b01      	cmp	r3, #1
 800b218:	d11c      	bne.n	800b254 <HAL_SPI_TransmitReceive+0x1f2>
 800b21a:	68fb      	ldr	r3, [r7, #12]
 800b21c:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 800b220:	b29b      	uxth	r3, r3
 800b222:	2b00      	cmp	r3, #0
 800b224:	d016      	beq.n	800b254 <HAL_SPI_TransmitReceive+0x1f2>
      {
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 800b226:	68fb      	ldr	r3, [r7, #12]
 800b228:	681b      	ldr	r3, [r3, #0]
 800b22a:	68da      	ldr	r2, [r3, #12]
 800b22c:	68fb      	ldr	r3, [r7, #12]
 800b22e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b230:	b292      	uxth	r2, r2
 800b232:	801a      	strh	r2, [r3, #0]
        hspi->pRxBuffPtr += sizeof(uint16_t);
 800b234:	68fb      	ldr	r3, [r7, #12]
 800b236:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b238:	1c9a      	adds	r2, r3, #2
 800b23a:	68fb      	ldr	r3, [r7, #12]
 800b23c:	641a      	str	r2, [r3, #64]	; 0x40
        hspi->RxXferCount--;
 800b23e:	68fb      	ldr	r3, [r7, #12]
 800b240:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 800b244:	b29b      	uxth	r3, r3
 800b246:	3b01      	subs	r3, #1
 800b248:	b29a      	uxth	r2, r3
 800b24a:	68fb      	ldr	r3, [r7, #12]
 800b24c:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 800b250:	2301      	movs	r3, #1
 800b252:	627b      	str	r3, [r7, #36]	; 0x24
      }
      if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
 800b254:	f7fa fd7e 	bl	8005d54 <HAL_GetTick>
 800b258:	4602      	mov	r2, r0
 800b25a:	69fb      	ldr	r3, [r7, #28]
 800b25c:	1ad3      	subs	r3, r2, r3
 800b25e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800b260:	429a      	cmp	r2, r3
 800b262:	d807      	bhi.n	800b274 <HAL_SPI_TransmitReceive+0x212>
 800b264:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b266:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b26a:	d003      	beq.n	800b274 <HAL_SPI_TransmitReceive+0x212>
      {
        errorcode = HAL_TIMEOUT;
 800b26c:	2303      	movs	r3, #3
 800b26e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        goto error;
 800b272:	e0fb      	b.n	800b46c <HAL_SPI_TransmitReceive+0x40a>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800b274:	68fb      	ldr	r3, [r7, #12]
 800b276:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800b278:	b29b      	uxth	r3, r3
 800b27a:	2b00      	cmp	r3, #0
 800b27c:	d1a3      	bne.n	800b1c6 <HAL_SPI_TransmitReceive+0x164>
 800b27e:	68fb      	ldr	r3, [r7, #12]
 800b280:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 800b284:	b29b      	uxth	r3, r3
 800b286:	2b00      	cmp	r3, #0
 800b288:	d19d      	bne.n	800b1c6 <HAL_SPI_TransmitReceive+0x164>
 800b28a:	e0df      	b.n	800b44c <HAL_SPI_TransmitReceive+0x3ea>
    }
  }
  /* Transmit and Receive data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 800b28c:	68fb      	ldr	r3, [r7, #12]
 800b28e:	685b      	ldr	r3, [r3, #4]
 800b290:	2b00      	cmp	r3, #0
 800b292:	d003      	beq.n	800b29c <HAL_SPI_TransmitReceive+0x23a>
 800b294:	8a7b      	ldrh	r3, [r7, #18]
 800b296:	2b01      	cmp	r3, #1
 800b298:	f040 80cb 	bne.w	800b432 <HAL_SPI_TransmitReceive+0x3d0>
    {
      if (hspi->TxXferCount > 1U)
 800b29c:	68fb      	ldr	r3, [r7, #12]
 800b29e:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800b2a0:	b29b      	uxth	r3, r3
 800b2a2:	2b01      	cmp	r3, #1
 800b2a4:	d912      	bls.n	800b2cc <HAL_SPI_TransmitReceive+0x26a>
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 800b2a6:	68fb      	ldr	r3, [r7, #12]
 800b2a8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b2aa:	881a      	ldrh	r2, [r3, #0]
 800b2ac:	68fb      	ldr	r3, [r7, #12]
 800b2ae:	681b      	ldr	r3, [r3, #0]
 800b2b0:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 800b2b2:	68fb      	ldr	r3, [r7, #12]
 800b2b4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b2b6:	1c9a      	adds	r2, r3, #2
 800b2b8:	68fb      	ldr	r3, [r7, #12]
 800b2ba:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->TxXferCount -= 2U;
 800b2bc:	68fb      	ldr	r3, [r7, #12]
 800b2be:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800b2c0:	b29b      	uxth	r3, r3
 800b2c2:	3b02      	subs	r3, #2
 800b2c4:	b29a      	uxth	r2, r3
 800b2c6:	68fb      	ldr	r3, [r7, #12]
 800b2c8:	87da      	strh	r2, [r3, #62]	; 0x3e
 800b2ca:	e0b2      	b.n	800b432 <HAL_SPI_TransmitReceive+0x3d0>
      }
      else
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 800b2cc:	68fb      	ldr	r3, [r7, #12]
 800b2ce:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800b2d0:	68fb      	ldr	r3, [r7, #12]
 800b2d2:	681b      	ldr	r3, [r3, #0]
 800b2d4:	330c      	adds	r3, #12
 800b2d6:	7812      	ldrb	r2, [r2, #0]
 800b2d8:	701a      	strb	r2, [r3, #0]
        hspi->pTxBuffPtr++;
 800b2da:	68fb      	ldr	r3, [r7, #12]
 800b2dc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b2de:	1c5a      	adds	r2, r3, #1
 800b2e0:	68fb      	ldr	r3, [r7, #12]
 800b2e2:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->TxXferCount--;
 800b2e4:	68fb      	ldr	r3, [r7, #12]
 800b2e6:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800b2e8:	b29b      	uxth	r3, r3
 800b2ea:	3b01      	subs	r3, #1
 800b2ec:	b29a      	uxth	r2, r3
 800b2ee:	68fb      	ldr	r3, [r7, #12]
 800b2f0:	87da      	strh	r2, [r3, #62]	; 0x3e
      }
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800b2f2:	e09e      	b.n	800b432 <HAL_SPI_TransmitReceive+0x3d0>
    {
      /* Check TXE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 800b2f4:	68fb      	ldr	r3, [r7, #12]
 800b2f6:	681b      	ldr	r3, [r3, #0]
 800b2f8:	689b      	ldr	r3, [r3, #8]
 800b2fa:	f003 0302 	and.w	r3, r3, #2
 800b2fe:	2b02      	cmp	r3, #2
 800b300:	d134      	bne.n	800b36c <HAL_SPI_TransmitReceive+0x30a>
 800b302:	68fb      	ldr	r3, [r7, #12]
 800b304:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800b306:	b29b      	uxth	r3, r3
 800b308:	2b00      	cmp	r3, #0
 800b30a:	d02f      	beq.n	800b36c <HAL_SPI_TransmitReceive+0x30a>
 800b30c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b30e:	2b01      	cmp	r3, #1
 800b310:	d12c      	bne.n	800b36c <HAL_SPI_TransmitReceive+0x30a>
      {
        if (hspi->TxXferCount > 1U)
 800b312:	68fb      	ldr	r3, [r7, #12]
 800b314:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800b316:	b29b      	uxth	r3, r3
 800b318:	2b01      	cmp	r3, #1
 800b31a:	d912      	bls.n	800b342 <HAL_SPI_TransmitReceive+0x2e0>
        {
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 800b31c:	68fb      	ldr	r3, [r7, #12]
 800b31e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b320:	881a      	ldrh	r2, [r3, #0]
 800b322:	68fb      	ldr	r3, [r7, #12]
 800b324:	681b      	ldr	r3, [r3, #0]
 800b326:	60da      	str	r2, [r3, #12]
          hspi->pTxBuffPtr += sizeof(uint16_t);
 800b328:	68fb      	ldr	r3, [r7, #12]
 800b32a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b32c:	1c9a      	adds	r2, r3, #2
 800b32e:	68fb      	ldr	r3, [r7, #12]
 800b330:	639a      	str	r2, [r3, #56]	; 0x38
          hspi->TxXferCount -= 2U;
 800b332:	68fb      	ldr	r3, [r7, #12]
 800b334:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800b336:	b29b      	uxth	r3, r3
 800b338:	3b02      	subs	r3, #2
 800b33a:	b29a      	uxth	r2, r3
 800b33c:	68fb      	ldr	r3, [r7, #12]
 800b33e:	87da      	strh	r2, [r3, #62]	; 0x3e
 800b340:	e012      	b.n	800b368 <HAL_SPI_TransmitReceive+0x306>
        }
        else
        {
          *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 800b342:	68fb      	ldr	r3, [r7, #12]
 800b344:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800b346:	68fb      	ldr	r3, [r7, #12]
 800b348:	681b      	ldr	r3, [r3, #0]
 800b34a:	330c      	adds	r3, #12
 800b34c:	7812      	ldrb	r2, [r2, #0]
 800b34e:	701a      	strb	r2, [r3, #0]
          hspi->pTxBuffPtr++;
 800b350:	68fb      	ldr	r3, [r7, #12]
 800b352:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b354:	1c5a      	adds	r2, r3, #1
 800b356:	68fb      	ldr	r3, [r7, #12]
 800b358:	639a      	str	r2, [r3, #56]	; 0x38
          hspi->TxXferCount--;
 800b35a:	68fb      	ldr	r3, [r7, #12]
 800b35c:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800b35e:	b29b      	uxth	r3, r3
 800b360:	3b01      	subs	r3, #1
 800b362:	b29a      	uxth	r2, r3
 800b364:	68fb      	ldr	r3, [r7, #12]
 800b366:	87da      	strh	r2, [r3, #62]	; 0x3e
        }
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 800b368:	2300      	movs	r3, #0
 800b36a:	627b      	str	r3, [r7, #36]	; 0x24
        }
#endif /* USE_SPI_CRC */
      }

      /* Wait until RXNE flag is reset */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 800b36c:	68fb      	ldr	r3, [r7, #12]
 800b36e:	681b      	ldr	r3, [r3, #0]
 800b370:	689b      	ldr	r3, [r3, #8]
 800b372:	f003 0301 	and.w	r3, r3, #1
 800b376:	2b01      	cmp	r3, #1
 800b378:	d148      	bne.n	800b40c <HAL_SPI_TransmitReceive+0x3aa>
 800b37a:	68fb      	ldr	r3, [r7, #12]
 800b37c:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 800b380:	b29b      	uxth	r3, r3
 800b382:	2b00      	cmp	r3, #0
 800b384:	d042      	beq.n	800b40c <HAL_SPI_TransmitReceive+0x3aa>
      {
        if (hspi->RxXferCount > 1U)
 800b386:	68fb      	ldr	r3, [r7, #12]
 800b388:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 800b38c:	b29b      	uxth	r3, r3
 800b38e:	2b01      	cmp	r3, #1
 800b390:	d923      	bls.n	800b3da <HAL_SPI_TransmitReceive+0x378>
        {
          *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 800b392:	68fb      	ldr	r3, [r7, #12]
 800b394:	681b      	ldr	r3, [r3, #0]
 800b396:	68da      	ldr	r2, [r3, #12]
 800b398:	68fb      	ldr	r3, [r7, #12]
 800b39a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b39c:	b292      	uxth	r2, r2
 800b39e:	801a      	strh	r2, [r3, #0]
          hspi->pRxBuffPtr += sizeof(uint16_t);
 800b3a0:	68fb      	ldr	r3, [r7, #12]
 800b3a2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b3a4:	1c9a      	adds	r2, r3, #2
 800b3a6:	68fb      	ldr	r3, [r7, #12]
 800b3a8:	641a      	str	r2, [r3, #64]	; 0x40
          hspi->RxXferCount -= 2U;
 800b3aa:	68fb      	ldr	r3, [r7, #12]
 800b3ac:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 800b3b0:	b29b      	uxth	r3, r3
 800b3b2:	3b02      	subs	r3, #2
 800b3b4:	b29a      	uxth	r2, r3
 800b3b6:	68fb      	ldr	r3, [r7, #12]
 800b3b8:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
          if (hspi->RxXferCount <= 1U)
 800b3bc:	68fb      	ldr	r3, [r7, #12]
 800b3be:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 800b3c2:	b29b      	uxth	r3, r3
 800b3c4:	2b01      	cmp	r3, #1
 800b3c6:	d81f      	bhi.n	800b408 <HAL_SPI_TransmitReceive+0x3a6>
          {
            /* Set RX Fifo threshold before to switch on 8 bit data size */
            SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800b3c8:	68fb      	ldr	r3, [r7, #12]
 800b3ca:	681b      	ldr	r3, [r3, #0]
 800b3cc:	685a      	ldr	r2, [r3, #4]
 800b3ce:	68fb      	ldr	r3, [r7, #12]
 800b3d0:	681b      	ldr	r3, [r3, #0]
 800b3d2:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800b3d6:	605a      	str	r2, [r3, #4]
 800b3d8:	e016      	b.n	800b408 <HAL_SPI_TransmitReceive+0x3a6>
          }
        }
        else
        {
          (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 800b3da:	68fb      	ldr	r3, [r7, #12]
 800b3dc:	681b      	ldr	r3, [r3, #0]
 800b3de:	f103 020c 	add.w	r2, r3, #12
 800b3e2:	68fb      	ldr	r3, [r7, #12]
 800b3e4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b3e6:	7812      	ldrb	r2, [r2, #0]
 800b3e8:	b2d2      	uxtb	r2, r2
 800b3ea:	701a      	strb	r2, [r3, #0]
          hspi->pRxBuffPtr++;
 800b3ec:	68fb      	ldr	r3, [r7, #12]
 800b3ee:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b3f0:	1c5a      	adds	r2, r3, #1
 800b3f2:	68fb      	ldr	r3, [r7, #12]
 800b3f4:	641a      	str	r2, [r3, #64]	; 0x40
          hspi->RxXferCount--;
 800b3f6:	68fb      	ldr	r3, [r7, #12]
 800b3f8:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 800b3fc:	b29b      	uxth	r3, r3
 800b3fe:	3b01      	subs	r3, #1
 800b400:	b29a      	uxth	r2, r3
 800b402:	68fb      	ldr	r3, [r7, #12]
 800b404:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
        }
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 800b408:	2301      	movs	r3, #1
 800b40a:	627b      	str	r3, [r7, #36]	; 0x24
      }
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
 800b40c:	f7fa fca2 	bl	8005d54 <HAL_GetTick>
 800b410:	4602      	mov	r2, r0
 800b412:	69fb      	ldr	r3, [r7, #28]
 800b414:	1ad3      	subs	r3, r2, r3
 800b416:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800b418:	429a      	cmp	r2, r3
 800b41a:	d803      	bhi.n	800b424 <HAL_SPI_TransmitReceive+0x3c2>
 800b41c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b41e:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b422:	d102      	bne.n	800b42a <HAL_SPI_TransmitReceive+0x3c8>
 800b424:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b426:	2b00      	cmp	r3, #0
 800b428:	d103      	bne.n	800b432 <HAL_SPI_TransmitReceive+0x3d0>
      {
        errorcode = HAL_TIMEOUT;
 800b42a:	2303      	movs	r3, #3
 800b42c:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        goto error;
 800b430:	e01c      	b.n	800b46c <HAL_SPI_TransmitReceive+0x40a>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800b432:	68fb      	ldr	r3, [r7, #12]
 800b434:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800b436:	b29b      	uxth	r3, r3
 800b438:	2b00      	cmp	r3, #0
 800b43a:	f47f af5b 	bne.w	800b2f4 <HAL_SPI_TransmitReceive+0x292>
 800b43e:	68fb      	ldr	r3, [r7, #12]
 800b440:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 800b444:	b29b      	uxth	r3, r3
 800b446:	2b00      	cmp	r3, #0
 800b448:	f47f af54 	bne.w	800b2f4 <HAL_SPI_TransmitReceive+0x292>
    errorcode = HAL_ERROR;
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 800b44c:	69fa      	ldr	r2, [r7, #28]
 800b44e:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800b450:	68f8      	ldr	r0, [r7, #12]
 800b452:	f000 f937 	bl	800b6c4 <SPI_EndRxTxTransaction>
 800b456:	4603      	mov	r3, r0
 800b458:	2b00      	cmp	r3, #0
 800b45a:	d006      	beq.n	800b46a <HAL_SPI_TransmitReceive+0x408>
  {
    errorcode = HAL_ERROR;
 800b45c:	2301      	movs	r3, #1
 800b45e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 800b462:	68fb      	ldr	r3, [r7, #12]
 800b464:	2220      	movs	r2, #32
 800b466:	661a      	str	r2, [r3, #96]	; 0x60
 800b468:	e000      	b.n	800b46c <HAL_SPI_TransmitReceive+0x40a>
  }

error :
 800b46a:	bf00      	nop
  hspi->State = HAL_SPI_STATE_READY;
 800b46c:	68fb      	ldr	r3, [r7, #12]
 800b46e:	2201      	movs	r2, #1
 800b470:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 800b474:	68fb      	ldr	r3, [r7, #12]
 800b476:	2200      	movs	r2, #0
 800b478:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
  return errorcode;
 800b47c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
}
 800b480:	4618      	mov	r0, r3
 800b482:	3728      	adds	r7, #40	; 0x28
 800b484:	46bd      	mov	sp, r7
 800b486:	bd80      	pop	{r7, pc}

0800b488 <SPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 800b488:	b580      	push	{r7, lr}
 800b48a:	b088      	sub	sp, #32
 800b48c:	af00      	add	r7, sp, #0
 800b48e:	60f8      	str	r0, [r7, #12]
 800b490:	60b9      	str	r1, [r7, #8]
 800b492:	603b      	str	r3, [r7, #0]
 800b494:	4613      	mov	r3, r2
 800b496:	71fb      	strb	r3, [r7, #7]
  __IO uint32_t count;
  uint32_t tmp_timeout;
  uint32_t tmp_tickstart;

  /* Adjust Timeout value  in case of end of transfer */
  tmp_timeout   = Timeout - (HAL_GetTick() - Tickstart);
 800b498:	f7fa fc5c 	bl	8005d54 <HAL_GetTick>
 800b49c:	4602      	mov	r2, r0
 800b49e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b4a0:	1a9b      	subs	r3, r3, r2
 800b4a2:	683a      	ldr	r2, [r7, #0]
 800b4a4:	4413      	add	r3, r2
 800b4a6:	61fb      	str	r3, [r7, #28]
  tmp_tickstart = HAL_GetTick();
 800b4a8:	f7fa fc54 	bl	8005d54 <HAL_GetTick>
 800b4ac:	61b8      	str	r0, [r7, #24]

  /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 800b4ae:	4b39      	ldr	r3, [pc, #228]	; (800b594 <SPI_WaitFlagStateUntilTimeout+0x10c>)
 800b4b0:	681b      	ldr	r3, [r3, #0]
 800b4b2:	015b      	lsls	r3, r3, #5
 800b4b4:	0d1b      	lsrs	r3, r3, #20
 800b4b6:	69fa      	ldr	r2, [r7, #28]
 800b4b8:	fb02 f303 	mul.w	r3, r2, r3
 800b4bc:	617b      	str	r3, [r7, #20]

  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 800b4be:	e054      	b.n	800b56a <SPI_WaitFlagStateUntilTimeout+0xe2>
  {
    if (Timeout != HAL_MAX_DELAY)
 800b4c0:	683b      	ldr	r3, [r7, #0]
 800b4c2:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b4c6:	d050      	beq.n	800b56a <SPI_WaitFlagStateUntilTimeout+0xe2>
    {
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 800b4c8:	f7fa fc44 	bl	8005d54 <HAL_GetTick>
 800b4cc:	4602      	mov	r2, r0
 800b4ce:	69bb      	ldr	r3, [r7, #24]
 800b4d0:	1ad3      	subs	r3, r2, r3
 800b4d2:	69fa      	ldr	r2, [r7, #28]
 800b4d4:	429a      	cmp	r2, r3
 800b4d6:	d902      	bls.n	800b4de <SPI_WaitFlagStateUntilTimeout+0x56>
 800b4d8:	69fb      	ldr	r3, [r7, #28]
 800b4da:	2b00      	cmp	r3, #0
 800b4dc:	d13d      	bne.n	800b55a <SPI_WaitFlagStateUntilTimeout+0xd2>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
           on both master and slave sides in order to resynchronize the master
           and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 800b4de:	68fb      	ldr	r3, [r7, #12]
 800b4e0:	681b      	ldr	r3, [r3, #0]
 800b4e2:	685a      	ldr	r2, [r3, #4]
 800b4e4:	68fb      	ldr	r3, [r7, #12]
 800b4e6:	681b      	ldr	r3, [r3, #0]
 800b4e8:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 800b4ec:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800b4ee:	68fb      	ldr	r3, [r7, #12]
 800b4f0:	685b      	ldr	r3, [r3, #4]
 800b4f2:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 800b4f6:	d111      	bne.n	800b51c <SPI_WaitFlagStateUntilTimeout+0x94>
 800b4f8:	68fb      	ldr	r3, [r7, #12]
 800b4fa:	689b      	ldr	r3, [r3, #8]
 800b4fc:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800b500:	d004      	beq.n	800b50c <SPI_WaitFlagStateUntilTimeout+0x84>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800b502:	68fb      	ldr	r3, [r7, #12]
 800b504:	689b      	ldr	r3, [r3, #8]
 800b506:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800b50a:	d107      	bne.n	800b51c <SPI_WaitFlagStateUntilTimeout+0x94>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 800b50c:	68fb      	ldr	r3, [r7, #12]
 800b50e:	681b      	ldr	r3, [r3, #0]
 800b510:	681a      	ldr	r2, [r3, #0]
 800b512:	68fb      	ldr	r3, [r7, #12]
 800b514:	681b      	ldr	r3, [r3, #0]
 800b516:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800b51a:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800b51c:	68fb      	ldr	r3, [r7, #12]
 800b51e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b520:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800b524:	d10f      	bne.n	800b546 <SPI_WaitFlagStateUntilTimeout+0xbe>
        {
          SPI_RESET_CRC(hspi);
 800b526:	68fb      	ldr	r3, [r7, #12]
 800b528:	681b      	ldr	r3, [r3, #0]
 800b52a:	681a      	ldr	r2, [r3, #0]
 800b52c:	68fb      	ldr	r3, [r7, #12]
 800b52e:	681b      	ldr	r3, [r3, #0]
 800b530:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800b534:	601a      	str	r2, [r3, #0]
 800b536:	68fb      	ldr	r3, [r7, #12]
 800b538:	681b      	ldr	r3, [r3, #0]
 800b53a:	681a      	ldr	r2, [r3, #0]
 800b53c:	68fb      	ldr	r3, [r7, #12]
 800b53e:	681b      	ldr	r3, [r3, #0]
 800b540:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800b544:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 800b546:	68fb      	ldr	r3, [r7, #12]
 800b548:	2201      	movs	r2, #1
 800b54a:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 800b54e:	68fb      	ldr	r3, [r7, #12]
 800b550:	2200      	movs	r2, #0
 800b552:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

        return HAL_TIMEOUT;
 800b556:	2303      	movs	r3, #3
 800b558:	e017      	b.n	800b58a <SPI_WaitFlagStateUntilTimeout+0x102>
      }
      /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
      if (count == 0U)
 800b55a:	697b      	ldr	r3, [r7, #20]
 800b55c:	2b00      	cmp	r3, #0
 800b55e:	d101      	bne.n	800b564 <SPI_WaitFlagStateUntilTimeout+0xdc>
      {
        tmp_timeout = 0U;
 800b560:	2300      	movs	r3, #0
 800b562:	61fb      	str	r3, [r7, #28]
      }
      count--;
 800b564:	697b      	ldr	r3, [r7, #20]
 800b566:	3b01      	subs	r3, #1
 800b568:	617b      	str	r3, [r7, #20]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 800b56a:	68fb      	ldr	r3, [r7, #12]
 800b56c:	681b      	ldr	r3, [r3, #0]
 800b56e:	689a      	ldr	r2, [r3, #8]
 800b570:	68bb      	ldr	r3, [r7, #8]
 800b572:	4013      	ands	r3, r2
 800b574:	68ba      	ldr	r2, [r7, #8]
 800b576:	429a      	cmp	r2, r3
 800b578:	bf0c      	ite	eq
 800b57a:	2301      	moveq	r3, #1
 800b57c:	2300      	movne	r3, #0
 800b57e:	b2db      	uxtb	r3, r3
 800b580:	461a      	mov	r2, r3
 800b582:	79fb      	ldrb	r3, [r7, #7]
 800b584:	429a      	cmp	r2, r3
 800b586:	d19b      	bne.n	800b4c0 <SPI_WaitFlagStateUntilTimeout+0x38>
    }
  }

  return HAL_OK;
 800b588:	2300      	movs	r3, #0
}
 800b58a:	4618      	mov	r0, r3
 800b58c:	3720      	adds	r7, #32
 800b58e:	46bd      	mov	sp, r7
 800b590:	bd80      	pop	{r7, pc}
 800b592:	bf00      	nop
 800b594:	20000008 	.word	0x20000008

0800b598 <SPI_WaitFifoStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 800b598:	b580      	push	{r7, lr}
 800b59a:	b08a      	sub	sp, #40	; 0x28
 800b59c:	af00      	add	r7, sp, #0
 800b59e:	60f8      	str	r0, [r7, #12]
 800b5a0:	60b9      	str	r1, [r7, #8]
 800b5a2:	607a      	str	r2, [r7, #4]
 800b5a4:	603b      	str	r3, [r7, #0]
  __IO uint32_t count;
  uint32_t tmp_timeout;
  uint32_t tmp_tickstart;
  __IO uint8_t  *ptmpreg8;
  __IO uint8_t  tmpreg8 = 0;
 800b5a6:	2300      	movs	r3, #0
 800b5a8:	75fb      	strb	r3, [r7, #23]

  /* Adjust Timeout value  in case of end of transfer */
  tmp_timeout = Timeout - (HAL_GetTick() - Tickstart);
 800b5aa:	f7fa fbd3 	bl	8005d54 <HAL_GetTick>
 800b5ae:	4602      	mov	r2, r0
 800b5b0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b5b2:	1a9b      	subs	r3, r3, r2
 800b5b4:	683a      	ldr	r2, [r7, #0]
 800b5b6:	4413      	add	r3, r2
 800b5b8:	627b      	str	r3, [r7, #36]	; 0x24
  tmp_tickstart = HAL_GetTick();
 800b5ba:	f7fa fbcb 	bl	8005d54 <HAL_GetTick>
 800b5be:	6238      	str	r0, [r7, #32]

  /* Initialize the 8bit temporary pointer */
  ptmpreg8 = (__IO uint8_t *)&hspi->Instance->DR;
 800b5c0:	68fb      	ldr	r3, [r7, #12]
 800b5c2:	681b      	ldr	r3, [r3, #0]
 800b5c4:	330c      	adds	r3, #12
 800b5c6:	61fb      	str	r3, [r7, #28]

  /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
  count = tmp_timeout * ((SystemCoreClock * 35U) >> 20U);
 800b5c8:	4b3d      	ldr	r3, [pc, #244]	; (800b6c0 <SPI_WaitFifoStateUntilTimeout+0x128>)
 800b5ca:	681a      	ldr	r2, [r3, #0]
 800b5cc:	4613      	mov	r3, r2
 800b5ce:	009b      	lsls	r3, r3, #2
 800b5d0:	4413      	add	r3, r2
 800b5d2:	00da      	lsls	r2, r3, #3
 800b5d4:	1ad3      	subs	r3, r2, r3
 800b5d6:	0d1b      	lsrs	r3, r3, #20
 800b5d8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b5da:	fb02 f303 	mul.w	r3, r2, r3
 800b5de:	61bb      	str	r3, [r7, #24]

  while ((hspi->Instance->SR & Fifo) != State)
 800b5e0:	e060      	b.n	800b6a4 <SPI_WaitFifoStateUntilTimeout+0x10c>
  {
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 800b5e2:	68bb      	ldr	r3, [r7, #8]
 800b5e4:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 800b5e8:	d107      	bne.n	800b5fa <SPI_WaitFifoStateUntilTimeout+0x62>
 800b5ea:	687b      	ldr	r3, [r7, #4]
 800b5ec:	2b00      	cmp	r3, #0
 800b5ee:	d104      	bne.n	800b5fa <SPI_WaitFifoStateUntilTimeout+0x62>
    {
      /* Flush Data Register by a blank read */
      tmpreg8 = *ptmpreg8;
 800b5f0:	69fb      	ldr	r3, [r7, #28]
 800b5f2:	781b      	ldrb	r3, [r3, #0]
 800b5f4:	b2db      	uxtb	r3, r3
 800b5f6:	75fb      	strb	r3, [r7, #23]
      /* To avoid GCC warning */
      UNUSED(tmpreg8);
 800b5f8:	7dfb      	ldrb	r3, [r7, #23]
    }

    if (Timeout != HAL_MAX_DELAY)
 800b5fa:	683b      	ldr	r3, [r7, #0]
 800b5fc:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b600:	d050      	beq.n	800b6a4 <SPI_WaitFifoStateUntilTimeout+0x10c>
    {
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 800b602:	f7fa fba7 	bl	8005d54 <HAL_GetTick>
 800b606:	4602      	mov	r2, r0
 800b608:	6a3b      	ldr	r3, [r7, #32]
 800b60a:	1ad3      	subs	r3, r2, r3
 800b60c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b60e:	429a      	cmp	r2, r3
 800b610:	d902      	bls.n	800b618 <SPI_WaitFifoStateUntilTimeout+0x80>
 800b612:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b614:	2b00      	cmp	r3, #0
 800b616:	d13d      	bne.n	800b694 <SPI_WaitFifoStateUntilTimeout+0xfc>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
           on both master and slave sides in order to resynchronize the master
           and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 800b618:	68fb      	ldr	r3, [r7, #12]
 800b61a:	681b      	ldr	r3, [r3, #0]
 800b61c:	685a      	ldr	r2, [r3, #4]
 800b61e:	68fb      	ldr	r3, [r7, #12]
 800b620:	681b      	ldr	r3, [r3, #0]
 800b622:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 800b626:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800b628:	68fb      	ldr	r3, [r7, #12]
 800b62a:	685b      	ldr	r3, [r3, #4]
 800b62c:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 800b630:	d111      	bne.n	800b656 <SPI_WaitFifoStateUntilTimeout+0xbe>
 800b632:	68fb      	ldr	r3, [r7, #12]
 800b634:	689b      	ldr	r3, [r3, #8]
 800b636:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800b63a:	d004      	beq.n	800b646 <SPI_WaitFifoStateUntilTimeout+0xae>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800b63c:	68fb      	ldr	r3, [r7, #12]
 800b63e:	689b      	ldr	r3, [r3, #8]
 800b640:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800b644:	d107      	bne.n	800b656 <SPI_WaitFifoStateUntilTimeout+0xbe>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 800b646:	68fb      	ldr	r3, [r7, #12]
 800b648:	681b      	ldr	r3, [r3, #0]
 800b64a:	681a      	ldr	r2, [r3, #0]
 800b64c:	68fb      	ldr	r3, [r7, #12]
 800b64e:	681b      	ldr	r3, [r3, #0]
 800b650:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800b654:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800b656:	68fb      	ldr	r3, [r7, #12]
 800b658:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b65a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800b65e:	d10f      	bne.n	800b680 <SPI_WaitFifoStateUntilTimeout+0xe8>
        {
          SPI_RESET_CRC(hspi);
 800b660:	68fb      	ldr	r3, [r7, #12]
 800b662:	681b      	ldr	r3, [r3, #0]
 800b664:	681a      	ldr	r2, [r3, #0]
 800b666:	68fb      	ldr	r3, [r7, #12]
 800b668:	681b      	ldr	r3, [r3, #0]
 800b66a:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800b66e:	601a      	str	r2, [r3, #0]
 800b670:	68fb      	ldr	r3, [r7, #12]
 800b672:	681b      	ldr	r3, [r3, #0]
 800b674:	681a      	ldr	r2, [r3, #0]
 800b676:	68fb      	ldr	r3, [r7, #12]
 800b678:	681b      	ldr	r3, [r3, #0]
 800b67a:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800b67e:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 800b680:	68fb      	ldr	r3, [r7, #12]
 800b682:	2201      	movs	r2, #1
 800b684:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 800b688:	68fb      	ldr	r3, [r7, #12]
 800b68a:	2200      	movs	r2, #0
 800b68c:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

        return HAL_TIMEOUT;
 800b690:	2303      	movs	r3, #3
 800b692:	e010      	b.n	800b6b6 <SPI_WaitFifoStateUntilTimeout+0x11e>
      }
      /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
      if (count == 0U)
 800b694:	69bb      	ldr	r3, [r7, #24]
 800b696:	2b00      	cmp	r3, #0
 800b698:	d101      	bne.n	800b69e <SPI_WaitFifoStateUntilTimeout+0x106>
      {
        tmp_timeout = 0U;
 800b69a:	2300      	movs	r3, #0
 800b69c:	627b      	str	r3, [r7, #36]	; 0x24
      }
      count--;
 800b69e:	69bb      	ldr	r3, [r7, #24]
 800b6a0:	3b01      	subs	r3, #1
 800b6a2:	61bb      	str	r3, [r7, #24]
  while ((hspi->Instance->SR & Fifo) != State)
 800b6a4:	68fb      	ldr	r3, [r7, #12]
 800b6a6:	681b      	ldr	r3, [r3, #0]
 800b6a8:	689a      	ldr	r2, [r3, #8]
 800b6aa:	68bb      	ldr	r3, [r7, #8]
 800b6ac:	4013      	ands	r3, r2
 800b6ae:	687a      	ldr	r2, [r7, #4]
 800b6b0:	429a      	cmp	r2, r3
 800b6b2:	d196      	bne.n	800b5e2 <SPI_WaitFifoStateUntilTimeout+0x4a>
    }
  }

  return HAL_OK;
 800b6b4:	2300      	movs	r3, #0
}
 800b6b6:	4618      	mov	r0, r3
 800b6b8:	3728      	adds	r7, #40	; 0x28
 800b6ba:	46bd      	mov	sp, r7
 800b6bc:	bd80      	pop	{r7, pc}
 800b6be:	bf00      	nop
 800b6c0:	20000008 	.word	0x20000008

0800b6c4 <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 800b6c4:	b580      	push	{r7, lr}
 800b6c6:	b086      	sub	sp, #24
 800b6c8:	af02      	add	r7, sp, #8
 800b6ca:	60f8      	str	r0, [r7, #12]
 800b6cc:	60b9      	str	r1, [r7, #8]
 800b6ce:	607a      	str	r2, [r7, #4]
  /* Control if the TX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 800b6d0:	687b      	ldr	r3, [r7, #4]
 800b6d2:	9300      	str	r3, [sp, #0]
 800b6d4:	68bb      	ldr	r3, [r7, #8]
 800b6d6:	2200      	movs	r2, #0
 800b6d8:	f44f 51c0 	mov.w	r1, #6144	; 0x1800
 800b6dc:	68f8      	ldr	r0, [r7, #12]
 800b6de:	f7ff ff5b 	bl	800b598 <SPI_WaitFifoStateUntilTimeout>
 800b6e2:	4603      	mov	r3, r0
 800b6e4:	2b00      	cmp	r3, #0
 800b6e6:	d007      	beq.n	800b6f8 <SPI_EndRxTxTransaction+0x34>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800b6e8:	68fb      	ldr	r3, [r7, #12]
 800b6ea:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800b6ec:	f043 0220 	orr.w	r2, r3, #32
 800b6f0:	68fb      	ldr	r3, [r7, #12]
 800b6f2:	661a      	str	r2, [r3, #96]	; 0x60
    return HAL_TIMEOUT;
 800b6f4:	2303      	movs	r3, #3
 800b6f6:	e027      	b.n	800b748 <SPI_EndRxTxTransaction+0x84>
  }

  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 800b6f8:	687b      	ldr	r3, [r7, #4]
 800b6fa:	9300      	str	r3, [sp, #0]
 800b6fc:	68bb      	ldr	r3, [r7, #8]
 800b6fe:	2200      	movs	r2, #0
 800b700:	2180      	movs	r1, #128	; 0x80
 800b702:	68f8      	ldr	r0, [r7, #12]
 800b704:	f7ff fec0 	bl	800b488 <SPI_WaitFlagStateUntilTimeout>
 800b708:	4603      	mov	r3, r0
 800b70a:	2b00      	cmp	r3, #0
 800b70c:	d007      	beq.n	800b71e <SPI_EndRxTxTransaction+0x5a>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800b70e:	68fb      	ldr	r3, [r7, #12]
 800b710:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800b712:	f043 0220 	orr.w	r2, r3, #32
 800b716:	68fb      	ldr	r3, [r7, #12]
 800b718:	661a      	str	r2, [r3, #96]	; 0x60
    return HAL_TIMEOUT;
 800b71a:	2303      	movs	r3, #3
 800b71c:	e014      	b.n	800b748 <SPI_EndRxTxTransaction+0x84>
  }

  /* Control if the RX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 800b71e:	687b      	ldr	r3, [r7, #4]
 800b720:	9300      	str	r3, [sp, #0]
 800b722:	68bb      	ldr	r3, [r7, #8]
 800b724:	2200      	movs	r2, #0
 800b726:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 800b72a:	68f8      	ldr	r0, [r7, #12]
 800b72c:	f7ff ff34 	bl	800b598 <SPI_WaitFifoStateUntilTimeout>
 800b730:	4603      	mov	r3, r0
 800b732:	2b00      	cmp	r3, #0
 800b734:	d007      	beq.n	800b746 <SPI_EndRxTxTransaction+0x82>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800b736:	68fb      	ldr	r3, [r7, #12]
 800b738:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800b73a:	f043 0220 	orr.w	r2, r3, #32
 800b73e:	68fb      	ldr	r3, [r7, #12]
 800b740:	661a      	str	r2, [r3, #96]	; 0x60
    return HAL_TIMEOUT;
 800b742:	2303      	movs	r3, #3
 800b744:	e000      	b.n	800b748 <SPI_EndRxTxTransaction+0x84>
  }

  return HAL_OK;
 800b746:	2300      	movs	r3, #0
}
 800b748:	4618      	mov	r0, r3
 800b74a:	3710      	adds	r7, #16
 800b74c:	46bd      	mov	sp, r7
 800b74e:	bd80      	pop	{r7, pc}

0800b750 <HAL_SRAM_Init>:
  * @param  ExtTiming Pointer to SRAM extended mode timing structure
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SRAM_Init(SRAM_HandleTypeDef *hsram, FMC_NORSRAM_TimingTypeDef *Timing,
                                FMC_NORSRAM_TimingTypeDef *ExtTiming)
{
 800b750:	b580      	push	{r7, lr}
 800b752:	b084      	sub	sp, #16
 800b754:	af00      	add	r7, sp, #0
 800b756:	60f8      	str	r0, [r7, #12]
 800b758:	60b9      	str	r1, [r7, #8]
 800b75a:	607a      	str	r2, [r7, #4]
  /* Check the SRAM handle parameter */
  if (hsram == NULL)
 800b75c:	68fb      	ldr	r3, [r7, #12]
 800b75e:	2b00      	cmp	r3, #0
 800b760:	d101      	bne.n	800b766 <HAL_SRAM_Init+0x16>
  {
    return HAL_ERROR;
 800b762:	2301      	movs	r3, #1
 800b764:	e038      	b.n	800b7d8 <HAL_SRAM_Init+0x88>
  }

  if (hsram->State == HAL_SRAM_STATE_RESET)
 800b766:	68fb      	ldr	r3, [r7, #12]
 800b768:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 800b76c:	b2db      	uxtb	r3, r3
 800b76e:	2b00      	cmp	r3, #0
 800b770:	d106      	bne.n	800b780 <HAL_SRAM_Init+0x30>
  {
    /* Allocate lock resource and initialize it */
    hsram->Lock = HAL_UNLOCKED;
 800b772:	68fb      	ldr	r3, [r7, #12]
 800b774:	2200      	movs	r2, #0
 800b776:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    /* Init the low level hardware */
    hsram->MspInitCallback(hsram);
#else
    /* Initialize the low level hardware (MSP) */
    HAL_SRAM_MspInit(hsram);
 800b77a:	68f8      	ldr	r0, [r7, #12]
 800b77c:	f7f6 f89c 	bl	80018b8 <HAL_SRAM_MspInit>
#endif /* USE_HAL_SRAM_REGISTER_CALLBACKS */
  }

  /* Initialize SRAM control Interface */
  (void)FMC_NORSRAM_Init(hsram->Instance, &(hsram->Init));
 800b780:	68fb      	ldr	r3, [r7, #12]
 800b782:	681a      	ldr	r2, [r3, #0]
 800b784:	68fb      	ldr	r3, [r7, #12]
 800b786:	3308      	adds	r3, #8
 800b788:	4619      	mov	r1, r3
 800b78a:	4610      	mov	r0, r2
 800b78c:	f001 fb3c 	bl	800ce08 <FMC_NORSRAM_Init>

  /* Initialize SRAM timing Interface */
  (void)FMC_NORSRAM_Timing_Init(hsram->Instance, Timing, hsram->Init.NSBank);
 800b790:	68fb      	ldr	r3, [r7, #12]
 800b792:	6818      	ldr	r0, [r3, #0]
 800b794:	68fb      	ldr	r3, [r7, #12]
 800b796:	689b      	ldr	r3, [r3, #8]
 800b798:	461a      	mov	r2, r3
 800b79a:	68b9      	ldr	r1, [r7, #8]
 800b79c:	f001 fc02 	bl	800cfa4 <FMC_NORSRAM_Timing_Init>

  /* Initialize SRAM extended mode timing Interface */
  (void)FMC_NORSRAM_Extended_Timing_Init(hsram->Extended, ExtTiming, hsram->Init.NSBank,
 800b7a0:	68fb      	ldr	r3, [r7, #12]
 800b7a2:	6858      	ldr	r0, [r3, #4]
 800b7a4:	68fb      	ldr	r3, [r7, #12]
 800b7a6:	689a      	ldr	r2, [r3, #8]
 800b7a8:	68fb      	ldr	r3, [r7, #12]
 800b7aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b7ac:	6879      	ldr	r1, [r7, #4]
 800b7ae:	f001 fc4b 	bl	800d048 <FMC_NORSRAM_Extended_Timing_Init>
                                         hsram->Init.ExtendedMode);

  /* Enable the NORSRAM device */
  __FMC_NORSRAM_ENABLE(hsram->Instance, hsram->Init.NSBank);
 800b7b2:	68fb      	ldr	r3, [r7, #12]
 800b7b4:	681b      	ldr	r3, [r3, #0]
 800b7b6:	68fa      	ldr	r2, [r7, #12]
 800b7b8:	6892      	ldr	r2, [r2, #8]
 800b7ba:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800b7be:	68fb      	ldr	r3, [r7, #12]
 800b7c0:	681b      	ldr	r3, [r3, #0]
 800b7c2:	68fa      	ldr	r2, [r7, #12]
 800b7c4:	6892      	ldr	r2, [r2, #8]
 800b7c6:	f041 0101 	orr.w	r1, r1, #1
 800b7ca:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

  /* Initialize the SRAM controller state */
  hsram->State = HAL_SRAM_STATE_READY;
 800b7ce:	68fb      	ldr	r3, [r7, #12]
 800b7d0:	2201      	movs	r2, #1
 800b7d2:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

  return HAL_OK;
 800b7d6:	2300      	movs	r3, #0
}
 800b7d8:	4618      	mov	r0, r3
 800b7da:	3710      	adds	r7, #16
 800b7dc:	46bd      	mov	sp, r7
 800b7de:	bd80      	pop	{r7, pc}

0800b7e0 <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 800b7e0:	b580      	push	{r7, lr}
 800b7e2:	b082      	sub	sp, #8
 800b7e4:	af00      	add	r7, sp, #0
 800b7e6:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 800b7e8:	687b      	ldr	r3, [r7, #4]
 800b7ea:	2b00      	cmp	r3, #0
 800b7ec:	d101      	bne.n	800b7f2 <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 800b7ee:	2301      	movs	r3, #1
 800b7f0:	e049      	b.n	800b886 <HAL_TIM_Base_Init+0xa6>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 800b7f2:	687b      	ldr	r3, [r7, #4]
 800b7f4:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800b7f8:	b2db      	uxtb	r3, r3
 800b7fa:	2b00      	cmp	r3, #0
 800b7fc:	d106      	bne.n	800b80c <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 800b7fe:	687b      	ldr	r3, [r7, #4]
 800b800:	2200      	movs	r2, #0
 800b802:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 800b806:	6878      	ldr	r0, [r7, #4]
 800b808:	f7fa f9ca 	bl	8005ba0 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800b80c:	687b      	ldr	r3, [r7, #4]
 800b80e:	2202      	movs	r2, #2
 800b810:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800b814:	687b      	ldr	r3, [r7, #4]
 800b816:	681a      	ldr	r2, [r3, #0]
 800b818:	687b      	ldr	r3, [r7, #4]
 800b81a:	3304      	adds	r3, #4
 800b81c:	4619      	mov	r1, r3
 800b81e:	4610      	mov	r0, r2
 800b820:	f000 fd82 	bl	800c328 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800b824:	687b      	ldr	r3, [r7, #4]
 800b826:	2201      	movs	r2, #1
 800b828:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800b82c:	687b      	ldr	r3, [r7, #4]
 800b82e:	2201      	movs	r2, #1
 800b830:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 800b834:	687b      	ldr	r3, [r7, #4]
 800b836:	2201      	movs	r2, #1
 800b838:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
 800b83c:	687b      	ldr	r3, [r7, #4]
 800b83e:	2201      	movs	r2, #1
 800b840:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 800b844:	687b      	ldr	r3, [r7, #4]
 800b846:	2201      	movs	r2, #1
 800b848:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
 800b84c:	687b      	ldr	r3, [r7, #4]
 800b84e:	2201      	movs	r2, #1
 800b850:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 800b854:	687b      	ldr	r3, [r7, #4]
 800b856:	2201      	movs	r2, #1
 800b858:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800b85c:	687b      	ldr	r3, [r7, #4]
 800b85e:	2201      	movs	r2, #1
 800b860:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 800b864:	687b      	ldr	r3, [r7, #4]
 800b866:	2201      	movs	r2, #1
 800b868:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 800b86c:	687b      	ldr	r3, [r7, #4]
 800b86e:	2201      	movs	r2, #1
 800b870:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
 800b874:	687b      	ldr	r3, [r7, #4]
 800b876:	2201      	movs	r2, #1
 800b878:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 800b87c:	687b      	ldr	r3, [r7, #4]
 800b87e:	2201      	movs	r2, #1
 800b880:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 800b884:	2300      	movs	r3, #0
}
 800b886:	4618      	mov	r0, r3
 800b888:	3708      	adds	r7, #8
 800b88a:	46bd      	mov	sp, r7
 800b88c:	bd80      	pop	{r7, pc}
	...

0800b890 <HAL_TIM_Base_Start>:
  * @brief  Starts the TIM Base generation.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
{
 800b890:	b480      	push	{r7}
 800b892:	b085      	sub	sp, #20
 800b894:	af00      	add	r7, sp, #0
 800b896:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 800b898:	687b      	ldr	r3, [r7, #4]
 800b89a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800b89e:	b2db      	uxtb	r3, r3
 800b8a0:	2b01      	cmp	r3, #1
 800b8a2:	d001      	beq.n	800b8a8 <HAL_TIM_Base_Start+0x18>
  {
    return HAL_ERROR;
 800b8a4:	2301      	movs	r3, #1
 800b8a6:	e04c      	b.n	800b942 <HAL_TIM_Base_Start+0xb2>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800b8a8:	687b      	ldr	r3, [r7, #4]
 800b8aa:	2202      	movs	r2, #2
 800b8ac:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800b8b0:	687b      	ldr	r3, [r7, #4]
 800b8b2:	681b      	ldr	r3, [r3, #0]
 800b8b4:	4a26      	ldr	r2, [pc, #152]	; (800b950 <HAL_TIM_Base_Start+0xc0>)
 800b8b6:	4293      	cmp	r3, r2
 800b8b8:	d022      	beq.n	800b900 <HAL_TIM_Base_Start+0x70>
 800b8ba:	687b      	ldr	r3, [r7, #4]
 800b8bc:	681b      	ldr	r3, [r3, #0]
 800b8be:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800b8c2:	d01d      	beq.n	800b900 <HAL_TIM_Base_Start+0x70>
 800b8c4:	687b      	ldr	r3, [r7, #4]
 800b8c6:	681b      	ldr	r3, [r3, #0]
 800b8c8:	4a22      	ldr	r2, [pc, #136]	; (800b954 <HAL_TIM_Base_Start+0xc4>)
 800b8ca:	4293      	cmp	r3, r2
 800b8cc:	d018      	beq.n	800b900 <HAL_TIM_Base_Start+0x70>
 800b8ce:	687b      	ldr	r3, [r7, #4]
 800b8d0:	681b      	ldr	r3, [r3, #0]
 800b8d2:	4a21      	ldr	r2, [pc, #132]	; (800b958 <HAL_TIM_Base_Start+0xc8>)
 800b8d4:	4293      	cmp	r3, r2
 800b8d6:	d013      	beq.n	800b900 <HAL_TIM_Base_Start+0x70>
 800b8d8:	687b      	ldr	r3, [r7, #4]
 800b8da:	681b      	ldr	r3, [r3, #0]
 800b8dc:	4a1f      	ldr	r2, [pc, #124]	; (800b95c <HAL_TIM_Base_Start+0xcc>)
 800b8de:	4293      	cmp	r3, r2
 800b8e0:	d00e      	beq.n	800b900 <HAL_TIM_Base_Start+0x70>
 800b8e2:	687b      	ldr	r3, [r7, #4]
 800b8e4:	681b      	ldr	r3, [r3, #0]
 800b8e6:	4a1e      	ldr	r2, [pc, #120]	; (800b960 <HAL_TIM_Base_Start+0xd0>)
 800b8e8:	4293      	cmp	r3, r2
 800b8ea:	d009      	beq.n	800b900 <HAL_TIM_Base_Start+0x70>
 800b8ec:	687b      	ldr	r3, [r7, #4]
 800b8ee:	681b      	ldr	r3, [r3, #0]
 800b8f0:	4a1c      	ldr	r2, [pc, #112]	; (800b964 <HAL_TIM_Base_Start+0xd4>)
 800b8f2:	4293      	cmp	r3, r2
 800b8f4:	d004      	beq.n	800b900 <HAL_TIM_Base_Start+0x70>
 800b8f6:	687b      	ldr	r3, [r7, #4]
 800b8f8:	681b      	ldr	r3, [r3, #0]
 800b8fa:	4a1b      	ldr	r2, [pc, #108]	; (800b968 <HAL_TIM_Base_Start+0xd8>)
 800b8fc:	4293      	cmp	r3, r2
 800b8fe:	d115      	bne.n	800b92c <HAL_TIM_Base_Start+0x9c>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800b900:	687b      	ldr	r3, [r7, #4]
 800b902:	681b      	ldr	r3, [r3, #0]
 800b904:	689a      	ldr	r2, [r3, #8]
 800b906:	4b19      	ldr	r3, [pc, #100]	; (800b96c <HAL_TIM_Base_Start+0xdc>)
 800b908:	4013      	ands	r3, r2
 800b90a:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800b90c:	68fb      	ldr	r3, [r7, #12]
 800b90e:	2b06      	cmp	r3, #6
 800b910:	d015      	beq.n	800b93e <HAL_TIM_Base_Start+0xae>
 800b912:	68fb      	ldr	r3, [r7, #12]
 800b914:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800b918:	d011      	beq.n	800b93e <HAL_TIM_Base_Start+0xae>
    {
      __HAL_TIM_ENABLE(htim);
 800b91a:	687b      	ldr	r3, [r7, #4]
 800b91c:	681b      	ldr	r3, [r3, #0]
 800b91e:	681a      	ldr	r2, [r3, #0]
 800b920:	687b      	ldr	r3, [r7, #4]
 800b922:	681b      	ldr	r3, [r3, #0]
 800b924:	f042 0201 	orr.w	r2, r2, #1
 800b928:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800b92a:	e008      	b.n	800b93e <HAL_TIM_Base_Start+0xae>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 800b92c:	687b      	ldr	r3, [r7, #4]
 800b92e:	681b      	ldr	r3, [r3, #0]
 800b930:	681a      	ldr	r2, [r3, #0]
 800b932:	687b      	ldr	r3, [r7, #4]
 800b934:	681b      	ldr	r3, [r3, #0]
 800b936:	f042 0201 	orr.w	r2, r2, #1
 800b93a:	601a      	str	r2, [r3, #0]
 800b93c:	e000      	b.n	800b940 <HAL_TIM_Base_Start+0xb0>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800b93e:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
 800b940:	2300      	movs	r3, #0
}
 800b942:	4618      	mov	r0, r3
 800b944:	3714      	adds	r7, #20
 800b946:	46bd      	mov	sp, r7
 800b948:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b94c:	4770      	bx	lr
 800b94e:	bf00      	nop
 800b950:	40012c00 	.word	0x40012c00
 800b954:	40000400 	.word	0x40000400
 800b958:	40000800 	.word	0x40000800
 800b95c:	40000c00 	.word	0x40000c00
 800b960:	40013400 	.word	0x40013400
 800b964:	40014000 	.word	0x40014000
 800b968:	40015000 	.word	0x40015000
 800b96c:	00010007 	.word	0x00010007

0800b970 <HAL_TIM_Base_Stop>:
  * @brief  Stops the TIM Base generation.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
{
 800b970:	b480      	push	{r7}
 800b972:	b083      	sub	sp, #12
 800b974:	af00      	add	r7, sp, #0
 800b976:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
 800b978:	687b      	ldr	r3, [r7, #4]
 800b97a:	681b      	ldr	r3, [r3, #0]
 800b97c:	6a1a      	ldr	r2, [r3, #32]
 800b97e:	f241 1311 	movw	r3, #4369	; 0x1111
 800b982:	4013      	ands	r3, r2
 800b984:	2b00      	cmp	r3, #0
 800b986:	d10f      	bne.n	800b9a8 <HAL_TIM_Base_Stop+0x38>
 800b988:	687b      	ldr	r3, [r7, #4]
 800b98a:	681b      	ldr	r3, [r3, #0]
 800b98c:	6a1a      	ldr	r2, [r3, #32]
 800b98e:	f244 4344 	movw	r3, #17476	; 0x4444
 800b992:	4013      	ands	r3, r2
 800b994:	2b00      	cmp	r3, #0
 800b996:	d107      	bne.n	800b9a8 <HAL_TIM_Base_Stop+0x38>
 800b998:	687b      	ldr	r3, [r7, #4]
 800b99a:	681b      	ldr	r3, [r3, #0]
 800b99c:	681a      	ldr	r2, [r3, #0]
 800b99e:	687b      	ldr	r3, [r7, #4]
 800b9a0:	681b      	ldr	r3, [r3, #0]
 800b9a2:	f022 0201 	bic.w	r2, r2, #1
 800b9a6:	601a      	str	r2, [r3, #0]

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_READY;
 800b9a8:	687b      	ldr	r3, [r7, #4]
 800b9aa:	2201      	movs	r2, #1
 800b9ac:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Return function status */
  return HAL_OK;
 800b9b0:	2300      	movs	r3, #0
}
 800b9b2:	4618      	mov	r0, r3
 800b9b4:	370c      	adds	r7, #12
 800b9b6:	46bd      	mov	sp, r7
 800b9b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b9bc:	4770      	bx	lr

0800b9be <HAL_TIM_OC_Init>:
  *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()
  * @param  htim TIM Output Compare handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)
{
 800b9be:	b580      	push	{r7, lr}
 800b9c0:	b082      	sub	sp, #8
 800b9c2:	af00      	add	r7, sp, #0
 800b9c4:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 800b9c6:	687b      	ldr	r3, [r7, #4]
 800b9c8:	2b00      	cmp	r3, #0
 800b9ca:	d101      	bne.n	800b9d0 <HAL_TIM_OC_Init+0x12>
  {
    return HAL_ERROR;
 800b9cc:	2301      	movs	r3, #1
 800b9ce:	e049      	b.n	800ba64 <HAL_TIM_OC_Init+0xa6>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 800b9d0:	687b      	ldr	r3, [r7, #4]
 800b9d2:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800b9d6:	b2db      	uxtb	r3, r3
 800b9d8:	2b00      	cmp	r3, #0
 800b9da:	d106      	bne.n	800b9ea <HAL_TIM_OC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 800b9dc:	687b      	ldr	r3, [r7, #4]
 800b9de:	2200      	movs	r2, #0
 800b9e0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->OC_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_OC_MspInit(htim);
 800b9e4:	6878      	ldr	r0, [r7, #4]
 800b9e6:	f000 f841 	bl	800ba6c <HAL_TIM_OC_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800b9ea:	687b      	ldr	r3, [r7, #4]
 800b9ec:	2202      	movs	r2, #2
 800b9ee:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Init the base time for the Output Compare */
  TIM_Base_SetConfig(htim->Instance,  &htim->Init);
 800b9f2:	687b      	ldr	r3, [r7, #4]
 800b9f4:	681a      	ldr	r2, [r3, #0]
 800b9f6:	687b      	ldr	r3, [r7, #4]
 800b9f8:	3304      	adds	r3, #4
 800b9fa:	4619      	mov	r1, r3
 800b9fc:	4610      	mov	r0, r2
 800b9fe:	f000 fc93 	bl	800c328 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800ba02:	687b      	ldr	r3, [r7, #4]
 800ba04:	2201      	movs	r2, #1
 800ba06:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800ba0a:	687b      	ldr	r3, [r7, #4]
 800ba0c:	2201      	movs	r2, #1
 800ba0e:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 800ba12:	687b      	ldr	r3, [r7, #4]
 800ba14:	2201      	movs	r2, #1
 800ba16:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
 800ba1a:	687b      	ldr	r3, [r7, #4]
 800ba1c:	2201      	movs	r2, #1
 800ba1e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 800ba22:	687b      	ldr	r3, [r7, #4]
 800ba24:	2201      	movs	r2, #1
 800ba26:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
 800ba2a:	687b      	ldr	r3, [r7, #4]
 800ba2c:	2201      	movs	r2, #1
 800ba2e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 800ba32:	687b      	ldr	r3, [r7, #4]
 800ba34:	2201      	movs	r2, #1
 800ba36:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800ba3a:	687b      	ldr	r3, [r7, #4]
 800ba3c:	2201      	movs	r2, #1
 800ba3e:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 800ba42:	687b      	ldr	r3, [r7, #4]
 800ba44:	2201      	movs	r2, #1
 800ba46:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 800ba4a:	687b      	ldr	r3, [r7, #4]
 800ba4c:	2201      	movs	r2, #1
 800ba4e:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
 800ba52:	687b      	ldr	r3, [r7, #4]
 800ba54:	2201      	movs	r2, #1
 800ba56:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 800ba5a:	687b      	ldr	r3, [r7, #4]
 800ba5c:	2201      	movs	r2, #1
 800ba5e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 800ba62:	2300      	movs	r3, #0
}
 800ba64:	4618      	mov	r0, r3
 800ba66:	3708      	adds	r7, #8
 800ba68:	46bd      	mov	sp, r7
 800ba6a:	bd80      	pop	{r7, pc}

0800ba6c <HAL_TIM_OC_MspInit>:
  * @brief  Initializes the TIM Output Compare MSP.
  * @param  htim TIM Output Compare handle
  * @retval None
  */
__weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
{
 800ba6c:	b480      	push	{r7}
 800ba6e:	b083      	sub	sp, #12
 800ba70:	af00      	add	r7, sp, #0
 800ba72:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_MspInit could be implemented in the user file
   */
}
 800ba74:	bf00      	nop
 800ba76:	370c      	adds	r7, #12
 800ba78:	46bd      	mov	sp, r7
 800ba7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ba7e:	4770      	bx	lr

0800ba80 <HAL_TIM_OnePulse_Start_IT>:
  * @param  htim TIM One Pulse handle
  * @param  OutputChannel See note above
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
{
 800ba80:	b580      	push	{r7, lr}
 800ba82:	b084      	sub	sp, #16
 800ba84:	af00      	add	r7, sp, #0
 800ba86:	6078      	str	r0, [r7, #4]
 800ba88:	6039      	str	r1, [r7, #0]
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
 800ba8a:	687b      	ldr	r3, [r7, #4]
 800ba8c:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 800ba90:	73fb      	strb	r3, [r7, #15]
  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
 800ba92:	687b      	ldr	r3, [r7, #4]
 800ba94:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
 800ba98:	73bb      	strb	r3, [r7, #14]
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
 800ba9a:	687b      	ldr	r3, [r7, #4]
 800ba9c:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 800baa0:	737b      	strb	r3, [r7, #13]
  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
 800baa2:	687b      	ldr	r3, [r7, #4]
 800baa4:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 800baa8:	733b      	strb	r3, [r7, #12]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(OutputChannel);

  /* Check the TIM channels state */
  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 800baaa:	7bfb      	ldrb	r3, [r7, #15]
 800baac:	2b01      	cmp	r3, #1
 800baae:	d108      	bne.n	800bac2 <HAL_TIM_OnePulse_Start_IT+0x42>
      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
 800bab0:	7bbb      	ldrb	r3, [r7, #14]
 800bab2:	2b01      	cmp	r3, #1
 800bab4:	d105      	bne.n	800bac2 <HAL_TIM_OnePulse_Start_IT+0x42>
      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 800bab6:	7b7b      	ldrb	r3, [r7, #13]
 800bab8:	2b01      	cmp	r3, #1
 800baba:	d102      	bne.n	800bac2 <HAL_TIM_OnePulse_Start_IT+0x42>
      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
 800babc:	7b3b      	ldrb	r3, [r7, #12]
 800babe:	2b01      	cmp	r3, #1
 800bac0:	d001      	beq.n	800bac6 <HAL_TIM_OnePulse_Start_IT+0x46>
  {
    return HAL_ERROR;
 800bac2:	2301      	movs	r3, #1
 800bac4:	e059      	b.n	800bb7a <HAL_TIM_OnePulse_Start_IT+0xfa>
  }

  /* Set the TIM channels state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 800bac6:	687b      	ldr	r3, [r7, #4]
 800bac8:	2202      	movs	r2, #2
 800baca:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 800bace:	687b      	ldr	r3, [r7, #4]
 800bad0:	2202      	movs	r2, #2
 800bad2:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 800bad6:	687b      	ldr	r3, [r7, #4]
 800bad8:	2202      	movs	r2, #2
 800bada:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 800bade:	687b      	ldr	r3, [r7, #4]
 800bae0:	2202      	movs	r2, #2
 800bae2:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

    No need to enable the counter, it's enabled automatically by hardware
    (the counter starts in response to a stimulus and generate a pulse */

  /* Enable the TIM Capture/Compare 1 interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 800bae6:	687b      	ldr	r3, [r7, #4]
 800bae8:	681b      	ldr	r3, [r3, #0]
 800baea:	68da      	ldr	r2, [r3, #12]
 800baec:	687b      	ldr	r3, [r7, #4]
 800baee:	681b      	ldr	r3, [r3, #0]
 800baf0:	f042 0202 	orr.w	r2, r2, #2
 800baf4:	60da      	str	r2, [r3, #12]

  /* Enable the TIM Capture/Compare 2 interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 800baf6:	687b      	ldr	r3, [r7, #4]
 800baf8:	681b      	ldr	r3, [r3, #0]
 800bafa:	68da      	ldr	r2, [r3, #12]
 800bafc:	687b      	ldr	r3, [r7, #4]
 800bafe:	681b      	ldr	r3, [r3, #0]
 800bb00:	f042 0204 	orr.w	r2, r2, #4
 800bb04:	60da      	str	r2, [r3, #12]

  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
 800bb06:	687b      	ldr	r3, [r7, #4]
 800bb08:	681b      	ldr	r3, [r3, #0]
 800bb0a:	2201      	movs	r2, #1
 800bb0c:	2100      	movs	r1, #0
 800bb0e:	4618      	mov	r0, r3
 800bb10:	f001 f878 	bl	800cc04 <TIM_CCxChannelCmd>
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
 800bb14:	687b      	ldr	r3, [r7, #4]
 800bb16:	681b      	ldr	r3, [r3, #0]
 800bb18:	2201      	movs	r2, #1
 800bb1a:	2104      	movs	r1, #4
 800bb1c:	4618      	mov	r0, r3
 800bb1e:	f001 f871 	bl	800cc04 <TIM_CCxChannelCmd>

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 800bb22:	687b      	ldr	r3, [r7, #4]
 800bb24:	681b      	ldr	r3, [r3, #0]
 800bb26:	4a17      	ldr	r2, [pc, #92]	; (800bb84 <HAL_TIM_OnePulse_Start_IT+0x104>)
 800bb28:	4293      	cmp	r3, r2
 800bb2a:	d018      	beq.n	800bb5e <HAL_TIM_OnePulse_Start_IT+0xde>
 800bb2c:	687b      	ldr	r3, [r7, #4]
 800bb2e:	681b      	ldr	r3, [r3, #0]
 800bb30:	4a15      	ldr	r2, [pc, #84]	; (800bb88 <HAL_TIM_OnePulse_Start_IT+0x108>)
 800bb32:	4293      	cmp	r3, r2
 800bb34:	d013      	beq.n	800bb5e <HAL_TIM_OnePulse_Start_IT+0xde>
 800bb36:	687b      	ldr	r3, [r7, #4]
 800bb38:	681b      	ldr	r3, [r3, #0]
 800bb3a:	4a14      	ldr	r2, [pc, #80]	; (800bb8c <HAL_TIM_OnePulse_Start_IT+0x10c>)
 800bb3c:	4293      	cmp	r3, r2
 800bb3e:	d00e      	beq.n	800bb5e <HAL_TIM_OnePulse_Start_IT+0xde>
 800bb40:	687b      	ldr	r3, [r7, #4]
 800bb42:	681b      	ldr	r3, [r3, #0]
 800bb44:	4a12      	ldr	r2, [pc, #72]	; (800bb90 <HAL_TIM_OnePulse_Start_IT+0x110>)
 800bb46:	4293      	cmp	r3, r2
 800bb48:	d009      	beq.n	800bb5e <HAL_TIM_OnePulse_Start_IT+0xde>
 800bb4a:	687b      	ldr	r3, [r7, #4]
 800bb4c:	681b      	ldr	r3, [r3, #0]
 800bb4e:	4a11      	ldr	r2, [pc, #68]	; (800bb94 <HAL_TIM_OnePulse_Start_IT+0x114>)
 800bb50:	4293      	cmp	r3, r2
 800bb52:	d004      	beq.n	800bb5e <HAL_TIM_OnePulse_Start_IT+0xde>
 800bb54:	687b      	ldr	r3, [r7, #4]
 800bb56:	681b      	ldr	r3, [r3, #0]
 800bb58:	4a0f      	ldr	r2, [pc, #60]	; (800bb98 <HAL_TIM_OnePulse_Start_IT+0x118>)
 800bb5a:	4293      	cmp	r3, r2
 800bb5c:	d101      	bne.n	800bb62 <HAL_TIM_OnePulse_Start_IT+0xe2>
 800bb5e:	2301      	movs	r3, #1
 800bb60:	e000      	b.n	800bb64 <HAL_TIM_OnePulse_Start_IT+0xe4>
 800bb62:	2300      	movs	r3, #0
 800bb64:	2b00      	cmp	r3, #0
 800bb66:	d007      	beq.n	800bb78 <HAL_TIM_OnePulse_Start_IT+0xf8>
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
 800bb68:	687b      	ldr	r3, [r7, #4]
 800bb6a:	681b      	ldr	r3, [r3, #0]
 800bb6c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800bb6e:	687b      	ldr	r3, [r7, #4]
 800bb70:	681b      	ldr	r3, [r3, #0]
 800bb72:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800bb76:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Return function status */
  return HAL_OK;
 800bb78:	2300      	movs	r3, #0
}
 800bb7a:	4618      	mov	r0, r3
 800bb7c:	3710      	adds	r7, #16
 800bb7e:	46bd      	mov	sp, r7
 800bb80:	bd80      	pop	{r7, pc}
 800bb82:	bf00      	nop
 800bb84:	40012c00 	.word	0x40012c00
 800bb88:	40013400 	.word	0x40013400
 800bb8c:	40014000 	.word	0x40014000
 800bb90:	40014400 	.word	0x40014400
 800bb94:	40014800 	.word	0x40014800
 800bb98:	40015000 	.word	0x40015000

0800bb9c <HAL_TIM_OnePulse_Stop_IT>:
  * @param  htim TIM One Pulse handle
  * @param  OutputChannel See note above
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
{
 800bb9c:	b580      	push	{r7, lr}
 800bb9e:	b082      	sub	sp, #8
 800bba0:	af00      	add	r7, sp, #0
 800bba2:	6078      	str	r0, [r7, #4]
 800bba4:	6039      	str	r1, [r7, #0]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(OutputChannel);

  /* Disable the TIM Capture/Compare 1 interrupt */
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
 800bba6:	687b      	ldr	r3, [r7, #4]
 800bba8:	681b      	ldr	r3, [r3, #0]
 800bbaa:	68da      	ldr	r2, [r3, #12]
 800bbac:	687b      	ldr	r3, [r7, #4]
 800bbae:	681b      	ldr	r3, [r3, #0]
 800bbb0:	f022 0202 	bic.w	r2, r2, #2
 800bbb4:	60da      	str	r2, [r3, #12]

  /* Disable the TIM Capture/Compare 2 interrupt */
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
 800bbb6:	687b      	ldr	r3, [r7, #4]
 800bbb8:	681b      	ldr	r3, [r3, #0]
 800bbba:	68da      	ldr	r2, [r3, #12]
 800bbbc:	687b      	ldr	r3, [r7, #4]
 800bbbe:	681b      	ldr	r3, [r3, #0]
 800bbc0:	f022 0204 	bic.w	r2, r2, #4
 800bbc4:	60da      	str	r2, [r3, #12]
  /* Disable the Capture compare and the Input Capture channels
  (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
  if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
  if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
  whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
 800bbc6:	687b      	ldr	r3, [r7, #4]
 800bbc8:	681b      	ldr	r3, [r3, #0]
 800bbca:	2200      	movs	r2, #0
 800bbcc:	2100      	movs	r1, #0
 800bbce:	4618      	mov	r0, r3
 800bbd0:	f001 f818 	bl	800cc04 <TIM_CCxChannelCmd>
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
 800bbd4:	687b      	ldr	r3, [r7, #4]
 800bbd6:	681b      	ldr	r3, [r3, #0]
 800bbd8:	2200      	movs	r2, #0
 800bbda:	2104      	movs	r1, #4
 800bbdc:	4618      	mov	r0, r3
 800bbde:	f001 f811 	bl	800cc04 <TIM_CCxChannelCmd>

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 800bbe2:	687b      	ldr	r3, [r7, #4]
 800bbe4:	681b      	ldr	r3, [r3, #0]
 800bbe6:	4a33      	ldr	r2, [pc, #204]	; (800bcb4 <HAL_TIM_OnePulse_Stop_IT+0x118>)
 800bbe8:	4293      	cmp	r3, r2
 800bbea:	d018      	beq.n	800bc1e <HAL_TIM_OnePulse_Stop_IT+0x82>
 800bbec:	687b      	ldr	r3, [r7, #4]
 800bbee:	681b      	ldr	r3, [r3, #0]
 800bbf0:	4a31      	ldr	r2, [pc, #196]	; (800bcb8 <HAL_TIM_OnePulse_Stop_IT+0x11c>)
 800bbf2:	4293      	cmp	r3, r2
 800bbf4:	d013      	beq.n	800bc1e <HAL_TIM_OnePulse_Stop_IT+0x82>
 800bbf6:	687b      	ldr	r3, [r7, #4]
 800bbf8:	681b      	ldr	r3, [r3, #0]
 800bbfa:	4a30      	ldr	r2, [pc, #192]	; (800bcbc <HAL_TIM_OnePulse_Stop_IT+0x120>)
 800bbfc:	4293      	cmp	r3, r2
 800bbfe:	d00e      	beq.n	800bc1e <HAL_TIM_OnePulse_Stop_IT+0x82>
 800bc00:	687b      	ldr	r3, [r7, #4]
 800bc02:	681b      	ldr	r3, [r3, #0]
 800bc04:	4a2e      	ldr	r2, [pc, #184]	; (800bcc0 <HAL_TIM_OnePulse_Stop_IT+0x124>)
 800bc06:	4293      	cmp	r3, r2
 800bc08:	d009      	beq.n	800bc1e <HAL_TIM_OnePulse_Stop_IT+0x82>
 800bc0a:	687b      	ldr	r3, [r7, #4]
 800bc0c:	681b      	ldr	r3, [r3, #0]
 800bc0e:	4a2d      	ldr	r2, [pc, #180]	; (800bcc4 <HAL_TIM_OnePulse_Stop_IT+0x128>)
 800bc10:	4293      	cmp	r3, r2
 800bc12:	d004      	beq.n	800bc1e <HAL_TIM_OnePulse_Stop_IT+0x82>
 800bc14:	687b      	ldr	r3, [r7, #4]
 800bc16:	681b      	ldr	r3, [r3, #0]
 800bc18:	4a2b      	ldr	r2, [pc, #172]	; (800bcc8 <HAL_TIM_OnePulse_Stop_IT+0x12c>)
 800bc1a:	4293      	cmp	r3, r2
 800bc1c:	d101      	bne.n	800bc22 <HAL_TIM_OnePulse_Stop_IT+0x86>
 800bc1e:	2301      	movs	r3, #1
 800bc20:	e000      	b.n	800bc24 <HAL_TIM_OnePulse_Stop_IT+0x88>
 800bc22:	2300      	movs	r3, #0
 800bc24:	2b00      	cmp	r3, #0
 800bc26:	d017      	beq.n	800bc58 <HAL_TIM_OnePulse_Stop_IT+0xbc>
  {
    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
 800bc28:	687b      	ldr	r3, [r7, #4]
 800bc2a:	681b      	ldr	r3, [r3, #0]
 800bc2c:	6a1a      	ldr	r2, [r3, #32]
 800bc2e:	f241 1311 	movw	r3, #4369	; 0x1111
 800bc32:	4013      	ands	r3, r2
 800bc34:	2b00      	cmp	r3, #0
 800bc36:	d10f      	bne.n	800bc58 <HAL_TIM_OnePulse_Stop_IT+0xbc>
 800bc38:	687b      	ldr	r3, [r7, #4]
 800bc3a:	681b      	ldr	r3, [r3, #0]
 800bc3c:	6a1a      	ldr	r2, [r3, #32]
 800bc3e:	f244 4344 	movw	r3, #17476	; 0x4444
 800bc42:	4013      	ands	r3, r2
 800bc44:	2b00      	cmp	r3, #0
 800bc46:	d107      	bne.n	800bc58 <HAL_TIM_OnePulse_Stop_IT+0xbc>
 800bc48:	687b      	ldr	r3, [r7, #4]
 800bc4a:	681b      	ldr	r3, [r3, #0]
 800bc4c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800bc4e:	687b      	ldr	r3, [r7, #4]
 800bc50:	681b      	ldr	r3, [r3, #0]
 800bc52:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800bc56:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
 800bc58:	687b      	ldr	r3, [r7, #4]
 800bc5a:	681b      	ldr	r3, [r3, #0]
 800bc5c:	6a1a      	ldr	r2, [r3, #32]
 800bc5e:	f241 1311 	movw	r3, #4369	; 0x1111
 800bc62:	4013      	ands	r3, r2
 800bc64:	2b00      	cmp	r3, #0
 800bc66:	d10f      	bne.n	800bc88 <HAL_TIM_OnePulse_Stop_IT+0xec>
 800bc68:	687b      	ldr	r3, [r7, #4]
 800bc6a:	681b      	ldr	r3, [r3, #0]
 800bc6c:	6a1a      	ldr	r2, [r3, #32]
 800bc6e:	f244 4344 	movw	r3, #17476	; 0x4444
 800bc72:	4013      	ands	r3, r2
 800bc74:	2b00      	cmp	r3, #0
 800bc76:	d107      	bne.n	800bc88 <HAL_TIM_OnePulse_Stop_IT+0xec>
 800bc78:	687b      	ldr	r3, [r7, #4]
 800bc7a:	681b      	ldr	r3, [r3, #0]
 800bc7c:	681a      	ldr	r2, [r3, #0]
 800bc7e:	687b      	ldr	r3, [r7, #4]
 800bc80:	681b      	ldr	r3, [r3, #0]
 800bc82:	f022 0201 	bic.w	r2, r2, #1
 800bc86:	601a      	str	r2, [r3, #0]

  /* Set the TIM channels state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 800bc88:	687b      	ldr	r3, [r7, #4]
 800bc8a:	2201      	movs	r2, #1
 800bc8c:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 800bc90:	687b      	ldr	r3, [r7, #4]
 800bc92:	2201      	movs	r2, #1
 800bc94:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 800bc98:	687b      	ldr	r3, [r7, #4]
 800bc9a:	2201      	movs	r2, #1
 800bc9c:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 800bca0:	687b      	ldr	r3, [r7, #4]
 800bca2:	2201      	movs	r2, #1
 800bca4:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Return function status */
  return HAL_OK;
 800bca8:	2300      	movs	r3, #0
}
 800bcaa:	4618      	mov	r0, r3
 800bcac:	3708      	adds	r7, #8
 800bcae:	46bd      	mov	sp, r7
 800bcb0:	bd80      	pop	{r7, pc}
 800bcb2:	bf00      	nop
 800bcb4:	40012c00 	.word	0x40012c00
 800bcb8:	40013400 	.word	0x40013400
 800bcbc:	40014000 	.word	0x40014000
 800bcc0:	40014400 	.word	0x40014400
 800bcc4:	40014800 	.word	0x40014800
 800bcc8:	40015000 	.word	0x40015000

0800bccc <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 800bccc:	b580      	push	{r7, lr}
 800bcce:	b082      	sub	sp, #8
 800bcd0:	af00      	add	r7, sp, #0
 800bcd2:	6078      	str	r0, [r7, #4]
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 800bcd4:	687b      	ldr	r3, [r7, #4]
 800bcd6:	681b      	ldr	r3, [r3, #0]
 800bcd8:	691b      	ldr	r3, [r3, #16]
 800bcda:	f003 0302 	and.w	r3, r3, #2
 800bcde:	2b02      	cmp	r3, #2
 800bce0:	d122      	bne.n	800bd28 <HAL_TIM_IRQHandler+0x5c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 800bce2:	687b      	ldr	r3, [r7, #4]
 800bce4:	681b      	ldr	r3, [r3, #0]
 800bce6:	68db      	ldr	r3, [r3, #12]
 800bce8:	f003 0302 	and.w	r3, r3, #2
 800bcec:	2b02      	cmp	r3, #2
 800bcee:	d11b      	bne.n	800bd28 <HAL_TIM_IRQHandler+0x5c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 800bcf0:	687b      	ldr	r3, [r7, #4]
 800bcf2:	681b      	ldr	r3, [r3, #0]
 800bcf4:	f06f 0202 	mvn.w	r2, #2
 800bcf8:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800bcfa:	687b      	ldr	r3, [r7, #4]
 800bcfc:	2201      	movs	r2, #1
 800bcfe:	771a      	strb	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 800bd00:	687b      	ldr	r3, [r7, #4]
 800bd02:	681b      	ldr	r3, [r3, #0]
 800bd04:	699b      	ldr	r3, [r3, #24]
 800bd06:	f003 0303 	and.w	r3, r3, #3
 800bd0a:	2b00      	cmp	r3, #0
 800bd0c:	d003      	beq.n	800bd16 <HAL_TIM_IRQHandler+0x4a>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 800bd0e:	6878      	ldr	r0, [r7, #4]
 800bd10:	f000 faec 	bl	800c2ec <HAL_TIM_IC_CaptureCallback>
 800bd14:	e005      	b.n	800bd22 <HAL_TIM_IRQHandler+0x56>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800bd16:	6878      	ldr	r0, [r7, #4]
 800bd18:	f7f9 f87e 	bl	8004e18 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 800bd1c:	6878      	ldr	r0, [r7, #4]
 800bd1e:	f000 faef 	bl	800c300 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800bd22:	687b      	ldr	r3, [r7, #4]
 800bd24:	2200      	movs	r2, #0
 800bd26:	771a      	strb	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 800bd28:	687b      	ldr	r3, [r7, #4]
 800bd2a:	681b      	ldr	r3, [r3, #0]
 800bd2c:	691b      	ldr	r3, [r3, #16]
 800bd2e:	f003 0304 	and.w	r3, r3, #4
 800bd32:	2b04      	cmp	r3, #4
 800bd34:	d122      	bne.n	800bd7c <HAL_TIM_IRQHandler+0xb0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 800bd36:	687b      	ldr	r3, [r7, #4]
 800bd38:	681b      	ldr	r3, [r3, #0]
 800bd3a:	68db      	ldr	r3, [r3, #12]
 800bd3c:	f003 0304 	and.w	r3, r3, #4
 800bd40:	2b04      	cmp	r3, #4
 800bd42:	d11b      	bne.n	800bd7c <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 800bd44:	687b      	ldr	r3, [r7, #4]
 800bd46:	681b      	ldr	r3, [r3, #0]
 800bd48:	f06f 0204 	mvn.w	r2, #4
 800bd4c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800bd4e:	687b      	ldr	r3, [r7, #4]
 800bd50:	2202      	movs	r2, #2
 800bd52:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 800bd54:	687b      	ldr	r3, [r7, #4]
 800bd56:	681b      	ldr	r3, [r3, #0]
 800bd58:	699b      	ldr	r3, [r3, #24]
 800bd5a:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800bd5e:	2b00      	cmp	r3, #0
 800bd60:	d003      	beq.n	800bd6a <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800bd62:	6878      	ldr	r0, [r7, #4]
 800bd64:	f000 fac2 	bl	800c2ec <HAL_TIM_IC_CaptureCallback>
 800bd68:	e005      	b.n	800bd76 <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800bd6a:	6878      	ldr	r0, [r7, #4]
 800bd6c:	f7f9 f854 	bl	8004e18 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800bd70:	6878      	ldr	r0, [r7, #4]
 800bd72:	f000 fac5 	bl	800c300 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800bd76:	687b      	ldr	r3, [r7, #4]
 800bd78:	2200      	movs	r2, #0
 800bd7a:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 800bd7c:	687b      	ldr	r3, [r7, #4]
 800bd7e:	681b      	ldr	r3, [r3, #0]
 800bd80:	691b      	ldr	r3, [r3, #16]
 800bd82:	f003 0308 	and.w	r3, r3, #8
 800bd86:	2b08      	cmp	r3, #8
 800bd88:	d122      	bne.n	800bdd0 <HAL_TIM_IRQHandler+0x104>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 800bd8a:	687b      	ldr	r3, [r7, #4]
 800bd8c:	681b      	ldr	r3, [r3, #0]
 800bd8e:	68db      	ldr	r3, [r3, #12]
 800bd90:	f003 0308 	and.w	r3, r3, #8
 800bd94:	2b08      	cmp	r3, #8
 800bd96:	d11b      	bne.n	800bdd0 <HAL_TIM_IRQHandler+0x104>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 800bd98:	687b      	ldr	r3, [r7, #4]
 800bd9a:	681b      	ldr	r3, [r3, #0]
 800bd9c:	f06f 0208 	mvn.w	r2, #8
 800bda0:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800bda2:	687b      	ldr	r3, [r7, #4]
 800bda4:	2204      	movs	r2, #4
 800bda6:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 800bda8:	687b      	ldr	r3, [r7, #4]
 800bdaa:	681b      	ldr	r3, [r3, #0]
 800bdac:	69db      	ldr	r3, [r3, #28]
 800bdae:	f003 0303 	and.w	r3, r3, #3
 800bdb2:	2b00      	cmp	r3, #0
 800bdb4:	d003      	beq.n	800bdbe <HAL_TIM_IRQHandler+0xf2>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800bdb6:	6878      	ldr	r0, [r7, #4]
 800bdb8:	f000 fa98 	bl	800c2ec <HAL_TIM_IC_CaptureCallback>
 800bdbc:	e005      	b.n	800bdca <HAL_TIM_IRQHandler+0xfe>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800bdbe:	6878      	ldr	r0, [r7, #4]
 800bdc0:	f7f9 f82a 	bl	8004e18 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800bdc4:	6878      	ldr	r0, [r7, #4]
 800bdc6:	f000 fa9b 	bl	800c300 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800bdca:	687b      	ldr	r3, [r7, #4]
 800bdcc:	2200      	movs	r2, #0
 800bdce:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 800bdd0:	687b      	ldr	r3, [r7, #4]
 800bdd2:	681b      	ldr	r3, [r3, #0]
 800bdd4:	691b      	ldr	r3, [r3, #16]
 800bdd6:	f003 0310 	and.w	r3, r3, #16
 800bdda:	2b10      	cmp	r3, #16
 800bddc:	d122      	bne.n	800be24 <HAL_TIM_IRQHandler+0x158>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 800bdde:	687b      	ldr	r3, [r7, #4]
 800bde0:	681b      	ldr	r3, [r3, #0]
 800bde2:	68db      	ldr	r3, [r3, #12]
 800bde4:	f003 0310 	and.w	r3, r3, #16
 800bde8:	2b10      	cmp	r3, #16
 800bdea:	d11b      	bne.n	800be24 <HAL_TIM_IRQHandler+0x158>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 800bdec:	687b      	ldr	r3, [r7, #4]
 800bdee:	681b      	ldr	r3, [r3, #0]
 800bdf0:	f06f 0210 	mvn.w	r2, #16
 800bdf4:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800bdf6:	687b      	ldr	r3, [r7, #4]
 800bdf8:	2208      	movs	r2, #8
 800bdfa:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 800bdfc:	687b      	ldr	r3, [r7, #4]
 800bdfe:	681b      	ldr	r3, [r3, #0]
 800be00:	69db      	ldr	r3, [r3, #28]
 800be02:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800be06:	2b00      	cmp	r3, #0
 800be08:	d003      	beq.n	800be12 <HAL_TIM_IRQHandler+0x146>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800be0a:	6878      	ldr	r0, [r7, #4]
 800be0c:	f000 fa6e 	bl	800c2ec <HAL_TIM_IC_CaptureCallback>
 800be10:	e005      	b.n	800be1e <HAL_TIM_IRQHandler+0x152>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800be12:	6878      	ldr	r0, [r7, #4]
 800be14:	f7f9 f800 	bl	8004e18 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800be18:	6878      	ldr	r0, [r7, #4]
 800be1a:	f000 fa71 	bl	800c300 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800be1e:	687b      	ldr	r3, [r7, #4]
 800be20:	2200      	movs	r2, #0
 800be22:	771a      	strb	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 800be24:	687b      	ldr	r3, [r7, #4]
 800be26:	681b      	ldr	r3, [r3, #0]
 800be28:	691b      	ldr	r3, [r3, #16]
 800be2a:	f003 0301 	and.w	r3, r3, #1
 800be2e:	2b01      	cmp	r3, #1
 800be30:	d10e      	bne.n	800be50 <HAL_TIM_IRQHandler+0x184>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 800be32:	687b      	ldr	r3, [r7, #4]
 800be34:	681b      	ldr	r3, [r3, #0]
 800be36:	68db      	ldr	r3, [r3, #12]
 800be38:	f003 0301 	and.w	r3, r3, #1
 800be3c:	2b01      	cmp	r3, #1
 800be3e:	d107      	bne.n	800be50 <HAL_TIM_IRQHandler+0x184>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 800be40:	687b      	ldr	r3, [r7, #4]
 800be42:	681b      	ldr	r3, [r3, #0]
 800be44:	f06f 0201 	mvn.w	r2, #1
 800be48:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 800be4a:	6878      	ldr	r0, [r7, #4]
 800be4c:	f000 fa44 	bl	800c2d8 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 800be50:	687b      	ldr	r3, [r7, #4]
 800be52:	681b      	ldr	r3, [r3, #0]
 800be54:	691b      	ldr	r3, [r3, #16]
 800be56:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800be5a:	2b80      	cmp	r3, #128	; 0x80
 800be5c:	d10e      	bne.n	800be7c <HAL_TIM_IRQHandler+0x1b0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800be5e:	687b      	ldr	r3, [r7, #4]
 800be60:	681b      	ldr	r3, [r3, #0]
 800be62:	68db      	ldr	r3, [r3, #12]
 800be64:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800be68:	2b80      	cmp	r3, #128	; 0x80
 800be6a:	d107      	bne.n	800be7c <HAL_TIM_IRQHandler+0x1b0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 800be6c:	687b      	ldr	r3, [r7, #4]
 800be6e:	681b      	ldr	r3, [r3, #0]
 800be70:	f06f 0280 	mvn.w	r2, #128	; 0x80
 800be74:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 800be76:	6878      	ldr	r0, [r7, #4]
 800be78:	f000 ff8a 	bl	800cd90 <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break2 input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 800be7c:	687b      	ldr	r3, [r7, #4]
 800be7e:	681b      	ldr	r3, [r3, #0]
 800be80:	691b      	ldr	r3, [r3, #16]
 800be82:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800be86:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800be8a:	d10e      	bne.n	800beaa <HAL_TIM_IRQHandler+0x1de>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800be8c:	687b      	ldr	r3, [r7, #4]
 800be8e:	681b      	ldr	r3, [r3, #0]
 800be90:	68db      	ldr	r3, [r3, #12]
 800be92:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800be96:	2b80      	cmp	r3, #128	; 0x80
 800be98:	d107      	bne.n	800beaa <HAL_TIM_IRQHandler+0x1de>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 800be9a:	687b      	ldr	r3, [r7, #4]
 800be9c:	681b      	ldr	r3, [r3, #0]
 800be9e:	f46f 7280 	mvn.w	r2, #256	; 0x100
 800bea2:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->Break2Callback(htim);
#else
      HAL_TIMEx_Break2Callback(htim);
 800bea4:	6878      	ldr	r0, [r7, #4]
 800bea6:	f000 ff7d 	bl	800cda4 <HAL_TIMEx_Break2Callback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 800beaa:	687b      	ldr	r3, [r7, #4]
 800beac:	681b      	ldr	r3, [r3, #0]
 800beae:	691b      	ldr	r3, [r3, #16]
 800beb0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800beb4:	2b40      	cmp	r3, #64	; 0x40
 800beb6:	d10e      	bne.n	800bed6 <HAL_TIM_IRQHandler+0x20a>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 800beb8:	687b      	ldr	r3, [r7, #4]
 800beba:	681b      	ldr	r3, [r3, #0]
 800bebc:	68db      	ldr	r3, [r3, #12]
 800bebe:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800bec2:	2b40      	cmp	r3, #64	; 0x40
 800bec4:	d107      	bne.n	800bed6 <HAL_TIM_IRQHandler+0x20a>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 800bec6:	687b      	ldr	r3, [r7, #4]
 800bec8:	681b      	ldr	r3, [r3, #0]
 800beca:	f06f 0240 	mvn.w	r2, #64	; 0x40
 800bece:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 800bed0:	6878      	ldr	r0, [r7, #4]
 800bed2:	f000 fa1f 	bl	800c314 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 800bed6:	687b      	ldr	r3, [r7, #4]
 800bed8:	681b      	ldr	r3, [r3, #0]
 800beda:	691b      	ldr	r3, [r3, #16]
 800bedc:	f003 0320 	and.w	r3, r3, #32
 800bee0:	2b20      	cmp	r3, #32
 800bee2:	d10e      	bne.n	800bf02 <HAL_TIM_IRQHandler+0x236>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 800bee4:	687b      	ldr	r3, [r7, #4]
 800bee6:	681b      	ldr	r3, [r3, #0]
 800bee8:	68db      	ldr	r3, [r3, #12]
 800beea:	f003 0320 	and.w	r3, r3, #32
 800beee:	2b20      	cmp	r3, #32
 800bef0:	d107      	bne.n	800bf02 <HAL_TIM_IRQHandler+0x236>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 800bef2:	687b      	ldr	r3, [r7, #4]
 800bef4:	681b      	ldr	r3, [r3, #0]
 800bef6:	f06f 0220 	mvn.w	r2, #32
 800befa:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 800befc:	6878      	ldr	r0, [r7, #4]
 800befe:	f000 ff3d 	bl	800cd7c <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Encoder index event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_IDX) != RESET)
 800bf02:	687b      	ldr	r3, [r7, #4]
 800bf04:	681b      	ldr	r3, [r3, #0]
 800bf06:	691b      	ldr	r3, [r3, #16]
 800bf08:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800bf0c:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800bf10:	d10f      	bne.n	800bf32 <HAL_TIM_IRQHandler+0x266>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_IDX) != RESET)
 800bf12:	687b      	ldr	r3, [r7, #4]
 800bf14:	681b      	ldr	r3, [r3, #0]
 800bf16:	68db      	ldr	r3, [r3, #12]
 800bf18:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800bf1c:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800bf20:	d107      	bne.n	800bf32 <HAL_TIM_IRQHandler+0x266>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_IDX);
 800bf22:	687b      	ldr	r3, [r7, #4]
 800bf24:	681b      	ldr	r3, [r3, #0]
 800bf26:	f46f 1280 	mvn.w	r2, #1048576	; 0x100000
 800bf2a:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->EncoderIndexCallback(htim);
#else
      HAL_TIMEx_EncoderIndexCallback(htim);
 800bf2c:	6878      	ldr	r0, [r7, #4]
 800bf2e:	f000 ff43 	bl	800cdb8 <HAL_TIMEx_EncoderIndexCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Direction change event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_DIR) != RESET)
 800bf32:	687b      	ldr	r3, [r7, #4]
 800bf34:	681b      	ldr	r3, [r3, #0]
 800bf36:	691b      	ldr	r3, [r3, #16]
 800bf38:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800bf3c:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 800bf40:	d10f      	bne.n	800bf62 <HAL_TIM_IRQHandler+0x296>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_DIR) != RESET)
 800bf42:	687b      	ldr	r3, [r7, #4]
 800bf44:	681b      	ldr	r3, [r3, #0]
 800bf46:	68db      	ldr	r3, [r3, #12]
 800bf48:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800bf4c:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 800bf50:	d107      	bne.n	800bf62 <HAL_TIM_IRQHandler+0x296>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_DIR);
 800bf52:	687b      	ldr	r3, [r7, #4]
 800bf54:	681b      	ldr	r3, [r3, #0]
 800bf56:	f46f 1200 	mvn.w	r2, #2097152	; 0x200000
 800bf5a:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->DirectionChangeCallback(htim);
#else
      HAL_TIMEx_DirectionChangeCallback(htim);
 800bf5c:	6878      	ldr	r0, [r7, #4]
 800bf5e:	f000 ff35 	bl	800cdcc <HAL_TIMEx_DirectionChangeCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Index error event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_IERR) != RESET)
 800bf62:	687b      	ldr	r3, [r7, #4]
 800bf64:	681b      	ldr	r3, [r3, #0]
 800bf66:	691b      	ldr	r3, [r3, #16]
 800bf68:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800bf6c:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800bf70:	d10f      	bne.n	800bf92 <HAL_TIM_IRQHandler+0x2c6>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_IERR) != RESET)
 800bf72:	687b      	ldr	r3, [r7, #4]
 800bf74:	681b      	ldr	r3, [r3, #0]
 800bf76:	68db      	ldr	r3, [r3, #12]
 800bf78:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800bf7c:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800bf80:	d107      	bne.n	800bf92 <HAL_TIM_IRQHandler+0x2c6>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_IERR);
 800bf82:	687b      	ldr	r3, [r7, #4]
 800bf84:	681b      	ldr	r3, [r3, #0]
 800bf86:	f46f 0280 	mvn.w	r2, #4194304	; 0x400000
 800bf8a:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->IndexErrorCallback(htim);
#else
      HAL_TIMEx_IndexErrorCallback(htim);
 800bf8c:	6878      	ldr	r0, [r7, #4]
 800bf8e:	f000 ff27 	bl	800cde0 <HAL_TIMEx_IndexErrorCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Transition error event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TERR) != RESET)
 800bf92:	687b      	ldr	r3, [r7, #4]
 800bf94:	681b      	ldr	r3, [r3, #0]
 800bf96:	691b      	ldr	r3, [r3, #16]
 800bf98:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800bf9c:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 800bfa0:	d10f      	bne.n	800bfc2 <HAL_TIM_IRQHandler+0x2f6>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TERR) != RESET)
 800bfa2:	687b      	ldr	r3, [r7, #4]
 800bfa4:	681b      	ldr	r3, [r3, #0]
 800bfa6:	68db      	ldr	r3, [r3, #12]
 800bfa8:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800bfac:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 800bfb0:	d107      	bne.n	800bfc2 <HAL_TIM_IRQHandler+0x2f6>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_TERR);
 800bfb2:	687b      	ldr	r3, [r7, #4]
 800bfb4:	681b      	ldr	r3, [r3, #0]
 800bfb6:	f46f 0200 	mvn.w	r2, #8388608	; 0x800000
 800bfba:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TransitionErrorCallback(htim);
#else
      HAL_TIMEx_TransitionErrorCallback(htim);
 800bfbc:	6878      	ldr	r0, [r7, #4]
 800bfbe:	f000 ff19 	bl	800cdf4 <HAL_TIMEx_TransitionErrorCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 800bfc2:	bf00      	nop
 800bfc4:	3708      	adds	r7, #8
 800bfc6:	46bd      	mov	sp, r7
 800bfc8:	bd80      	pop	{r7, pc}
	...

0800bfcc <HAL_TIM_OC_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim,
                                           TIM_OC_InitTypeDef *sConfig,
                                           uint32_t Channel)
{
 800bfcc:	b580      	push	{r7, lr}
 800bfce:	b086      	sub	sp, #24
 800bfd0:	af00      	add	r7, sp, #0
 800bfd2:	60f8      	str	r0, [r7, #12]
 800bfd4:	60b9      	str	r1, [r7, #8]
 800bfd6:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 800bfd8:	2300      	movs	r3, #0
 800bfda:	75fb      	strb	r3, [r7, #23]
  assert_param(IS_TIM_CHANNELS(Channel));
  assert_param(IS_TIM_OC_CHANNEL_MODE(sConfig->OCMode, Channel));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));

  /* Process Locked */
  __HAL_LOCK(htim);
 800bfdc:	68fb      	ldr	r3, [r7, #12]
 800bfde:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 800bfe2:	2b01      	cmp	r3, #1
 800bfe4:	d101      	bne.n	800bfea <HAL_TIM_OC_ConfigChannel+0x1e>
 800bfe6:	2302      	movs	r3, #2
 800bfe8:	e066      	b.n	800c0b8 <HAL_TIM_OC_ConfigChannel+0xec>
 800bfea:	68fb      	ldr	r3, [r7, #12]
 800bfec:	2201      	movs	r2, #1
 800bfee:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  switch (Channel)
 800bff2:	687b      	ldr	r3, [r7, #4]
 800bff4:	2b14      	cmp	r3, #20
 800bff6:	d857      	bhi.n	800c0a8 <HAL_TIM_OC_ConfigChannel+0xdc>
 800bff8:	a201      	add	r2, pc, #4	; (adr r2, 800c000 <HAL_TIM_OC_ConfigChannel+0x34>)
 800bffa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800bffe:	bf00      	nop
 800c000:	0800c055 	.word	0x0800c055
 800c004:	0800c0a9 	.word	0x0800c0a9
 800c008:	0800c0a9 	.word	0x0800c0a9
 800c00c:	0800c0a9 	.word	0x0800c0a9
 800c010:	0800c063 	.word	0x0800c063
 800c014:	0800c0a9 	.word	0x0800c0a9
 800c018:	0800c0a9 	.word	0x0800c0a9
 800c01c:	0800c0a9 	.word	0x0800c0a9
 800c020:	0800c071 	.word	0x0800c071
 800c024:	0800c0a9 	.word	0x0800c0a9
 800c028:	0800c0a9 	.word	0x0800c0a9
 800c02c:	0800c0a9 	.word	0x0800c0a9
 800c030:	0800c07f 	.word	0x0800c07f
 800c034:	0800c0a9 	.word	0x0800c0a9
 800c038:	0800c0a9 	.word	0x0800c0a9
 800c03c:	0800c0a9 	.word	0x0800c0a9
 800c040:	0800c08d 	.word	0x0800c08d
 800c044:	0800c0a9 	.word	0x0800c0a9
 800c048:	0800c0a9 	.word	0x0800c0a9
 800c04c:	0800c0a9 	.word	0x0800c0a9
 800c050:	0800c09b 	.word	0x0800c09b
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 1 in Output Compare */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 800c054:	68fb      	ldr	r3, [r7, #12]
 800c056:	681b      	ldr	r3, [r3, #0]
 800c058:	68b9      	ldr	r1, [r7, #8]
 800c05a:	4618      	mov	r0, r3
 800c05c:	f000 fa0c 	bl	800c478 <TIM_OC1_SetConfig>
      break;
 800c060:	e025      	b.n	800c0ae <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 2 in Output Compare */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 800c062:	68fb      	ldr	r3, [r7, #12]
 800c064:	681b      	ldr	r3, [r3, #0]
 800c066:	68b9      	ldr	r1, [r7, #8]
 800c068:	4618      	mov	r0, r3
 800c06a:	f000 fa9f 	bl	800c5ac <TIM_OC2_SetConfig>
      break;
 800c06e:	e01e      	b.n	800c0ae <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 3 in Output Compare */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 800c070:	68fb      	ldr	r3, [r7, #12]
 800c072:	681b      	ldr	r3, [r3, #0]
 800c074:	68b9      	ldr	r1, [r7, #8]
 800c076:	4618      	mov	r0, r3
 800c078:	f000 fb2c 	bl	800c6d4 <TIM_OC3_SetConfig>
      break;
 800c07c:	e017      	b.n	800c0ae <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 4 in Output Compare */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 800c07e:	68fb      	ldr	r3, [r7, #12]
 800c080:	681b      	ldr	r3, [r3, #0]
 800c082:	68b9      	ldr	r1, [r7, #8]
 800c084:	4618      	mov	r0, r3
 800c086:	f000 fbb7 	bl	800c7f8 <TIM_OC4_SetConfig>
      break;
 800c08a:	e010      	b.n	800c0ae <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 5 in Output Compare */
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 800c08c:	68fb      	ldr	r3, [r7, #12]
 800c08e:	681b      	ldr	r3, [r3, #0]
 800c090:	68b9      	ldr	r1, [r7, #8]
 800c092:	4618      	mov	r0, r3
 800c094:	f000 fc44 	bl	800c920 <TIM_OC5_SetConfig>
      break;
 800c098:	e009      	b.n	800c0ae <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 6 in Output Compare */
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 800c09a:	68fb      	ldr	r3, [r7, #12]
 800c09c:	681b      	ldr	r3, [r3, #0]
 800c09e:	68b9      	ldr	r1, [r7, #8]
 800c0a0:	4618      	mov	r0, r3
 800c0a2:	f000 fca7 	bl	800c9f4 <TIM_OC6_SetConfig>
      break;
 800c0a6:	e002      	b.n	800c0ae <HAL_TIM_OC_ConfigChannel+0xe2>
    }

    default:
      status = HAL_ERROR;
 800c0a8:	2301      	movs	r3, #1
 800c0aa:	75fb      	strb	r3, [r7, #23]
      break;
 800c0ac:	bf00      	nop
  }

  __HAL_UNLOCK(htim);
 800c0ae:	68fb      	ldr	r3, [r7, #12]
 800c0b0:	2200      	movs	r2, #0
 800c0b2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
 800c0b6:	7dfb      	ldrb	r3, [r7, #23]
}
 800c0b8:	4618      	mov	r0, r3
 800c0ba:	3718      	adds	r7, #24
 800c0bc:	46bd      	mov	sp, r7
 800c0be:	bd80      	pop	{r7, pc}

0800c0c0 <HAL_TIM_ConfigClockSource>:
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
{
 800c0c0:	b580      	push	{r7, lr}
 800c0c2:	b084      	sub	sp, #16
 800c0c4:	af00      	add	r7, sp, #0
 800c0c6:	6078      	str	r0, [r7, #4]
 800c0c8:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 800c0ca:	2300      	movs	r3, #0
 800c0cc:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpsmcr;

  /* Process Locked */
  __HAL_LOCK(htim);
 800c0ce:	687b      	ldr	r3, [r7, #4]
 800c0d0:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 800c0d4:	2b01      	cmp	r3, #1
 800c0d6:	d101      	bne.n	800c0dc <HAL_TIM_ConfigClockSource+0x1c>
 800c0d8:	2302      	movs	r3, #2
 800c0da:	e0ee      	b.n	800c2ba <HAL_TIM_ConfigClockSource+0x1fa>
 800c0dc:	687b      	ldr	r3, [r7, #4]
 800c0de:	2201      	movs	r2, #1
 800c0e0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
 800c0e4:	687b      	ldr	r3, [r7, #4]
 800c0e6:	2202      	movs	r2, #2
 800c0e8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
 800c0ec:	687b      	ldr	r3, [r7, #4]
 800c0ee:	681b      	ldr	r3, [r3, #0]
 800c0f0:	689b      	ldr	r3, [r3, #8]
 800c0f2:	60bb      	str	r3, [r7, #8]
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
 800c0f4:	68bb      	ldr	r3, [r7, #8]
 800c0f6:	f423 1344 	bic.w	r3, r3, #3211264	; 0x310000
 800c0fa:	f023 0377 	bic.w	r3, r3, #119	; 0x77
 800c0fe:	60bb      	str	r3, [r7, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800c100:	68bb      	ldr	r3, [r7, #8]
 800c102:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 800c106:	60bb      	str	r3, [r7, #8]
  htim->Instance->SMCR = tmpsmcr;
 800c108:	687b      	ldr	r3, [r7, #4]
 800c10a:	681b      	ldr	r3, [r3, #0]
 800c10c:	68ba      	ldr	r2, [r7, #8]
 800c10e:	609a      	str	r2, [r3, #8]

  switch (sClockSourceConfig->ClockSource)
 800c110:	683b      	ldr	r3, [r7, #0]
 800c112:	681b      	ldr	r3, [r3, #0]
 800c114:	4a6b      	ldr	r2, [pc, #428]	; (800c2c4 <HAL_TIM_ConfigClockSource+0x204>)
 800c116:	4293      	cmp	r3, r2
 800c118:	f000 80b9 	beq.w	800c28e <HAL_TIM_ConfigClockSource+0x1ce>
 800c11c:	4a69      	ldr	r2, [pc, #420]	; (800c2c4 <HAL_TIM_ConfigClockSource+0x204>)
 800c11e:	4293      	cmp	r3, r2
 800c120:	f200 80be 	bhi.w	800c2a0 <HAL_TIM_ConfigClockSource+0x1e0>
 800c124:	4a68      	ldr	r2, [pc, #416]	; (800c2c8 <HAL_TIM_ConfigClockSource+0x208>)
 800c126:	4293      	cmp	r3, r2
 800c128:	f000 80b1 	beq.w	800c28e <HAL_TIM_ConfigClockSource+0x1ce>
 800c12c:	4a66      	ldr	r2, [pc, #408]	; (800c2c8 <HAL_TIM_ConfigClockSource+0x208>)
 800c12e:	4293      	cmp	r3, r2
 800c130:	f200 80b6 	bhi.w	800c2a0 <HAL_TIM_ConfigClockSource+0x1e0>
 800c134:	4a65      	ldr	r2, [pc, #404]	; (800c2cc <HAL_TIM_ConfigClockSource+0x20c>)
 800c136:	4293      	cmp	r3, r2
 800c138:	f000 80a9 	beq.w	800c28e <HAL_TIM_ConfigClockSource+0x1ce>
 800c13c:	4a63      	ldr	r2, [pc, #396]	; (800c2cc <HAL_TIM_ConfigClockSource+0x20c>)
 800c13e:	4293      	cmp	r3, r2
 800c140:	f200 80ae 	bhi.w	800c2a0 <HAL_TIM_ConfigClockSource+0x1e0>
 800c144:	4a62      	ldr	r2, [pc, #392]	; (800c2d0 <HAL_TIM_ConfigClockSource+0x210>)
 800c146:	4293      	cmp	r3, r2
 800c148:	f000 80a1 	beq.w	800c28e <HAL_TIM_ConfigClockSource+0x1ce>
 800c14c:	4a60      	ldr	r2, [pc, #384]	; (800c2d0 <HAL_TIM_ConfigClockSource+0x210>)
 800c14e:	4293      	cmp	r3, r2
 800c150:	f200 80a6 	bhi.w	800c2a0 <HAL_TIM_ConfigClockSource+0x1e0>
 800c154:	4a5f      	ldr	r2, [pc, #380]	; (800c2d4 <HAL_TIM_ConfigClockSource+0x214>)
 800c156:	4293      	cmp	r3, r2
 800c158:	f000 8099 	beq.w	800c28e <HAL_TIM_ConfigClockSource+0x1ce>
 800c15c:	4a5d      	ldr	r2, [pc, #372]	; (800c2d4 <HAL_TIM_ConfigClockSource+0x214>)
 800c15e:	4293      	cmp	r3, r2
 800c160:	f200 809e 	bhi.w	800c2a0 <HAL_TIM_ConfigClockSource+0x1e0>
 800c164:	f1b3 1f10 	cmp.w	r3, #1048592	; 0x100010
 800c168:	f000 8091 	beq.w	800c28e <HAL_TIM_ConfigClockSource+0x1ce>
 800c16c:	f1b3 1f10 	cmp.w	r3, #1048592	; 0x100010
 800c170:	f200 8096 	bhi.w	800c2a0 <HAL_TIM_ConfigClockSource+0x1e0>
 800c174:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800c178:	f000 8089 	beq.w	800c28e <HAL_TIM_ConfigClockSource+0x1ce>
 800c17c:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800c180:	f200 808e 	bhi.w	800c2a0 <HAL_TIM_ConfigClockSource+0x1e0>
 800c184:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800c188:	d03e      	beq.n	800c208 <HAL_TIM_ConfigClockSource+0x148>
 800c18a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800c18e:	f200 8087 	bhi.w	800c2a0 <HAL_TIM_ConfigClockSource+0x1e0>
 800c192:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800c196:	f000 8086 	beq.w	800c2a6 <HAL_TIM_ConfigClockSource+0x1e6>
 800c19a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800c19e:	d87f      	bhi.n	800c2a0 <HAL_TIM_ConfigClockSource+0x1e0>
 800c1a0:	2b70      	cmp	r3, #112	; 0x70
 800c1a2:	d01a      	beq.n	800c1da <HAL_TIM_ConfigClockSource+0x11a>
 800c1a4:	2b70      	cmp	r3, #112	; 0x70
 800c1a6:	d87b      	bhi.n	800c2a0 <HAL_TIM_ConfigClockSource+0x1e0>
 800c1a8:	2b60      	cmp	r3, #96	; 0x60
 800c1aa:	d050      	beq.n	800c24e <HAL_TIM_ConfigClockSource+0x18e>
 800c1ac:	2b60      	cmp	r3, #96	; 0x60
 800c1ae:	d877      	bhi.n	800c2a0 <HAL_TIM_ConfigClockSource+0x1e0>
 800c1b0:	2b50      	cmp	r3, #80	; 0x50
 800c1b2:	d03c      	beq.n	800c22e <HAL_TIM_ConfigClockSource+0x16e>
 800c1b4:	2b50      	cmp	r3, #80	; 0x50
 800c1b6:	d873      	bhi.n	800c2a0 <HAL_TIM_ConfigClockSource+0x1e0>
 800c1b8:	2b40      	cmp	r3, #64	; 0x40
 800c1ba:	d058      	beq.n	800c26e <HAL_TIM_ConfigClockSource+0x1ae>
 800c1bc:	2b40      	cmp	r3, #64	; 0x40
 800c1be:	d86f      	bhi.n	800c2a0 <HAL_TIM_ConfigClockSource+0x1e0>
 800c1c0:	2b30      	cmp	r3, #48	; 0x30
 800c1c2:	d064      	beq.n	800c28e <HAL_TIM_ConfigClockSource+0x1ce>
 800c1c4:	2b30      	cmp	r3, #48	; 0x30
 800c1c6:	d86b      	bhi.n	800c2a0 <HAL_TIM_ConfigClockSource+0x1e0>
 800c1c8:	2b20      	cmp	r3, #32
 800c1ca:	d060      	beq.n	800c28e <HAL_TIM_ConfigClockSource+0x1ce>
 800c1cc:	2b20      	cmp	r3, #32
 800c1ce:	d867      	bhi.n	800c2a0 <HAL_TIM_ConfigClockSource+0x1e0>
 800c1d0:	2b00      	cmp	r3, #0
 800c1d2:	d05c      	beq.n	800c28e <HAL_TIM_ConfigClockSource+0x1ce>
 800c1d4:	2b10      	cmp	r3, #16
 800c1d6:	d05a      	beq.n	800c28e <HAL_TIM_ConfigClockSource+0x1ce>
 800c1d8:	e062      	b.n	800c2a0 <HAL_TIM_ConfigClockSource+0x1e0>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 800c1da:	687b      	ldr	r3, [r7, #4]
 800c1dc:	6818      	ldr	r0, [r3, #0]
 800c1de:	683b      	ldr	r3, [r7, #0]
 800c1e0:	6899      	ldr	r1, [r3, #8]
 800c1e2:	683b      	ldr	r3, [r7, #0]
 800c1e4:	685a      	ldr	r2, [r3, #4]
 800c1e6:	683b      	ldr	r3, [r7, #0]
 800c1e8:	68db      	ldr	r3, [r3, #12]
 800c1ea:	f000 fceb 	bl	800cbc4 <TIM_ETR_SetConfig>
                        sClockSourceConfig->ClockPrescaler,
                        sClockSourceConfig->ClockPolarity,
                        sClockSourceConfig->ClockFilter);

      /* Select the External clock mode1 and the ETRF trigger */
      tmpsmcr = htim->Instance->SMCR;
 800c1ee:	687b      	ldr	r3, [r7, #4]
 800c1f0:	681b      	ldr	r3, [r3, #0]
 800c1f2:	689b      	ldr	r3, [r3, #8]
 800c1f4:	60bb      	str	r3, [r7, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 800c1f6:	68bb      	ldr	r3, [r7, #8]
 800c1f8:	f043 0377 	orr.w	r3, r3, #119	; 0x77
 800c1fc:	60bb      	str	r3, [r7, #8]
      /* Write to TIMx SMCR */
      htim->Instance->SMCR = tmpsmcr;
 800c1fe:	687b      	ldr	r3, [r7, #4]
 800c200:	681b      	ldr	r3, [r3, #0]
 800c202:	68ba      	ldr	r2, [r7, #8]
 800c204:	609a      	str	r2, [r3, #8]
      break;
 800c206:	e04f      	b.n	800c2a8 <HAL_TIM_ConfigClockSource+0x1e8>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 800c208:	687b      	ldr	r3, [r7, #4]
 800c20a:	6818      	ldr	r0, [r3, #0]
 800c20c:	683b      	ldr	r3, [r7, #0]
 800c20e:	6899      	ldr	r1, [r3, #8]
 800c210:	683b      	ldr	r3, [r7, #0]
 800c212:	685a      	ldr	r2, [r3, #4]
 800c214:	683b      	ldr	r3, [r7, #0]
 800c216:	68db      	ldr	r3, [r3, #12]
 800c218:	f000 fcd4 	bl	800cbc4 <TIM_ETR_SetConfig>
                        sClockSourceConfig->ClockPrescaler,
                        sClockSourceConfig->ClockPolarity,
                        sClockSourceConfig->ClockFilter);
      /* Enable the External clock mode2 */
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 800c21c:	687b      	ldr	r3, [r7, #4]
 800c21e:	681b      	ldr	r3, [r3, #0]
 800c220:	689a      	ldr	r2, [r3, #8]
 800c222:	687b      	ldr	r3, [r7, #4]
 800c224:	681b      	ldr	r3, [r3, #0]
 800c226:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800c22a:	609a      	str	r2, [r3, #8]
      break;
 800c22c:	e03c      	b.n	800c2a8 <HAL_TIM_ConfigClockSource+0x1e8>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 800c22e:	687b      	ldr	r3, [r7, #4]
 800c230:	6818      	ldr	r0, [r3, #0]
 800c232:	683b      	ldr	r3, [r7, #0]
 800c234:	6859      	ldr	r1, [r3, #4]
 800c236:	683b      	ldr	r3, [r7, #0]
 800c238:	68db      	ldr	r3, [r3, #12]
 800c23a:	461a      	mov	r2, r3
 800c23c:	f000 fc46 	bl	800cacc <TIM_TI1_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
 800c240:	687b      	ldr	r3, [r7, #4]
 800c242:	681b      	ldr	r3, [r3, #0]
 800c244:	2150      	movs	r1, #80	; 0x50
 800c246:	4618      	mov	r0, r3
 800c248:	f000 fc9f 	bl	800cb8a <TIM_ITRx_SetConfig>
      break;
 800c24c:	e02c      	b.n	800c2a8 <HAL_TIM_ConfigClockSource+0x1e8>

      /* Check TI2 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI2_ConfigInputStage(htim->Instance,
 800c24e:	687b      	ldr	r3, [r7, #4]
 800c250:	6818      	ldr	r0, [r3, #0]
 800c252:	683b      	ldr	r3, [r7, #0]
 800c254:	6859      	ldr	r1, [r3, #4]
 800c256:	683b      	ldr	r3, [r7, #0]
 800c258:	68db      	ldr	r3, [r3, #12]
 800c25a:	461a      	mov	r2, r3
 800c25c:	f000 fc65 	bl	800cb2a <TIM_TI2_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
 800c260:	687b      	ldr	r3, [r7, #4]
 800c262:	681b      	ldr	r3, [r3, #0]
 800c264:	2160      	movs	r1, #96	; 0x60
 800c266:	4618      	mov	r0, r3
 800c268:	f000 fc8f 	bl	800cb8a <TIM_ITRx_SetConfig>
      break;
 800c26c:	e01c      	b.n	800c2a8 <HAL_TIM_ConfigClockSource+0x1e8>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 800c26e:	687b      	ldr	r3, [r7, #4]
 800c270:	6818      	ldr	r0, [r3, #0]
 800c272:	683b      	ldr	r3, [r7, #0]
 800c274:	6859      	ldr	r1, [r3, #4]
 800c276:	683b      	ldr	r3, [r7, #0]
 800c278:	68db      	ldr	r3, [r3, #12]
 800c27a:	461a      	mov	r2, r3
 800c27c:	f000 fc26 	bl	800cacc <TIM_TI1_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
 800c280:	687b      	ldr	r3, [r7, #4]
 800c282:	681b      	ldr	r3, [r3, #0]
 800c284:	2140      	movs	r1, #64	; 0x40
 800c286:	4618      	mov	r0, r3
 800c288:	f000 fc7f 	bl	800cb8a <TIM_ITRx_SetConfig>
      break;
 800c28c:	e00c      	b.n	800c2a8 <HAL_TIM_ConfigClockSource+0x1e8>
    case TIM_CLOCKSOURCE_ITR11:
    {
      /* Check whether or not the timer instance supports internal trigger input */
      assert_param(IS_TIM_CLOCKSOURCE_INSTANCE((htim->Instance), sClockSourceConfig->ClockSource));

      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
 800c28e:	687b      	ldr	r3, [r7, #4]
 800c290:	681a      	ldr	r2, [r3, #0]
 800c292:	683b      	ldr	r3, [r7, #0]
 800c294:	681b      	ldr	r3, [r3, #0]
 800c296:	4619      	mov	r1, r3
 800c298:	4610      	mov	r0, r2
 800c29a:	f000 fc76 	bl	800cb8a <TIM_ITRx_SetConfig>
      break;
 800c29e:	e003      	b.n	800c2a8 <HAL_TIM_ConfigClockSource+0x1e8>
    }

    default:
      status = HAL_ERROR;
 800c2a0:	2301      	movs	r3, #1
 800c2a2:	73fb      	strb	r3, [r7, #15]
      break;
 800c2a4:	e000      	b.n	800c2a8 <HAL_TIM_ConfigClockSource+0x1e8>
      break;
 800c2a6:	bf00      	nop
  }
  htim->State = HAL_TIM_STATE_READY;
 800c2a8:	687b      	ldr	r3, [r7, #4]
 800c2aa:	2201      	movs	r2, #1
 800c2ac:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 800c2b0:	687b      	ldr	r3, [r7, #4]
 800c2b2:	2200      	movs	r2, #0
 800c2b4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
 800c2b8:	7bfb      	ldrb	r3, [r7, #15]
}
 800c2ba:	4618      	mov	r0, r3
 800c2bc:	3710      	adds	r7, #16
 800c2be:	46bd      	mov	sp, r7
 800c2c0:	bd80      	pop	{r7, pc}
 800c2c2:	bf00      	nop
 800c2c4:	00100070 	.word	0x00100070
 800c2c8:	00100050 	.word	0x00100050
 800c2cc:	00100040 	.word	0x00100040
 800c2d0:	00100030 	.word	0x00100030
 800c2d4:	00100020 	.word	0x00100020

0800c2d8 <HAL_TIM_PeriodElapsedCallback>:
  * @brief  Period elapsed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 800c2d8:	b480      	push	{r7}
 800c2da:	b083      	sub	sp, #12
 800c2dc:	af00      	add	r7, sp, #0
 800c2de:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   */
}
 800c2e0:	bf00      	nop
 800c2e2:	370c      	adds	r7, #12
 800c2e4:	46bd      	mov	sp, r7
 800c2e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c2ea:	4770      	bx	lr

0800c2ec <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 800c2ec:	b480      	push	{r7}
 800c2ee:	b083      	sub	sp, #12
 800c2f0:	af00      	add	r7, sp, #0
 800c2f2:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 800c2f4:	bf00      	nop
 800c2f6:	370c      	adds	r7, #12
 800c2f8:	46bd      	mov	sp, r7
 800c2fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c2fe:	4770      	bx	lr

0800c300 <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 800c300:	b480      	push	{r7}
 800c302:	b083      	sub	sp, #12
 800c304:	af00      	add	r7, sp, #0
 800c306:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 800c308:	bf00      	nop
 800c30a:	370c      	adds	r7, #12
 800c30c:	46bd      	mov	sp, r7
 800c30e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c312:	4770      	bx	lr

0800c314 <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 800c314:	b480      	push	{r7}
 800c316:	b083      	sub	sp, #12
 800c318:	af00      	add	r7, sp, #0
 800c31a:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 800c31c:	bf00      	nop
 800c31e:	370c      	adds	r7, #12
 800c320:	46bd      	mov	sp, r7
 800c322:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c326:	4770      	bx	lr

0800c328 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 800c328:	b480      	push	{r7}
 800c32a:	b085      	sub	sp, #20
 800c32c:	af00      	add	r7, sp, #0
 800c32e:	6078      	str	r0, [r7, #4]
 800c330:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 800c332:	687b      	ldr	r3, [r7, #4]
 800c334:	681b      	ldr	r3, [r3, #0]
 800c336:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800c338:	687b      	ldr	r3, [r7, #4]
 800c33a:	4a46      	ldr	r2, [pc, #280]	; (800c454 <TIM_Base_SetConfig+0x12c>)
 800c33c:	4293      	cmp	r3, r2
 800c33e:	d017      	beq.n	800c370 <TIM_Base_SetConfig+0x48>
 800c340:	687b      	ldr	r3, [r7, #4]
 800c342:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800c346:	d013      	beq.n	800c370 <TIM_Base_SetConfig+0x48>
 800c348:	687b      	ldr	r3, [r7, #4]
 800c34a:	4a43      	ldr	r2, [pc, #268]	; (800c458 <TIM_Base_SetConfig+0x130>)
 800c34c:	4293      	cmp	r3, r2
 800c34e:	d00f      	beq.n	800c370 <TIM_Base_SetConfig+0x48>
 800c350:	687b      	ldr	r3, [r7, #4]
 800c352:	4a42      	ldr	r2, [pc, #264]	; (800c45c <TIM_Base_SetConfig+0x134>)
 800c354:	4293      	cmp	r3, r2
 800c356:	d00b      	beq.n	800c370 <TIM_Base_SetConfig+0x48>
 800c358:	687b      	ldr	r3, [r7, #4]
 800c35a:	4a41      	ldr	r2, [pc, #260]	; (800c460 <TIM_Base_SetConfig+0x138>)
 800c35c:	4293      	cmp	r3, r2
 800c35e:	d007      	beq.n	800c370 <TIM_Base_SetConfig+0x48>
 800c360:	687b      	ldr	r3, [r7, #4]
 800c362:	4a40      	ldr	r2, [pc, #256]	; (800c464 <TIM_Base_SetConfig+0x13c>)
 800c364:	4293      	cmp	r3, r2
 800c366:	d003      	beq.n	800c370 <TIM_Base_SetConfig+0x48>
 800c368:	687b      	ldr	r3, [r7, #4]
 800c36a:	4a3f      	ldr	r2, [pc, #252]	; (800c468 <TIM_Base_SetConfig+0x140>)
 800c36c:	4293      	cmp	r3, r2
 800c36e:	d108      	bne.n	800c382 <TIM_Base_SetConfig+0x5a>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800c370:	68fb      	ldr	r3, [r7, #12]
 800c372:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800c376:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 800c378:	683b      	ldr	r3, [r7, #0]
 800c37a:	685b      	ldr	r3, [r3, #4]
 800c37c:	68fa      	ldr	r2, [r7, #12]
 800c37e:	4313      	orrs	r3, r2
 800c380:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800c382:	687b      	ldr	r3, [r7, #4]
 800c384:	4a33      	ldr	r2, [pc, #204]	; (800c454 <TIM_Base_SetConfig+0x12c>)
 800c386:	4293      	cmp	r3, r2
 800c388:	d023      	beq.n	800c3d2 <TIM_Base_SetConfig+0xaa>
 800c38a:	687b      	ldr	r3, [r7, #4]
 800c38c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800c390:	d01f      	beq.n	800c3d2 <TIM_Base_SetConfig+0xaa>
 800c392:	687b      	ldr	r3, [r7, #4]
 800c394:	4a30      	ldr	r2, [pc, #192]	; (800c458 <TIM_Base_SetConfig+0x130>)
 800c396:	4293      	cmp	r3, r2
 800c398:	d01b      	beq.n	800c3d2 <TIM_Base_SetConfig+0xaa>
 800c39a:	687b      	ldr	r3, [r7, #4]
 800c39c:	4a2f      	ldr	r2, [pc, #188]	; (800c45c <TIM_Base_SetConfig+0x134>)
 800c39e:	4293      	cmp	r3, r2
 800c3a0:	d017      	beq.n	800c3d2 <TIM_Base_SetConfig+0xaa>
 800c3a2:	687b      	ldr	r3, [r7, #4]
 800c3a4:	4a2e      	ldr	r2, [pc, #184]	; (800c460 <TIM_Base_SetConfig+0x138>)
 800c3a6:	4293      	cmp	r3, r2
 800c3a8:	d013      	beq.n	800c3d2 <TIM_Base_SetConfig+0xaa>
 800c3aa:	687b      	ldr	r3, [r7, #4]
 800c3ac:	4a2d      	ldr	r2, [pc, #180]	; (800c464 <TIM_Base_SetConfig+0x13c>)
 800c3ae:	4293      	cmp	r3, r2
 800c3b0:	d00f      	beq.n	800c3d2 <TIM_Base_SetConfig+0xaa>
 800c3b2:	687b      	ldr	r3, [r7, #4]
 800c3b4:	4a2d      	ldr	r2, [pc, #180]	; (800c46c <TIM_Base_SetConfig+0x144>)
 800c3b6:	4293      	cmp	r3, r2
 800c3b8:	d00b      	beq.n	800c3d2 <TIM_Base_SetConfig+0xaa>
 800c3ba:	687b      	ldr	r3, [r7, #4]
 800c3bc:	4a2c      	ldr	r2, [pc, #176]	; (800c470 <TIM_Base_SetConfig+0x148>)
 800c3be:	4293      	cmp	r3, r2
 800c3c0:	d007      	beq.n	800c3d2 <TIM_Base_SetConfig+0xaa>
 800c3c2:	687b      	ldr	r3, [r7, #4]
 800c3c4:	4a2b      	ldr	r2, [pc, #172]	; (800c474 <TIM_Base_SetConfig+0x14c>)
 800c3c6:	4293      	cmp	r3, r2
 800c3c8:	d003      	beq.n	800c3d2 <TIM_Base_SetConfig+0xaa>
 800c3ca:	687b      	ldr	r3, [r7, #4]
 800c3cc:	4a26      	ldr	r2, [pc, #152]	; (800c468 <TIM_Base_SetConfig+0x140>)
 800c3ce:	4293      	cmp	r3, r2
 800c3d0:	d108      	bne.n	800c3e4 <TIM_Base_SetConfig+0xbc>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 800c3d2:	68fb      	ldr	r3, [r7, #12]
 800c3d4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800c3d8:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800c3da:	683b      	ldr	r3, [r7, #0]
 800c3dc:	68db      	ldr	r3, [r3, #12]
 800c3de:	68fa      	ldr	r2, [r7, #12]
 800c3e0:	4313      	orrs	r3, r2
 800c3e2:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800c3e4:	68fb      	ldr	r3, [r7, #12]
 800c3e6:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 800c3ea:	683b      	ldr	r3, [r7, #0]
 800c3ec:	695b      	ldr	r3, [r3, #20]
 800c3ee:	4313      	orrs	r3, r2
 800c3f0:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 800c3f2:	687b      	ldr	r3, [r7, #4]
 800c3f4:	68fa      	ldr	r2, [r7, #12]
 800c3f6:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 800c3f8:	683b      	ldr	r3, [r7, #0]
 800c3fa:	689a      	ldr	r2, [r3, #8]
 800c3fc:	687b      	ldr	r3, [r7, #4]
 800c3fe:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 800c400:	683b      	ldr	r3, [r7, #0]
 800c402:	681a      	ldr	r2, [r3, #0]
 800c404:	687b      	ldr	r3, [r7, #4]
 800c406:	629a      	str	r2, [r3, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800c408:	687b      	ldr	r3, [r7, #4]
 800c40a:	4a12      	ldr	r2, [pc, #72]	; (800c454 <TIM_Base_SetConfig+0x12c>)
 800c40c:	4293      	cmp	r3, r2
 800c40e:	d013      	beq.n	800c438 <TIM_Base_SetConfig+0x110>
 800c410:	687b      	ldr	r3, [r7, #4]
 800c412:	4a14      	ldr	r2, [pc, #80]	; (800c464 <TIM_Base_SetConfig+0x13c>)
 800c414:	4293      	cmp	r3, r2
 800c416:	d00f      	beq.n	800c438 <TIM_Base_SetConfig+0x110>
 800c418:	687b      	ldr	r3, [r7, #4]
 800c41a:	4a14      	ldr	r2, [pc, #80]	; (800c46c <TIM_Base_SetConfig+0x144>)
 800c41c:	4293      	cmp	r3, r2
 800c41e:	d00b      	beq.n	800c438 <TIM_Base_SetConfig+0x110>
 800c420:	687b      	ldr	r3, [r7, #4]
 800c422:	4a13      	ldr	r2, [pc, #76]	; (800c470 <TIM_Base_SetConfig+0x148>)
 800c424:	4293      	cmp	r3, r2
 800c426:	d007      	beq.n	800c438 <TIM_Base_SetConfig+0x110>
 800c428:	687b      	ldr	r3, [r7, #4]
 800c42a:	4a12      	ldr	r2, [pc, #72]	; (800c474 <TIM_Base_SetConfig+0x14c>)
 800c42c:	4293      	cmp	r3, r2
 800c42e:	d003      	beq.n	800c438 <TIM_Base_SetConfig+0x110>
 800c430:	687b      	ldr	r3, [r7, #4]
 800c432:	4a0d      	ldr	r2, [pc, #52]	; (800c468 <TIM_Base_SetConfig+0x140>)
 800c434:	4293      	cmp	r3, r2
 800c436:	d103      	bne.n	800c440 <TIM_Base_SetConfig+0x118>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 800c438:	683b      	ldr	r3, [r7, #0]
 800c43a:	691a      	ldr	r2, [r3, #16]
 800c43c:	687b      	ldr	r3, [r7, #4]
 800c43e:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 800c440:	687b      	ldr	r3, [r7, #4]
 800c442:	2201      	movs	r2, #1
 800c444:	615a      	str	r2, [r3, #20]
}
 800c446:	bf00      	nop
 800c448:	3714      	adds	r7, #20
 800c44a:	46bd      	mov	sp, r7
 800c44c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c450:	4770      	bx	lr
 800c452:	bf00      	nop
 800c454:	40012c00 	.word	0x40012c00
 800c458:	40000400 	.word	0x40000400
 800c45c:	40000800 	.word	0x40000800
 800c460:	40000c00 	.word	0x40000c00
 800c464:	40013400 	.word	0x40013400
 800c468:	40015000 	.word	0x40015000
 800c46c:	40014000 	.word	0x40014000
 800c470:	40014400 	.word	0x40014400
 800c474:	40014800 	.word	0x40014800

0800c478 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800c478:	b480      	push	{r7}
 800c47a:	b087      	sub	sp, #28
 800c47c:	af00      	add	r7, sp, #0
 800c47e:	6078      	str	r0, [r7, #4]
 800c480:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800c482:	687b      	ldr	r3, [r7, #4]
 800c484:	6a1b      	ldr	r3, [r3, #32]
 800c486:	f023 0201 	bic.w	r2, r3, #1
 800c48a:	687b      	ldr	r3, [r7, #4]
 800c48c:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800c48e:	687b      	ldr	r3, [r7, #4]
 800c490:	6a1b      	ldr	r3, [r3, #32]
 800c492:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800c494:	687b      	ldr	r3, [r7, #4]
 800c496:	685b      	ldr	r3, [r3, #4]
 800c498:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800c49a:	687b      	ldr	r3, [r7, #4]
 800c49c:	699b      	ldr	r3, [r3, #24]
 800c49e:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
 800c4a0:	68fb      	ldr	r3, [r7, #12]
 800c4a2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800c4a6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800c4aa:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 800c4ac:	68fb      	ldr	r3, [r7, #12]
 800c4ae:	f023 0303 	bic.w	r3, r3, #3
 800c4b2:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800c4b4:	683b      	ldr	r3, [r7, #0]
 800c4b6:	681b      	ldr	r3, [r3, #0]
 800c4b8:	68fa      	ldr	r2, [r7, #12]
 800c4ba:	4313      	orrs	r3, r2
 800c4bc:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 800c4be:	697b      	ldr	r3, [r7, #20]
 800c4c0:	f023 0302 	bic.w	r3, r3, #2
 800c4c4:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 800c4c6:	683b      	ldr	r3, [r7, #0]
 800c4c8:	689b      	ldr	r3, [r3, #8]
 800c4ca:	697a      	ldr	r2, [r7, #20]
 800c4cc:	4313      	orrs	r3, r2
 800c4ce:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 800c4d0:	687b      	ldr	r3, [r7, #4]
 800c4d2:	4a30      	ldr	r2, [pc, #192]	; (800c594 <TIM_OC1_SetConfig+0x11c>)
 800c4d4:	4293      	cmp	r3, r2
 800c4d6:	d013      	beq.n	800c500 <TIM_OC1_SetConfig+0x88>
 800c4d8:	687b      	ldr	r3, [r7, #4]
 800c4da:	4a2f      	ldr	r2, [pc, #188]	; (800c598 <TIM_OC1_SetConfig+0x120>)
 800c4dc:	4293      	cmp	r3, r2
 800c4de:	d00f      	beq.n	800c500 <TIM_OC1_SetConfig+0x88>
 800c4e0:	687b      	ldr	r3, [r7, #4]
 800c4e2:	4a2e      	ldr	r2, [pc, #184]	; (800c59c <TIM_OC1_SetConfig+0x124>)
 800c4e4:	4293      	cmp	r3, r2
 800c4e6:	d00b      	beq.n	800c500 <TIM_OC1_SetConfig+0x88>
 800c4e8:	687b      	ldr	r3, [r7, #4]
 800c4ea:	4a2d      	ldr	r2, [pc, #180]	; (800c5a0 <TIM_OC1_SetConfig+0x128>)
 800c4ec:	4293      	cmp	r3, r2
 800c4ee:	d007      	beq.n	800c500 <TIM_OC1_SetConfig+0x88>
 800c4f0:	687b      	ldr	r3, [r7, #4]
 800c4f2:	4a2c      	ldr	r2, [pc, #176]	; (800c5a4 <TIM_OC1_SetConfig+0x12c>)
 800c4f4:	4293      	cmp	r3, r2
 800c4f6:	d003      	beq.n	800c500 <TIM_OC1_SetConfig+0x88>
 800c4f8:	687b      	ldr	r3, [r7, #4]
 800c4fa:	4a2b      	ldr	r2, [pc, #172]	; (800c5a8 <TIM_OC1_SetConfig+0x130>)
 800c4fc:	4293      	cmp	r3, r2
 800c4fe:	d10c      	bne.n	800c51a <TIM_OC1_SetConfig+0xa2>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 800c500:	697b      	ldr	r3, [r7, #20]
 800c502:	f023 0308 	bic.w	r3, r3, #8
 800c506:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 800c508:	683b      	ldr	r3, [r7, #0]
 800c50a:	68db      	ldr	r3, [r3, #12]
 800c50c:	697a      	ldr	r2, [r7, #20]
 800c50e:	4313      	orrs	r3, r2
 800c510:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 800c512:	697b      	ldr	r3, [r7, #20]
 800c514:	f023 0304 	bic.w	r3, r3, #4
 800c518:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800c51a:	687b      	ldr	r3, [r7, #4]
 800c51c:	4a1d      	ldr	r2, [pc, #116]	; (800c594 <TIM_OC1_SetConfig+0x11c>)
 800c51e:	4293      	cmp	r3, r2
 800c520:	d013      	beq.n	800c54a <TIM_OC1_SetConfig+0xd2>
 800c522:	687b      	ldr	r3, [r7, #4]
 800c524:	4a1c      	ldr	r2, [pc, #112]	; (800c598 <TIM_OC1_SetConfig+0x120>)
 800c526:	4293      	cmp	r3, r2
 800c528:	d00f      	beq.n	800c54a <TIM_OC1_SetConfig+0xd2>
 800c52a:	687b      	ldr	r3, [r7, #4]
 800c52c:	4a1b      	ldr	r2, [pc, #108]	; (800c59c <TIM_OC1_SetConfig+0x124>)
 800c52e:	4293      	cmp	r3, r2
 800c530:	d00b      	beq.n	800c54a <TIM_OC1_SetConfig+0xd2>
 800c532:	687b      	ldr	r3, [r7, #4]
 800c534:	4a1a      	ldr	r2, [pc, #104]	; (800c5a0 <TIM_OC1_SetConfig+0x128>)
 800c536:	4293      	cmp	r3, r2
 800c538:	d007      	beq.n	800c54a <TIM_OC1_SetConfig+0xd2>
 800c53a:	687b      	ldr	r3, [r7, #4]
 800c53c:	4a19      	ldr	r2, [pc, #100]	; (800c5a4 <TIM_OC1_SetConfig+0x12c>)
 800c53e:	4293      	cmp	r3, r2
 800c540:	d003      	beq.n	800c54a <TIM_OC1_SetConfig+0xd2>
 800c542:	687b      	ldr	r3, [r7, #4]
 800c544:	4a18      	ldr	r2, [pc, #96]	; (800c5a8 <TIM_OC1_SetConfig+0x130>)
 800c546:	4293      	cmp	r3, r2
 800c548:	d111      	bne.n	800c56e <TIM_OC1_SetConfig+0xf6>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
 800c54a:	693b      	ldr	r3, [r7, #16]
 800c54c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800c550:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 800c552:	693b      	ldr	r3, [r7, #16]
 800c554:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800c558:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
 800c55a:	683b      	ldr	r3, [r7, #0]
 800c55c:	695b      	ldr	r3, [r3, #20]
 800c55e:	693a      	ldr	r2, [r7, #16]
 800c560:	4313      	orrs	r3, r2
 800c562:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 800c564:	683b      	ldr	r3, [r7, #0]
 800c566:	699b      	ldr	r3, [r3, #24]
 800c568:	693a      	ldr	r2, [r7, #16]
 800c56a:	4313      	orrs	r3, r2
 800c56c:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800c56e:	687b      	ldr	r3, [r7, #4]
 800c570:	693a      	ldr	r2, [r7, #16]
 800c572:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800c574:	687b      	ldr	r3, [r7, #4]
 800c576:	68fa      	ldr	r2, [r7, #12]
 800c578:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 800c57a:	683b      	ldr	r3, [r7, #0]
 800c57c:	685a      	ldr	r2, [r3, #4]
 800c57e:	687b      	ldr	r3, [r7, #4]
 800c580:	635a      	str	r2, [r3, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800c582:	687b      	ldr	r3, [r7, #4]
 800c584:	697a      	ldr	r2, [r7, #20]
 800c586:	621a      	str	r2, [r3, #32]
}
 800c588:	bf00      	nop
 800c58a:	371c      	adds	r7, #28
 800c58c:	46bd      	mov	sp, r7
 800c58e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c592:	4770      	bx	lr
 800c594:	40012c00 	.word	0x40012c00
 800c598:	40013400 	.word	0x40013400
 800c59c:	40014000 	.word	0x40014000
 800c5a0:	40014400 	.word	0x40014400
 800c5a4:	40014800 	.word	0x40014800
 800c5a8:	40015000 	.word	0x40015000

0800c5ac <TIM_OC2_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800c5ac:	b480      	push	{r7}
 800c5ae:	b087      	sub	sp, #28
 800c5b0:	af00      	add	r7, sp, #0
 800c5b2:	6078      	str	r0, [r7, #4]
 800c5b4:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800c5b6:	687b      	ldr	r3, [r7, #4]
 800c5b8:	6a1b      	ldr	r3, [r3, #32]
 800c5ba:	f023 0210 	bic.w	r2, r3, #16
 800c5be:	687b      	ldr	r3, [r7, #4]
 800c5c0:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800c5c2:	687b      	ldr	r3, [r7, #4]
 800c5c4:	6a1b      	ldr	r3, [r3, #32]
 800c5c6:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800c5c8:	687b      	ldr	r3, [r7, #4]
 800c5ca:	685b      	ldr	r3, [r3, #4]
 800c5cc:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800c5ce:	687b      	ldr	r3, [r7, #4]
 800c5d0:	699b      	ldr	r3, [r3, #24]
 800c5d2:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
 800c5d4:	68fb      	ldr	r3, [r7, #12]
 800c5d6:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800c5da:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800c5de:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 800c5e0:	68fb      	ldr	r3, [r7, #12]
 800c5e2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800c5e6:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800c5e8:	683b      	ldr	r3, [r7, #0]
 800c5ea:	681b      	ldr	r3, [r3, #0]
 800c5ec:	021b      	lsls	r3, r3, #8
 800c5ee:	68fa      	ldr	r2, [r7, #12]
 800c5f0:	4313      	orrs	r3, r2
 800c5f2:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 800c5f4:	697b      	ldr	r3, [r7, #20]
 800c5f6:	f023 0320 	bic.w	r3, r3, #32
 800c5fa:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4U);
 800c5fc:	683b      	ldr	r3, [r7, #0]
 800c5fe:	689b      	ldr	r3, [r3, #8]
 800c600:	011b      	lsls	r3, r3, #4
 800c602:	697a      	ldr	r2, [r7, #20]
 800c604:	4313      	orrs	r3, r2
 800c606:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 800c608:	687b      	ldr	r3, [r7, #4]
 800c60a:	4a2c      	ldr	r2, [pc, #176]	; (800c6bc <TIM_OC2_SetConfig+0x110>)
 800c60c:	4293      	cmp	r3, r2
 800c60e:	d007      	beq.n	800c620 <TIM_OC2_SetConfig+0x74>
 800c610:	687b      	ldr	r3, [r7, #4]
 800c612:	4a2b      	ldr	r2, [pc, #172]	; (800c6c0 <TIM_OC2_SetConfig+0x114>)
 800c614:	4293      	cmp	r3, r2
 800c616:	d003      	beq.n	800c620 <TIM_OC2_SetConfig+0x74>
 800c618:	687b      	ldr	r3, [r7, #4]
 800c61a:	4a2a      	ldr	r2, [pc, #168]	; (800c6c4 <TIM_OC2_SetConfig+0x118>)
 800c61c:	4293      	cmp	r3, r2
 800c61e:	d10d      	bne.n	800c63c <TIM_OC2_SetConfig+0x90>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
 800c620:	697b      	ldr	r3, [r7, #20]
 800c622:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800c626:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 800c628:	683b      	ldr	r3, [r7, #0]
 800c62a:	68db      	ldr	r3, [r3, #12]
 800c62c:	011b      	lsls	r3, r3, #4
 800c62e:	697a      	ldr	r2, [r7, #20]
 800c630:	4313      	orrs	r3, r2
 800c632:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;
 800c634:	697b      	ldr	r3, [r7, #20]
 800c636:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800c63a:	617b      	str	r3, [r7, #20]

  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800c63c:	687b      	ldr	r3, [r7, #4]
 800c63e:	4a1f      	ldr	r2, [pc, #124]	; (800c6bc <TIM_OC2_SetConfig+0x110>)
 800c640:	4293      	cmp	r3, r2
 800c642:	d013      	beq.n	800c66c <TIM_OC2_SetConfig+0xc0>
 800c644:	687b      	ldr	r3, [r7, #4]
 800c646:	4a1e      	ldr	r2, [pc, #120]	; (800c6c0 <TIM_OC2_SetConfig+0x114>)
 800c648:	4293      	cmp	r3, r2
 800c64a:	d00f      	beq.n	800c66c <TIM_OC2_SetConfig+0xc0>
 800c64c:	687b      	ldr	r3, [r7, #4]
 800c64e:	4a1e      	ldr	r2, [pc, #120]	; (800c6c8 <TIM_OC2_SetConfig+0x11c>)
 800c650:	4293      	cmp	r3, r2
 800c652:	d00b      	beq.n	800c66c <TIM_OC2_SetConfig+0xc0>
 800c654:	687b      	ldr	r3, [r7, #4]
 800c656:	4a1d      	ldr	r2, [pc, #116]	; (800c6cc <TIM_OC2_SetConfig+0x120>)
 800c658:	4293      	cmp	r3, r2
 800c65a:	d007      	beq.n	800c66c <TIM_OC2_SetConfig+0xc0>
 800c65c:	687b      	ldr	r3, [r7, #4]
 800c65e:	4a1c      	ldr	r2, [pc, #112]	; (800c6d0 <TIM_OC2_SetConfig+0x124>)
 800c660:	4293      	cmp	r3, r2
 800c662:	d003      	beq.n	800c66c <TIM_OC2_SetConfig+0xc0>
 800c664:	687b      	ldr	r3, [r7, #4]
 800c666:	4a17      	ldr	r2, [pc, #92]	; (800c6c4 <TIM_OC2_SetConfig+0x118>)
 800c668:	4293      	cmp	r3, r2
 800c66a:	d113      	bne.n	800c694 <TIM_OC2_SetConfig+0xe8>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
 800c66c:	693b      	ldr	r3, [r7, #16]
 800c66e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800c672:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 800c674:	693b      	ldr	r3, [r7, #16]
 800c676:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800c67a:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 800c67c:	683b      	ldr	r3, [r7, #0]
 800c67e:	695b      	ldr	r3, [r3, #20]
 800c680:	009b      	lsls	r3, r3, #2
 800c682:	693a      	ldr	r2, [r7, #16]
 800c684:	4313      	orrs	r3, r2
 800c686:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 800c688:	683b      	ldr	r3, [r7, #0]
 800c68a:	699b      	ldr	r3, [r3, #24]
 800c68c:	009b      	lsls	r3, r3, #2
 800c68e:	693a      	ldr	r2, [r7, #16]
 800c690:	4313      	orrs	r3, r2
 800c692:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800c694:	687b      	ldr	r3, [r7, #4]
 800c696:	693a      	ldr	r2, [r7, #16]
 800c698:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800c69a:	687b      	ldr	r3, [r7, #4]
 800c69c:	68fa      	ldr	r2, [r7, #12]
 800c69e:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 800c6a0:	683b      	ldr	r3, [r7, #0]
 800c6a2:	685a      	ldr	r2, [r3, #4]
 800c6a4:	687b      	ldr	r3, [r7, #4]
 800c6a6:	639a      	str	r2, [r3, #56]	; 0x38

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800c6a8:	687b      	ldr	r3, [r7, #4]
 800c6aa:	697a      	ldr	r2, [r7, #20]
 800c6ac:	621a      	str	r2, [r3, #32]
}
 800c6ae:	bf00      	nop
 800c6b0:	371c      	adds	r7, #28
 800c6b2:	46bd      	mov	sp, r7
 800c6b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c6b8:	4770      	bx	lr
 800c6ba:	bf00      	nop
 800c6bc:	40012c00 	.word	0x40012c00
 800c6c0:	40013400 	.word	0x40013400
 800c6c4:	40015000 	.word	0x40015000
 800c6c8:	40014000 	.word	0x40014000
 800c6cc:	40014400 	.word	0x40014400
 800c6d0:	40014800 	.word	0x40014800

0800c6d4 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800c6d4:	b480      	push	{r7}
 800c6d6:	b087      	sub	sp, #28
 800c6d8:	af00      	add	r7, sp, #0
 800c6da:	6078      	str	r0, [r7, #4]
 800c6dc:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 800c6de:	687b      	ldr	r3, [r7, #4]
 800c6e0:	6a1b      	ldr	r3, [r3, #32]
 800c6e2:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 800c6e6:	687b      	ldr	r3, [r7, #4]
 800c6e8:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800c6ea:	687b      	ldr	r3, [r7, #4]
 800c6ec:	6a1b      	ldr	r3, [r3, #32]
 800c6ee:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800c6f0:	687b      	ldr	r3, [r7, #4]
 800c6f2:	685b      	ldr	r3, [r3, #4]
 800c6f4:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800c6f6:	687b      	ldr	r3, [r7, #4]
 800c6f8:	69db      	ldr	r3, [r3, #28]
 800c6fa:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
 800c6fc:	68fb      	ldr	r3, [r7, #12]
 800c6fe:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800c702:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800c706:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 800c708:	68fb      	ldr	r3, [r7, #12]
 800c70a:	f023 0303 	bic.w	r3, r3, #3
 800c70e:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800c710:	683b      	ldr	r3, [r7, #0]
 800c712:	681b      	ldr	r3, [r3, #0]
 800c714:	68fa      	ldr	r2, [r7, #12]
 800c716:	4313      	orrs	r3, r2
 800c718:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 800c71a:	697b      	ldr	r3, [r7, #20]
 800c71c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800c720:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 800c722:	683b      	ldr	r3, [r7, #0]
 800c724:	689b      	ldr	r3, [r3, #8]
 800c726:	021b      	lsls	r3, r3, #8
 800c728:	697a      	ldr	r2, [r7, #20]
 800c72a:	4313      	orrs	r3, r2
 800c72c:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 800c72e:	687b      	ldr	r3, [r7, #4]
 800c730:	4a2b      	ldr	r2, [pc, #172]	; (800c7e0 <TIM_OC3_SetConfig+0x10c>)
 800c732:	4293      	cmp	r3, r2
 800c734:	d007      	beq.n	800c746 <TIM_OC3_SetConfig+0x72>
 800c736:	687b      	ldr	r3, [r7, #4]
 800c738:	4a2a      	ldr	r2, [pc, #168]	; (800c7e4 <TIM_OC3_SetConfig+0x110>)
 800c73a:	4293      	cmp	r3, r2
 800c73c:	d003      	beq.n	800c746 <TIM_OC3_SetConfig+0x72>
 800c73e:	687b      	ldr	r3, [r7, #4]
 800c740:	4a29      	ldr	r2, [pc, #164]	; (800c7e8 <TIM_OC3_SetConfig+0x114>)
 800c742:	4293      	cmp	r3, r2
 800c744:	d10d      	bne.n	800c762 <TIM_OC3_SetConfig+0x8e>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 800c746:	697b      	ldr	r3, [r7, #20]
 800c748:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800c74c:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 800c74e:	683b      	ldr	r3, [r7, #0]
 800c750:	68db      	ldr	r3, [r3, #12]
 800c752:	021b      	lsls	r3, r3, #8
 800c754:	697a      	ldr	r2, [r7, #20]
 800c756:	4313      	orrs	r3, r2
 800c758:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 800c75a:	697b      	ldr	r3, [r7, #20]
 800c75c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800c760:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800c762:	687b      	ldr	r3, [r7, #4]
 800c764:	4a1e      	ldr	r2, [pc, #120]	; (800c7e0 <TIM_OC3_SetConfig+0x10c>)
 800c766:	4293      	cmp	r3, r2
 800c768:	d013      	beq.n	800c792 <TIM_OC3_SetConfig+0xbe>
 800c76a:	687b      	ldr	r3, [r7, #4]
 800c76c:	4a1d      	ldr	r2, [pc, #116]	; (800c7e4 <TIM_OC3_SetConfig+0x110>)
 800c76e:	4293      	cmp	r3, r2
 800c770:	d00f      	beq.n	800c792 <TIM_OC3_SetConfig+0xbe>
 800c772:	687b      	ldr	r3, [r7, #4]
 800c774:	4a1d      	ldr	r2, [pc, #116]	; (800c7ec <TIM_OC3_SetConfig+0x118>)
 800c776:	4293      	cmp	r3, r2
 800c778:	d00b      	beq.n	800c792 <TIM_OC3_SetConfig+0xbe>
 800c77a:	687b      	ldr	r3, [r7, #4]
 800c77c:	4a1c      	ldr	r2, [pc, #112]	; (800c7f0 <TIM_OC3_SetConfig+0x11c>)
 800c77e:	4293      	cmp	r3, r2
 800c780:	d007      	beq.n	800c792 <TIM_OC3_SetConfig+0xbe>
 800c782:	687b      	ldr	r3, [r7, #4]
 800c784:	4a1b      	ldr	r2, [pc, #108]	; (800c7f4 <TIM_OC3_SetConfig+0x120>)
 800c786:	4293      	cmp	r3, r2
 800c788:	d003      	beq.n	800c792 <TIM_OC3_SetConfig+0xbe>
 800c78a:	687b      	ldr	r3, [r7, #4]
 800c78c:	4a16      	ldr	r2, [pc, #88]	; (800c7e8 <TIM_OC3_SetConfig+0x114>)
 800c78e:	4293      	cmp	r3, r2
 800c790:	d113      	bne.n	800c7ba <TIM_OC3_SetConfig+0xe6>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
 800c792:	693b      	ldr	r3, [r7, #16]
 800c794:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800c798:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 800c79a:	693b      	ldr	r3, [r7, #16]
 800c79c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800c7a0:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 800c7a2:	683b      	ldr	r3, [r7, #0]
 800c7a4:	695b      	ldr	r3, [r3, #20]
 800c7a6:	011b      	lsls	r3, r3, #4
 800c7a8:	693a      	ldr	r2, [r7, #16]
 800c7aa:	4313      	orrs	r3, r2
 800c7ac:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 800c7ae:	683b      	ldr	r3, [r7, #0]
 800c7b0:	699b      	ldr	r3, [r3, #24]
 800c7b2:	011b      	lsls	r3, r3, #4
 800c7b4:	693a      	ldr	r2, [r7, #16]
 800c7b6:	4313      	orrs	r3, r2
 800c7b8:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800c7ba:	687b      	ldr	r3, [r7, #4]
 800c7bc:	693a      	ldr	r2, [r7, #16]
 800c7be:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 800c7c0:	687b      	ldr	r3, [r7, #4]
 800c7c2:	68fa      	ldr	r2, [r7, #12]
 800c7c4:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 800c7c6:	683b      	ldr	r3, [r7, #0]
 800c7c8:	685a      	ldr	r2, [r3, #4]
 800c7ca:	687b      	ldr	r3, [r7, #4]
 800c7cc:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800c7ce:	687b      	ldr	r3, [r7, #4]
 800c7d0:	697a      	ldr	r2, [r7, #20]
 800c7d2:	621a      	str	r2, [r3, #32]
}
 800c7d4:	bf00      	nop
 800c7d6:	371c      	adds	r7, #28
 800c7d8:	46bd      	mov	sp, r7
 800c7da:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c7de:	4770      	bx	lr
 800c7e0:	40012c00 	.word	0x40012c00
 800c7e4:	40013400 	.word	0x40013400
 800c7e8:	40015000 	.word	0x40015000
 800c7ec:	40014000 	.word	0x40014000
 800c7f0:	40014400 	.word	0x40014400
 800c7f4:	40014800 	.word	0x40014800

0800c7f8 <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800c7f8:	b480      	push	{r7}
 800c7fa:	b087      	sub	sp, #28
 800c7fc:	af00      	add	r7, sp, #0
 800c7fe:	6078      	str	r0, [r7, #4]
 800c800:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 800c802:	687b      	ldr	r3, [r7, #4]
 800c804:	6a1b      	ldr	r3, [r3, #32]
 800c806:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 800c80a:	687b      	ldr	r3, [r7, #4]
 800c80c:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800c80e:	687b      	ldr	r3, [r7, #4]
 800c810:	6a1b      	ldr	r3, [r3, #32]
 800c812:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800c814:	687b      	ldr	r3, [r7, #4]
 800c816:	685b      	ldr	r3, [r3, #4]
 800c818:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800c81a:	687b      	ldr	r3, [r7, #4]
 800c81c:	69db      	ldr	r3, [r3, #28]
 800c81e:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
 800c820:	68fb      	ldr	r3, [r7, #12]
 800c822:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800c826:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800c82a:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 800c82c:	68fb      	ldr	r3, [r7, #12]
 800c82e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800c832:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800c834:	683b      	ldr	r3, [r7, #0]
 800c836:	681b      	ldr	r3, [r3, #0]
 800c838:	021b      	lsls	r3, r3, #8
 800c83a:	68fa      	ldr	r2, [r7, #12]
 800c83c:	4313      	orrs	r3, r2
 800c83e:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 800c840:	697b      	ldr	r3, [r7, #20]
 800c842:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800c846:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 800c848:	683b      	ldr	r3, [r7, #0]
 800c84a:	689b      	ldr	r3, [r3, #8]
 800c84c:	031b      	lsls	r3, r3, #12
 800c84e:	697a      	ldr	r2, [r7, #20]
 800c850:	4313      	orrs	r3, r2
 800c852:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_4))
 800c854:	687b      	ldr	r3, [r7, #4]
 800c856:	4a2c      	ldr	r2, [pc, #176]	; (800c908 <TIM_OC4_SetConfig+0x110>)
 800c858:	4293      	cmp	r3, r2
 800c85a:	d007      	beq.n	800c86c <TIM_OC4_SetConfig+0x74>
 800c85c:	687b      	ldr	r3, [r7, #4]
 800c85e:	4a2b      	ldr	r2, [pc, #172]	; (800c90c <TIM_OC4_SetConfig+0x114>)
 800c860:	4293      	cmp	r3, r2
 800c862:	d003      	beq.n	800c86c <TIM_OC4_SetConfig+0x74>
 800c864:	687b      	ldr	r3, [r7, #4]
 800c866:	4a2a      	ldr	r2, [pc, #168]	; (800c910 <TIM_OC4_SetConfig+0x118>)
 800c868:	4293      	cmp	r3, r2
 800c86a:	d10d      	bne.n	800c888 <TIM_OC4_SetConfig+0x90>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC4NP;
 800c86c:	697b      	ldr	r3, [r7, #20]
 800c86e:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800c872:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 12U);
 800c874:	683b      	ldr	r3, [r7, #0]
 800c876:	68db      	ldr	r3, [r3, #12]
 800c878:	031b      	lsls	r3, r3, #12
 800c87a:	697a      	ldr	r2, [r7, #20]
 800c87c:	4313      	orrs	r3, r2
 800c87e:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC4NE;
 800c880:	697b      	ldr	r3, [r7, #20]
 800c882:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800c886:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800c888:	687b      	ldr	r3, [r7, #4]
 800c88a:	4a1f      	ldr	r2, [pc, #124]	; (800c908 <TIM_OC4_SetConfig+0x110>)
 800c88c:	4293      	cmp	r3, r2
 800c88e:	d013      	beq.n	800c8b8 <TIM_OC4_SetConfig+0xc0>
 800c890:	687b      	ldr	r3, [r7, #4]
 800c892:	4a1e      	ldr	r2, [pc, #120]	; (800c90c <TIM_OC4_SetConfig+0x114>)
 800c894:	4293      	cmp	r3, r2
 800c896:	d00f      	beq.n	800c8b8 <TIM_OC4_SetConfig+0xc0>
 800c898:	687b      	ldr	r3, [r7, #4]
 800c89a:	4a1e      	ldr	r2, [pc, #120]	; (800c914 <TIM_OC4_SetConfig+0x11c>)
 800c89c:	4293      	cmp	r3, r2
 800c89e:	d00b      	beq.n	800c8b8 <TIM_OC4_SetConfig+0xc0>
 800c8a0:	687b      	ldr	r3, [r7, #4]
 800c8a2:	4a1d      	ldr	r2, [pc, #116]	; (800c918 <TIM_OC4_SetConfig+0x120>)
 800c8a4:	4293      	cmp	r3, r2
 800c8a6:	d007      	beq.n	800c8b8 <TIM_OC4_SetConfig+0xc0>
 800c8a8:	687b      	ldr	r3, [r7, #4]
 800c8aa:	4a1c      	ldr	r2, [pc, #112]	; (800c91c <TIM_OC4_SetConfig+0x124>)
 800c8ac:	4293      	cmp	r3, r2
 800c8ae:	d003      	beq.n	800c8b8 <TIM_OC4_SetConfig+0xc0>
 800c8b0:	687b      	ldr	r3, [r7, #4]
 800c8b2:	4a17      	ldr	r2, [pc, #92]	; (800c910 <TIM_OC4_SetConfig+0x118>)
 800c8b4:	4293      	cmp	r3, r2
 800c8b6:	d113      	bne.n	800c8e0 <TIM_OC4_SetConfig+0xe8>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 800c8b8:	693b      	ldr	r3, [r7, #16]
 800c8ba:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800c8be:	613b      	str	r3, [r7, #16]
    /* Reset the Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4N;
 800c8c0:	693b      	ldr	r3, [r7, #16]
 800c8c2:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800c8c6:	613b      	str	r3, [r7, #16]

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 800c8c8:	683b      	ldr	r3, [r7, #0]
 800c8ca:	695b      	ldr	r3, [r3, #20]
 800c8cc:	019b      	lsls	r3, r3, #6
 800c8ce:	693a      	ldr	r2, [r7, #16]
 800c8d0:	4313      	orrs	r3, r2
 800c8d2:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 6U);
 800c8d4:	683b      	ldr	r3, [r7, #0]
 800c8d6:	699b      	ldr	r3, [r3, #24]
 800c8d8:	019b      	lsls	r3, r3, #6
 800c8da:	693a      	ldr	r2, [r7, #16]
 800c8dc:	4313      	orrs	r3, r2
 800c8de:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800c8e0:	687b      	ldr	r3, [r7, #4]
 800c8e2:	693a      	ldr	r2, [r7, #16]
 800c8e4:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 800c8e6:	687b      	ldr	r3, [r7, #4]
 800c8e8:	68fa      	ldr	r2, [r7, #12]
 800c8ea:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 800c8ec:	683b      	ldr	r3, [r7, #0]
 800c8ee:	685a      	ldr	r2, [r3, #4]
 800c8f0:	687b      	ldr	r3, [r7, #4]
 800c8f2:	641a      	str	r2, [r3, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800c8f4:	687b      	ldr	r3, [r7, #4]
 800c8f6:	697a      	ldr	r2, [r7, #20]
 800c8f8:	621a      	str	r2, [r3, #32]
}
 800c8fa:	bf00      	nop
 800c8fc:	371c      	adds	r7, #28
 800c8fe:	46bd      	mov	sp, r7
 800c900:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c904:	4770      	bx	lr
 800c906:	bf00      	nop
 800c908:	40012c00 	.word	0x40012c00
 800c90c:	40013400 	.word	0x40013400
 800c910:	40015000 	.word	0x40015000
 800c914:	40014000 	.word	0x40014000
 800c918:	40014400 	.word	0x40014400
 800c91c:	40014800 	.word	0x40014800

0800c920 <TIM_OC5_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 800c920:	b480      	push	{r7}
 800c922:	b087      	sub	sp, #28
 800c924:	af00      	add	r7, sp, #0
 800c926:	6078      	str	r0, [r7, #4]
 800c928:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
 800c92a:	687b      	ldr	r3, [r7, #4]
 800c92c:	6a1b      	ldr	r3, [r3, #32]
 800c92e:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 800c932:	687b      	ldr	r3, [r7, #4]
 800c934:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800c936:	687b      	ldr	r3, [r7, #4]
 800c938:	6a1b      	ldr	r3, [r3, #32]
 800c93a:	613b      	str	r3, [r7, #16]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800c93c:	687b      	ldr	r3, [r7, #4]
 800c93e:	685b      	ldr	r3, [r3, #4]
 800c940:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 800c942:	687b      	ldr	r3, [r7, #4]
 800c944:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800c946:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 800c948:	68fb      	ldr	r3, [r7, #12]
 800c94a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800c94e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800c952:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800c954:	683b      	ldr	r3, [r7, #0]
 800c956:	681b      	ldr	r3, [r3, #0]
 800c958:	68fa      	ldr	r2, [r7, #12]
 800c95a:	4313      	orrs	r3, r2
 800c95c:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
 800c95e:	693b      	ldr	r3, [r7, #16]
 800c960:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 800c964:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16U);
 800c966:	683b      	ldr	r3, [r7, #0]
 800c968:	689b      	ldr	r3, [r3, #8]
 800c96a:	041b      	lsls	r3, r3, #16
 800c96c:	693a      	ldr	r2, [r7, #16]
 800c96e:	4313      	orrs	r3, r2
 800c970:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800c972:	687b      	ldr	r3, [r7, #4]
 800c974:	4a19      	ldr	r2, [pc, #100]	; (800c9dc <TIM_OC5_SetConfig+0xbc>)
 800c976:	4293      	cmp	r3, r2
 800c978:	d013      	beq.n	800c9a2 <TIM_OC5_SetConfig+0x82>
 800c97a:	687b      	ldr	r3, [r7, #4]
 800c97c:	4a18      	ldr	r2, [pc, #96]	; (800c9e0 <TIM_OC5_SetConfig+0xc0>)
 800c97e:	4293      	cmp	r3, r2
 800c980:	d00f      	beq.n	800c9a2 <TIM_OC5_SetConfig+0x82>
 800c982:	687b      	ldr	r3, [r7, #4]
 800c984:	4a17      	ldr	r2, [pc, #92]	; (800c9e4 <TIM_OC5_SetConfig+0xc4>)
 800c986:	4293      	cmp	r3, r2
 800c988:	d00b      	beq.n	800c9a2 <TIM_OC5_SetConfig+0x82>
 800c98a:	687b      	ldr	r3, [r7, #4]
 800c98c:	4a16      	ldr	r2, [pc, #88]	; (800c9e8 <TIM_OC5_SetConfig+0xc8>)
 800c98e:	4293      	cmp	r3, r2
 800c990:	d007      	beq.n	800c9a2 <TIM_OC5_SetConfig+0x82>
 800c992:	687b      	ldr	r3, [r7, #4]
 800c994:	4a15      	ldr	r2, [pc, #84]	; (800c9ec <TIM_OC5_SetConfig+0xcc>)
 800c996:	4293      	cmp	r3, r2
 800c998:	d003      	beq.n	800c9a2 <TIM_OC5_SetConfig+0x82>
 800c99a:	687b      	ldr	r3, [r7, #4]
 800c99c:	4a14      	ldr	r2, [pc, #80]	; (800c9f0 <TIM_OC5_SetConfig+0xd0>)
 800c99e:	4293      	cmp	r3, r2
 800c9a0:	d109      	bne.n	800c9b6 <TIM_OC5_SetConfig+0x96>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
 800c9a2:	697b      	ldr	r3, [r7, #20]
 800c9a4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800c9a8:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 800c9aa:	683b      	ldr	r3, [r7, #0]
 800c9ac:	695b      	ldr	r3, [r3, #20]
 800c9ae:	021b      	lsls	r3, r3, #8
 800c9b0:	697a      	ldr	r2, [r7, #20]
 800c9b2:	4313      	orrs	r3, r2
 800c9b4:	617b      	str	r3, [r7, #20]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800c9b6:	687b      	ldr	r3, [r7, #4]
 800c9b8:	697a      	ldr	r2, [r7, #20]
 800c9ba:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 800c9bc:	687b      	ldr	r3, [r7, #4]
 800c9be:	68fa      	ldr	r2, [r7, #12]
 800c9c0:	651a      	str	r2, [r3, #80]	; 0x50

  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 800c9c2:	683b      	ldr	r3, [r7, #0]
 800c9c4:	685a      	ldr	r2, [r3, #4]
 800c9c6:	687b      	ldr	r3, [r7, #4]
 800c9c8:	649a      	str	r2, [r3, #72]	; 0x48

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800c9ca:	687b      	ldr	r3, [r7, #4]
 800c9cc:	693a      	ldr	r2, [r7, #16]
 800c9ce:	621a      	str	r2, [r3, #32]
}
 800c9d0:	bf00      	nop
 800c9d2:	371c      	adds	r7, #28
 800c9d4:	46bd      	mov	sp, r7
 800c9d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c9da:	4770      	bx	lr
 800c9dc:	40012c00 	.word	0x40012c00
 800c9e0:	40013400 	.word	0x40013400
 800c9e4:	40014000 	.word	0x40014000
 800c9e8:	40014400 	.word	0x40014400
 800c9ec:	40014800 	.word	0x40014800
 800c9f0:	40015000 	.word	0x40015000

0800c9f4 <TIM_OC6_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 800c9f4:	b480      	push	{r7}
 800c9f6:	b087      	sub	sp, #28
 800c9f8:	af00      	add	r7, sp, #0
 800c9fa:	6078      	str	r0, [r7, #4]
 800c9fc:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 800c9fe:	687b      	ldr	r3, [r7, #4]
 800ca00:	6a1b      	ldr	r3, [r3, #32]
 800ca02:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
 800ca06:	687b      	ldr	r3, [r7, #4]
 800ca08:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800ca0a:	687b      	ldr	r3, [r7, #4]
 800ca0c:	6a1b      	ldr	r3, [r3, #32]
 800ca0e:	613b      	str	r3, [r7, #16]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800ca10:	687b      	ldr	r3, [r7, #4]
 800ca12:	685b      	ldr	r3, [r3, #4]
 800ca14:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 800ca16:	687b      	ldr	r3, [r7, #4]
 800ca18:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800ca1a:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 800ca1c:	68fb      	ldr	r3, [r7, #12]
 800ca1e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800ca22:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800ca26:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800ca28:	683b      	ldr	r3, [r7, #0]
 800ca2a:	681b      	ldr	r3, [r3, #0]
 800ca2c:	021b      	lsls	r3, r3, #8
 800ca2e:	68fa      	ldr	r2, [r7, #12]
 800ca30:	4313      	orrs	r3, r2
 800ca32:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 800ca34:	693b      	ldr	r3, [r7, #16]
 800ca36:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800ca3a:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20U);
 800ca3c:	683b      	ldr	r3, [r7, #0]
 800ca3e:	689b      	ldr	r3, [r3, #8]
 800ca40:	051b      	lsls	r3, r3, #20
 800ca42:	693a      	ldr	r2, [r7, #16]
 800ca44:	4313      	orrs	r3, r2
 800ca46:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800ca48:	687b      	ldr	r3, [r7, #4]
 800ca4a:	4a1a      	ldr	r2, [pc, #104]	; (800cab4 <TIM_OC6_SetConfig+0xc0>)
 800ca4c:	4293      	cmp	r3, r2
 800ca4e:	d013      	beq.n	800ca78 <TIM_OC6_SetConfig+0x84>
 800ca50:	687b      	ldr	r3, [r7, #4]
 800ca52:	4a19      	ldr	r2, [pc, #100]	; (800cab8 <TIM_OC6_SetConfig+0xc4>)
 800ca54:	4293      	cmp	r3, r2
 800ca56:	d00f      	beq.n	800ca78 <TIM_OC6_SetConfig+0x84>
 800ca58:	687b      	ldr	r3, [r7, #4]
 800ca5a:	4a18      	ldr	r2, [pc, #96]	; (800cabc <TIM_OC6_SetConfig+0xc8>)
 800ca5c:	4293      	cmp	r3, r2
 800ca5e:	d00b      	beq.n	800ca78 <TIM_OC6_SetConfig+0x84>
 800ca60:	687b      	ldr	r3, [r7, #4]
 800ca62:	4a17      	ldr	r2, [pc, #92]	; (800cac0 <TIM_OC6_SetConfig+0xcc>)
 800ca64:	4293      	cmp	r3, r2
 800ca66:	d007      	beq.n	800ca78 <TIM_OC6_SetConfig+0x84>
 800ca68:	687b      	ldr	r3, [r7, #4]
 800ca6a:	4a16      	ldr	r2, [pc, #88]	; (800cac4 <TIM_OC6_SetConfig+0xd0>)
 800ca6c:	4293      	cmp	r3, r2
 800ca6e:	d003      	beq.n	800ca78 <TIM_OC6_SetConfig+0x84>
 800ca70:	687b      	ldr	r3, [r7, #4]
 800ca72:	4a15      	ldr	r2, [pc, #84]	; (800cac8 <TIM_OC6_SetConfig+0xd4>)
 800ca74:	4293      	cmp	r3, r2
 800ca76:	d109      	bne.n	800ca8c <TIM_OC6_SetConfig+0x98>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
 800ca78:	697b      	ldr	r3, [r7, #20]
 800ca7a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800ca7e:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 800ca80:	683b      	ldr	r3, [r7, #0]
 800ca82:	695b      	ldr	r3, [r3, #20]
 800ca84:	029b      	lsls	r3, r3, #10
 800ca86:	697a      	ldr	r2, [r7, #20]
 800ca88:	4313      	orrs	r3, r2
 800ca8a:	617b      	str	r3, [r7, #20]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800ca8c:	687b      	ldr	r3, [r7, #4]
 800ca8e:	697a      	ldr	r2, [r7, #20]
 800ca90:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 800ca92:	687b      	ldr	r3, [r7, #4]
 800ca94:	68fa      	ldr	r2, [r7, #12]
 800ca96:	651a      	str	r2, [r3, #80]	; 0x50

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 800ca98:	683b      	ldr	r3, [r7, #0]
 800ca9a:	685a      	ldr	r2, [r3, #4]
 800ca9c:	687b      	ldr	r3, [r7, #4]
 800ca9e:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800caa0:	687b      	ldr	r3, [r7, #4]
 800caa2:	693a      	ldr	r2, [r7, #16]
 800caa4:	621a      	str	r2, [r3, #32]
}
 800caa6:	bf00      	nop
 800caa8:	371c      	adds	r7, #28
 800caaa:	46bd      	mov	sp, r7
 800caac:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cab0:	4770      	bx	lr
 800cab2:	bf00      	nop
 800cab4:	40012c00 	.word	0x40012c00
 800cab8:	40013400 	.word	0x40013400
 800cabc:	40014000 	.word	0x40014000
 800cac0:	40014400 	.word	0x40014400
 800cac4:	40014800 	.word	0x40014800
 800cac8:	40015000 	.word	0x40015000

0800cacc <TIM_TI1_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 800cacc:	b480      	push	{r7}
 800cace:	b087      	sub	sp, #28
 800cad0:	af00      	add	r7, sp, #0
 800cad2:	60f8      	str	r0, [r7, #12]
 800cad4:	60b9      	str	r1, [r7, #8]
 800cad6:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 800cad8:	68fb      	ldr	r3, [r7, #12]
 800cada:	6a1b      	ldr	r3, [r3, #32]
 800cadc:	617b      	str	r3, [r7, #20]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800cade:	68fb      	ldr	r3, [r7, #12]
 800cae0:	6a1b      	ldr	r3, [r3, #32]
 800cae2:	f023 0201 	bic.w	r2, r3, #1
 800cae6:	68fb      	ldr	r3, [r7, #12]
 800cae8:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800caea:	68fb      	ldr	r3, [r7, #12]
 800caec:	699b      	ldr	r3, [r3, #24]
 800caee:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800caf0:	693b      	ldr	r3, [r7, #16]
 800caf2:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800caf6:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 800caf8:	687b      	ldr	r3, [r7, #4]
 800cafa:	011b      	lsls	r3, r3, #4
 800cafc:	693a      	ldr	r2, [r7, #16]
 800cafe:	4313      	orrs	r3, r2
 800cb00:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800cb02:	697b      	ldr	r3, [r7, #20]
 800cb04:	f023 030a 	bic.w	r3, r3, #10
 800cb08:	617b      	str	r3, [r7, #20]
  tmpccer |= TIM_ICPolarity;
 800cb0a:	697a      	ldr	r2, [r7, #20]
 800cb0c:	68bb      	ldr	r3, [r7, #8]
 800cb0e:	4313      	orrs	r3, r2
 800cb10:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 800cb12:	68fb      	ldr	r3, [r7, #12]
 800cb14:	693a      	ldr	r2, [r7, #16]
 800cb16:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800cb18:	68fb      	ldr	r3, [r7, #12]
 800cb1a:	697a      	ldr	r2, [r7, #20]
 800cb1c:	621a      	str	r2, [r3, #32]
}
 800cb1e:	bf00      	nop
 800cb20:	371c      	adds	r7, #28
 800cb22:	46bd      	mov	sp, r7
 800cb24:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cb28:	4770      	bx	lr

0800cb2a <TIM_TI2_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 800cb2a:	b480      	push	{r7}
 800cb2c:	b087      	sub	sp, #28
 800cb2e:	af00      	add	r7, sp, #0
 800cb30:	60f8      	str	r0, [r7, #12]
 800cb32:	60b9      	str	r1, [r7, #8]
 800cb34:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800cb36:	68fb      	ldr	r3, [r7, #12]
 800cb38:	6a1b      	ldr	r3, [r3, #32]
 800cb3a:	f023 0210 	bic.w	r2, r3, #16
 800cb3e:	68fb      	ldr	r3, [r7, #12]
 800cb40:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800cb42:	68fb      	ldr	r3, [r7, #12]
 800cb44:	699b      	ldr	r3, [r3, #24]
 800cb46:	617b      	str	r3, [r7, #20]
  tmpccer = TIMx->CCER;
 800cb48:	68fb      	ldr	r3, [r7, #12]
 800cb4a:	6a1b      	ldr	r3, [r3, #32]
 800cb4c:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 800cb4e:	697b      	ldr	r3, [r7, #20]
 800cb50:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
 800cb54:	617b      	str	r3, [r7, #20]
  tmpccmr1 |= (TIM_ICFilter << 12U);
 800cb56:	687b      	ldr	r3, [r7, #4]
 800cb58:	031b      	lsls	r3, r3, #12
 800cb5a:	697a      	ldr	r2, [r7, #20]
 800cb5c:	4313      	orrs	r3, r2
 800cb5e:	617b      	str	r3, [r7, #20]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800cb60:	693b      	ldr	r3, [r7, #16]
 800cb62:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 800cb66:	613b      	str	r3, [r7, #16]
  tmpccer |= (TIM_ICPolarity << 4U);
 800cb68:	68bb      	ldr	r3, [r7, #8]
 800cb6a:	011b      	lsls	r3, r3, #4
 800cb6c:	693a      	ldr	r2, [r7, #16]
 800cb6e:	4313      	orrs	r3, r2
 800cb70:	613b      	str	r3, [r7, #16]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 800cb72:	68fb      	ldr	r3, [r7, #12]
 800cb74:	697a      	ldr	r2, [r7, #20]
 800cb76:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800cb78:	68fb      	ldr	r3, [r7, #12]
 800cb7a:	693a      	ldr	r2, [r7, #16]
 800cb7c:	621a      	str	r2, [r3, #32]
}
 800cb7e:	bf00      	nop
 800cb80:	371c      	adds	r7, #28
 800cb82:	46bd      	mov	sp, r7
 800cb84:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cb88:	4770      	bx	lr

0800cb8a <TIM_ITRx_SetConfig>:
  *       (*)  Value not defined in all devices.
  *
  * @retval None
  */
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
 800cb8a:	b480      	push	{r7}
 800cb8c:	b085      	sub	sp, #20
 800cb8e:	af00      	add	r7, sp, #0
 800cb90:	6078      	str	r0, [r7, #4]
 800cb92:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800cb94:	687b      	ldr	r3, [r7, #4]
 800cb96:	689b      	ldr	r3, [r3, #8]
 800cb98:	60fb      	str	r3, [r7, #12]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 800cb9a:	68fb      	ldr	r3, [r7, #12]
 800cb9c:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 800cba0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800cba4:	60fb      	str	r3, [r7, #12]
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800cba6:	683a      	ldr	r2, [r7, #0]
 800cba8:	68fb      	ldr	r3, [r7, #12]
 800cbaa:	4313      	orrs	r3, r2
 800cbac:	f043 0307 	orr.w	r3, r3, #7
 800cbb0:	60fb      	str	r3, [r7, #12]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800cbb2:	687b      	ldr	r3, [r7, #4]
 800cbb4:	68fa      	ldr	r2, [r7, #12]
 800cbb6:	609a      	str	r2, [r3, #8]
}
 800cbb8:	bf00      	nop
 800cbba:	3714      	adds	r7, #20
 800cbbc:	46bd      	mov	sp, r7
 800cbbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cbc2:	4770      	bx	lr

0800cbc4 <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 800cbc4:	b480      	push	{r7}
 800cbc6:	b087      	sub	sp, #28
 800cbc8:	af00      	add	r7, sp, #0
 800cbca:	60f8      	str	r0, [r7, #12]
 800cbcc:	60b9      	str	r1, [r7, #8]
 800cbce:	607a      	str	r2, [r7, #4]
 800cbd0:	603b      	str	r3, [r7, #0]
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 800cbd2:	68fb      	ldr	r3, [r7, #12]
 800cbd4:	689b      	ldr	r3, [r3, #8]
 800cbd6:	617b      	str	r3, [r7, #20]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800cbd8:	697b      	ldr	r3, [r7, #20]
 800cbda:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 800cbde:	617b      	str	r3, [r7, #20]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 800cbe0:	683b      	ldr	r3, [r7, #0]
 800cbe2:	021a      	lsls	r2, r3, #8
 800cbe4:	687b      	ldr	r3, [r7, #4]
 800cbe6:	431a      	orrs	r2, r3
 800cbe8:	68bb      	ldr	r3, [r7, #8]
 800cbea:	4313      	orrs	r3, r2
 800cbec:	697a      	ldr	r2, [r7, #20]
 800cbee:	4313      	orrs	r3, r2
 800cbf0:	617b      	str	r3, [r7, #20]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800cbf2:	68fb      	ldr	r3, [r7, #12]
 800cbf4:	697a      	ldr	r2, [r7, #20]
 800cbf6:	609a      	str	r2, [r3, #8]
}
 800cbf8:	bf00      	nop
 800cbfa:	371c      	adds	r7, #28
 800cbfc:	46bd      	mov	sp, r7
 800cbfe:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc02:	4770      	bx	lr

0800cc04 <TIM_CCxChannelCmd>:
  * @param  ChannelState specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
{
 800cc04:	b480      	push	{r7}
 800cc06:	b087      	sub	sp, #28
 800cc08:	af00      	add	r7, sp, #0
 800cc0a:	60f8      	str	r0, [r7, #12]
 800cc0c:	60b9      	str	r1, [r7, #8]
 800cc0e:	607a      	str	r2, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 800cc10:	68bb      	ldr	r3, [r7, #8]
 800cc12:	f003 031f 	and.w	r3, r3, #31
 800cc16:	2201      	movs	r2, #1
 800cc18:	fa02 f303 	lsl.w	r3, r2, r3
 800cc1c:	617b      	str	r3, [r7, #20]

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 800cc1e:	68fb      	ldr	r3, [r7, #12]
 800cc20:	6a1a      	ldr	r2, [r3, #32]
 800cc22:	697b      	ldr	r3, [r7, #20]
 800cc24:	43db      	mvns	r3, r3
 800cc26:	401a      	ands	r2, r3
 800cc28:	68fb      	ldr	r3, [r7, #12]
 800cc2a:	621a      	str	r2, [r3, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 800cc2c:	68fb      	ldr	r3, [r7, #12]
 800cc2e:	6a1a      	ldr	r2, [r3, #32]
 800cc30:	68bb      	ldr	r3, [r7, #8]
 800cc32:	f003 031f 	and.w	r3, r3, #31
 800cc36:	6879      	ldr	r1, [r7, #4]
 800cc38:	fa01 f303 	lsl.w	r3, r1, r3
 800cc3c:	431a      	orrs	r2, r3
 800cc3e:	68fb      	ldr	r3, [r7, #12]
 800cc40:	621a      	str	r2, [r3, #32]
}
 800cc42:	bf00      	nop
 800cc44:	371c      	adds	r7, #28
 800cc46:	46bd      	mov	sp, r7
 800cc48:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc4c:	4770      	bx	lr
	...

0800cc50 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
 800cc50:	b480      	push	{r7}
 800cc52:	b085      	sub	sp, #20
 800cc54:	af00      	add	r7, sp, #0
 800cc56:	6078      	str	r0, [r7, #4]
 800cc58:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 800cc5a:	687b      	ldr	r3, [r7, #4]
 800cc5c:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 800cc60:	2b01      	cmp	r3, #1
 800cc62:	d101      	bne.n	800cc68 <HAL_TIMEx_MasterConfigSynchronization+0x18>
 800cc64:	2302      	movs	r3, #2
 800cc66:	e074      	b.n	800cd52 <HAL_TIMEx_MasterConfigSynchronization+0x102>
 800cc68:	687b      	ldr	r3, [r7, #4]
 800cc6a:	2201      	movs	r2, #1
 800cc6c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 800cc70:	687b      	ldr	r3, [r7, #4]
 800cc72:	2202      	movs	r2, #2
 800cc74:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 800cc78:	687b      	ldr	r3, [r7, #4]
 800cc7a:	681b      	ldr	r3, [r3, #0]
 800cc7c:	685b      	ldr	r3, [r3, #4]
 800cc7e:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 800cc80:	687b      	ldr	r3, [r7, #4]
 800cc82:	681b      	ldr	r3, [r3, #0]
 800cc84:	689b      	ldr	r3, [r3, #8]
 800cc86:	60bb      	str	r3, [r7, #8]

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 800cc88:	687b      	ldr	r3, [r7, #4]
 800cc8a:	681b      	ldr	r3, [r3, #0]
 800cc8c:	4a34      	ldr	r2, [pc, #208]	; (800cd60 <HAL_TIMEx_MasterConfigSynchronization+0x110>)
 800cc8e:	4293      	cmp	r3, r2
 800cc90:	d009      	beq.n	800cca6 <HAL_TIMEx_MasterConfigSynchronization+0x56>
 800cc92:	687b      	ldr	r3, [r7, #4]
 800cc94:	681b      	ldr	r3, [r3, #0]
 800cc96:	4a33      	ldr	r2, [pc, #204]	; (800cd64 <HAL_TIMEx_MasterConfigSynchronization+0x114>)
 800cc98:	4293      	cmp	r3, r2
 800cc9a:	d004      	beq.n	800cca6 <HAL_TIMEx_MasterConfigSynchronization+0x56>
 800cc9c:	687b      	ldr	r3, [r7, #4]
 800cc9e:	681b      	ldr	r3, [r3, #0]
 800cca0:	4a31      	ldr	r2, [pc, #196]	; (800cd68 <HAL_TIMEx_MasterConfigSynchronization+0x118>)
 800cca2:	4293      	cmp	r3, r2
 800cca4:	d108      	bne.n	800ccb8 <HAL_TIMEx_MasterConfigSynchronization+0x68>
  {
    /* Check the parameters */
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));

    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
 800cca6:	68fb      	ldr	r3, [r7, #12]
 800cca8:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 800ccac:	60fb      	str	r3, [r7, #12]
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 800ccae:	683b      	ldr	r3, [r7, #0]
 800ccb0:	685b      	ldr	r3, [r3, #4]
 800ccb2:	68fa      	ldr	r2, [r7, #12]
 800ccb4:	4313      	orrs	r3, r2
 800ccb6:	60fb      	str	r3, [r7, #12]
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 800ccb8:	68fb      	ldr	r3, [r7, #12]
 800ccba:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 800ccbe:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800ccc2:	60fb      	str	r3, [r7, #12]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800ccc4:	683b      	ldr	r3, [r7, #0]
 800ccc6:	681b      	ldr	r3, [r3, #0]
 800ccc8:	68fa      	ldr	r2, [r7, #12]
 800ccca:	4313      	orrs	r3, r2
 800cccc:	60fb      	str	r3, [r7, #12]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 800ccce:	687b      	ldr	r3, [r7, #4]
 800ccd0:	681b      	ldr	r3, [r3, #0]
 800ccd2:	68fa      	ldr	r2, [r7, #12]
 800ccd4:	605a      	str	r2, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800ccd6:	687b      	ldr	r3, [r7, #4]
 800ccd8:	681b      	ldr	r3, [r3, #0]
 800ccda:	4a21      	ldr	r2, [pc, #132]	; (800cd60 <HAL_TIMEx_MasterConfigSynchronization+0x110>)
 800ccdc:	4293      	cmp	r3, r2
 800ccde:	d022      	beq.n	800cd26 <HAL_TIMEx_MasterConfigSynchronization+0xd6>
 800cce0:	687b      	ldr	r3, [r7, #4]
 800cce2:	681b      	ldr	r3, [r3, #0]
 800cce4:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800cce8:	d01d      	beq.n	800cd26 <HAL_TIMEx_MasterConfigSynchronization+0xd6>
 800ccea:	687b      	ldr	r3, [r7, #4]
 800ccec:	681b      	ldr	r3, [r3, #0]
 800ccee:	4a1f      	ldr	r2, [pc, #124]	; (800cd6c <HAL_TIMEx_MasterConfigSynchronization+0x11c>)
 800ccf0:	4293      	cmp	r3, r2
 800ccf2:	d018      	beq.n	800cd26 <HAL_TIMEx_MasterConfigSynchronization+0xd6>
 800ccf4:	687b      	ldr	r3, [r7, #4]
 800ccf6:	681b      	ldr	r3, [r3, #0]
 800ccf8:	4a1d      	ldr	r2, [pc, #116]	; (800cd70 <HAL_TIMEx_MasterConfigSynchronization+0x120>)
 800ccfa:	4293      	cmp	r3, r2
 800ccfc:	d013      	beq.n	800cd26 <HAL_TIMEx_MasterConfigSynchronization+0xd6>
 800ccfe:	687b      	ldr	r3, [r7, #4]
 800cd00:	681b      	ldr	r3, [r3, #0]
 800cd02:	4a1c      	ldr	r2, [pc, #112]	; (800cd74 <HAL_TIMEx_MasterConfigSynchronization+0x124>)
 800cd04:	4293      	cmp	r3, r2
 800cd06:	d00e      	beq.n	800cd26 <HAL_TIMEx_MasterConfigSynchronization+0xd6>
 800cd08:	687b      	ldr	r3, [r7, #4]
 800cd0a:	681b      	ldr	r3, [r3, #0]
 800cd0c:	4a15      	ldr	r2, [pc, #84]	; (800cd64 <HAL_TIMEx_MasterConfigSynchronization+0x114>)
 800cd0e:	4293      	cmp	r3, r2
 800cd10:	d009      	beq.n	800cd26 <HAL_TIMEx_MasterConfigSynchronization+0xd6>
 800cd12:	687b      	ldr	r3, [r7, #4]
 800cd14:	681b      	ldr	r3, [r3, #0]
 800cd16:	4a18      	ldr	r2, [pc, #96]	; (800cd78 <HAL_TIMEx_MasterConfigSynchronization+0x128>)
 800cd18:	4293      	cmp	r3, r2
 800cd1a:	d004      	beq.n	800cd26 <HAL_TIMEx_MasterConfigSynchronization+0xd6>
 800cd1c:	687b      	ldr	r3, [r7, #4]
 800cd1e:	681b      	ldr	r3, [r3, #0]
 800cd20:	4a11      	ldr	r2, [pc, #68]	; (800cd68 <HAL_TIMEx_MasterConfigSynchronization+0x118>)
 800cd22:	4293      	cmp	r3, r2
 800cd24:	d10c      	bne.n	800cd40 <HAL_TIMEx_MasterConfigSynchronization+0xf0>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 800cd26:	68bb      	ldr	r3, [r7, #8]
 800cd28:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800cd2c:	60bb      	str	r3, [r7, #8]
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800cd2e:	683b      	ldr	r3, [r7, #0]
 800cd30:	689b      	ldr	r3, [r3, #8]
 800cd32:	68ba      	ldr	r2, [r7, #8]
 800cd34:	4313      	orrs	r3, r2
 800cd36:	60bb      	str	r3, [r7, #8]

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 800cd38:	687b      	ldr	r3, [r7, #4]
 800cd3a:	681b      	ldr	r3, [r3, #0]
 800cd3c:	68ba      	ldr	r2, [r7, #8]
 800cd3e:	609a      	str	r2, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 800cd40:	687b      	ldr	r3, [r7, #4]
 800cd42:	2201      	movs	r2, #1
 800cd44:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 800cd48:	687b      	ldr	r3, [r7, #4]
 800cd4a:	2200      	movs	r2, #0
 800cd4c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 800cd50:	2300      	movs	r3, #0
}
 800cd52:	4618      	mov	r0, r3
 800cd54:	3714      	adds	r7, #20
 800cd56:	46bd      	mov	sp, r7
 800cd58:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd5c:	4770      	bx	lr
 800cd5e:	bf00      	nop
 800cd60:	40012c00 	.word	0x40012c00
 800cd64:	40013400 	.word	0x40013400
 800cd68:	40015000 	.word	0x40015000
 800cd6c:	40000400 	.word	0x40000400
 800cd70:	40000800 	.word	0x40000800
 800cd74:	40000c00 	.word	0x40000c00
 800cd78:	40014000 	.word	0x40014000

0800cd7c <HAL_TIMEx_CommutCallback>:
  * @brief  Hall commutation changed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
 800cd7c:	b480      	push	{r7}
 800cd7e:	b083      	sub	sp, #12
 800cd80:	af00      	add	r7, sp, #0
 800cd82:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 800cd84:	bf00      	nop
 800cd86:	370c      	adds	r7, #12
 800cd88:	46bd      	mov	sp, r7
 800cd8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd8e:	4770      	bx	lr

0800cd90 <HAL_TIMEx_BreakCallback>:
  * @brief  Hall Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 800cd90:	b480      	push	{r7}
 800cd92:	b083      	sub	sp, #12
 800cd94:	af00      	add	r7, sp, #0
 800cd96:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 800cd98:	bf00      	nop
 800cd9a:	370c      	adds	r7, #12
 800cd9c:	46bd      	mov	sp, r7
 800cd9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cda2:	4770      	bx	lr

0800cda4 <HAL_TIMEx_Break2Callback>:
  * @brief  Hall Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
 800cda4:	b480      	push	{r7}
 800cda6:	b083      	sub	sp, #12
 800cda8:	af00      	add	r7, sp, #0
 800cdaa:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 800cdac:	bf00      	nop
 800cdae:	370c      	adds	r7, #12
 800cdb0:	46bd      	mov	sp, r7
 800cdb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cdb6:	4770      	bx	lr

0800cdb8 <HAL_TIMEx_EncoderIndexCallback>:
  * @brief  Encoder index callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_EncoderIndexCallback(TIM_HandleTypeDef *htim)
{
 800cdb8:	b480      	push	{r7}
 800cdba:	b083      	sub	sp, #12
 800cdbc:	af00      	add	r7, sp, #0
 800cdbe:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_EncoderIndexCallback could be implemented in the user file
   */
}
 800cdc0:	bf00      	nop
 800cdc2:	370c      	adds	r7, #12
 800cdc4:	46bd      	mov	sp, r7
 800cdc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cdca:	4770      	bx	lr

0800cdcc <HAL_TIMEx_DirectionChangeCallback>:
  * @brief  Direction change callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_DirectionChangeCallback(TIM_HandleTypeDef *htim)
{
 800cdcc:	b480      	push	{r7}
 800cdce:	b083      	sub	sp, #12
 800cdd0:	af00      	add	r7, sp, #0
 800cdd2:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_DirectionChangeCallback could be implemented in the user file
   */
}
 800cdd4:	bf00      	nop
 800cdd6:	370c      	adds	r7, #12
 800cdd8:	46bd      	mov	sp, r7
 800cdda:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cdde:	4770      	bx	lr

0800cde0 <HAL_TIMEx_IndexErrorCallback>:
  * @brief  Index error callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_IndexErrorCallback(TIM_HandleTypeDef *htim)
{
 800cde0:	b480      	push	{r7}
 800cde2:	b083      	sub	sp, #12
 800cde4:	af00      	add	r7, sp, #0
 800cde6:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_IndexErrorCallback could be implemented in the user file
   */
}
 800cde8:	bf00      	nop
 800cdea:	370c      	adds	r7, #12
 800cdec:	46bd      	mov	sp, r7
 800cdee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cdf2:	4770      	bx	lr

0800cdf4 <HAL_TIMEx_TransitionErrorCallback>:
  * @brief  Transition error callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_TransitionErrorCallback(TIM_HandleTypeDef *htim)
{
 800cdf4:	b480      	push	{r7}
 800cdf6:	b083      	sub	sp, #12
 800cdf8:	af00      	add	r7, sp, #0
 800cdfa:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_TransitionErrorCallback could be implemented in the user file
   */
}
 800cdfc:	bf00      	nop
 800cdfe:	370c      	adds	r7, #12
 800ce00:	46bd      	mov	sp, r7
 800ce02:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ce06:	4770      	bx	lr

0800ce08 <FMC_NORSRAM_Init>:
  * @param  Init Pointer to NORSRAM Initialization structure
  * @retval HAL status
  */
HAL_StatusTypeDef  FMC_NORSRAM_Init(FMC_NORSRAM_TypeDef *Device,
                                    FMC_NORSRAM_InitTypeDef *Init)
{
 800ce08:	b480      	push	{r7}
 800ce0a:	b087      	sub	sp, #28
 800ce0c:	af00      	add	r7, sp, #0
 800ce0e:	6078      	str	r0, [r7, #4]
 800ce10:	6039      	str	r1, [r7, #0]
  assert_param(IS_FMC_PAGESIZE(Init->PageSize));
  assert_param(IS_FMC_NBL_SETUPTIME(Init->NBLSetupTime));
  assert_param(IS_FUNCTIONAL_STATE(Init->MaxChipSelectPulse));

  /* Disable NORSRAM Device */
  __FMC_NORSRAM_DISABLE(Device, Init->NSBank);
 800ce12:	683b      	ldr	r3, [r7, #0]
 800ce14:	681a      	ldr	r2, [r3, #0]
 800ce16:	687b      	ldr	r3, [r7, #4]
 800ce18:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800ce1c:	683a      	ldr	r2, [r7, #0]
 800ce1e:	6812      	ldr	r2, [r2, #0]
 800ce20:	f023 0101 	bic.w	r1, r3, #1
 800ce24:	687b      	ldr	r3, [r7, #4]
 800ce26:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

  /* Set NORSRAM device control parameters */
  if (Init->MemoryType == FMC_MEMORY_TYPE_NOR)
 800ce2a:	683b      	ldr	r3, [r7, #0]
 800ce2c:	689b      	ldr	r3, [r3, #8]
 800ce2e:	2b08      	cmp	r3, #8
 800ce30:	d102      	bne.n	800ce38 <FMC_NORSRAM_Init+0x30>
  {
    flashaccess = FMC_NORSRAM_FLASH_ACCESS_ENABLE;
 800ce32:	2340      	movs	r3, #64	; 0x40
 800ce34:	617b      	str	r3, [r7, #20]
 800ce36:	e001      	b.n	800ce3c <FMC_NORSRAM_Init+0x34>
  }
  else
  {
    flashaccess = FMC_NORSRAM_FLASH_ACCESS_DISABLE;
 800ce38:	2300      	movs	r3, #0
 800ce3a:	617b      	str	r3, [r7, #20]
  }

  btcr_reg = (flashaccess                   | \
              Init->DataAddressMux          | \
 800ce3c:	683b      	ldr	r3, [r7, #0]
 800ce3e:	685a      	ldr	r2, [r3, #4]
  btcr_reg = (flashaccess                   | \
 800ce40:	697b      	ldr	r3, [r7, #20]
 800ce42:	431a      	orrs	r2, r3
              Init->MemoryType              | \
 800ce44:	683b      	ldr	r3, [r7, #0]
 800ce46:	689b      	ldr	r3, [r3, #8]
              Init->DataAddressMux          | \
 800ce48:	431a      	orrs	r2, r3
              Init->MemoryDataWidth         | \
 800ce4a:	683b      	ldr	r3, [r7, #0]
 800ce4c:	68db      	ldr	r3, [r3, #12]
              Init->MemoryType              | \
 800ce4e:	431a      	orrs	r2, r3
              Init->BurstAccessMode         | \
 800ce50:	683b      	ldr	r3, [r7, #0]
 800ce52:	691b      	ldr	r3, [r3, #16]
              Init->MemoryDataWidth         | \
 800ce54:	431a      	orrs	r2, r3
              Init->WaitSignalPolarity      | \
 800ce56:	683b      	ldr	r3, [r7, #0]
 800ce58:	695b      	ldr	r3, [r3, #20]
              Init->BurstAccessMode         | \
 800ce5a:	431a      	orrs	r2, r3
              Init->WaitSignalActive        | \
 800ce5c:	683b      	ldr	r3, [r7, #0]
 800ce5e:	699b      	ldr	r3, [r3, #24]
              Init->WaitSignalPolarity      | \
 800ce60:	431a      	orrs	r2, r3
              Init->WriteOperation          | \
 800ce62:	683b      	ldr	r3, [r7, #0]
 800ce64:	69db      	ldr	r3, [r3, #28]
              Init->WaitSignalActive        | \
 800ce66:	431a      	orrs	r2, r3
              Init->WaitSignal              | \
 800ce68:	683b      	ldr	r3, [r7, #0]
 800ce6a:	6a1b      	ldr	r3, [r3, #32]
              Init->WriteOperation          | \
 800ce6c:	431a      	orrs	r2, r3
              Init->ExtendedMode            | \
 800ce6e:	683b      	ldr	r3, [r7, #0]
 800ce70:	6a5b      	ldr	r3, [r3, #36]	; 0x24
              Init->WaitSignal              | \
 800ce72:	431a      	orrs	r2, r3
              Init->AsynchronousWait        | \
 800ce74:	683b      	ldr	r3, [r7, #0]
 800ce76:	6a9b      	ldr	r3, [r3, #40]	; 0x28
              Init->ExtendedMode            | \
 800ce78:	431a      	orrs	r2, r3
              Init->WriteBurst);
 800ce7a:	683b      	ldr	r3, [r7, #0]
 800ce7c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  btcr_reg = (flashaccess                   | \
 800ce7e:	4313      	orrs	r3, r2
 800ce80:	613b      	str	r3, [r7, #16]

  btcr_reg |= Init->ContinuousClock;
 800ce82:	683b      	ldr	r3, [r7, #0]
 800ce84:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ce86:	693a      	ldr	r2, [r7, #16]
 800ce88:	4313      	orrs	r3, r2
 800ce8a:	613b      	str	r3, [r7, #16]
  btcr_reg |= Init->WriteFifo;
 800ce8c:	683b      	ldr	r3, [r7, #0]
 800ce8e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ce90:	693a      	ldr	r2, [r7, #16]
 800ce92:	4313      	orrs	r3, r2
 800ce94:	613b      	str	r3, [r7, #16]
  btcr_reg |= Init->NBLSetupTime;
 800ce96:	683b      	ldr	r3, [r7, #0]
 800ce98:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ce9a:	693a      	ldr	r2, [r7, #16]
 800ce9c:	4313      	orrs	r3, r2
 800ce9e:	613b      	str	r3, [r7, #16]
  btcr_reg |= Init->PageSize;
 800cea0:	683b      	ldr	r3, [r7, #0]
 800cea2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800cea4:	693a      	ldr	r2, [r7, #16]
 800cea6:	4313      	orrs	r3, r2
 800cea8:	613b      	str	r3, [r7, #16]

  mask = (FMC_BCRx_MBKEN                |
 800ceaa:	4b3d      	ldr	r3, [pc, #244]	; (800cfa0 <FMC_NORSRAM_Init+0x198>)
 800ceac:	60fb      	str	r3, [r7, #12]
          FMC_BCRx_WAITEN               |
          FMC_BCRx_EXTMOD               |
          FMC_BCRx_ASYNCWAIT            |
          FMC_BCRx_CBURSTRW);

  mask |= FMC_BCR1_CCLKEN;
 800ceae:	68fb      	ldr	r3, [r7, #12]
 800ceb0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800ceb4:	60fb      	str	r3, [r7, #12]
  mask |= FMC_BCR1_WFDIS;
 800ceb6:	68fb      	ldr	r3, [r7, #12]
 800ceb8:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800cebc:	60fb      	str	r3, [r7, #12]
  mask |= FMC_BCRx_NBLSET;
 800cebe:	68fb      	ldr	r3, [r7, #12]
 800cec0:	f443 0340 	orr.w	r3, r3, #12582912	; 0xc00000
 800cec4:	60fb      	str	r3, [r7, #12]
  mask |= FMC_BCRx_CPSIZE;
 800cec6:	68fb      	ldr	r3, [r7, #12]
 800cec8:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
 800cecc:	60fb      	str	r3, [r7, #12]

  MODIFY_REG(Device->BTCR[Init->NSBank], mask, btcr_reg);
 800cece:	683b      	ldr	r3, [r7, #0]
 800ced0:	681a      	ldr	r2, [r3, #0]
 800ced2:	687b      	ldr	r3, [r7, #4]
 800ced4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800ced8:	68fb      	ldr	r3, [r7, #12]
 800ceda:	43db      	mvns	r3, r3
 800cedc:	ea02 0103 	and.w	r1, r2, r3
 800cee0:	683b      	ldr	r3, [r7, #0]
 800cee2:	681a      	ldr	r2, [r3, #0]
 800cee4:	693b      	ldr	r3, [r7, #16]
 800cee6:	4319      	orrs	r1, r3
 800cee8:	687b      	ldr	r3, [r7, #4]
 800ceea:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

  /* Configure synchronous mode when Continuous clock is enabled for bank2..4 */
  if ((Init->ContinuousClock == FMC_CONTINUOUS_CLOCK_SYNC_ASYNC) && (Init->NSBank != FMC_NORSRAM_BANK1))
 800ceee:	683b      	ldr	r3, [r7, #0]
 800cef0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800cef2:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800cef6:	d10c      	bne.n	800cf12 <FMC_NORSRAM_Init+0x10a>
 800cef8:	683b      	ldr	r3, [r7, #0]
 800cefa:	681b      	ldr	r3, [r3, #0]
 800cefc:	2b00      	cmp	r3, #0
 800cefe:	d008      	beq.n	800cf12 <FMC_NORSRAM_Init+0x10a>
  {
    MODIFY_REG(Device->BTCR[FMC_NORSRAM_BANK1], FMC_BCR1_CCLKEN, Init->ContinuousClock);
 800cf00:	687b      	ldr	r3, [r7, #4]
 800cf02:	681b      	ldr	r3, [r3, #0]
 800cf04:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
 800cf08:	683b      	ldr	r3, [r7, #0]
 800cf0a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800cf0c:	431a      	orrs	r2, r3
 800cf0e:	687b      	ldr	r3, [r7, #4]
 800cf10:	601a      	str	r2, [r3, #0]
  }

  if (Init->NSBank != FMC_NORSRAM_BANK1)
 800cf12:	683b      	ldr	r3, [r7, #0]
 800cf14:	681b      	ldr	r3, [r3, #0]
 800cf16:	2b00      	cmp	r3, #0
 800cf18:	d006      	beq.n	800cf28 <FMC_NORSRAM_Init+0x120>
  {
    /* Configure Write FIFO mode when Write Fifo is enabled for bank2..4 */
    SET_BIT(Device->BTCR[FMC_NORSRAM_BANK1], (uint32_t)(Init->WriteFifo));
 800cf1a:	687b      	ldr	r3, [r7, #4]
 800cf1c:	681a      	ldr	r2, [r3, #0]
 800cf1e:	683b      	ldr	r3, [r7, #0]
 800cf20:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800cf22:	431a      	orrs	r2, r3
 800cf24:	687b      	ldr	r3, [r7, #4]
 800cf26:	601a      	str	r2, [r3, #0]
  }

  /* Check PSRAM chip select counter state */
  if (Init->MaxChipSelectPulse == ENABLE)
 800cf28:	683b      	ldr	r3, [r7, #0]
 800cf2a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800cf2e:	2b01      	cmp	r3, #1
 800cf30:	d12f      	bne.n	800cf92 <FMC_NORSRAM_Init+0x18a>
  {
    /* Check the parameters */
    assert_param(IS_FMC_MAX_CHIP_SELECT_PULSE_TIME(Init->MaxChipSelectPulseTime));

    /* Configure PSRAM chip select counter value */
    MODIFY_REG(Device->PCSCNTR, FMC_PCSCNTR_CSCOUNT, (uint32_t)(Init->MaxChipSelectPulseTime));
 800cf32:	687b      	ldr	r3, [r7, #4]
 800cf34:	6a1b      	ldr	r3, [r3, #32]
 800cf36:	0c1b      	lsrs	r3, r3, #16
 800cf38:	041b      	lsls	r3, r3, #16
 800cf3a:	683a      	ldr	r2, [r7, #0]
 800cf3c:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800cf3e:	431a      	orrs	r2, r3
 800cf40:	687b      	ldr	r3, [r7, #4]
 800cf42:	621a      	str	r2, [r3, #32]

    /* Enable PSRAM chip select counter for the bank */
    switch (Init->NSBank)
 800cf44:	683b      	ldr	r3, [r7, #0]
 800cf46:	681b      	ldr	r3, [r3, #0]
 800cf48:	2b04      	cmp	r3, #4
 800cf4a:	d014      	beq.n	800cf76 <FMC_NORSRAM_Init+0x16e>
 800cf4c:	2b04      	cmp	r3, #4
 800cf4e:	d819      	bhi.n	800cf84 <FMC_NORSRAM_Init+0x17c>
 800cf50:	2b00      	cmp	r3, #0
 800cf52:	d002      	beq.n	800cf5a <FMC_NORSRAM_Init+0x152>
 800cf54:	2b02      	cmp	r3, #2
 800cf56:	d007      	beq.n	800cf68 <FMC_NORSRAM_Init+0x160>
 800cf58:	e014      	b.n	800cf84 <FMC_NORSRAM_Init+0x17c>
    {
      case FMC_NORSRAM_BANK1 :
        SET_BIT(Device->PCSCNTR, FMC_PCSCNTR_CNTB1EN);
 800cf5a:	687b      	ldr	r3, [r7, #4]
 800cf5c:	6a1b      	ldr	r3, [r3, #32]
 800cf5e:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 800cf62:	687b      	ldr	r3, [r7, #4]
 800cf64:	621a      	str	r2, [r3, #32]
        break;
 800cf66:	e014      	b.n	800cf92 <FMC_NORSRAM_Init+0x18a>

      case FMC_NORSRAM_BANK2 :
        SET_BIT(Device->PCSCNTR, FMC_PCSCNTR_CNTB2EN);
 800cf68:	687b      	ldr	r3, [r7, #4]
 800cf6a:	6a1b      	ldr	r3, [r3, #32]
 800cf6c:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
 800cf70:	687b      	ldr	r3, [r7, #4]
 800cf72:	621a      	str	r2, [r3, #32]
        break;
 800cf74:	e00d      	b.n	800cf92 <FMC_NORSRAM_Init+0x18a>

      case FMC_NORSRAM_BANK3 :
        SET_BIT(Device->PCSCNTR, FMC_PCSCNTR_CNTB3EN);
 800cf76:	687b      	ldr	r3, [r7, #4]
 800cf78:	6a1b      	ldr	r3, [r3, #32]
 800cf7a:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
 800cf7e:	687b      	ldr	r3, [r7, #4]
 800cf80:	621a      	str	r2, [r3, #32]
        break;
 800cf82:	e006      	b.n	800cf92 <FMC_NORSRAM_Init+0x18a>

      default :
        SET_BIT(Device->PCSCNTR, FMC_PCSCNTR_CNTB4EN);
 800cf84:	687b      	ldr	r3, [r7, #4]
 800cf86:	6a1b      	ldr	r3, [r3, #32]
 800cf88:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
 800cf8c:	687b      	ldr	r3, [r7, #4]
 800cf8e:	621a      	str	r2, [r3, #32]
        break;
 800cf90:	bf00      	nop
    }
  }

  return HAL_OK;
 800cf92:	2300      	movs	r3, #0
}
 800cf94:	4618      	mov	r0, r3
 800cf96:	371c      	adds	r7, #28
 800cf98:	46bd      	mov	sp, r7
 800cf9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf9e:	4770      	bx	lr
 800cfa0:	0008fb7f 	.word	0x0008fb7f

0800cfa4 <FMC_NORSRAM_Timing_Init>:
  * @param  Bank NORSRAM bank number
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_NORSRAM_Timing_Init(FMC_NORSRAM_TypeDef *Device,
                                          FMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank)
{
 800cfa4:	b480      	push	{r7}
 800cfa6:	b087      	sub	sp, #28
 800cfa8:	af00      	add	r7, sp, #0
 800cfaa:	60f8      	str	r0, [r7, #12]
 800cfac:	60b9      	str	r1, [r7, #8]
 800cfae:	607a      	str	r2, [r7, #4]
  assert_param(IS_FMC_DATA_LATENCY(Timing->DataLatency));
  assert_param(IS_FMC_ACCESS_MODE(Timing->AccessMode));
  assert_param(IS_FMC_NORSRAM_BANK(Bank));

  /* Set FMC_NORSRAM device timing parameters */
  MODIFY_REG(Device->BTCR[Bank + 1U], BTR_CLEAR_MASK, (Timing->AddressSetupTime                                  |
 800cfb0:	687b      	ldr	r3, [r7, #4]
 800cfb2:	1c5a      	adds	r2, r3, #1
 800cfb4:	68fb      	ldr	r3, [r7, #12]
 800cfb6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800cfba:	68bb      	ldr	r3, [r7, #8]
 800cfbc:	681a      	ldr	r2, [r3, #0]
 800cfbe:	68bb      	ldr	r3, [r7, #8]
 800cfc0:	685b      	ldr	r3, [r3, #4]
 800cfc2:	011b      	lsls	r3, r3, #4
 800cfc4:	431a      	orrs	r2, r3
 800cfc6:	68bb      	ldr	r3, [r7, #8]
 800cfc8:	689b      	ldr	r3, [r3, #8]
 800cfca:	021b      	lsls	r3, r3, #8
 800cfcc:	431a      	orrs	r2, r3
 800cfce:	68bb      	ldr	r3, [r7, #8]
 800cfd0:	68db      	ldr	r3, [r3, #12]
 800cfd2:	079b      	lsls	r3, r3, #30
 800cfd4:	431a      	orrs	r2, r3
 800cfd6:	68bb      	ldr	r3, [r7, #8]
 800cfd8:	691b      	ldr	r3, [r3, #16]
 800cfda:	041b      	lsls	r3, r3, #16
 800cfdc:	431a      	orrs	r2, r3
 800cfde:	68bb      	ldr	r3, [r7, #8]
 800cfe0:	695b      	ldr	r3, [r3, #20]
 800cfe2:	3b01      	subs	r3, #1
 800cfe4:	051b      	lsls	r3, r3, #20
 800cfe6:	431a      	orrs	r2, r3
 800cfe8:	68bb      	ldr	r3, [r7, #8]
 800cfea:	699b      	ldr	r3, [r3, #24]
 800cfec:	3b02      	subs	r3, #2
 800cfee:	061b      	lsls	r3, r3, #24
 800cff0:	ea42 0103 	orr.w	r1, r2, r3
 800cff4:	68bb      	ldr	r3, [r7, #8]
 800cff6:	69db      	ldr	r3, [r3, #28]
 800cff8:	687a      	ldr	r2, [r7, #4]
 800cffa:	3201      	adds	r2, #1
 800cffc:	4319      	orrs	r1, r3
 800cffe:	68fb      	ldr	r3, [r7, #12]
 800d000:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
                                                       (((Timing->CLKDivision) - 1U)     << FMC_BTRx_CLKDIV_Pos)  |
                                                       (((Timing->DataLatency) - 2U)     << FMC_BTRx_DATLAT_Pos)  |
                                                       (Timing->AccessMode)));

  /* Configure Clock division value (in NORSRAM bank 1) when continuous clock is enabled */
  if (HAL_IS_BIT_SET(Device->BTCR[FMC_NORSRAM_BANK1], FMC_BCR1_CCLKEN))
 800d004:	68fb      	ldr	r3, [r7, #12]
 800d006:	681b      	ldr	r3, [r3, #0]
 800d008:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800d00c:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800d010:	d113      	bne.n	800d03a <FMC_NORSRAM_Timing_Init+0x96>
  {
    tmpr = (uint32_t)(Device->BTCR[FMC_NORSRAM_BANK1 + 1U] & ~((0x0FU) << FMC_BTRx_CLKDIV_Pos));
 800d012:	68fb      	ldr	r3, [r7, #12]
 800d014:	685b      	ldr	r3, [r3, #4]
 800d016:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 800d01a:	617b      	str	r3, [r7, #20]
    tmpr |= (uint32_t)(((Timing->CLKDivision) - 1U) << FMC_BTRx_CLKDIV_Pos);
 800d01c:	68bb      	ldr	r3, [r7, #8]
 800d01e:	695b      	ldr	r3, [r3, #20]
 800d020:	3b01      	subs	r3, #1
 800d022:	051b      	lsls	r3, r3, #20
 800d024:	697a      	ldr	r2, [r7, #20]
 800d026:	4313      	orrs	r3, r2
 800d028:	617b      	str	r3, [r7, #20]
    MODIFY_REG(Device->BTCR[FMC_NORSRAM_BANK1 + 1U], FMC_BTRx_CLKDIV, tmpr);
 800d02a:	68fb      	ldr	r3, [r7, #12]
 800d02c:	685b      	ldr	r3, [r3, #4]
 800d02e:	f423 0270 	bic.w	r2, r3, #15728640	; 0xf00000
 800d032:	697b      	ldr	r3, [r7, #20]
 800d034:	431a      	orrs	r2, r3
 800d036:	68fb      	ldr	r3, [r7, #12]
 800d038:	605a      	str	r2, [r3, #4]
  }

  return HAL_OK;
 800d03a:	2300      	movs	r3, #0
}
 800d03c:	4618      	mov	r0, r3
 800d03e:	371c      	adds	r7, #28
 800d040:	46bd      	mov	sp, r7
 800d042:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d046:	4770      	bx	lr

0800d048 <FMC_NORSRAM_Extended_Timing_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_NORSRAM_Extended_Timing_Init(FMC_NORSRAM_EXTENDED_TypeDef *Device,
                                                   FMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank,
                                                   uint32_t ExtendedMode)
{
 800d048:	b480      	push	{r7}
 800d04a:	b085      	sub	sp, #20
 800d04c:	af00      	add	r7, sp, #0
 800d04e:	60f8      	str	r0, [r7, #12]
 800d050:	60b9      	str	r1, [r7, #8]
 800d052:	607a      	str	r2, [r7, #4]
 800d054:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FMC_EXTENDED_MODE(ExtendedMode));

  /* Set NORSRAM device timing register for write configuration, if extended mode is used */
  if (ExtendedMode == FMC_EXTENDED_MODE_ENABLE)
 800d056:	683b      	ldr	r3, [r7, #0]
 800d058:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800d05c:	d121      	bne.n	800d0a2 <FMC_NORSRAM_Extended_Timing_Init+0x5a>
    assert_param(IS_FMC_TURNAROUND_TIME(Timing->BusTurnAroundDuration));
    assert_param(IS_FMC_ACCESS_MODE(Timing->AccessMode));
    assert_param(IS_FMC_NORSRAM_BANK(Bank));

    /* Set NORSRAM device timing register for write configuration, if extended mode is used */
    MODIFY_REG(Device->BWTR[Bank], BWTR_CLEAR_MASK, (Timing->AddressSetupTime                                    |
 800d05e:	68fb      	ldr	r3, [r7, #12]
 800d060:	687a      	ldr	r2, [r7, #4]
 800d062:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800d066:	f003 627f 	and.w	r2, r3, #267386880	; 0xff00000
 800d06a:	68bb      	ldr	r3, [r7, #8]
 800d06c:	6819      	ldr	r1, [r3, #0]
 800d06e:	68bb      	ldr	r3, [r7, #8]
 800d070:	685b      	ldr	r3, [r3, #4]
 800d072:	011b      	lsls	r3, r3, #4
 800d074:	4319      	orrs	r1, r3
 800d076:	68bb      	ldr	r3, [r7, #8]
 800d078:	689b      	ldr	r3, [r3, #8]
 800d07a:	021b      	lsls	r3, r3, #8
 800d07c:	4319      	orrs	r1, r3
 800d07e:	68bb      	ldr	r3, [r7, #8]
 800d080:	68db      	ldr	r3, [r3, #12]
 800d082:	079b      	lsls	r3, r3, #30
 800d084:	4319      	orrs	r1, r3
 800d086:	68bb      	ldr	r3, [r7, #8]
 800d088:	69db      	ldr	r3, [r3, #28]
 800d08a:	4319      	orrs	r1, r3
 800d08c:	68bb      	ldr	r3, [r7, #8]
 800d08e:	691b      	ldr	r3, [r3, #16]
 800d090:	041b      	lsls	r3, r3, #16
 800d092:	430b      	orrs	r3, r1
 800d094:	ea42 0103 	orr.w	r1, r2, r3
 800d098:	68fb      	ldr	r3, [r7, #12]
 800d09a:	687a      	ldr	r2, [r7, #4]
 800d09c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 800d0a0:	e005      	b.n	800d0ae <FMC_NORSRAM_Extended_Timing_Init+0x66>
                                                     Timing->AccessMode                                          |
                                                     ((Timing->BusTurnAroundDuration)  << FMC_BWTRx_BUSTURN_Pos)));
  }
  else
  {
    Device->BWTR[Bank] = 0x0FFFFFFFU;
 800d0a2:	68fb      	ldr	r3, [r7, #12]
 800d0a4:	687a      	ldr	r2, [r7, #4]
 800d0a6:	f06f 4170 	mvn.w	r1, #4026531840	; 0xf0000000
 800d0aa:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  }

  return HAL_OK;
 800d0ae:	2300      	movs	r3, #0
}
 800d0b0:	4618      	mov	r0, r3
 800d0b2:	3714      	adds	r7, #20
 800d0b4:	46bd      	mov	sp, r7
 800d0b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d0ba:	4770      	bx	lr

0800d0bc <setpixel>:
#include "framebuf.h"

#define MAX(a,b) (((a)>(b))?(a):(b))
#define MIN(a,b) (((a)<(b))?(a):(b))

void setpixel(const tFramebuf *fb, unsigned int x, unsigned int y, uint32_t col) {
 800d0bc:	b480      	push	{r7}
 800d0be:	b085      	sub	sp, #20
 800d0c0:	af00      	add	r7, sp, #0
 800d0c2:	60f8      	str	r0, [r7, #12]
 800d0c4:	60b9      	str	r1, [r7, #8]
 800d0c6:	607a      	str	r2, [r7, #4]
 800d0c8:	603b      	str	r3, [r7, #0]
	((uint16_t *)fb->buf)[x + y * fb->stride] = col;
 800d0ca:	68fb      	ldr	r3, [r7, #12]
 800d0cc:	681a      	ldr	r2, [r3, #0]
 800d0ce:	68fb      	ldr	r3, [r7, #12]
 800d0d0:	891b      	ldrh	r3, [r3, #8]
 800d0d2:	4619      	mov	r1, r3
 800d0d4:	687b      	ldr	r3, [r7, #4]
 800d0d6:	fb03 f101 	mul.w	r1, r3, r1
 800d0da:	68bb      	ldr	r3, [r7, #8]
 800d0dc:	440b      	add	r3, r1
 800d0de:	005b      	lsls	r3, r3, #1
 800d0e0:	4413      	add	r3, r2
 800d0e2:	683a      	ldr	r2, [r7, #0]
 800d0e4:	b292      	uxth	r2, r2
 800d0e6:	801a      	strh	r2, [r3, #0]
}
 800d0e8:	bf00      	nop
 800d0ea:	3714      	adds	r7, #20
 800d0ec:	46bd      	mov	sp, r7
 800d0ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d0f2:	4770      	bx	lr

0800d0f4 <setpixel_checked>:

void setpixel_checked(const tFramebuf *fb, int x, int y, int col, int mask) {
 800d0f4:	b580      	push	{r7, lr}
 800d0f6:	b084      	sub	sp, #16
 800d0f8:	af00      	add	r7, sp, #0
 800d0fa:	60f8      	str	r0, [r7, #12]
 800d0fc:	60b9      	str	r1, [r7, #8]
 800d0fe:	607a      	str	r2, [r7, #4]
 800d100:	603b      	str	r3, [r7, #0]
    if (mask && 0 <= x && x < fb->width && 0 <= y && y < fb->height) {
 800d102:	69bb      	ldr	r3, [r7, #24]
 800d104:	2b00      	cmp	r3, #0
 800d106:	d017      	beq.n	800d138 <setpixel_checked+0x44>
 800d108:	68bb      	ldr	r3, [r7, #8]
 800d10a:	2b00      	cmp	r3, #0
 800d10c:	db14      	blt.n	800d138 <setpixel_checked+0x44>
 800d10e:	68fb      	ldr	r3, [r7, #12]
 800d110:	889b      	ldrh	r3, [r3, #4]
 800d112:	461a      	mov	r2, r3
 800d114:	68bb      	ldr	r3, [r7, #8]
 800d116:	4293      	cmp	r3, r2
 800d118:	da0e      	bge.n	800d138 <setpixel_checked+0x44>
 800d11a:	687b      	ldr	r3, [r7, #4]
 800d11c:	2b00      	cmp	r3, #0
 800d11e:	db0b      	blt.n	800d138 <setpixel_checked+0x44>
 800d120:	68fb      	ldr	r3, [r7, #12]
 800d122:	88db      	ldrh	r3, [r3, #6]
 800d124:	461a      	mov	r2, r3
 800d126:	687b      	ldr	r3, [r7, #4]
 800d128:	4293      	cmp	r3, r2
 800d12a:	da05      	bge.n	800d138 <setpixel_checked+0x44>
        setpixel(fb, x, y, col);
 800d12c:	68b9      	ldr	r1, [r7, #8]
 800d12e:	687a      	ldr	r2, [r7, #4]
 800d130:	683b      	ldr	r3, [r7, #0]
 800d132:	68f8      	ldr	r0, [r7, #12]
 800d134:	f7ff ffc2 	bl	800d0bc <setpixel>
    }
}
 800d138:	bf00      	nop
 800d13a:	3710      	adds	r7, #16
 800d13c:	46bd      	mov	sp, r7
 800d13e:	bd80      	pop	{r7, pc}

0800d140 <fill_rect>:

uint32_t getpixel(const tFramebuf *fb, unsigned int x, unsigned int y) {
	return ((uint16_t *)fb->buf)[x + y * fb->stride];
}

void fill_rect(const tFramebuf *fb, int x, int y, int w, int h, uint32_t col) {
 800d140:	b480      	push	{r7}
 800d142:	b089      	sub	sp, #36	; 0x24
 800d144:	af00      	add	r7, sp, #0
 800d146:	60f8      	str	r0, [r7, #12]
 800d148:	60b9      	str	r1, [r7, #8]
 800d14a:	607a      	str	r2, [r7, #4]
 800d14c:	603b      	str	r3, [r7, #0]
    if (h < 1 || w < 1 || x + w <= 0 || y + h <= 0 || y >= fb->height || x >= fb->width) {
 800d14e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d150:	2b00      	cmp	r3, #0
 800d152:	dd66      	ble.n	800d222 <fill_rect+0xe2>
 800d154:	683b      	ldr	r3, [r7, #0]
 800d156:	2b00      	cmp	r3, #0
 800d158:	dd63      	ble.n	800d222 <fill_rect+0xe2>
 800d15a:	68ba      	ldr	r2, [r7, #8]
 800d15c:	683b      	ldr	r3, [r7, #0]
 800d15e:	4413      	add	r3, r2
 800d160:	2b00      	cmp	r3, #0
 800d162:	dd5e      	ble.n	800d222 <fill_rect+0xe2>
 800d164:	687a      	ldr	r2, [r7, #4]
 800d166:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d168:	4413      	add	r3, r2
 800d16a:	2b00      	cmp	r3, #0
 800d16c:	dd59      	ble.n	800d222 <fill_rect+0xe2>
 800d16e:	68fb      	ldr	r3, [r7, #12]
 800d170:	88db      	ldrh	r3, [r3, #6]
 800d172:	461a      	mov	r2, r3
 800d174:	687b      	ldr	r3, [r7, #4]
 800d176:	4293      	cmp	r3, r2
 800d178:	da53      	bge.n	800d222 <fill_rect+0xe2>
 800d17a:	68fb      	ldr	r3, [r7, #12]
 800d17c:	889b      	ldrh	r3, [r3, #4]
 800d17e:	461a      	mov	r2, r3
 800d180:	68bb      	ldr	r3, [r7, #8]
 800d182:	4293      	cmp	r3, r2
 800d184:	da4d      	bge.n	800d222 <fill_rect+0xe2>
        // No operation needed.
        return;
    }

    // clip to the framebuffer
    int xend = MIN(fb->width, x + w);
 800d186:	68ba      	ldr	r2, [r7, #8]
 800d188:	683b      	ldr	r3, [r7, #0]
 800d18a:	4413      	add	r3, r2
 800d18c:	68fa      	ldr	r2, [r7, #12]
 800d18e:	8892      	ldrh	r2, [r2, #4]
 800d190:	4293      	cmp	r3, r2
 800d192:	bfa8      	it	ge
 800d194:	4613      	movge	r3, r2
 800d196:	617b      	str	r3, [r7, #20]
    int yend = MIN(fb->height, y + h);
 800d198:	687a      	ldr	r2, [r7, #4]
 800d19a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d19c:	4413      	add	r3, r2
 800d19e:	68fa      	ldr	r2, [r7, #12]
 800d1a0:	88d2      	ldrh	r2, [r2, #6]
 800d1a2:	4293      	cmp	r3, r2
 800d1a4:	bfa8      	it	ge
 800d1a6:	4613      	movge	r3, r2
 800d1a8:	613b      	str	r3, [r7, #16]
    x = MAX(x, 0);
 800d1aa:	68bb      	ldr	r3, [r7, #8]
 800d1ac:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800d1b0:	60bb      	str	r3, [r7, #8]
    y = MAX(y, 0);
 800d1b2:	687b      	ldr	r3, [r7, #4]
 800d1b4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800d1b8:	607b      	str	r3, [r7, #4]

    w = xend - x;
 800d1ba:	697a      	ldr	r2, [r7, #20]
 800d1bc:	68bb      	ldr	r3, [r7, #8]
 800d1be:	1ad3      	subs	r3, r2, r3
 800d1c0:	603b      	str	r3, [r7, #0]
    h = yend - y;
 800d1c2:	693a      	ldr	r2, [r7, #16]
 800d1c4:	687b      	ldr	r3, [r7, #4]
 800d1c6:	1ad3      	subs	r3, r2, r3
 800d1c8:	62bb      	str	r3, [r7, #40]	; 0x28
    uint16_t *b = &((uint16_t *)fb->buf)[x + y * fb->stride];
 800d1ca:	68fb      	ldr	r3, [r7, #12]
 800d1cc:	681a      	ldr	r2, [r3, #0]
 800d1ce:	68fb      	ldr	r3, [r7, #12]
 800d1d0:	891b      	ldrh	r3, [r3, #8]
 800d1d2:	4619      	mov	r1, r3
 800d1d4:	687b      	ldr	r3, [r7, #4]
 800d1d6:	fb03 f101 	mul.w	r1, r3, r1
 800d1da:	68bb      	ldr	r3, [r7, #8]
 800d1dc:	440b      	add	r3, r1
 800d1de:	005b      	lsls	r3, r3, #1
 800d1e0:	4413      	add	r3, r2
 800d1e2:	61fb      	str	r3, [r7, #28]
    while (h--) {
 800d1e4:	e017      	b.n	800d216 <fill_rect+0xd6>
        for (unsigned int ww = w; ww; --ww) {
 800d1e6:	683b      	ldr	r3, [r7, #0]
 800d1e8:	61bb      	str	r3, [r7, #24]
 800d1ea:	e008      	b.n	800d1fe <fill_rect+0xbe>
            *b++ = col;
 800d1ec:	69fb      	ldr	r3, [r7, #28]
 800d1ee:	1c9a      	adds	r2, r3, #2
 800d1f0:	61fa      	str	r2, [r7, #28]
 800d1f2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d1f4:	b292      	uxth	r2, r2
 800d1f6:	801a      	strh	r2, [r3, #0]
        for (unsigned int ww = w; ww; --ww) {
 800d1f8:	69bb      	ldr	r3, [r7, #24]
 800d1fa:	3b01      	subs	r3, #1
 800d1fc:	61bb      	str	r3, [r7, #24]
 800d1fe:	69bb      	ldr	r3, [r7, #24]
 800d200:	2b00      	cmp	r3, #0
 800d202:	d1f3      	bne.n	800d1ec <fill_rect+0xac>
        }
        b += fb->stride - w;
 800d204:	68fb      	ldr	r3, [r7, #12]
 800d206:	891b      	ldrh	r3, [r3, #8]
 800d208:	461a      	mov	r2, r3
 800d20a:	683b      	ldr	r3, [r7, #0]
 800d20c:	1ad3      	subs	r3, r2, r3
 800d20e:	005b      	lsls	r3, r3, #1
 800d210:	69fa      	ldr	r2, [r7, #28]
 800d212:	4413      	add	r3, r2
 800d214:	61fb      	str	r3, [r7, #28]
    while (h--) {
 800d216:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d218:	1e5a      	subs	r2, r3, #1
 800d21a:	62ba      	str	r2, [r7, #40]	; 0x28
 800d21c:	2b00      	cmp	r3, #0
 800d21e:	d1e2      	bne.n	800d1e6 <fill_rect+0xa6>
 800d220:	e000      	b.n	800d224 <fill_rect+0xe4>
        return;
 800d222:	bf00      	nop
    }

}
 800d224:	3724      	adds	r7, #36	; 0x24
 800d226:	46bd      	mov	sp, r7
 800d228:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d22c:	4770      	bx	lr

0800d22e <framebuf_init>:

void framebuf_init(tFramebuf *fb, uint16_t width, uint16_t height, char *buf ) {
 800d22e:	b480      	push	{r7}
 800d230:	b085      	sub	sp, #20
 800d232:	af00      	add	r7, sp, #0
 800d234:	60f8      	str	r0, [r7, #12]
 800d236:	607b      	str	r3, [r7, #4]
 800d238:	460b      	mov	r3, r1
 800d23a:	817b      	strh	r3, [r7, #10]
 800d23c:	4613      	mov	r3, r2
 800d23e:	813b      	strh	r3, [r7, #8]
    fb->width = width;
 800d240:	68fb      	ldr	r3, [r7, #12]
 800d242:	897a      	ldrh	r2, [r7, #10]
 800d244:	809a      	strh	r2, [r3, #4]
    fb->height = height;
 800d246:	68fb      	ldr	r3, [r7, #12]
 800d248:	893a      	ldrh	r2, [r7, #8]
 800d24a:	80da      	strh	r2, [r3, #6]
	fb->buf = buf;
 800d24c:	68fb      	ldr	r3, [r7, #12]
 800d24e:	687a      	ldr	r2, [r7, #4]
 800d250:	601a      	str	r2, [r3, #0]
	fb->stride = fb->width;
 800d252:	68fb      	ldr	r3, [r7, #12]
 800d254:	889a      	ldrh	r2, [r3, #4]
 800d256:	68fb      	ldr	r3, [r7, #12]
 800d258:	811a      	strh	r2, [r3, #8]
}
 800d25a:	bf00      	nop
 800d25c:	3714      	adds	r7, #20
 800d25e:	46bd      	mov	sp, r7
 800d260:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d264:	4770      	bx	lr

0800d266 <framebuf_fill>:

void framebuf_fill( const tFramebuf *fb, uint32_t col ) {
 800d266:	b580      	push	{r7, lr}
 800d268:	b084      	sub	sp, #16
 800d26a:	af02      	add	r7, sp, #8
 800d26c:	6078      	str	r0, [r7, #4]
 800d26e:	6039      	str	r1, [r7, #0]
    fill_rect( fb, 0, 0, fb->width, fb->height, col);
 800d270:	687b      	ldr	r3, [r7, #4]
 800d272:	889b      	ldrh	r3, [r3, #4]
 800d274:	4619      	mov	r1, r3
 800d276:	687b      	ldr	r3, [r7, #4]
 800d278:	88db      	ldrh	r3, [r3, #6]
 800d27a:	461a      	mov	r2, r3
 800d27c:	683b      	ldr	r3, [r7, #0]
 800d27e:	9301      	str	r3, [sp, #4]
 800d280:	9200      	str	r2, [sp, #0]
 800d282:	460b      	mov	r3, r1
 800d284:	2200      	movs	r2, #0
 800d286:	2100      	movs	r1, #0
 800d288:	6878      	ldr	r0, [r7, #4]
 800d28a:	f7ff ff59 	bl	800d140 <fill_rect>
}
 800d28e:	bf00      	nop
 800d290:	3708      	adds	r7, #8
 800d292:	46bd      	mov	sp, r7
 800d294:	bd80      	pop	{r7, pc}

0800d296 <framebuf_fill_rect>:

void framebuf_fill_rect( const tFramebuf *fb, int x, int y, int w, int h, uint32_t col ) {
 800d296:	b580      	push	{r7, lr}
 800d298:	b086      	sub	sp, #24
 800d29a:	af02      	add	r7, sp, #8
 800d29c:	60f8      	str	r0, [r7, #12]
 800d29e:	60b9      	str	r1, [r7, #8]
 800d2a0:	607a      	str	r2, [r7, #4]
 800d2a2:	603b      	str	r3, [r7, #0]
    fill_rect( fb, x, y, w, h, col );
 800d2a4:	69fb      	ldr	r3, [r7, #28]
 800d2a6:	9301      	str	r3, [sp, #4]
 800d2a8:	69bb      	ldr	r3, [r7, #24]
 800d2aa:	9300      	str	r3, [sp, #0]
 800d2ac:	683b      	ldr	r3, [r7, #0]
 800d2ae:	687a      	ldr	r2, [r7, #4]
 800d2b0:	68b9      	ldr	r1, [r7, #8]
 800d2b2:	68f8      	ldr	r0, [r7, #12]
 800d2b4:	f7ff ff44 	bl	800d140 <fill_rect>
}
 800d2b8:	bf00      	nop
 800d2ba:	3710      	adds	r7, #16
 800d2bc:	46bd      	mov	sp, r7
 800d2be:	bd80      	pop	{r7, pc}

0800d2c0 <framebuf_pixel>:

void framebuf_pixel( const tFramebuf *fb, int x, int y, uint32_t col ) {
 800d2c0:	b580      	push	{r7, lr}
 800d2c2:	b084      	sub	sp, #16
 800d2c4:	af00      	add	r7, sp, #0
 800d2c6:	60f8      	str	r0, [r7, #12]
 800d2c8:	60b9      	str	r1, [r7, #8]
 800d2ca:	607a      	str	r2, [r7, #4]
 800d2cc:	603b      	str	r3, [r7, #0]
    if (0 <= x && x < fb->width && 0 <= y && y < fb->height) {
 800d2ce:	68bb      	ldr	r3, [r7, #8]
 800d2d0:	2b00      	cmp	r3, #0
 800d2d2:	db14      	blt.n	800d2fe <framebuf_pixel+0x3e>
 800d2d4:	68fb      	ldr	r3, [r7, #12]
 800d2d6:	889b      	ldrh	r3, [r3, #4]
 800d2d8:	461a      	mov	r2, r3
 800d2da:	68bb      	ldr	r3, [r7, #8]
 800d2dc:	4293      	cmp	r3, r2
 800d2de:	da0e      	bge.n	800d2fe <framebuf_pixel+0x3e>
 800d2e0:	687b      	ldr	r3, [r7, #4]
 800d2e2:	2b00      	cmp	r3, #0
 800d2e4:	db0b      	blt.n	800d2fe <framebuf_pixel+0x3e>
 800d2e6:	68fb      	ldr	r3, [r7, #12]
 800d2e8:	88db      	ldrh	r3, [r3, #6]
 800d2ea:	461a      	mov	r2, r3
 800d2ec:	687b      	ldr	r3, [r7, #4]
 800d2ee:	4293      	cmp	r3, r2
 800d2f0:	da05      	bge.n	800d2fe <framebuf_pixel+0x3e>
		setpixel( fb, x, y,  col );
 800d2f2:	68b9      	ldr	r1, [r7, #8]
 800d2f4:	687a      	ldr	r2, [r7, #4]
 800d2f6:	683b      	ldr	r3, [r7, #0]
 800d2f8:	68f8      	ldr	r0, [r7, #12]
 800d2fa:	f7ff fedf 	bl	800d0bc <setpixel>
    }
}
 800d2fe:	bf00      	nop
 800d300:	3710      	adds	r7, #16
 800d302:	46bd      	mov	sp, r7
 800d304:	bd80      	pop	{r7, pc}

0800d306 <framebuf_hline>:

void framebuf_hline( const tFramebuf *fb, int x, int y, int w, uint32_t col ) {
 800d306:	b580      	push	{r7, lr}
 800d308:	b086      	sub	sp, #24
 800d30a:	af02      	add	r7, sp, #8
 800d30c:	60f8      	str	r0, [r7, #12]
 800d30e:	60b9      	str	r1, [r7, #8]
 800d310:	607a      	str	r2, [r7, #4]
 800d312:	603b      	str	r3, [r7, #0]
	fill_rect( fb, x, y, w, 1, col );
 800d314:	69bb      	ldr	r3, [r7, #24]
 800d316:	9301      	str	r3, [sp, #4]
 800d318:	2301      	movs	r3, #1
 800d31a:	9300      	str	r3, [sp, #0]
 800d31c:	683b      	ldr	r3, [r7, #0]
 800d31e:	687a      	ldr	r2, [r7, #4]
 800d320:	68b9      	ldr	r1, [r7, #8]
 800d322:	68f8      	ldr	r0, [r7, #12]
 800d324:	f7ff ff0c 	bl	800d140 <fill_rect>
}
 800d328:	bf00      	nop
 800d32a:	3710      	adds	r7, #16
 800d32c:	46bd      	mov	sp, r7
 800d32e:	bd80      	pop	{r7, pc}

0800d330 <framebuf_vline>:

void framebuf_vline( const tFramebuf *fb, int x, int y, int h, uint32_t col ) {
 800d330:	b580      	push	{r7, lr}
 800d332:	b086      	sub	sp, #24
 800d334:	af02      	add	r7, sp, #8
 800d336:	60f8      	str	r0, [r7, #12]
 800d338:	60b9      	str	r1, [r7, #8]
 800d33a:	607a      	str	r2, [r7, #4]
 800d33c:	603b      	str	r3, [r7, #0]
	fill_rect( fb, x, y, 1, h, col );
 800d33e:	69bb      	ldr	r3, [r7, #24]
 800d340:	9301      	str	r3, [sp, #4]
 800d342:	683b      	ldr	r3, [r7, #0]
 800d344:	9300      	str	r3, [sp, #0]
 800d346:	2301      	movs	r3, #1
 800d348:	687a      	ldr	r2, [r7, #4]
 800d34a:	68b9      	ldr	r1, [r7, #8]
 800d34c:	68f8      	ldr	r0, [r7, #12]
 800d34e:	f7ff fef7 	bl	800d140 <fill_rect>
}
 800d352:	bf00      	nop
 800d354:	3710      	adds	r7, #16
 800d356:	46bd      	mov	sp, r7
 800d358:	bd80      	pop	{r7, pc}

0800d35a <line>:
	fill_rect( fb, x, y + h - 1, w, 1, col );
	fill_rect( fb, x, y, 1, h, col );
	fill_rect( fb, x + w - 1, y, 1, h, col );
}

void line(const tFramebuf *fb, int x1, int y1, int x2, int y2, uint32_t col) {
 800d35a:	b580      	push	{r7, lr}
 800d35c:	b08c      	sub	sp, #48	; 0x30
 800d35e:	af00      	add	r7, sp, #0
 800d360:	60f8      	str	r0, [r7, #12]
 800d362:	60b9      	str	r1, [r7, #8]
 800d364:	607a      	str	r2, [r7, #4]
 800d366:	603b      	str	r3, [r7, #0]
	int dx = x2 - x1;
 800d368:	683a      	ldr	r2, [r7, #0]
 800d36a:	68bb      	ldr	r3, [r7, #8]
 800d36c:	1ad3      	subs	r3, r2, r3
 800d36e:	62fb      	str	r3, [r7, #44]	; 0x2c
	int sx;
    if (dx > 0) {
 800d370:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d372:	2b00      	cmp	r3, #0
 800d374:	dd02      	ble.n	800d37c <line+0x22>
        sx = 1;
 800d376:	2301      	movs	r3, #1
 800d378:	62bb      	str	r3, [r7, #40]	; 0x28
 800d37a:	e005      	b.n	800d388 <line+0x2e>
    } else {
        dx = -dx;
 800d37c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d37e:	425b      	negs	r3, r3
 800d380:	62fb      	str	r3, [r7, #44]	; 0x2c
        sx = -1;
 800d382:	f04f 33ff 	mov.w	r3, #4294967295
 800d386:	62bb      	str	r3, [r7, #40]	; 0x28
    }

    int dy = y2 - y1;
 800d388:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800d38a:	687b      	ldr	r3, [r7, #4]
 800d38c:	1ad3      	subs	r3, r2, r3
 800d38e:	627b      	str	r3, [r7, #36]	; 0x24
    int sy;
    if (dy > 0) {
 800d390:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d392:	2b00      	cmp	r3, #0
 800d394:	dd02      	ble.n	800d39c <line+0x42>
        sy = 1;
 800d396:	2301      	movs	r3, #1
 800d398:	623b      	str	r3, [r7, #32]
 800d39a:	e005      	b.n	800d3a8 <line+0x4e>
    } else {
        dy = -dy;
 800d39c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d39e:	425b      	negs	r3, r3
 800d3a0:	627b      	str	r3, [r7, #36]	; 0x24
        sy = -1;
 800d3a2:	f04f 33ff 	mov.w	r3, #4294967295
 800d3a6:	623b      	str	r3, [r7, #32]
    }

    int steep;
    if (dy > dx) {
 800d3a8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d3aa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d3ac:	429a      	cmp	r2, r3
 800d3ae:	dd14      	ble.n	800d3da <line+0x80>
        int temp;
        temp = x1;
 800d3b0:	68bb      	ldr	r3, [r7, #8]
 800d3b2:	613b      	str	r3, [r7, #16]
        x1 = y1;
 800d3b4:	687b      	ldr	r3, [r7, #4]
 800d3b6:	60bb      	str	r3, [r7, #8]
        y1 = temp;
 800d3b8:	693b      	ldr	r3, [r7, #16]
 800d3ba:	607b      	str	r3, [r7, #4]
        temp = dx;
 800d3bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d3be:	613b      	str	r3, [r7, #16]
        dx = dy;
 800d3c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d3c2:	62fb      	str	r3, [r7, #44]	; 0x2c
        dy = temp;
 800d3c4:	693b      	ldr	r3, [r7, #16]
 800d3c6:	627b      	str	r3, [r7, #36]	; 0x24
        temp = sx;
 800d3c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d3ca:	613b      	str	r3, [r7, #16]
        sx = sy;
 800d3cc:	6a3b      	ldr	r3, [r7, #32]
 800d3ce:	62bb      	str	r3, [r7, #40]	; 0x28
        sy = temp;
 800d3d0:	693b      	ldr	r3, [r7, #16]
 800d3d2:	623b      	str	r3, [r7, #32]
        steep = 1;
 800d3d4:	2301      	movs	r3, #1
 800d3d6:	61fb      	str	r3, [r7, #28]
 800d3d8:	e001      	b.n	800d3de <line+0x84>
    } else {
        steep = 0;
 800d3da:	2300      	movs	r3, #0
 800d3dc:	61fb      	str	r3, [r7, #28]
    }

    int e = 2 * dy - dx;
 800d3de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d3e0:	005a      	lsls	r2, r3, #1
 800d3e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d3e4:	1ad3      	subs	r3, r2, r3
 800d3e6:	61bb      	str	r3, [r7, #24]
    for (int i = 0; i < dx; ++i) {
 800d3e8:	2300      	movs	r3, #0
 800d3ea:	617b      	str	r3, [r7, #20]
 800d3ec:	e04c      	b.n	800d488 <line+0x12e>
        if (steep) {
 800d3ee:	69fb      	ldr	r3, [r7, #28]
 800d3f0:	2b00      	cmp	r3, #0
 800d3f2:	d018      	beq.n	800d426 <line+0xcc>
            if (0 <= y1 && y1 < fb->width && 0 <= x1 && x1 < fb->height) {
 800d3f4:	687b      	ldr	r3, [r7, #4]
 800d3f6:	2b00      	cmp	r3, #0
 800d3f8:	db37      	blt.n	800d46a <line+0x110>
 800d3fa:	68fb      	ldr	r3, [r7, #12]
 800d3fc:	889b      	ldrh	r3, [r3, #4]
 800d3fe:	461a      	mov	r2, r3
 800d400:	687b      	ldr	r3, [r7, #4]
 800d402:	4293      	cmp	r3, r2
 800d404:	da31      	bge.n	800d46a <line+0x110>
 800d406:	68bb      	ldr	r3, [r7, #8]
 800d408:	2b00      	cmp	r3, #0
 800d40a:	db2e      	blt.n	800d46a <line+0x110>
 800d40c:	68fb      	ldr	r3, [r7, #12]
 800d40e:	88db      	ldrh	r3, [r3, #6]
 800d410:	461a      	mov	r2, r3
 800d412:	68bb      	ldr	r3, [r7, #8]
 800d414:	4293      	cmp	r3, r2
 800d416:	da28      	bge.n	800d46a <line+0x110>
                setpixel(fb, y1, x1, col);
 800d418:	6879      	ldr	r1, [r7, #4]
 800d41a:	68ba      	ldr	r2, [r7, #8]
 800d41c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800d41e:	68f8      	ldr	r0, [r7, #12]
 800d420:	f7ff fe4c 	bl	800d0bc <setpixel>
 800d424:	e021      	b.n	800d46a <line+0x110>
            }
        } else {
            if (0 <= x1 && x1 < fb->width && 0 <= y1 && y1 < fb->height) {
 800d426:	68bb      	ldr	r3, [r7, #8]
 800d428:	2b00      	cmp	r3, #0
 800d42a:	db1e      	blt.n	800d46a <line+0x110>
 800d42c:	68fb      	ldr	r3, [r7, #12]
 800d42e:	889b      	ldrh	r3, [r3, #4]
 800d430:	461a      	mov	r2, r3
 800d432:	68bb      	ldr	r3, [r7, #8]
 800d434:	4293      	cmp	r3, r2
 800d436:	da18      	bge.n	800d46a <line+0x110>
 800d438:	687b      	ldr	r3, [r7, #4]
 800d43a:	2b00      	cmp	r3, #0
 800d43c:	db15      	blt.n	800d46a <line+0x110>
 800d43e:	68fb      	ldr	r3, [r7, #12]
 800d440:	88db      	ldrh	r3, [r3, #6]
 800d442:	461a      	mov	r2, r3
 800d444:	687b      	ldr	r3, [r7, #4]
 800d446:	4293      	cmp	r3, r2
 800d448:	da0f      	bge.n	800d46a <line+0x110>
                setpixel(fb, x1, y1, col);
 800d44a:	68b9      	ldr	r1, [r7, #8]
 800d44c:	687a      	ldr	r2, [r7, #4]
 800d44e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800d450:	68f8      	ldr	r0, [r7, #12]
 800d452:	f7ff fe33 	bl	800d0bc <setpixel>
            }
        }
        while (e >= 0) {
 800d456:	e008      	b.n	800d46a <line+0x110>
            y1 += sy;
 800d458:	687a      	ldr	r2, [r7, #4]
 800d45a:	6a3b      	ldr	r3, [r7, #32]
 800d45c:	4413      	add	r3, r2
 800d45e:	607b      	str	r3, [r7, #4]
            e -= 2 * dx;
 800d460:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d462:	005b      	lsls	r3, r3, #1
 800d464:	69ba      	ldr	r2, [r7, #24]
 800d466:	1ad3      	subs	r3, r2, r3
 800d468:	61bb      	str	r3, [r7, #24]
        while (e >= 0) {
 800d46a:	69bb      	ldr	r3, [r7, #24]
 800d46c:	2b00      	cmp	r3, #0
 800d46e:	daf3      	bge.n	800d458 <line+0xfe>
        }
        x1 += sx;
 800d470:	68ba      	ldr	r2, [r7, #8]
 800d472:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d474:	4413      	add	r3, r2
 800d476:	60bb      	str	r3, [r7, #8]
        e += 2 * dy;
 800d478:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d47a:	005b      	lsls	r3, r3, #1
 800d47c:	69ba      	ldr	r2, [r7, #24]
 800d47e:	4413      	add	r3, r2
 800d480:	61bb      	str	r3, [r7, #24]
    for (int i = 0; i < dx; ++i) {
 800d482:	697b      	ldr	r3, [r7, #20]
 800d484:	3301      	adds	r3, #1
 800d486:	617b      	str	r3, [r7, #20]
 800d488:	697a      	ldr	r2, [r7, #20]
 800d48a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d48c:	429a      	cmp	r2, r3
 800d48e:	dbae      	blt.n	800d3ee <line+0x94>
    }

    if (0 <= x2 && x2 < fb->width && 0 <= y2 && y2 < fb->height) {
 800d490:	683b      	ldr	r3, [r7, #0]
 800d492:	2b00      	cmp	r3, #0
 800d494:	db14      	blt.n	800d4c0 <line+0x166>
 800d496:	68fb      	ldr	r3, [r7, #12]
 800d498:	889b      	ldrh	r3, [r3, #4]
 800d49a:	461a      	mov	r2, r3
 800d49c:	683b      	ldr	r3, [r7, #0]
 800d49e:	4293      	cmp	r3, r2
 800d4a0:	da0e      	bge.n	800d4c0 <line+0x166>
 800d4a2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d4a4:	2b00      	cmp	r3, #0
 800d4a6:	db0b      	blt.n	800d4c0 <line+0x166>
 800d4a8:	68fb      	ldr	r3, [r7, #12]
 800d4aa:	88db      	ldrh	r3, [r3, #6]
 800d4ac:	461a      	mov	r2, r3
 800d4ae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d4b0:	4293      	cmp	r3, r2
 800d4b2:	da05      	bge.n	800d4c0 <line+0x166>
        setpixel(fb, x2, y2, col);
 800d4b4:	6839      	ldr	r1, [r7, #0]
 800d4b6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800d4b8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800d4ba:	68f8      	ldr	r0, [r7, #12]
 800d4bc:	f7ff fdfe 	bl	800d0bc <setpixel>
    }
}
 800d4c0:	bf00      	nop
 800d4c2:	3730      	adds	r7, #48	; 0x30
 800d4c4:	46bd      	mov	sp, r7
 800d4c6:	bd80      	pop	{r7, pc}

0800d4c8 <framebuf_line>:

void framebuf_line(const tFramebuf *fb, int x1, int y1, int x2, int y2, uint32_t col) {
 800d4c8:	b580      	push	{r7, lr}
 800d4ca:	b086      	sub	sp, #24
 800d4cc:	af02      	add	r7, sp, #8
 800d4ce:	60f8      	str	r0, [r7, #12]
 800d4d0:	60b9      	str	r1, [r7, #8]
 800d4d2:	607a      	str	r2, [r7, #4]
 800d4d4:	603b      	str	r3, [r7, #0]
    line( fb, x1, y1, x2, y2, col );
 800d4d6:	69fb      	ldr	r3, [r7, #28]
 800d4d8:	9301      	str	r3, [sp, #4]
 800d4da:	69bb      	ldr	r3, [r7, #24]
 800d4dc:	9300      	str	r3, [sp, #0]
 800d4de:	683b      	ldr	r3, [r7, #0]
 800d4e0:	687a      	ldr	r2, [r7, #4]
 800d4e2:	68b9      	ldr	r1, [r7, #8]
 800d4e4:	68f8      	ldr	r0, [r7, #12]
 800d4e6:	f7ff ff38 	bl	800d35a <line>
}
 800d4ea:	bf00      	nop
 800d4ec:	3710      	adds	r7, #16
 800d4ee:	46bd      	mov	sp, r7
 800d4f0:	bd80      	pop	{r7, pc}

0800d4f2 <framebuf_circle>:
        }
    }
}
*/

void framebuf_circle(const tFramebuf *fb, int xc, int yc, int radius, uint32_t col) {
 800d4f2:	b580      	push	{r7, lr}
 800d4f4:	b088      	sub	sp, #32
 800d4f6:	af00      	add	r7, sp, #0
 800d4f8:	60f8      	str	r0, [r7, #12]
 800d4fa:	60b9      	str	r1, [r7, #8]
 800d4fc:	607a      	str	r2, [r7, #4]
 800d4fe:	603b      	str	r3, [r7, #0]
    int x = 0;
 800d500:	2300      	movs	r3, #0
 800d502:	61fb      	str	r3, [r7, #28]
    int y = radius;
 800d504:	683b      	ldr	r3, [r7, #0]
 800d506:	61bb      	str	r3, [r7, #24]
    int d = 3 - 2 * radius;
 800d508:	683b      	ldr	r3, [r7, #0]
 800d50a:	005b      	lsls	r3, r3, #1
 800d50c:	f1c3 0303 	rsb	r3, r3, #3
 800d510:	617b      	str	r3, [r7, #20]

    while (x <= y) {
 800d512:	e067      	b.n	800d5e4 <framebuf_circle+0xf2>
        framebuf_pixel(fb, xc + x, yc + y, col);
 800d514:	68ba      	ldr	r2, [r7, #8]
 800d516:	69fb      	ldr	r3, [r7, #28]
 800d518:	18d1      	adds	r1, r2, r3
 800d51a:	687a      	ldr	r2, [r7, #4]
 800d51c:	69bb      	ldr	r3, [r7, #24]
 800d51e:	441a      	add	r2, r3
 800d520:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d522:	68f8      	ldr	r0, [r7, #12]
 800d524:	f7ff fecc 	bl	800d2c0 <framebuf_pixel>
        framebuf_pixel(fb, xc - x, yc + y, col);
 800d528:	68ba      	ldr	r2, [r7, #8]
 800d52a:	69fb      	ldr	r3, [r7, #28]
 800d52c:	1ad1      	subs	r1, r2, r3
 800d52e:	687a      	ldr	r2, [r7, #4]
 800d530:	69bb      	ldr	r3, [r7, #24]
 800d532:	441a      	add	r2, r3
 800d534:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d536:	68f8      	ldr	r0, [r7, #12]
 800d538:	f7ff fec2 	bl	800d2c0 <framebuf_pixel>
        framebuf_pixel(fb, xc + x, yc - y, col);
 800d53c:	68ba      	ldr	r2, [r7, #8]
 800d53e:	69fb      	ldr	r3, [r7, #28]
 800d540:	18d1      	adds	r1, r2, r3
 800d542:	687a      	ldr	r2, [r7, #4]
 800d544:	69bb      	ldr	r3, [r7, #24]
 800d546:	1ad2      	subs	r2, r2, r3
 800d548:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d54a:	68f8      	ldr	r0, [r7, #12]
 800d54c:	f7ff feb8 	bl	800d2c0 <framebuf_pixel>
        framebuf_pixel(fb, xc - x, yc - y, col);
 800d550:	68ba      	ldr	r2, [r7, #8]
 800d552:	69fb      	ldr	r3, [r7, #28]
 800d554:	1ad1      	subs	r1, r2, r3
 800d556:	687a      	ldr	r2, [r7, #4]
 800d558:	69bb      	ldr	r3, [r7, #24]
 800d55a:	1ad2      	subs	r2, r2, r3
 800d55c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d55e:	68f8      	ldr	r0, [r7, #12]
 800d560:	f7ff feae 	bl	800d2c0 <framebuf_pixel>
        framebuf_pixel(fb, xc + y, yc + x, col);
 800d564:	68ba      	ldr	r2, [r7, #8]
 800d566:	69bb      	ldr	r3, [r7, #24]
 800d568:	18d1      	adds	r1, r2, r3
 800d56a:	687a      	ldr	r2, [r7, #4]
 800d56c:	69fb      	ldr	r3, [r7, #28]
 800d56e:	441a      	add	r2, r3
 800d570:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d572:	68f8      	ldr	r0, [r7, #12]
 800d574:	f7ff fea4 	bl	800d2c0 <framebuf_pixel>
        framebuf_pixel(fb, xc - y, yc + x, col);
 800d578:	68ba      	ldr	r2, [r7, #8]
 800d57a:	69bb      	ldr	r3, [r7, #24]
 800d57c:	1ad1      	subs	r1, r2, r3
 800d57e:	687a      	ldr	r2, [r7, #4]
 800d580:	69fb      	ldr	r3, [r7, #28]
 800d582:	441a      	add	r2, r3
 800d584:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d586:	68f8      	ldr	r0, [r7, #12]
 800d588:	f7ff fe9a 	bl	800d2c0 <framebuf_pixel>
        framebuf_pixel(fb, xc + y, yc - x, col);
 800d58c:	68ba      	ldr	r2, [r7, #8]
 800d58e:	69bb      	ldr	r3, [r7, #24]
 800d590:	18d1      	adds	r1, r2, r3
 800d592:	687a      	ldr	r2, [r7, #4]
 800d594:	69fb      	ldr	r3, [r7, #28]
 800d596:	1ad2      	subs	r2, r2, r3
 800d598:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d59a:	68f8      	ldr	r0, [r7, #12]
 800d59c:	f7ff fe90 	bl	800d2c0 <framebuf_pixel>
        framebuf_pixel(fb, xc - y, yc - x, col);
 800d5a0:	68ba      	ldr	r2, [r7, #8]
 800d5a2:	69bb      	ldr	r3, [r7, #24]
 800d5a4:	1ad1      	subs	r1, r2, r3
 800d5a6:	687a      	ldr	r2, [r7, #4]
 800d5a8:	69fb      	ldr	r3, [r7, #28]
 800d5aa:	1ad2      	subs	r2, r2, r3
 800d5ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d5ae:	68f8      	ldr	r0, [r7, #12]
 800d5b0:	f7ff fe86 	bl	800d2c0 <framebuf_pixel>

        if (d < 0) {
 800d5b4:	697b      	ldr	r3, [r7, #20]
 800d5b6:	2b00      	cmp	r3, #0
 800d5b8:	da06      	bge.n	800d5c8 <framebuf_circle+0xd6>
            d = d + 4 * x + 6;
 800d5ba:	69fb      	ldr	r3, [r7, #28]
 800d5bc:	009a      	lsls	r2, r3, #2
 800d5be:	697b      	ldr	r3, [r7, #20]
 800d5c0:	4413      	add	r3, r2
 800d5c2:	3306      	adds	r3, #6
 800d5c4:	617b      	str	r3, [r7, #20]
 800d5c6:	e00a      	b.n	800d5de <framebuf_circle+0xec>
        } else {
            d = d + 4 * (x - y) + 10;
 800d5c8:	69fa      	ldr	r2, [r7, #28]
 800d5ca:	69bb      	ldr	r3, [r7, #24]
 800d5cc:	1ad3      	subs	r3, r2, r3
 800d5ce:	009a      	lsls	r2, r3, #2
 800d5d0:	697b      	ldr	r3, [r7, #20]
 800d5d2:	4413      	add	r3, r2
 800d5d4:	330a      	adds	r3, #10
 800d5d6:	617b      	str	r3, [r7, #20]
            y--;
 800d5d8:	69bb      	ldr	r3, [r7, #24]
 800d5da:	3b01      	subs	r3, #1
 800d5dc:	61bb      	str	r3, [r7, #24]
        }
        x++;
 800d5de:	69fb      	ldr	r3, [r7, #28]
 800d5e0:	3301      	adds	r3, #1
 800d5e2:	61fb      	str	r3, [r7, #28]
    while (x <= y) {
 800d5e4:	69fa      	ldr	r2, [r7, #28]
 800d5e6:	69bb      	ldr	r3, [r7, #24]
 800d5e8:	429a      	cmp	r2, r3
 800d5ea:	dd93      	ble.n	800d514 <framebuf_circle+0x22>
    }
}
 800d5ec:	bf00      	nop
 800d5ee:	bf00      	nop
 800d5f0:	3720      	adds	r7, #32
 800d5f2:	46bd      	mov	sp, r7
 800d5f4:	bd80      	pop	{r7, pc}

0800d5f6 <framebuf_circle_quadrant>:
#define QUADRANT_0   0x01
#define QUADRANT_90  0x02
#define QUADRANT_180 0x04
#define QUADRANT_270 0x08
void framebuf_circle_quadrant(const tFramebuf *fb, int xc, int yc, int radius, uint32_t col, uint8_t quadrant) {
 800d5f6:	b580      	push	{r7, lr}
 800d5f8:	b088      	sub	sp, #32
 800d5fa:	af00      	add	r7, sp, #0
 800d5fc:	60f8      	str	r0, [r7, #12]
 800d5fe:	60b9      	str	r1, [r7, #8]
 800d600:	607a      	str	r2, [r7, #4]
 800d602:	603b      	str	r3, [r7, #0]
    int x = 0;
 800d604:	2300      	movs	r3, #0
 800d606:	61fb      	str	r3, [r7, #28]
    int y = radius;
 800d608:	683b      	ldr	r3, [r7, #0]
 800d60a:	61bb      	str	r3, [r7, #24]
    int d = 3 - 2 * radius;
 800d60c:	683b      	ldr	r3, [r7, #0]
 800d60e:	005b      	lsls	r3, r3, #1
 800d610:	f1c3 0303 	rsb	r3, r3, #3
 800d614:	617b      	str	r3, [r7, #20]

    while (x <= y) {
 800d616:	e07f      	b.n	800d718 <framebuf_circle_quadrant+0x122>
        if (quadrant & QUADRANT_0) {
 800d618:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 800d61c:	f003 0301 	and.w	r3, r3, #1
 800d620:	2b00      	cmp	r3, #0
 800d622:	d013      	beq.n	800d64c <framebuf_circle_quadrant+0x56>
            framebuf_pixel(fb, xc + x, yc + y, col);
 800d624:	68ba      	ldr	r2, [r7, #8]
 800d626:	69fb      	ldr	r3, [r7, #28]
 800d628:	18d1      	adds	r1, r2, r3
 800d62a:	687a      	ldr	r2, [r7, #4]
 800d62c:	69bb      	ldr	r3, [r7, #24]
 800d62e:	441a      	add	r2, r3
 800d630:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d632:	68f8      	ldr	r0, [r7, #12]
 800d634:	f7ff fe44 	bl	800d2c0 <framebuf_pixel>
            framebuf_pixel(fb, xc + y, yc + x, col);
 800d638:	68ba      	ldr	r2, [r7, #8]
 800d63a:	69bb      	ldr	r3, [r7, #24]
 800d63c:	18d1      	adds	r1, r2, r3
 800d63e:	687a      	ldr	r2, [r7, #4]
 800d640:	69fb      	ldr	r3, [r7, #28]
 800d642:	441a      	add	r2, r3
 800d644:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d646:	68f8      	ldr	r0, [r7, #12]
 800d648:	f7ff fe3a 	bl	800d2c0 <framebuf_pixel>
        }
        if (quadrant & QUADRANT_90) {
 800d64c:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 800d650:	f003 0302 	and.w	r3, r3, #2
 800d654:	2b00      	cmp	r3, #0
 800d656:	d013      	beq.n	800d680 <framebuf_circle_quadrant+0x8a>
            framebuf_pixel(fb, xc - x, yc + y, col);
 800d658:	68ba      	ldr	r2, [r7, #8]
 800d65a:	69fb      	ldr	r3, [r7, #28]
 800d65c:	1ad1      	subs	r1, r2, r3
 800d65e:	687a      	ldr	r2, [r7, #4]
 800d660:	69bb      	ldr	r3, [r7, #24]
 800d662:	441a      	add	r2, r3
 800d664:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d666:	68f8      	ldr	r0, [r7, #12]
 800d668:	f7ff fe2a 	bl	800d2c0 <framebuf_pixel>
            framebuf_pixel(fb, xc - y, yc + x, col);
 800d66c:	68ba      	ldr	r2, [r7, #8]
 800d66e:	69bb      	ldr	r3, [r7, #24]
 800d670:	1ad1      	subs	r1, r2, r3
 800d672:	687a      	ldr	r2, [r7, #4]
 800d674:	69fb      	ldr	r3, [r7, #28]
 800d676:	441a      	add	r2, r3
 800d678:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d67a:	68f8      	ldr	r0, [r7, #12]
 800d67c:	f7ff fe20 	bl	800d2c0 <framebuf_pixel>
        }
        if (quadrant & QUADRANT_180) {
 800d680:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 800d684:	f003 0304 	and.w	r3, r3, #4
 800d688:	2b00      	cmp	r3, #0
 800d68a:	d013      	beq.n	800d6b4 <framebuf_circle_quadrant+0xbe>
            framebuf_pixel(fb, xc - x, yc - y, col);
 800d68c:	68ba      	ldr	r2, [r7, #8]
 800d68e:	69fb      	ldr	r3, [r7, #28]
 800d690:	1ad1      	subs	r1, r2, r3
 800d692:	687a      	ldr	r2, [r7, #4]
 800d694:	69bb      	ldr	r3, [r7, #24]
 800d696:	1ad2      	subs	r2, r2, r3
 800d698:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d69a:	68f8      	ldr	r0, [r7, #12]
 800d69c:	f7ff fe10 	bl	800d2c0 <framebuf_pixel>
            framebuf_pixel(fb, xc - y, yc - x, col);
 800d6a0:	68ba      	ldr	r2, [r7, #8]
 800d6a2:	69bb      	ldr	r3, [r7, #24]
 800d6a4:	1ad1      	subs	r1, r2, r3
 800d6a6:	687a      	ldr	r2, [r7, #4]
 800d6a8:	69fb      	ldr	r3, [r7, #28]
 800d6aa:	1ad2      	subs	r2, r2, r3
 800d6ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d6ae:	68f8      	ldr	r0, [r7, #12]
 800d6b0:	f7ff fe06 	bl	800d2c0 <framebuf_pixel>
        }
        if (quadrant & QUADRANT_270) {
 800d6b4:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 800d6b8:	f003 0308 	and.w	r3, r3, #8
 800d6bc:	2b00      	cmp	r3, #0
 800d6be:	d013      	beq.n	800d6e8 <framebuf_circle_quadrant+0xf2>
            framebuf_pixel(fb, xc + x, yc - y, col);
 800d6c0:	68ba      	ldr	r2, [r7, #8]
 800d6c2:	69fb      	ldr	r3, [r7, #28]
 800d6c4:	18d1      	adds	r1, r2, r3
 800d6c6:	687a      	ldr	r2, [r7, #4]
 800d6c8:	69bb      	ldr	r3, [r7, #24]
 800d6ca:	1ad2      	subs	r2, r2, r3
 800d6cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d6ce:	68f8      	ldr	r0, [r7, #12]
 800d6d0:	f7ff fdf6 	bl	800d2c0 <framebuf_pixel>
            framebuf_pixel(fb, xc + y, yc - x, col);
 800d6d4:	68ba      	ldr	r2, [r7, #8]
 800d6d6:	69bb      	ldr	r3, [r7, #24]
 800d6d8:	18d1      	adds	r1, r2, r3
 800d6da:	687a      	ldr	r2, [r7, #4]
 800d6dc:	69fb      	ldr	r3, [r7, #28]
 800d6de:	1ad2      	subs	r2, r2, r3
 800d6e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d6e2:	68f8      	ldr	r0, [r7, #12]
 800d6e4:	f7ff fdec 	bl	800d2c0 <framebuf_pixel>
        }

        if (d < 0) {
 800d6e8:	697b      	ldr	r3, [r7, #20]
 800d6ea:	2b00      	cmp	r3, #0
 800d6ec:	da06      	bge.n	800d6fc <framebuf_circle_quadrant+0x106>
            d = d + 4 * x + 6;
 800d6ee:	69fb      	ldr	r3, [r7, #28]
 800d6f0:	009a      	lsls	r2, r3, #2
 800d6f2:	697b      	ldr	r3, [r7, #20]
 800d6f4:	4413      	add	r3, r2
 800d6f6:	3306      	adds	r3, #6
 800d6f8:	617b      	str	r3, [r7, #20]
 800d6fa:	e00a      	b.n	800d712 <framebuf_circle_quadrant+0x11c>
        } else {
            d = d + 4 * (x - y) + 10;
 800d6fc:	69fa      	ldr	r2, [r7, #28]
 800d6fe:	69bb      	ldr	r3, [r7, #24]
 800d700:	1ad3      	subs	r3, r2, r3
 800d702:	009a      	lsls	r2, r3, #2
 800d704:	697b      	ldr	r3, [r7, #20]
 800d706:	4413      	add	r3, r2
 800d708:	330a      	adds	r3, #10
 800d70a:	617b      	str	r3, [r7, #20]
            y--;
 800d70c:	69bb      	ldr	r3, [r7, #24]
 800d70e:	3b01      	subs	r3, #1
 800d710:	61bb      	str	r3, [r7, #24]
        }
        x++;
 800d712:	69fb      	ldr	r3, [r7, #28]
 800d714:	3301      	adds	r3, #1
 800d716:	61fb      	str	r3, [r7, #28]
    while (x <= y) {
 800d718:	69fa      	ldr	r2, [r7, #28]
 800d71a:	69bb      	ldr	r3, [r7, #24]
 800d71c:	429a      	cmp	r2, r3
 800d71e:	f77f af7b 	ble.w	800d618 <framebuf_circle_quadrant+0x22>
    }
}
 800d722:	bf00      	nop
 800d724:	bf00      	nop
 800d726:	3720      	adds	r7, #32
 800d728:	46bd      	mov	sp, r7
 800d72a:	bd80      	pop	{r7, pc}

0800d72c <framebuf_fill_circle>:

void framebuf_fill_circle(const tFramebuf *fb, int xc, int yc, int radius, uint32_t col) {
 800d72c:	b580      	push	{r7, lr}
 800d72e:	b08a      	sub	sp, #40	; 0x28
 800d730:	af02      	add	r7, sp, #8
 800d732:	60f8      	str	r0, [r7, #12]
 800d734:	60b9      	str	r1, [r7, #8]
 800d736:	607a      	str	r2, [r7, #4]
 800d738:	603b      	str	r3, [r7, #0]
    framebuf_hline(fb, xc - radius, yc, 2 * radius, col);
 800d73a:	68ba      	ldr	r2, [r7, #8]
 800d73c:	683b      	ldr	r3, [r7, #0]
 800d73e:	1ad1      	subs	r1, r2, r3
 800d740:	683b      	ldr	r3, [r7, #0]
 800d742:	005a      	lsls	r2, r3, #1
 800d744:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d746:	9300      	str	r3, [sp, #0]
 800d748:	4613      	mov	r3, r2
 800d74a:	687a      	ldr	r2, [r7, #4]
 800d74c:	68f8      	ldr	r0, [r7, #12]
 800d74e:	f7ff fdda 	bl	800d306 <framebuf_hline>

    int x = 0;
 800d752:	2300      	movs	r3, #0
 800d754:	61fb      	str	r3, [r7, #28]
    int y = radius;
 800d756:	683b      	ldr	r3, [r7, #0]
 800d758:	61bb      	str	r3, [r7, #24]
    int d = 3 - 2 * radius;
 800d75a:	683b      	ldr	r3, [r7, #0]
 800d75c:	005b      	lsls	r3, r3, #1
 800d75e:	f1c3 0303 	rsb	r3, r3, #3
 800d762:	617b      	str	r3, [r7, #20]

    while (x <= y) {
 800d764:	e055      	b.n	800d812 <framebuf_fill_circle+0xe6>
        if (y > 0) {
 800d766:	69bb      	ldr	r3, [r7, #24]
 800d768:	2b00      	cmp	r3, #0
 800d76a:	dd1b      	ble.n	800d7a4 <framebuf_fill_circle+0x78>
            framebuf_hline(fb, xc - x, yc - y, 2 * x, col);
 800d76c:	68ba      	ldr	r2, [r7, #8]
 800d76e:	69fb      	ldr	r3, [r7, #28]
 800d770:	1ad1      	subs	r1, r2, r3
 800d772:	687a      	ldr	r2, [r7, #4]
 800d774:	69bb      	ldr	r3, [r7, #24]
 800d776:	1ad2      	subs	r2, r2, r3
 800d778:	69fb      	ldr	r3, [r7, #28]
 800d77a:	0058      	lsls	r0, r3, #1
 800d77c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d77e:	9300      	str	r3, [sp, #0]
 800d780:	4603      	mov	r3, r0
 800d782:	68f8      	ldr	r0, [r7, #12]
 800d784:	f7ff fdbf 	bl	800d306 <framebuf_hline>
            framebuf_hline(fb, xc - x, yc + y, 2 * x, col);
 800d788:	68ba      	ldr	r2, [r7, #8]
 800d78a:	69fb      	ldr	r3, [r7, #28]
 800d78c:	1ad1      	subs	r1, r2, r3
 800d78e:	687a      	ldr	r2, [r7, #4]
 800d790:	69bb      	ldr	r3, [r7, #24]
 800d792:	441a      	add	r2, r3
 800d794:	69fb      	ldr	r3, [r7, #28]
 800d796:	0058      	lsls	r0, r3, #1
 800d798:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d79a:	9300      	str	r3, [sp, #0]
 800d79c:	4603      	mov	r3, r0
 800d79e:	68f8      	ldr	r0, [r7, #12]
 800d7a0:	f7ff fdb1 	bl	800d306 <framebuf_hline>
        }

        if (x > 0) {
 800d7a4:	69fb      	ldr	r3, [r7, #28]
 800d7a6:	2b00      	cmp	r3, #0
 800d7a8:	dd1b      	ble.n	800d7e2 <framebuf_fill_circle+0xb6>
            framebuf_hline(fb, xc - y, yc - x, 2 * y, col);
 800d7aa:	68ba      	ldr	r2, [r7, #8]
 800d7ac:	69bb      	ldr	r3, [r7, #24]
 800d7ae:	1ad1      	subs	r1, r2, r3
 800d7b0:	687a      	ldr	r2, [r7, #4]
 800d7b2:	69fb      	ldr	r3, [r7, #28]
 800d7b4:	1ad2      	subs	r2, r2, r3
 800d7b6:	69bb      	ldr	r3, [r7, #24]
 800d7b8:	0058      	lsls	r0, r3, #1
 800d7ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d7bc:	9300      	str	r3, [sp, #0]
 800d7be:	4603      	mov	r3, r0
 800d7c0:	68f8      	ldr	r0, [r7, #12]
 800d7c2:	f7ff fda0 	bl	800d306 <framebuf_hline>
            framebuf_hline(fb, xc - y, yc + x, 2 * y, col);
 800d7c6:	68ba      	ldr	r2, [r7, #8]
 800d7c8:	69bb      	ldr	r3, [r7, #24]
 800d7ca:	1ad1      	subs	r1, r2, r3
 800d7cc:	687a      	ldr	r2, [r7, #4]
 800d7ce:	69fb      	ldr	r3, [r7, #28]
 800d7d0:	441a      	add	r2, r3
 800d7d2:	69bb      	ldr	r3, [r7, #24]
 800d7d4:	0058      	lsls	r0, r3, #1
 800d7d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d7d8:	9300      	str	r3, [sp, #0]
 800d7da:	4603      	mov	r3, r0
 800d7dc:	68f8      	ldr	r0, [r7, #12]
 800d7de:	f7ff fd92 	bl	800d306 <framebuf_hline>
        }

        if (d < 0) {
 800d7e2:	697b      	ldr	r3, [r7, #20]
 800d7e4:	2b00      	cmp	r3, #0
 800d7e6:	da06      	bge.n	800d7f6 <framebuf_fill_circle+0xca>
            d = d + 4 * x + 6;
 800d7e8:	69fb      	ldr	r3, [r7, #28]
 800d7ea:	009a      	lsls	r2, r3, #2
 800d7ec:	697b      	ldr	r3, [r7, #20]
 800d7ee:	4413      	add	r3, r2
 800d7f0:	3306      	adds	r3, #6
 800d7f2:	617b      	str	r3, [r7, #20]
 800d7f4:	e00a      	b.n	800d80c <framebuf_fill_circle+0xe0>
        } else {
            d = d + 4 * (x - y) + 10;
 800d7f6:	69fa      	ldr	r2, [r7, #28]
 800d7f8:	69bb      	ldr	r3, [r7, #24]
 800d7fa:	1ad3      	subs	r3, r2, r3
 800d7fc:	009a      	lsls	r2, r3, #2
 800d7fe:	697b      	ldr	r3, [r7, #20]
 800d800:	4413      	add	r3, r2
 800d802:	330a      	adds	r3, #10
 800d804:	617b      	str	r3, [r7, #20]
            y--;
 800d806:	69bb      	ldr	r3, [r7, #24]
 800d808:	3b01      	subs	r3, #1
 800d80a:	61bb      	str	r3, [r7, #24]
        }
        x++;
 800d80c:	69fb      	ldr	r3, [r7, #28]
 800d80e:	3301      	adds	r3, #1
 800d810:	61fb      	str	r3, [r7, #28]
    while (x <= y) {
 800d812:	69fa      	ldr	r2, [r7, #28]
 800d814:	69bb      	ldr	r3, [r7, #24]
 800d816:	429a      	cmp	r2, r3
 800d818:	dda5      	ble.n	800d766 <framebuf_fill_circle+0x3a>
    }
}
 800d81a:	bf00      	nop
 800d81c:	bf00      	nop
 800d81e:	3720      	adds	r7, #32
 800d820:	46bd      	mov	sp, r7
 800d822:	bd80      	pop	{r7, pc}

0800d824 <framebuf_fill_circle_quadrant>:

void framebuf_fill_circle_quadrant(const tFramebuf *fb, int xc, int yc, int radius, uint32_t col, uint8_t quadrant) {
 800d824:	b580      	push	{r7, lr}
 800d826:	b08a      	sub	sp, #40	; 0x28
 800d828:	af02      	add	r7, sp, #8
 800d82a:	60f8      	str	r0, [r7, #12]
 800d82c:	60b9      	str	r1, [r7, #8]
 800d82e:	607a      	str	r2, [r7, #4]
 800d830:	603b      	str	r3, [r7, #0]
    framebuf_hline(fb, xc - radius, yc, 2 * radius, col);
 800d832:	68ba      	ldr	r2, [r7, #8]
 800d834:	683b      	ldr	r3, [r7, #0]
 800d836:	1ad1      	subs	r1, r2, r3
 800d838:	683b      	ldr	r3, [r7, #0]
 800d83a:	005a      	lsls	r2, r3, #1
 800d83c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d83e:	9300      	str	r3, [sp, #0]
 800d840:	4613      	mov	r3, r2
 800d842:	687a      	ldr	r2, [r7, #4]
 800d844:	68f8      	ldr	r0, [r7, #12]
 800d846:	f7ff fd5e 	bl	800d306 <framebuf_hline>

    int x = 0;
 800d84a:	2300      	movs	r3, #0
 800d84c:	61fb      	str	r3, [r7, #28]
    int y = radius;
 800d84e:	683b      	ldr	r3, [r7, #0]
 800d850:	61bb      	str	r3, [r7, #24]
    int d = 3 - 2 * radius;
 800d852:	683b      	ldr	r3, [r7, #0]
 800d854:	005b      	lsls	r3, r3, #1
 800d856:	f1c3 0303 	rsb	r3, r3, #3
 800d85a:	617b      	str	r3, [r7, #20]

    while (x <= y) {
 800d85c:	e0ab      	b.n	800d9b6 <framebuf_fill_circle_quadrant+0x192>
        if (quadrant & QUADRANT_0) {
 800d85e:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 800d862:	f003 0301 	and.w	r3, r3, #1
 800d866:	2b00      	cmp	r3, #0
 800d868:	d01e      	beq.n	800d8a8 <framebuf_fill_circle_quadrant+0x84>
            if (y > 0) {
 800d86a:	69bb      	ldr	r3, [r7, #24]
 800d86c:	2b00      	cmp	r3, #0
 800d86e:	dd1b      	ble.n	800d8a8 <framebuf_fill_circle_quadrant+0x84>
                framebuf_hline(fb, xc + x, yc - y, 2 * x, col);
 800d870:	68ba      	ldr	r2, [r7, #8]
 800d872:	69fb      	ldr	r3, [r7, #28]
 800d874:	18d1      	adds	r1, r2, r3
 800d876:	687a      	ldr	r2, [r7, #4]
 800d878:	69bb      	ldr	r3, [r7, #24]
 800d87a:	1ad2      	subs	r2, r2, r3
 800d87c:	69fb      	ldr	r3, [r7, #28]
 800d87e:	0058      	lsls	r0, r3, #1
 800d880:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d882:	9300      	str	r3, [sp, #0]
 800d884:	4603      	mov	r3, r0
 800d886:	68f8      	ldr	r0, [r7, #12]
 800d888:	f7ff fd3d 	bl	800d306 <framebuf_hline>
                framebuf_hline(fb, xc + x, yc + y, 2 * x, col);
 800d88c:	68ba      	ldr	r2, [r7, #8]
 800d88e:	69fb      	ldr	r3, [r7, #28]
 800d890:	18d1      	adds	r1, r2, r3
 800d892:	687a      	ldr	r2, [r7, #4]
 800d894:	69bb      	ldr	r3, [r7, #24]
 800d896:	441a      	add	r2, r3
 800d898:	69fb      	ldr	r3, [r7, #28]
 800d89a:	0058      	lsls	r0, r3, #1
 800d89c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d89e:	9300      	str	r3, [sp, #0]
 800d8a0:	4603      	mov	r3, r0
 800d8a2:	68f8      	ldr	r0, [r7, #12]
 800d8a4:	f7ff fd2f 	bl	800d306 <framebuf_hline>
            }
        }
        if (quadrant & QUADRANT_90) {
 800d8a8:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 800d8ac:	f003 0302 	and.w	r3, r3, #2
 800d8b0:	2b00      	cmp	r3, #0
 800d8b2:	d01e      	beq.n	800d8f2 <framebuf_fill_circle_quadrant+0xce>
            if (x > 0) {
 800d8b4:	69fb      	ldr	r3, [r7, #28]
 800d8b6:	2b00      	cmp	r3, #0
 800d8b8:	dd1b      	ble.n	800d8f2 <framebuf_fill_circle_quadrant+0xce>
                framebuf_hline(fb, xc - y, yc - x, 2 * y, col);
 800d8ba:	68ba      	ldr	r2, [r7, #8]
 800d8bc:	69bb      	ldr	r3, [r7, #24]
 800d8be:	1ad1      	subs	r1, r2, r3
 800d8c0:	687a      	ldr	r2, [r7, #4]
 800d8c2:	69fb      	ldr	r3, [r7, #28]
 800d8c4:	1ad2      	subs	r2, r2, r3
 800d8c6:	69bb      	ldr	r3, [r7, #24]
 800d8c8:	0058      	lsls	r0, r3, #1
 800d8ca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d8cc:	9300      	str	r3, [sp, #0]
 800d8ce:	4603      	mov	r3, r0
 800d8d0:	68f8      	ldr	r0, [r7, #12]
 800d8d2:	f7ff fd18 	bl	800d306 <framebuf_hline>
                framebuf_hline(fb, xc - y, yc + x, 2 * y, col);
 800d8d6:	68ba      	ldr	r2, [r7, #8]
 800d8d8:	69bb      	ldr	r3, [r7, #24]
 800d8da:	1ad1      	subs	r1, r2, r3
 800d8dc:	687a      	ldr	r2, [r7, #4]
 800d8de:	69fb      	ldr	r3, [r7, #28]
 800d8e0:	441a      	add	r2, r3
 800d8e2:	69bb      	ldr	r3, [r7, #24]
 800d8e4:	0058      	lsls	r0, r3, #1
 800d8e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d8e8:	9300      	str	r3, [sp, #0]
 800d8ea:	4603      	mov	r3, r0
 800d8ec:	68f8      	ldr	r0, [r7, #12]
 800d8ee:	f7ff fd0a 	bl	800d306 <framebuf_hline>
            }
        }
        if (quadrant & QUADRANT_180) {
 800d8f2:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 800d8f6:	f003 0304 	and.w	r3, r3, #4
 800d8fa:	2b00      	cmp	r3, #0
 800d8fc:	d01e      	beq.n	800d93c <framebuf_fill_circle_quadrant+0x118>
            if (y > 0) {
 800d8fe:	69bb      	ldr	r3, [r7, #24]
 800d900:	2b00      	cmp	r3, #0
 800d902:	dd1b      	ble.n	800d93c <framebuf_fill_circle_quadrant+0x118>
                framebuf_hline(fb, xc - x, yc - y, 2 * x, col);
 800d904:	68ba      	ldr	r2, [r7, #8]
 800d906:	69fb      	ldr	r3, [r7, #28]
 800d908:	1ad1      	subs	r1, r2, r3
 800d90a:	687a      	ldr	r2, [r7, #4]
 800d90c:	69bb      	ldr	r3, [r7, #24]
 800d90e:	1ad2      	subs	r2, r2, r3
 800d910:	69fb      	ldr	r3, [r7, #28]
 800d912:	0058      	lsls	r0, r3, #1
 800d914:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d916:	9300      	str	r3, [sp, #0]
 800d918:	4603      	mov	r3, r0
 800d91a:	68f8      	ldr	r0, [r7, #12]
 800d91c:	f7ff fcf3 	bl	800d306 <framebuf_hline>
                framebuf_hline(fb, xc - x, yc + y, 2 * x, col);
 800d920:	68ba      	ldr	r2, [r7, #8]
 800d922:	69fb      	ldr	r3, [r7, #28]
 800d924:	1ad1      	subs	r1, r2, r3
 800d926:	687a      	ldr	r2, [r7, #4]
 800d928:	69bb      	ldr	r3, [r7, #24]
 800d92a:	441a      	add	r2, r3
 800d92c:	69fb      	ldr	r3, [r7, #28]
 800d92e:	0058      	lsls	r0, r3, #1
 800d930:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d932:	9300      	str	r3, [sp, #0]
 800d934:	4603      	mov	r3, r0
 800d936:	68f8      	ldr	r0, [r7, #12]
 800d938:	f7ff fce5 	bl	800d306 <framebuf_hline>
            }
        }
        if (quadrant & QUADRANT_270) {
 800d93c:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 800d940:	f003 0308 	and.w	r3, r3, #8
 800d944:	2b00      	cmp	r3, #0
 800d946:	d01e      	beq.n	800d986 <framebuf_fill_circle_quadrant+0x162>
            if (x > 0) {
 800d948:	69fb      	ldr	r3, [r7, #28]
 800d94a:	2b00      	cmp	r3, #0
 800d94c:	dd1b      	ble.n	800d986 <framebuf_fill_circle_quadrant+0x162>
                framebuf_hline(fb, xc + y, yc - x, 2 * y, col);
 800d94e:	68ba      	ldr	r2, [r7, #8]
 800d950:	69bb      	ldr	r3, [r7, #24]
 800d952:	18d1      	adds	r1, r2, r3
 800d954:	687a      	ldr	r2, [r7, #4]
 800d956:	69fb      	ldr	r3, [r7, #28]
 800d958:	1ad2      	subs	r2, r2, r3
 800d95a:	69bb      	ldr	r3, [r7, #24]
 800d95c:	0058      	lsls	r0, r3, #1
 800d95e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d960:	9300      	str	r3, [sp, #0]
 800d962:	4603      	mov	r3, r0
 800d964:	68f8      	ldr	r0, [r7, #12]
 800d966:	f7ff fcce 	bl	800d306 <framebuf_hline>
                framebuf_hline(fb, xc + y, yc + x, 2 * y, col);
 800d96a:	68ba      	ldr	r2, [r7, #8]
 800d96c:	69bb      	ldr	r3, [r7, #24]
 800d96e:	18d1      	adds	r1, r2, r3
 800d970:	687a      	ldr	r2, [r7, #4]
 800d972:	69fb      	ldr	r3, [r7, #28]
 800d974:	441a      	add	r2, r3
 800d976:	69bb      	ldr	r3, [r7, #24]
 800d978:	0058      	lsls	r0, r3, #1
 800d97a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d97c:	9300      	str	r3, [sp, #0]
 800d97e:	4603      	mov	r3, r0
 800d980:	68f8      	ldr	r0, [r7, #12]
 800d982:	f7ff fcc0 	bl	800d306 <framebuf_hline>
            }
        }

        if (d < 0) {
 800d986:	697b      	ldr	r3, [r7, #20]
 800d988:	2b00      	cmp	r3, #0
 800d98a:	da06      	bge.n	800d99a <framebuf_fill_circle_quadrant+0x176>
            d = d + 4 * x + 6;
 800d98c:	69fb      	ldr	r3, [r7, #28]
 800d98e:	009a      	lsls	r2, r3, #2
 800d990:	697b      	ldr	r3, [r7, #20]
 800d992:	4413      	add	r3, r2
 800d994:	3306      	adds	r3, #6
 800d996:	617b      	str	r3, [r7, #20]
 800d998:	e00a      	b.n	800d9b0 <framebuf_fill_circle_quadrant+0x18c>
        } else {
            d = d + 4 * (x - y) + 10;
 800d99a:	69fa      	ldr	r2, [r7, #28]
 800d99c:	69bb      	ldr	r3, [r7, #24]
 800d99e:	1ad3      	subs	r3, r2, r3
 800d9a0:	009a      	lsls	r2, r3, #2
 800d9a2:	697b      	ldr	r3, [r7, #20]
 800d9a4:	4413      	add	r3, r2
 800d9a6:	330a      	adds	r3, #10
 800d9a8:	617b      	str	r3, [r7, #20]
            y--;
 800d9aa:	69bb      	ldr	r3, [r7, #24]
 800d9ac:	3b01      	subs	r3, #1
 800d9ae:	61bb      	str	r3, [r7, #24]
        }
        x++;
 800d9b0:	69fb      	ldr	r3, [r7, #28]
 800d9b2:	3301      	adds	r3, #1
 800d9b4:	61fb      	str	r3, [r7, #28]
    while (x <= y) {
 800d9b6:	69fa      	ldr	r2, [r7, #28]
 800d9b8:	69bb      	ldr	r3, [r7, #24]
 800d9ba:	429a      	cmp	r2, r3
 800d9bc:	f77f af4f 	ble.w	800d85e <framebuf_fill_circle_quadrant+0x3a>
    }
}
 800d9c0:	bf00      	nop
 800d9c2:	bf00      	nop
 800d9c4:	3720      	adds	r7, #32
 800d9c6:	46bd      	mov	sp, r7
 800d9c8:	bd80      	pop	{r7, pc}
	...

0800d9cc <nk_buffer_init_fixed>:
    b->grow_factor = 2.0f;
    b->pool = *a;
}
NK_API void
nk_buffer_init_fixed(struct nk_buffer *b, void *m, nk_size size)
{
 800d9cc:	b580      	push	{r7, lr}
 800d9ce:	b084      	sub	sp, #16
 800d9d0:	af00      	add	r7, sp, #0
 800d9d2:	60f8      	str	r0, [r7, #12]
 800d9d4:	60b9      	str	r1, [r7, #8]
 800d9d6:	607a      	str	r2, [r7, #4]
    NK_ASSERT(b);
 800d9d8:	68fb      	ldr	r3, [r7, #12]
 800d9da:	2b00      	cmp	r3, #0
 800d9dc:	d105      	bne.n	800d9ea <nk_buffer_init_fixed+0x1e>
 800d9de:	4b1b      	ldr	r3, [pc, #108]	; (800da4c <nk_buffer_init_fixed+0x80>)
 800d9e0:	4a1b      	ldr	r2, [pc, #108]	; (800da50 <nk_buffer_init_fixed+0x84>)
 800d9e2:	2136      	movs	r1, #54	; 0x36
 800d9e4:	481b      	ldr	r0, [pc, #108]	; (800da54 <nk_buffer_init_fixed+0x88>)
 800d9e6:	f010 f817 	bl	801da18 <__assert_func>
    NK_ASSERT(m);
 800d9ea:	68bb      	ldr	r3, [r7, #8]
 800d9ec:	2b00      	cmp	r3, #0
 800d9ee:	d105      	bne.n	800d9fc <nk_buffer_init_fixed+0x30>
 800d9f0:	4b19      	ldr	r3, [pc, #100]	; (800da58 <nk_buffer_init_fixed+0x8c>)
 800d9f2:	4a17      	ldr	r2, [pc, #92]	; (800da50 <nk_buffer_init_fixed+0x84>)
 800d9f4:	2137      	movs	r1, #55	; 0x37
 800d9f6:	4817      	ldr	r0, [pc, #92]	; (800da54 <nk_buffer_init_fixed+0x88>)
 800d9f8:	f010 f80e 	bl	801da18 <__assert_func>
    NK_ASSERT(size);
 800d9fc:	687b      	ldr	r3, [r7, #4]
 800d9fe:	2b00      	cmp	r3, #0
 800da00:	d105      	bne.n	800da0e <nk_buffer_init_fixed+0x42>
 800da02:	4b16      	ldr	r3, [pc, #88]	; (800da5c <nk_buffer_init_fixed+0x90>)
 800da04:	4a12      	ldr	r2, [pc, #72]	; (800da50 <nk_buffer_init_fixed+0x84>)
 800da06:	2138      	movs	r1, #56	; 0x38
 800da08:	4812      	ldr	r0, [pc, #72]	; (800da54 <nk_buffer_init_fixed+0x88>)
 800da0a:	f010 f805 	bl	801da18 <__assert_func>
    if (!b || !m || !size) return;
 800da0e:	68fb      	ldr	r3, [r7, #12]
 800da10:	2b00      	cmp	r3, #0
 800da12:	d016      	beq.n	800da42 <nk_buffer_init_fixed+0x76>
 800da14:	68bb      	ldr	r3, [r7, #8]
 800da16:	2b00      	cmp	r3, #0
 800da18:	d013      	beq.n	800da42 <nk_buffer_init_fixed+0x76>
 800da1a:	687b      	ldr	r3, [r7, #4]
 800da1c:	2b00      	cmp	r3, #0
 800da1e:	d010      	beq.n	800da42 <nk_buffer_init_fixed+0x76>

    nk_zero(b, sizeof(*b));
 800da20:	213c      	movs	r1, #60	; 0x3c
 800da22:	68f8      	ldr	r0, [r7, #12]
 800da24:	f00e fb00 	bl	801c028 <nk_zero>
    b->type = NK_BUFFER_FIXED;
 800da28:	68fb      	ldr	r3, [r7, #12]
 800da2a:	2200      	movs	r2, #0
 800da2c:	771a      	strb	r2, [r3, #28]
    b->memory.ptr = m;
 800da2e:	68fb      	ldr	r3, [r7, #12]
 800da30:	68ba      	ldr	r2, [r7, #8]
 800da32:	621a      	str	r2, [r3, #32]
    b->memory.size = size;
 800da34:	68fb      	ldr	r3, [r7, #12]
 800da36:	687a      	ldr	r2, [r7, #4]
 800da38:	625a      	str	r2, [r3, #36]	; 0x24
    b->size = size;
 800da3a:	68fb      	ldr	r3, [r7, #12]
 800da3c:	687a      	ldr	r2, [r7, #4]
 800da3e:	639a      	str	r2, [r3, #56]	; 0x38
 800da40:	e000      	b.n	800da44 <nk_buffer_init_fixed+0x78>
    if (!b || !m || !size) return;
 800da42:	bf00      	nop
}
 800da44:	3710      	adds	r7, #16
 800da46:	46bd      	mov	sp, r7
 800da48:	bd80      	pop	{r7, pc}
 800da4a:	bf00      	nop
 800da4c:	08021444 	.word	0x08021444
 800da50:	08023170 	.word	0x08023170
 800da54:	08021448 	.word	0x08021448
 800da58:	08021478 	.word	0x08021478
 800da5c:	0802147c 	.word	0x0802147c

0800da60 <nk_buffer_align>:
NK_LIB void*
nk_buffer_align(void *unaligned,
    nk_size align, nk_size *alignment,
    enum nk_buffer_allocation_type type)
{
 800da60:	b480      	push	{r7}
 800da62:	b087      	sub	sp, #28
 800da64:	af00      	add	r7, sp, #0
 800da66:	60f8      	str	r0, [r7, #12]
 800da68:	60b9      	str	r1, [r7, #8]
 800da6a:	607a      	str	r2, [r7, #4]
 800da6c:	70fb      	strb	r3, [r7, #3]
    void *memory = 0;
 800da6e:	2300      	movs	r3, #0
 800da70:	617b      	str	r3, [r7, #20]
    switch (type) {
 800da72:	78fb      	ldrb	r3, [r7, #3]
 800da74:	2b01      	cmp	r3, #1
 800da76:	d018      	beq.n	800daaa <nk_buffer_align+0x4a>
    default:
    case NK_BUFFER_MAX:
    case NK_BUFFER_FRONT:
        if (align) {
 800da78:	68bb      	ldr	r3, [r7, #8]
 800da7a:	2b00      	cmp	r3, #0
 800da7c:	d00f      	beq.n	800da9e <nk_buffer_align+0x3e>
            memory = NK_ALIGN_PTR(unaligned, align);
 800da7e:	68bb      	ldr	r3, [r7, #8]
 800da80:	3b01      	subs	r3, #1
 800da82:	68fa      	ldr	r2, [r7, #12]
 800da84:	4413      	add	r3, r2
 800da86:	461a      	mov	r2, r3
 800da88:	68bb      	ldr	r3, [r7, #8]
 800da8a:	425b      	negs	r3, r3
 800da8c:	4013      	ands	r3, r2
 800da8e:	617b      	str	r3, [r7, #20]
            *alignment = (nk_size)((nk_byte*)memory - (nk_byte*)unaligned);
 800da90:	697a      	ldr	r2, [r7, #20]
 800da92:	68fb      	ldr	r3, [r7, #12]
 800da94:	1ad3      	subs	r3, r2, r3
 800da96:	461a      	mov	r2, r3
 800da98:	687b      	ldr	r3, [r7, #4]
 800da9a:	601a      	str	r2, [r3, #0]
        } else {
            memory = unaligned;
            *alignment = 0;
        }
        break;
 800da9c:	e01a      	b.n	800dad4 <nk_buffer_align+0x74>
            memory = unaligned;
 800da9e:	68fb      	ldr	r3, [r7, #12]
 800daa0:	617b      	str	r3, [r7, #20]
            *alignment = 0;
 800daa2:	687b      	ldr	r3, [r7, #4]
 800daa4:	2200      	movs	r2, #0
 800daa6:	601a      	str	r2, [r3, #0]
        break;
 800daa8:	e014      	b.n	800dad4 <nk_buffer_align+0x74>
    case NK_BUFFER_BACK:
        if (align) {
 800daaa:	68bb      	ldr	r3, [r7, #8]
 800daac:	2b00      	cmp	r3, #0
 800daae:	d00b      	beq.n	800dac8 <nk_buffer_align+0x68>
            memory = NK_ALIGN_PTR_BACK(unaligned, align);
 800dab0:	68bb      	ldr	r3, [r7, #8]
 800dab2:	425a      	negs	r2, r3
 800dab4:	68fb      	ldr	r3, [r7, #12]
 800dab6:	4013      	ands	r3, r2
 800dab8:	617b      	str	r3, [r7, #20]
            *alignment = (nk_size)((nk_byte*)unaligned - (nk_byte*)memory);
 800daba:	68fa      	ldr	r2, [r7, #12]
 800dabc:	697b      	ldr	r3, [r7, #20]
 800dabe:	1ad3      	subs	r3, r2, r3
 800dac0:	461a      	mov	r2, r3
 800dac2:	687b      	ldr	r3, [r7, #4]
 800dac4:	601a      	str	r2, [r3, #0]
        } else {
            memory = unaligned;
            *alignment = 0;
        }
        break;
 800dac6:	e004      	b.n	800dad2 <nk_buffer_align+0x72>
            memory = unaligned;
 800dac8:	68fb      	ldr	r3, [r7, #12]
 800daca:	617b      	str	r3, [r7, #20]
            *alignment = 0;
 800dacc:	687b      	ldr	r3, [r7, #4]
 800dace:	2200      	movs	r2, #0
 800dad0:	601a      	str	r2, [r3, #0]
        break;
 800dad2:	bf00      	nop
    }
    return memory;
 800dad4:	697b      	ldr	r3, [r7, #20]
}
 800dad6:	4618      	mov	r0, r3
 800dad8:	371c      	adds	r7, #28
 800dada:	46bd      	mov	sp, r7
 800dadc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dae0:	4770      	bx	lr
	...

0800dae4 <nk_buffer_realloc>:
NK_LIB void*
nk_buffer_realloc(struct nk_buffer *b, nk_size capacity, nk_size *size)
{
 800dae4:	b580      	push	{r7, lr}
 800dae6:	b08a      	sub	sp, #40	; 0x28
 800dae8:	af00      	add	r7, sp, #0
 800daea:	60f8      	str	r0, [r7, #12]
 800daec:	60b9      	str	r1, [r7, #8]
 800daee:	607a      	str	r2, [r7, #4]
    void *temp;
    nk_size buffer_size;

    NK_ASSERT(b);
 800daf0:	68fb      	ldr	r3, [r7, #12]
 800daf2:	2b00      	cmp	r3, #0
 800daf4:	d105      	bne.n	800db02 <nk_buffer_realloc+0x1e>
 800daf6:	4b3c      	ldr	r3, [pc, #240]	; (800dbe8 <nk_buffer_realloc+0x104>)
 800daf8:	4a3c      	ldr	r2, [pc, #240]	; (800dbec <nk_buffer_realloc+0x108>)
 800dafa:	2165      	movs	r1, #101	; 0x65
 800dafc:	483c      	ldr	r0, [pc, #240]	; (800dbf0 <nk_buffer_realloc+0x10c>)
 800dafe:	f00f ff8b 	bl	801da18 <__assert_func>
    NK_ASSERT(size);
 800db02:	687b      	ldr	r3, [r7, #4]
 800db04:	2b00      	cmp	r3, #0
 800db06:	d105      	bne.n	800db14 <nk_buffer_realloc+0x30>
 800db08:	4b3a      	ldr	r3, [pc, #232]	; (800dbf4 <nk_buffer_realloc+0x110>)
 800db0a:	4a38      	ldr	r2, [pc, #224]	; (800dbec <nk_buffer_realloc+0x108>)
 800db0c:	2166      	movs	r1, #102	; 0x66
 800db0e:	4838      	ldr	r0, [pc, #224]	; (800dbf0 <nk_buffer_realloc+0x10c>)
 800db10:	f00f ff82 	bl	801da18 <__assert_func>
    if (!b || !size || !b->pool.alloc || !b->pool.free)
 800db14:	68fb      	ldr	r3, [r7, #12]
 800db16:	2b00      	cmp	r3, #0
 800db18:	d00a      	beq.n	800db30 <nk_buffer_realloc+0x4c>
 800db1a:	687b      	ldr	r3, [r7, #4]
 800db1c:	2b00      	cmp	r3, #0
 800db1e:	d007      	beq.n	800db30 <nk_buffer_realloc+0x4c>
 800db20:	68fb      	ldr	r3, [r7, #12]
 800db22:	695b      	ldr	r3, [r3, #20]
 800db24:	2b00      	cmp	r3, #0
 800db26:	d003      	beq.n	800db30 <nk_buffer_realloc+0x4c>
 800db28:	68fb      	ldr	r3, [r7, #12]
 800db2a:	699b      	ldr	r3, [r3, #24]
 800db2c:	2b00      	cmp	r3, #0
 800db2e:	d101      	bne.n	800db34 <nk_buffer_realloc+0x50>
        return 0;
 800db30:	2300      	movs	r3, #0
 800db32:	e054      	b.n	800dbde <nk_buffer_realloc+0xfa>

    buffer_size = b->memory.size;
 800db34:	68fb      	ldr	r3, [r7, #12]
 800db36:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800db38:	627b      	str	r3, [r7, #36]	; 0x24
    temp = b->pool.alloc(b->pool.userdata, b->memory.ptr, capacity);
 800db3a:	68fb      	ldr	r3, [r7, #12]
 800db3c:	695b      	ldr	r3, [r3, #20]
 800db3e:	68fa      	ldr	r2, [r7, #12]
 800db40:	6a11      	ldr	r1, [r2, #32]
 800db42:	68f8      	ldr	r0, [r7, #12]
 800db44:	68ba      	ldr	r2, [r7, #8]
 800db46:	6900      	ldr	r0, [r0, #16]
 800db48:	4798      	blx	r3
 800db4a:	6238      	str	r0, [r7, #32]
    NK_ASSERT(temp);
 800db4c:	6a3b      	ldr	r3, [r7, #32]
 800db4e:	2b00      	cmp	r3, #0
 800db50:	d105      	bne.n	800db5e <nk_buffer_realloc+0x7a>
 800db52:	4b29      	ldr	r3, [pc, #164]	; (800dbf8 <nk_buffer_realloc+0x114>)
 800db54:	4a25      	ldr	r2, [pc, #148]	; (800dbec <nk_buffer_realloc+0x108>)
 800db56:	216c      	movs	r1, #108	; 0x6c
 800db58:	4825      	ldr	r0, [pc, #148]	; (800dbf0 <nk_buffer_realloc+0x10c>)
 800db5a:	f00f ff5d 	bl	801da18 <__assert_func>
    if (!temp) return 0;
 800db5e:	6a3b      	ldr	r3, [r7, #32]
 800db60:	2b00      	cmp	r3, #0
 800db62:	d101      	bne.n	800db68 <nk_buffer_realloc+0x84>
 800db64:	2300      	movs	r3, #0
 800db66:	e03a      	b.n	800dbde <nk_buffer_realloc+0xfa>

    *size = capacity;
 800db68:	687b      	ldr	r3, [r7, #4]
 800db6a:	68ba      	ldr	r2, [r7, #8]
 800db6c:	601a      	str	r2, [r3, #0]
    if (temp != b->memory.ptr) {
 800db6e:	68fb      	ldr	r3, [r7, #12]
 800db70:	6a1b      	ldr	r3, [r3, #32]
 800db72:	6a3a      	ldr	r2, [r7, #32]
 800db74:	429a      	cmp	r2, r3
 800db76:	d00d      	beq.n	800db94 <nk_buffer_realloc+0xb0>
        NK_MEMCPY(temp, b->memory.ptr, buffer_size);
 800db78:	68fb      	ldr	r3, [r7, #12]
 800db7a:	6a1b      	ldr	r3, [r3, #32]
 800db7c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800db7e:	4619      	mov	r1, r3
 800db80:	6a38      	ldr	r0, [r7, #32]
 800db82:	f00e f901 	bl	801bd88 <nk_memcopy>
        b->pool.free(b->pool.userdata, b->memory.ptr);
 800db86:	68fb      	ldr	r3, [r7, #12]
 800db88:	699b      	ldr	r3, [r3, #24]
 800db8a:	68fa      	ldr	r2, [r7, #12]
 800db8c:	6a11      	ldr	r1, [r2, #32]
 800db8e:	68fa      	ldr	r2, [r7, #12]
 800db90:	6910      	ldr	r0, [r2, #16]
 800db92:	4798      	blx	r3
    }

    if (b->size == buffer_size) {
 800db94:	68fb      	ldr	r3, [r7, #12]
 800db96:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800db98:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800db9a:	429a      	cmp	r2, r3
 800db9c:	d104      	bne.n	800dba8 <nk_buffer_realloc+0xc4>
        /* no back buffer so just set correct size */
        b->size = capacity;
 800db9e:	68fb      	ldr	r3, [r7, #12]
 800dba0:	68ba      	ldr	r2, [r7, #8]
 800dba2:	639a      	str	r2, [r3, #56]	; 0x38
        return temp;
 800dba4:	6a3b      	ldr	r3, [r7, #32]
 800dba6:	e01a      	b.n	800dbde <nk_buffer_realloc+0xfa>
    } else {
        /* copy back buffer to the end of the new buffer */
        void *dst, *src;
        nk_size back_size;
        back_size = buffer_size - b->size;
 800dba8:	68fb      	ldr	r3, [r7, #12]
 800dbaa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800dbac:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800dbae:	1ad3      	subs	r3, r2, r3
 800dbb0:	61fb      	str	r3, [r7, #28]
        dst = nk_ptr_add(void, temp, capacity - back_size);
 800dbb2:	68ba      	ldr	r2, [r7, #8]
 800dbb4:	69fb      	ldr	r3, [r7, #28]
 800dbb6:	1ad3      	subs	r3, r2, r3
 800dbb8:	6a3a      	ldr	r2, [r7, #32]
 800dbba:	4413      	add	r3, r2
 800dbbc:	61bb      	str	r3, [r7, #24]
        src = nk_ptr_add(void, temp, b->size);
 800dbbe:	68fb      	ldr	r3, [r7, #12]
 800dbc0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800dbc2:	6a3a      	ldr	r2, [r7, #32]
 800dbc4:	4413      	add	r3, r2
 800dbc6:	617b      	str	r3, [r7, #20]
        NK_MEMCPY(dst, src, back_size);
 800dbc8:	69fa      	ldr	r2, [r7, #28]
 800dbca:	6979      	ldr	r1, [r7, #20]
 800dbcc:	69b8      	ldr	r0, [r7, #24]
 800dbce:	f00e f8db 	bl	801bd88 <nk_memcopy>
        b->size = capacity - back_size;
 800dbd2:	68ba      	ldr	r2, [r7, #8]
 800dbd4:	69fb      	ldr	r3, [r7, #28]
 800dbd6:	1ad2      	subs	r2, r2, r3
 800dbd8:	68fb      	ldr	r3, [r7, #12]
 800dbda:	639a      	str	r2, [r3, #56]	; 0x38
    }
    return temp;
 800dbdc:	6a3b      	ldr	r3, [r7, #32]
}
 800dbde:	4618      	mov	r0, r3
 800dbe0:	3728      	adds	r7, #40	; 0x28
 800dbe2:	46bd      	mov	sp, r7
 800dbe4:	bd80      	pop	{r7, pc}
 800dbe6:	bf00      	nop
 800dbe8:	08021444 	.word	0x08021444
 800dbec:	08023188 	.word	0x08023188
 800dbf0:	08021448 	.word	0x08021448
 800dbf4:	0802147c 	.word	0x0802147c
 800dbf8:	08021484 	.word	0x08021484

0800dbfc <nk_buffer_alloc>:
NK_LIB void*
nk_buffer_alloc(struct nk_buffer *b, enum nk_buffer_allocation_type type,
    nk_size size, nk_size align)
{
 800dbfc:	b580      	push	{r7, lr}
 800dbfe:	b08a      	sub	sp, #40	; 0x28
 800dc00:	af00      	add	r7, sp, #0
 800dc02:	60f8      	str	r0, [r7, #12]
 800dc04:	607a      	str	r2, [r7, #4]
 800dc06:	603b      	str	r3, [r7, #0]
 800dc08:	460b      	mov	r3, r1
 800dc0a:	72fb      	strb	r3, [r7, #11]
    int full;
    nk_size alignment;
    void *unaligned;
    void *memory;

    NK_ASSERT(b);
 800dc0c:	68fb      	ldr	r3, [r7, #12]
 800dc0e:	2b00      	cmp	r3, #0
 800dc10:	d105      	bne.n	800dc1e <nk_buffer_alloc+0x22>
 800dc12:	4b7a      	ldr	r3, [pc, #488]	; (800ddfc <nk_buffer_alloc+0x200>)
 800dc14:	4a7a      	ldr	r2, [pc, #488]	; (800de00 <nk_buffer_alloc+0x204>)
 800dc16:	218e      	movs	r1, #142	; 0x8e
 800dc18:	487a      	ldr	r0, [pc, #488]	; (800de04 <nk_buffer_alloc+0x208>)
 800dc1a:	f00f fefd 	bl	801da18 <__assert_func>
    NK_ASSERT(size);
 800dc1e:	687b      	ldr	r3, [r7, #4]
 800dc20:	2b00      	cmp	r3, #0
 800dc22:	d105      	bne.n	800dc30 <nk_buffer_alloc+0x34>
 800dc24:	4b78      	ldr	r3, [pc, #480]	; (800de08 <nk_buffer_alloc+0x20c>)
 800dc26:	4a76      	ldr	r2, [pc, #472]	; (800de00 <nk_buffer_alloc+0x204>)
 800dc28:	218f      	movs	r1, #143	; 0x8f
 800dc2a:	4876      	ldr	r0, [pc, #472]	; (800de04 <nk_buffer_alloc+0x208>)
 800dc2c:	f00f fef4 	bl	801da18 <__assert_func>
    if (!b || !size) return 0;
 800dc30:	68fb      	ldr	r3, [r7, #12]
 800dc32:	2b00      	cmp	r3, #0
 800dc34:	d002      	beq.n	800dc3c <nk_buffer_alloc+0x40>
 800dc36:	687b      	ldr	r3, [r7, #4]
 800dc38:	2b00      	cmp	r3, #0
 800dc3a:	d101      	bne.n	800dc40 <nk_buffer_alloc+0x44>
 800dc3c:	2300      	movs	r3, #0
 800dc3e:	e0d9      	b.n	800ddf4 <nk_buffer_alloc+0x1f8>
    b->needed += size;
 800dc40:	68fb      	ldr	r3, [r7, #12]
 800dc42:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800dc44:	687b      	ldr	r3, [r7, #4]
 800dc46:	441a      	add	r2, r3
 800dc48:	68fb      	ldr	r3, [r7, #12]
 800dc4a:	631a      	str	r2, [r3, #48]	; 0x30

    /* calculate total size with needed alignment + size */
    if (type == NK_BUFFER_FRONT)
 800dc4c:	7afb      	ldrb	r3, [r7, #11]
 800dc4e:	2b00      	cmp	r3, #0
 800dc50:	d106      	bne.n	800dc60 <nk_buffer_alloc+0x64>
        unaligned = nk_ptr_add(void, b->memory.ptr, b->allocated);
 800dc52:	68fb      	ldr	r3, [r7, #12]
 800dc54:	6a1a      	ldr	r2, [r3, #32]
 800dc56:	68fb      	ldr	r3, [r7, #12]
 800dc58:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800dc5a:	4413      	add	r3, r2
 800dc5c:	623b      	str	r3, [r7, #32]
 800dc5e:	e007      	b.n	800dc70 <nk_buffer_alloc+0x74>
    else unaligned = nk_ptr_add(void, b->memory.ptr, b->size - size);
 800dc60:	68fb      	ldr	r3, [r7, #12]
 800dc62:	6a1a      	ldr	r2, [r3, #32]
 800dc64:	68fb      	ldr	r3, [r7, #12]
 800dc66:	6b99      	ldr	r1, [r3, #56]	; 0x38
 800dc68:	687b      	ldr	r3, [r7, #4]
 800dc6a:	1acb      	subs	r3, r1, r3
 800dc6c:	4413      	add	r3, r2
 800dc6e:	623b      	str	r3, [r7, #32]
    memory = nk_buffer_align(unaligned, align, &alignment, type);
 800dc70:	7afb      	ldrb	r3, [r7, #11]
 800dc72:	f107 0214 	add.w	r2, r7, #20
 800dc76:	6839      	ldr	r1, [r7, #0]
 800dc78:	6a38      	ldr	r0, [r7, #32]
 800dc7a:	f7ff fef1 	bl	800da60 <nk_buffer_align>
 800dc7e:	61f8      	str	r0, [r7, #28]

    /* check if buffer has enough memory*/
    if (type == NK_BUFFER_FRONT)
 800dc80:	7afb      	ldrb	r3, [r7, #11]
 800dc82:	2b00      	cmp	r3, #0
 800dc84:	d10e      	bne.n	800dca4 <nk_buffer_alloc+0xa8>
        full = ((b->allocated + size + alignment) > b->size);
 800dc86:	68fb      	ldr	r3, [r7, #12]
 800dc88:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800dc8a:	687b      	ldr	r3, [r7, #4]
 800dc8c:	441a      	add	r2, r3
 800dc8e:	697b      	ldr	r3, [r7, #20]
 800dc90:	441a      	add	r2, r3
 800dc92:	68fb      	ldr	r3, [r7, #12]
 800dc94:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800dc96:	429a      	cmp	r2, r3
 800dc98:	bf8c      	ite	hi
 800dc9a:	2301      	movhi	r3, #1
 800dc9c:	2300      	movls	r3, #0
 800dc9e:	b2db      	uxtb	r3, r3
 800dca0:	627b      	str	r3, [r7, #36]	; 0x24
 800dca2:	e012      	b.n	800dcca <nk_buffer_alloc+0xce>
    else full = ((b->size - NK_MIN(b->size,(size + alignment))) <= b->allocated);
 800dca4:	68fb      	ldr	r3, [r7, #12]
 800dca6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800dca8:	6979      	ldr	r1, [r7, #20]
 800dcaa:	687b      	ldr	r3, [r7, #4]
 800dcac:	4419      	add	r1, r3
 800dcae:	68fb      	ldr	r3, [r7, #12]
 800dcb0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800dcb2:	428b      	cmp	r3, r1
 800dcb4:	bf28      	it	cs
 800dcb6:	460b      	movcs	r3, r1
 800dcb8:	1ad2      	subs	r2, r2, r3
 800dcba:	68fb      	ldr	r3, [r7, #12]
 800dcbc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800dcbe:	429a      	cmp	r2, r3
 800dcc0:	bf94      	ite	ls
 800dcc2:	2301      	movls	r3, #1
 800dcc4:	2300      	movhi	r3, #0
 800dcc6:	b2db      	uxtb	r3, r3
 800dcc8:	627b      	str	r3, [r7, #36]	; 0x24

    if (full) {
 800dcca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dccc:	2b00      	cmp	r3, #0
 800dcce:	d071      	beq.n	800ddb4 <nk_buffer_alloc+0x1b8>
        nk_size capacity;
        if (b->type != NK_BUFFER_DYNAMIC)
 800dcd0:	68fb      	ldr	r3, [r7, #12]
 800dcd2:	7f1b      	ldrb	r3, [r3, #28]
 800dcd4:	2b01      	cmp	r3, #1
 800dcd6:	d001      	beq.n	800dcdc <nk_buffer_alloc+0xe0>
            return 0;
 800dcd8:	2300      	movs	r3, #0
 800dcda:	e08b      	b.n	800ddf4 <nk_buffer_alloc+0x1f8>
        NK_ASSERT(b->pool.alloc && b->pool.free);
 800dcdc:	68fb      	ldr	r3, [r7, #12]
 800dcde:	695b      	ldr	r3, [r3, #20]
 800dce0:	2b00      	cmp	r3, #0
 800dce2:	d003      	beq.n	800dcec <nk_buffer_alloc+0xf0>
 800dce4:	68fb      	ldr	r3, [r7, #12]
 800dce6:	699b      	ldr	r3, [r3, #24]
 800dce8:	2b00      	cmp	r3, #0
 800dcea:	d105      	bne.n	800dcf8 <nk_buffer_alloc+0xfc>
 800dcec:	4b47      	ldr	r3, [pc, #284]	; (800de0c <nk_buffer_alloc+0x210>)
 800dcee:	4a44      	ldr	r2, [pc, #272]	; (800de00 <nk_buffer_alloc+0x204>)
 800dcf0:	21a2      	movs	r1, #162	; 0xa2
 800dcf2:	4844      	ldr	r0, [pc, #272]	; (800de04 <nk_buffer_alloc+0x208>)
 800dcf4:	f00f fe90 	bl	801da18 <__assert_func>
        if (b->type != NK_BUFFER_DYNAMIC || !b->pool.alloc || !b->pool.free)
 800dcf8:	68fb      	ldr	r3, [r7, #12]
 800dcfa:	7f1b      	ldrb	r3, [r3, #28]
 800dcfc:	2b01      	cmp	r3, #1
 800dcfe:	d107      	bne.n	800dd10 <nk_buffer_alloc+0x114>
 800dd00:	68fb      	ldr	r3, [r7, #12]
 800dd02:	695b      	ldr	r3, [r3, #20]
 800dd04:	2b00      	cmp	r3, #0
 800dd06:	d003      	beq.n	800dd10 <nk_buffer_alloc+0x114>
 800dd08:	68fb      	ldr	r3, [r7, #12]
 800dd0a:	699b      	ldr	r3, [r3, #24]
 800dd0c:	2b00      	cmp	r3, #0
 800dd0e:	d101      	bne.n	800dd14 <nk_buffer_alloc+0x118>
            return 0;
 800dd10:	2300      	movs	r3, #0
 800dd12:	e06f      	b.n	800ddf4 <nk_buffer_alloc+0x1f8>

        /* buffer is full so allocate bigger buffer if dynamic */
        capacity = (nk_size)((float)b->memory.size * b->grow_factor);
 800dd14:	68fb      	ldr	r3, [r7, #12]
 800dd16:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800dd18:	ee07 3a90 	vmov	s15, r3
 800dd1c:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 800dd20:	68fb      	ldr	r3, [r7, #12]
 800dd22:	edd3 7a0a 	vldr	s15, [r3, #40]	; 0x28
 800dd26:	ee67 7a27 	vmul.f32	s15, s14, s15
 800dd2a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800dd2e:	ee17 3a90 	vmov	r3, s15
 800dd32:	61bb      	str	r3, [r7, #24]
        capacity = NK_MAX(capacity, nk_round_up_pow2((nk_uint)(b->allocated + size)));
 800dd34:	68fb      	ldr	r3, [r7, #12]
 800dd36:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800dd38:	687b      	ldr	r3, [r7, #4]
 800dd3a:	4413      	add	r3, r2
 800dd3c:	4618      	mov	r0, r3
 800dd3e:	f005 fcdf 	bl	8013700 <nk_round_up_pow2>
 800dd42:	4602      	mov	r2, r0
 800dd44:	69bb      	ldr	r3, [r7, #24]
 800dd46:	4293      	cmp	r3, r2
 800dd48:	d208      	bcs.n	800dd5c <nk_buffer_alloc+0x160>
 800dd4a:	68fb      	ldr	r3, [r7, #12]
 800dd4c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800dd4e:	687b      	ldr	r3, [r7, #4]
 800dd50:	4413      	add	r3, r2
 800dd52:	4618      	mov	r0, r3
 800dd54:	f005 fcd4 	bl	8013700 <nk_round_up_pow2>
 800dd58:	4603      	mov	r3, r0
 800dd5a:	e000      	b.n	800dd5e <nk_buffer_alloc+0x162>
 800dd5c:	69bb      	ldr	r3, [r7, #24]
 800dd5e:	61bb      	str	r3, [r7, #24]
        b->memory.ptr = nk_buffer_realloc(b, capacity, &b->memory.size);
 800dd60:	68fb      	ldr	r3, [r7, #12]
 800dd62:	3324      	adds	r3, #36	; 0x24
 800dd64:	461a      	mov	r2, r3
 800dd66:	69b9      	ldr	r1, [r7, #24]
 800dd68:	68f8      	ldr	r0, [r7, #12]
 800dd6a:	f7ff febb 	bl	800dae4 <nk_buffer_realloc>
 800dd6e:	4602      	mov	r2, r0
 800dd70:	68fb      	ldr	r3, [r7, #12]
 800dd72:	621a      	str	r2, [r3, #32]
        if (!b->memory.ptr) return 0;
 800dd74:	68fb      	ldr	r3, [r7, #12]
 800dd76:	6a1b      	ldr	r3, [r3, #32]
 800dd78:	2b00      	cmp	r3, #0
 800dd7a:	d101      	bne.n	800dd80 <nk_buffer_alloc+0x184>
 800dd7c:	2300      	movs	r3, #0
 800dd7e:	e039      	b.n	800ddf4 <nk_buffer_alloc+0x1f8>

        /* align newly allocated pointer */
        if (type == NK_BUFFER_FRONT)
 800dd80:	7afb      	ldrb	r3, [r7, #11]
 800dd82:	2b00      	cmp	r3, #0
 800dd84:	d106      	bne.n	800dd94 <nk_buffer_alloc+0x198>
            unaligned = nk_ptr_add(void, b->memory.ptr, b->allocated);
 800dd86:	68fb      	ldr	r3, [r7, #12]
 800dd88:	6a1a      	ldr	r2, [r3, #32]
 800dd8a:	68fb      	ldr	r3, [r7, #12]
 800dd8c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800dd8e:	4413      	add	r3, r2
 800dd90:	623b      	str	r3, [r7, #32]
 800dd92:	e007      	b.n	800dda4 <nk_buffer_alloc+0x1a8>
        else unaligned = nk_ptr_add(void, b->memory.ptr, b->size - size);
 800dd94:	68fb      	ldr	r3, [r7, #12]
 800dd96:	6a1a      	ldr	r2, [r3, #32]
 800dd98:	68fb      	ldr	r3, [r7, #12]
 800dd9a:	6b99      	ldr	r1, [r3, #56]	; 0x38
 800dd9c:	687b      	ldr	r3, [r7, #4]
 800dd9e:	1acb      	subs	r3, r1, r3
 800dda0:	4413      	add	r3, r2
 800dda2:	623b      	str	r3, [r7, #32]
        memory = nk_buffer_align(unaligned, align, &alignment, type);
 800dda4:	7afb      	ldrb	r3, [r7, #11]
 800dda6:	f107 0214 	add.w	r2, r7, #20
 800ddaa:	6839      	ldr	r1, [r7, #0]
 800ddac:	6a38      	ldr	r0, [r7, #32]
 800ddae:	f7ff fe57 	bl	800da60 <nk_buffer_align>
 800ddb2:	61f8      	str	r0, [r7, #28]
    }
    if (type == NK_BUFFER_FRONT)
 800ddb4:	7afb      	ldrb	r3, [r7, #11]
 800ddb6:	2b00      	cmp	r3, #0
 800ddb8:	d108      	bne.n	800ddcc <nk_buffer_alloc+0x1d0>
        b->allocated += size + alignment;
 800ddba:	68fb      	ldr	r3, [r7, #12]
 800ddbc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ddbe:	6979      	ldr	r1, [r7, #20]
 800ddc0:	687b      	ldr	r3, [r7, #4]
 800ddc2:	440b      	add	r3, r1
 800ddc4:	441a      	add	r2, r3
 800ddc6:	68fb      	ldr	r3, [r7, #12]
 800ddc8:	62da      	str	r2, [r3, #44]	; 0x2c
 800ddca:	e007      	b.n	800dddc <nk_buffer_alloc+0x1e0>
    else b->size -= (size + alignment);
 800ddcc:	68fb      	ldr	r3, [r7, #12]
 800ddce:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800ddd0:	6979      	ldr	r1, [r7, #20]
 800ddd2:	687b      	ldr	r3, [r7, #4]
 800ddd4:	440b      	add	r3, r1
 800ddd6:	1ad2      	subs	r2, r2, r3
 800ddd8:	68fb      	ldr	r3, [r7, #12]
 800ddda:	639a      	str	r2, [r3, #56]	; 0x38
    b->needed += alignment;
 800dddc:	68fb      	ldr	r3, [r7, #12]
 800ddde:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800dde0:	697b      	ldr	r3, [r7, #20]
 800dde2:	441a      	add	r2, r3
 800dde4:	68fb      	ldr	r3, [r7, #12]
 800dde6:	631a      	str	r2, [r3, #48]	; 0x30
    b->calls++;
 800dde8:	68fb      	ldr	r3, [r7, #12]
 800ddea:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ddec:	1c5a      	adds	r2, r3, #1
 800ddee:	68fb      	ldr	r3, [r7, #12]
 800ddf0:	635a      	str	r2, [r3, #52]	; 0x34
    return memory;
 800ddf2:	69fb      	ldr	r3, [r7, #28]
}
 800ddf4:	4618      	mov	r0, r3
 800ddf6:	3728      	adds	r7, #40	; 0x28
 800ddf8:	46bd      	mov	sp, r7
 800ddfa:	bd80      	pop	{r7, pc}
 800ddfc:	08021444 	.word	0x08021444
 800de00:	0802319c 	.word	0x0802319c
 800de04:	08021448 	.word	0x08021448
 800de08:	0802147c 	.word	0x0802147c
 800de0c:	0802148c 	.word	0x0802148c

0800de10 <nk_buffer_reset>:
        buffer->marker[type].offset = buffer->size;
    else buffer->marker[type].offset = buffer->allocated;
}
NK_API void
nk_buffer_reset(struct nk_buffer *buffer, enum nk_buffer_allocation_type type)
{
 800de10:	b580      	push	{r7, lr}
 800de12:	b082      	sub	sp, #8
 800de14:	af00      	add	r7, sp, #0
 800de16:	6078      	str	r0, [r7, #4]
 800de18:	460b      	mov	r3, r1
 800de1a:	70fb      	strb	r3, [r7, #3]
    NK_ASSERT(buffer);
 800de1c:	687b      	ldr	r3, [r7, #4]
 800de1e:	2b00      	cmp	r3, #0
 800de20:	d105      	bne.n	800de2e <nk_buffer_reset+0x1e>
 800de22:	4b2c      	ldr	r3, [pc, #176]	; (800ded4 <nk_buffer_reset+0xc4>)
 800de24:	4a2c      	ldr	r2, [pc, #176]	; (800ded8 <nk_buffer_reset+0xc8>)
 800de26:	21ce      	movs	r1, #206	; 0xce
 800de28:	482c      	ldr	r0, [pc, #176]	; (800dedc <nk_buffer_reset+0xcc>)
 800de2a:	f00f fdf5 	bl	801da18 <__assert_func>
    if (!buffer) return;
 800de2e:	687b      	ldr	r3, [r7, #4]
 800de30:	2b00      	cmp	r3, #0
 800de32:	d04b      	beq.n	800decc <nk_buffer_reset+0xbc>
    if (type == NK_BUFFER_BACK) {
 800de34:	78fb      	ldrb	r3, [r7, #3]
 800de36:	2b01      	cmp	r3, #1
 800de38:	d124      	bne.n	800de84 <nk_buffer_reset+0x74>
        /* reset back buffer either back to marker or empty */
        buffer->needed -= (buffer->memory.size - buffer->marker[type].offset);
 800de3a:	687b      	ldr	r3, [r7, #4]
 800de3c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800de3e:	78fb      	ldrb	r3, [r7, #3]
 800de40:	6879      	ldr	r1, [r7, #4]
 800de42:	00db      	lsls	r3, r3, #3
 800de44:	440b      	add	r3, r1
 800de46:	6859      	ldr	r1, [r3, #4]
 800de48:	687b      	ldr	r3, [r7, #4]
 800de4a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800de4c:	1acb      	subs	r3, r1, r3
 800de4e:	441a      	add	r2, r3
 800de50:	687b      	ldr	r3, [r7, #4]
 800de52:	631a      	str	r2, [r3, #48]	; 0x30
        if (buffer->marker[type].active)
 800de54:	78fa      	ldrb	r2, [r7, #3]
 800de56:	687b      	ldr	r3, [r7, #4]
 800de58:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 800de5c:	2b00      	cmp	r3, #0
 800de5e:	d007      	beq.n	800de70 <nk_buffer_reset+0x60>
            buffer->size = buffer->marker[type].offset;
 800de60:	78fb      	ldrb	r3, [r7, #3]
 800de62:	687a      	ldr	r2, [r7, #4]
 800de64:	00db      	lsls	r3, r3, #3
 800de66:	4413      	add	r3, r2
 800de68:	685a      	ldr	r2, [r3, #4]
 800de6a:	687b      	ldr	r3, [r7, #4]
 800de6c:	639a      	str	r2, [r3, #56]	; 0x38
 800de6e:	e003      	b.n	800de78 <nk_buffer_reset+0x68>
        else buffer->size = buffer->memory.size;
 800de70:	687b      	ldr	r3, [r7, #4]
 800de72:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800de74:	687b      	ldr	r3, [r7, #4]
 800de76:	639a      	str	r2, [r3, #56]	; 0x38
        buffer->marker[type].active = nk_false;
 800de78:	78fa      	ldrb	r2, [r7, #3]
 800de7a:	687b      	ldr	r3, [r7, #4]
 800de7c:	2100      	movs	r1, #0
 800de7e:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
 800de82:	e024      	b.n	800dece <nk_buffer_reset+0xbe>
    } else {
        /* reset front buffer either back to back marker or empty */
        buffer->needed -= (buffer->allocated - buffer->marker[type].offset);
 800de84:	687b      	ldr	r3, [r7, #4]
 800de86:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800de88:	78fb      	ldrb	r3, [r7, #3]
 800de8a:	6879      	ldr	r1, [r7, #4]
 800de8c:	00db      	lsls	r3, r3, #3
 800de8e:	440b      	add	r3, r1
 800de90:	6859      	ldr	r1, [r3, #4]
 800de92:	687b      	ldr	r3, [r7, #4]
 800de94:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800de96:	1acb      	subs	r3, r1, r3
 800de98:	441a      	add	r2, r3
 800de9a:	687b      	ldr	r3, [r7, #4]
 800de9c:	631a      	str	r2, [r3, #48]	; 0x30
        if (buffer->marker[type].active)
 800de9e:	78fa      	ldrb	r2, [r7, #3]
 800dea0:	687b      	ldr	r3, [r7, #4]
 800dea2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 800dea6:	2b00      	cmp	r3, #0
 800dea8:	d007      	beq.n	800deba <nk_buffer_reset+0xaa>
            buffer->allocated = buffer->marker[type].offset;
 800deaa:	78fb      	ldrb	r3, [r7, #3]
 800deac:	687a      	ldr	r2, [r7, #4]
 800deae:	00db      	lsls	r3, r3, #3
 800deb0:	4413      	add	r3, r2
 800deb2:	685a      	ldr	r2, [r3, #4]
 800deb4:	687b      	ldr	r3, [r7, #4]
 800deb6:	62da      	str	r2, [r3, #44]	; 0x2c
 800deb8:	e002      	b.n	800dec0 <nk_buffer_reset+0xb0>
        else buffer->allocated = 0;
 800deba:	687b      	ldr	r3, [r7, #4]
 800debc:	2200      	movs	r2, #0
 800debe:	62da      	str	r2, [r3, #44]	; 0x2c
        buffer->marker[type].active = nk_false;
 800dec0:	78fa      	ldrb	r2, [r7, #3]
 800dec2:	687b      	ldr	r3, [r7, #4]
 800dec4:	2100      	movs	r1, #0
 800dec6:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
 800deca:	e000      	b.n	800dece <nk_buffer_reset+0xbe>
    if (!buffer) return;
 800decc:	bf00      	nop
    }
}
 800dece:	3708      	adds	r7, #8
 800ded0:	46bd      	mov	sp, r7
 800ded2:	bd80      	pop	{r7, pc}
 800ded4:	080214ac 	.word	0x080214ac
 800ded8:	080231ac 	.word	0x080231ac
 800dedc:	08021448 	.word	0x08021448

0800dee0 <nk_buffer_clear>:
NK_API void
nk_buffer_clear(struct nk_buffer *b)
{
 800dee0:	b580      	push	{r7, lr}
 800dee2:	b082      	sub	sp, #8
 800dee4:	af00      	add	r7, sp, #0
 800dee6:	6078      	str	r0, [r7, #4]
    NK_ASSERT(b);
 800dee8:	687b      	ldr	r3, [r7, #4]
 800deea:	2b00      	cmp	r3, #0
 800deec:	d105      	bne.n	800defa <nk_buffer_clear+0x1a>
 800deee:	4b0d      	ldr	r3, [pc, #52]	; (800df24 <nk_buffer_clear+0x44>)
 800def0:	4a0d      	ldr	r2, [pc, #52]	; (800df28 <nk_buffer_clear+0x48>)
 800def2:	21e3      	movs	r1, #227	; 0xe3
 800def4:	480d      	ldr	r0, [pc, #52]	; (800df2c <nk_buffer_clear+0x4c>)
 800def6:	f00f fd8f 	bl	801da18 <__assert_func>
    if (!b) return;
 800defa:	687b      	ldr	r3, [r7, #4]
 800defc:	2b00      	cmp	r3, #0
 800defe:	d00d      	beq.n	800df1c <nk_buffer_clear+0x3c>
    b->allocated = 0;
 800df00:	687b      	ldr	r3, [r7, #4]
 800df02:	2200      	movs	r2, #0
 800df04:	62da      	str	r2, [r3, #44]	; 0x2c
    b->size = b->memory.size;
 800df06:	687b      	ldr	r3, [r7, #4]
 800df08:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800df0a:	687b      	ldr	r3, [r7, #4]
 800df0c:	639a      	str	r2, [r3, #56]	; 0x38
    b->calls = 0;
 800df0e:	687b      	ldr	r3, [r7, #4]
 800df10:	2200      	movs	r2, #0
 800df12:	635a      	str	r2, [r3, #52]	; 0x34
    b->needed = 0;
 800df14:	687b      	ldr	r3, [r7, #4]
 800df16:	2200      	movs	r2, #0
 800df18:	631a      	str	r2, [r3, #48]	; 0x30
 800df1a:	e000      	b.n	800df1e <nk_buffer_clear+0x3e>
    if (!b) return;
 800df1c:	bf00      	nop
}
 800df1e:	3708      	adds	r7, #8
 800df20:	46bd      	mov	sp, r7
 800df22:	bd80      	pop	{r7, pc}
 800df24:	08021444 	.word	0x08021444
 800df28:	080231bc 	.word	0x080231bc
 800df2c:	08021448 	.word	0x08021448

0800df30 <nk_draw_symbol>:
 * ===============================================================*/
NK_LIB void
nk_draw_symbol(struct nk_command_buffer *out, enum nk_symbol_type type,
    struct nk_rect content, struct nk_color background, struct nk_color foreground,
    float border_width, const struct nk_user_font *font)
{
 800df30:	b580      	push	{r7, lr}
 800df32:	b0a0      	sub	sp, #128	; 0x80
 800df34:	af02      	add	r7, sp, #8
 800df36:	6278      	str	r0, [r7, #36]	; 0x24
 800df38:	eeb0 6a40 	vmov.f32	s12, s0
 800df3c:	eef0 6a60 	vmov.f32	s13, s1
 800df40:	eeb0 7a41 	vmov.f32	s14, s2
 800df44:	eef0 7a61 	vmov.f32	s15, s3
 800df48:	60fa      	str	r2, [r7, #12]
 800df4a:	60bb      	str	r3, [r7, #8]
 800df4c:	ed87 2a01 	vstr	s4, [r7, #4]
 800df50:	460b      	mov	r3, r1
 800df52:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 800df56:	ed87 6a04 	vstr	s12, [r7, #16]
 800df5a:	edc7 6a05 	vstr	s13, [r7, #20]
 800df5e:	ed87 7a06 	vstr	s14, [r7, #24]
 800df62:	edc7 7a07 	vstr	s15, [r7, #28]
    switch (type) {
 800df66:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800df6a:	3b01      	subs	r3, #1
 800df6c:	2b0b      	cmp	r3, #11
 800df6e:	f200 815e 	bhi.w	800e22e <nk_draw_symbol+0x2fe>
 800df72:	a201      	add	r2, pc, #4	; (adr r2, 800df78 <nk_draw_symbol+0x48>)
 800df74:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800df78:	0800dfa9 	.word	0x0800dfa9
 800df7c:	0800dfa9 	.word	0x0800dfa9
 800df80:	0800e031 	.word	0x0800e031
 800df84:	0800e031 	.word	0x0800e031
 800df88:	0800e031 	.word	0x0800e031
 800df8c:	0800e031 	.word	0x0800e031
 800df90:	0800e193 	.word	0x0800e193
 800df94:	0800e193 	.word	0x0800e193
 800df98:	0800e193 	.word	0x0800e193
 800df9c:	0800e193 	.word	0x0800e193
 800dfa0:	0800dfa9 	.word	0x0800dfa9
 800dfa4:	0800dfa9 	.word	0x0800dfa9
    case NK_SYMBOL_X:
    case NK_SYMBOL_UNDERSCORE:
    case NK_SYMBOL_PLUS:
    case NK_SYMBOL_MINUS: {
        /* single character text symbol */
        const char *X = (type == NK_SYMBOL_X) ? "x":
 800dfa8:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800dfac:	2b01      	cmp	r3, #1
 800dfae:	d00d      	beq.n	800dfcc <nk_draw_symbol+0x9c>
 800dfb0:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800dfb4:	2b02      	cmp	r3, #2
 800dfb6:	d007      	beq.n	800dfc8 <nk_draw_symbol+0x98>
 800dfb8:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800dfbc:	2b0b      	cmp	r3, #11
 800dfbe:	d101      	bne.n	800dfc4 <nk_draw_symbol+0x94>
 800dfc0:	4b9e      	ldr	r3, [pc, #632]	; (800e23c <nk_draw_symbol+0x30c>)
 800dfc2:	e004      	b.n	800dfce <nk_draw_symbol+0x9e>
 800dfc4:	4b9e      	ldr	r3, [pc, #632]	; (800e240 <nk_draw_symbol+0x310>)
 800dfc6:	e002      	b.n	800dfce <nk_draw_symbol+0x9e>
 800dfc8:	4b9e      	ldr	r3, [pc, #632]	; (800e244 <nk_draw_symbol+0x314>)
 800dfca:	e000      	b.n	800dfce <nk_draw_symbol+0x9e>
 800dfcc:	4b9e      	ldr	r3, [pc, #632]	; (800e248 <nk_draw_symbol+0x318>)
 800dfce:	673b      	str	r3, [r7, #112]	; 0x70
            (type == NK_SYMBOL_UNDERSCORE) ? "_":
            (type == NK_SYMBOL_PLUS) ? "+": "-";
        struct nk_text text;
        text.padding = nk_vec2(0,0);
 800dfd0:	eddf 0a9e 	vldr	s1, [pc, #632]	; 800e24c <nk_draw_symbol+0x31c>
 800dfd4:	ed9f 0a9d 	vldr	s0, [pc, #628]	; 800e24c <nk_draw_symbol+0x31c>
 800dfd8:	f005 fc6e 	bl	80138b8 <nk_vec2>
 800dfdc:	eeb0 7a40 	vmov.f32	s14, s0
 800dfe0:	eef0 7a60 	vmov.f32	s15, s1
 800dfe4:	ed87 7a10 	vstr	s14, [r7, #64]	; 0x40
 800dfe8:	edc7 7a11 	vstr	s15, [r7, #68]	; 0x44
        text.background = background;
 800dfec:	68fb      	ldr	r3, [r7, #12]
 800dfee:	64bb      	str	r3, [r7, #72]	; 0x48
        text.text = foreground;
 800dff0:	68bb      	ldr	r3, [r7, #8]
 800dff2:	64fb      	str	r3, [r7, #76]	; 0x4c
        nk_widget_text(out, content, X, 1, &text, NK_TEXT_CENTERED, font);
 800dff4:	f107 0240 	add.w	r2, r7, #64	; 0x40
 800dff8:	ed97 6a04 	vldr	s12, [r7, #16]
 800dffc:	edd7 6a05 	vldr	s13, [r7, #20]
 800e000:	ed97 7a06 	vldr	s14, [r7, #24]
 800e004:	edd7 7a07 	vldr	s15, [r7, #28]
 800e008:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800e00c:	9301      	str	r3, [sp, #4]
 800e00e:	2312      	movs	r3, #18
 800e010:	9300      	str	r3, [sp, #0]
 800e012:	4613      	mov	r3, r2
 800e014:	2201      	movs	r2, #1
 800e016:	6f39      	ldr	r1, [r7, #112]	; 0x70
 800e018:	eeb0 0a46 	vmov.f32	s0, s12
 800e01c:	eef0 0a66 	vmov.f32	s1, s13
 800e020:	eeb0 1a47 	vmov.f32	s2, s14
 800e024:	eef0 1a67 	vmov.f32	s3, s15
 800e028:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800e02a:	f00c fe43 	bl	801acb4 <nk_widget_text>
    } break;
 800e02e:	e101      	b.n	800e234 <nk_draw_symbol+0x304>
    case NK_SYMBOL_CIRCLE_SOLID:
    case NK_SYMBOL_CIRCLE_OUTLINE:
    case NK_SYMBOL_RECT_SOLID:
    case NK_SYMBOL_RECT_OUTLINE: {
        /* simple empty/filled shapes */
        if (type == NK_SYMBOL_RECT_SOLID || type == NK_SYMBOL_RECT_OUTLINE) {
 800e030:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800e034:	2b05      	cmp	r3, #5
 800e036:	d003      	beq.n	800e040 <nk_draw_symbol+0x110>
 800e038:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800e03c:	2b06      	cmp	r3, #6
 800e03e:	d155      	bne.n	800e0ec <nk_draw_symbol+0x1bc>
            nk_fill_rect(out, content,  0, foreground);
 800e040:	ed97 6a04 	vldr	s12, [r7, #16]
 800e044:	edd7 6a05 	vldr	s13, [r7, #20]
 800e048:	ed97 7a06 	vldr	s14, [r7, #24]
 800e04c:	edd7 7a07 	vldr	s15, [r7, #28]
 800e050:	68b9      	ldr	r1, [r7, #8]
 800e052:	ed9f 2a7e 	vldr	s4, [pc, #504]	; 800e24c <nk_draw_symbol+0x31c>
 800e056:	eeb0 0a46 	vmov.f32	s0, s12
 800e05a:	eef0 0a66 	vmov.f32	s1, s13
 800e05e:	eeb0 1a47 	vmov.f32	s2, s14
 800e062:	eef0 1a67 	vmov.f32	s3, s15
 800e066:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800e068:	f002 fe18 	bl	8010c9c <nk_fill_rect>
            if (type == NK_SYMBOL_RECT_OUTLINE)
 800e06c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800e070:	2b06      	cmp	r3, #6
 800e072:	f040 808d 	bne.w	800e190 <nk_draw_symbol+0x260>
                nk_fill_rect(out, nk_shrink_rect(content, border_width), 0, background);
 800e076:	ed97 6a04 	vldr	s12, [r7, #16]
 800e07a:	edd7 6a05 	vldr	s13, [r7, #20]
 800e07e:	ed97 7a06 	vldr	s14, [r7, #24]
 800e082:	edd7 7a07 	vldr	s15, [r7, #28]
 800e086:	ed97 2a01 	vldr	s4, [r7, #4]
 800e08a:	eeb0 0a46 	vmov.f32	s0, s12
 800e08e:	eef0 0a66 	vmov.f32	s1, s13
 800e092:	eeb0 1a47 	vmov.f32	s2, s14
 800e096:	eef0 1a67 	vmov.f32	s3, s15
 800e09a:	f005 fb8d 	bl	80137b8 <nk_shrink_rect>
 800e09e:	eeb0 6a40 	vmov.f32	s12, s0
 800e0a2:	eef0 6a60 	vmov.f32	s13, s1
 800e0a6:	eeb0 7a41 	vmov.f32	s14, s2
 800e0aa:	eef0 7a61 	vmov.f32	s15, s3
 800e0ae:	ed87 6a14 	vstr	s12, [r7, #80]	; 0x50
 800e0b2:	edc7 6a15 	vstr	s13, [r7, #84]	; 0x54
 800e0b6:	ed87 7a16 	vstr	s14, [r7, #88]	; 0x58
 800e0ba:	edc7 7a17 	vstr	s15, [r7, #92]	; 0x5c
 800e0be:	ed97 6a14 	vldr	s12, [r7, #80]	; 0x50
 800e0c2:	edd7 6a15 	vldr	s13, [r7, #84]	; 0x54
 800e0c6:	ed97 7a16 	vldr	s14, [r7, #88]	; 0x58
 800e0ca:	edd7 7a17 	vldr	s15, [r7, #92]	; 0x5c
 800e0ce:	68f9      	ldr	r1, [r7, #12]
 800e0d0:	ed9f 2a5e 	vldr	s4, [pc, #376]	; 800e24c <nk_draw_symbol+0x31c>
 800e0d4:	eeb0 0a46 	vmov.f32	s0, s12
 800e0d8:	eef0 0a66 	vmov.f32	s1, s13
 800e0dc:	eeb0 1a47 	vmov.f32	s2, s14
 800e0e0:	eef0 1a67 	vmov.f32	s3, s15
 800e0e4:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800e0e6:	f002 fdd9 	bl	8010c9c <nk_fill_rect>
            if (type == NK_SYMBOL_RECT_OUTLINE)
 800e0ea:	e051      	b.n	800e190 <nk_draw_symbol+0x260>
        } else {
            nk_fill_circle(out, content, foreground);
 800e0ec:	ed97 6a04 	vldr	s12, [r7, #16]
 800e0f0:	edd7 6a05 	vldr	s13, [r7, #20]
 800e0f4:	ed97 7a06 	vldr	s14, [r7, #24]
 800e0f8:	edd7 7a07 	vldr	s15, [r7, #28]
 800e0fc:	68b9      	ldr	r1, [r7, #8]
 800e0fe:	eeb0 0a46 	vmov.f32	s0, s12
 800e102:	eef0 0a66 	vmov.f32	s1, s13
 800e106:	eeb0 1a47 	vmov.f32	s2, s14
 800e10a:	eef0 1a67 	vmov.f32	s3, s15
 800e10e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800e110:	f002 feba 	bl	8010e88 <nk_fill_circle>
            if (type == NK_SYMBOL_CIRCLE_OUTLINE)
 800e114:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800e118:	2b04      	cmp	r3, #4
 800e11a:	f040 808a 	bne.w	800e232 <nk_draw_symbol+0x302>
                nk_fill_circle(out, nk_shrink_rect(content, 1), background);
 800e11e:	ed97 6a04 	vldr	s12, [r7, #16]
 800e122:	edd7 6a05 	vldr	s13, [r7, #20]
 800e126:	ed97 7a06 	vldr	s14, [r7, #24]
 800e12a:	edd7 7a07 	vldr	s15, [r7, #28]
 800e12e:	eeb7 2a00 	vmov.f32	s4, #112	; 0x3f800000  1.0
 800e132:	eeb0 0a46 	vmov.f32	s0, s12
 800e136:	eef0 0a66 	vmov.f32	s1, s13
 800e13a:	eeb0 1a47 	vmov.f32	s2, s14
 800e13e:	eef0 1a67 	vmov.f32	s3, s15
 800e142:	f005 fb39 	bl	80137b8 <nk_shrink_rect>
 800e146:	eeb0 6a40 	vmov.f32	s12, s0
 800e14a:	eef0 6a60 	vmov.f32	s13, s1
 800e14e:	eeb0 7a41 	vmov.f32	s14, s2
 800e152:	eef0 7a61 	vmov.f32	s15, s3
 800e156:	ed87 6a18 	vstr	s12, [r7, #96]	; 0x60
 800e15a:	edc7 6a19 	vstr	s13, [r7, #100]	; 0x64
 800e15e:	ed87 7a1a 	vstr	s14, [r7, #104]	; 0x68
 800e162:	edc7 7a1b 	vstr	s15, [r7, #108]	; 0x6c
 800e166:	ed97 6a18 	vldr	s12, [r7, #96]	; 0x60
 800e16a:	edd7 6a19 	vldr	s13, [r7, #100]	; 0x64
 800e16e:	ed97 7a1a 	vldr	s14, [r7, #104]	; 0x68
 800e172:	edd7 7a1b 	vldr	s15, [r7, #108]	; 0x6c
 800e176:	68f9      	ldr	r1, [r7, #12]
 800e178:	eeb0 0a46 	vmov.f32	s0, s12
 800e17c:	eef0 0a66 	vmov.f32	s1, s13
 800e180:	eeb0 1a47 	vmov.f32	s2, s14
 800e184:	eef0 1a67 	vmov.f32	s3, s15
 800e188:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800e18a:	f002 fe7d 	bl	8010e88 <nk_fill_circle>
        }
    } break;
 800e18e:	e050      	b.n	800e232 <nk_draw_symbol+0x302>
 800e190:	e04f      	b.n	800e232 <nk_draw_symbol+0x302>
    case NK_SYMBOL_TRIANGLE_DOWN:
    case NK_SYMBOL_TRIANGLE_LEFT:
    case NK_SYMBOL_TRIANGLE_RIGHT: {
        enum nk_heading heading;
        struct nk_vec2 points[3];
        heading = (type == NK_SYMBOL_TRIANGLE_RIGHT) ? NK_RIGHT :
 800e192:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800e196:	2b0a      	cmp	r3, #10
 800e198:	d00d      	beq.n	800e1b6 <nk_draw_symbol+0x286>
 800e19a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800e19e:	2b09      	cmp	r3, #9
 800e1a0:	d007      	beq.n	800e1b2 <nk_draw_symbol+0x282>
 800e1a2:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800e1a6:	2b07      	cmp	r3, #7
 800e1a8:	d101      	bne.n	800e1ae <nk_draw_symbol+0x27e>
 800e1aa:	2300      	movs	r3, #0
 800e1ac:	e004      	b.n	800e1b8 <nk_draw_symbol+0x288>
 800e1ae:	2302      	movs	r3, #2
 800e1b0:	e002      	b.n	800e1b8 <nk_draw_symbol+0x288>
 800e1b2:	2303      	movs	r3, #3
 800e1b4:	e000      	b.n	800e1b8 <nk_draw_symbol+0x288>
 800e1b6:	2301      	movs	r3, #1
 800e1b8:	f887 3077 	strb.w	r3, [r7, #119]	; 0x77
            (type == NK_SYMBOL_TRIANGLE_LEFT) ? NK_LEFT:
            (type == NK_SYMBOL_TRIANGLE_UP) ? NK_UP: NK_DOWN;
        nk_triangle_from_direction(points, content, 0, 0, heading);
 800e1bc:	f897 2077 	ldrb.w	r2, [r7, #119]	; 0x77
 800e1c0:	ed97 6a04 	vldr	s12, [r7, #16]
 800e1c4:	edd7 6a05 	vldr	s13, [r7, #20]
 800e1c8:	ed97 7a06 	vldr	s14, [r7, #24]
 800e1cc:	edd7 7a07 	vldr	s15, [r7, #28]
 800e1d0:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800e1d4:	4611      	mov	r1, r2
 800e1d6:	eddf 2a1d 	vldr	s5, [pc, #116]	; 800e24c <nk_draw_symbol+0x31c>
 800e1da:	ed9f 2a1c 	vldr	s4, [pc, #112]	; 800e24c <nk_draw_symbol+0x31c>
 800e1de:	eeb0 0a46 	vmov.f32	s0, s12
 800e1e2:	eef0 0a66 	vmov.f32	s1, s13
 800e1e6:	eeb0 1a47 	vmov.f32	s2, s14
 800e1ea:	eef0 1a67 	vmov.f32	s3, s15
 800e1ee:	4618      	mov	r0, r3
 800e1f0:	f005 fc34 	bl	8013a5c <nk_triangle_from_direction>
        nk_fill_triangle(out, points[0].x, points[0].y, points[1].x, points[1].y,
 800e1f4:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
 800e1f8:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
 800e1fc:	edd7 6a0c 	vldr	s13, [r7, #48]	; 0x30
 800e200:	ed97 6a0d 	vldr	s12, [r7, #52]	; 0x34
 800e204:	edd7 5a0e 	vldr	s11, [r7, #56]	; 0x38
 800e208:	ed97 5a0f 	vldr	s10, [r7, #60]	; 0x3c
 800e20c:	68b9      	ldr	r1, [r7, #8]
 800e20e:	eef0 2a45 	vmov.f32	s5, s10
 800e212:	eeb0 2a65 	vmov.f32	s4, s11
 800e216:	eef0 1a46 	vmov.f32	s3, s12
 800e21a:	eeb0 1a66 	vmov.f32	s2, s13
 800e21e:	eef0 0a47 	vmov.f32	s1, s14
 800e222:	eeb0 0a67 	vmov.f32	s0, s15
 800e226:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800e228:	f002 ff18 	bl	801105c <nk_fill_triangle>
            points[2].x, points[2].y, foreground);
    } break;
 800e22c:	e002      	b.n	800e234 <nk_draw_symbol+0x304>
    default:
    case NK_SYMBOL_NONE:
    case NK_SYMBOL_MAX: break;
 800e22e:	bf00      	nop
 800e230:	e000      	b.n	800e234 <nk_draw_symbol+0x304>
    } break;
 800e232:	bf00      	nop
    }
}
 800e234:	bf00      	nop
 800e236:	3778      	adds	r7, #120	; 0x78
 800e238:	46bd      	mov	sp, r7
 800e23a:	bd80      	pop	{r7, pc}
 800e23c:	080214c8 	.word	0x080214c8
 800e240:	080214cc 	.word	0x080214cc
 800e244:	080214d0 	.word	0x080214d0
 800e248:	080214d4 	.word	0x080214d4
 800e24c:	00000000 	.word	0x00000000

0800e250 <nk_button_behavior>:
NK_LIB nk_bool
nk_button_behavior(nk_flags *state, struct nk_rect r,
    const struct nk_input *i, enum nk_button_behavior behavior)
{
 800e250:	b580      	push	{r7, lr}
 800e252:	b08a      	sub	sp, #40	; 0x28
 800e254:	af00      	add	r7, sp, #0
 800e256:	61f8      	str	r0, [r7, #28]
 800e258:	eeb0 6a40 	vmov.f32	s12, s0
 800e25c:	eef0 6a60 	vmov.f32	s13, s1
 800e260:	eeb0 7a41 	vmov.f32	s14, s2
 800e264:	eef0 7a61 	vmov.f32	s15, s3
 800e268:	60b9      	str	r1, [r7, #8]
 800e26a:	4613      	mov	r3, r2
 800e26c:	ed87 6a03 	vstr	s12, [r7, #12]
 800e270:	edc7 6a04 	vstr	s13, [r7, #16]
 800e274:	ed87 7a05 	vstr	s14, [r7, #20]
 800e278:	edc7 7a06 	vstr	s15, [r7, #24]
 800e27c:	71fb      	strb	r3, [r7, #7]
    int ret = 0;
 800e27e:	2300      	movs	r3, #0
 800e280:	627b      	str	r3, [r7, #36]	; 0x24
    nk_widget_state_reset(state);
 800e282:	69fb      	ldr	r3, [r7, #28]
 800e284:	681b      	ldr	r3, [r3, #0]
 800e286:	f003 0302 	and.w	r3, r3, #2
 800e28a:	2b00      	cmp	r3, #0
 800e28c:	d003      	beq.n	800e296 <nk_button_behavior+0x46>
 800e28e:	69fb      	ldr	r3, [r7, #28]
 800e290:	2206      	movs	r2, #6
 800e292:	601a      	str	r2, [r3, #0]
 800e294:	e002      	b.n	800e29c <nk_button_behavior+0x4c>
 800e296:	69fb      	ldr	r3, [r7, #28]
 800e298:	2204      	movs	r2, #4
 800e29a:	601a      	str	r2, [r3, #0]
    if (!i) return 0;
 800e29c:	68bb      	ldr	r3, [r7, #8]
 800e29e:	2b00      	cmp	r3, #0
 800e2a0:	d101      	bne.n	800e2a6 <nk_button_behavior+0x56>
 800e2a2:	2300      	movs	r3, #0
 800e2a4:	e088      	b.n	800e3b8 <nk_button_behavior+0x168>
    if (nk_input_is_mouse_hovering_rect(i, r)) {
 800e2a6:	ed97 6a03 	vldr	s12, [r7, #12]
 800e2aa:	edd7 6a04 	vldr	s13, [r7, #16]
 800e2ae:	ed97 7a05 	vldr	s14, [r7, #20]
 800e2b2:	edd7 7a06 	vldr	s15, [r7, #24]
 800e2b6:	eeb0 0a46 	vmov.f32	s0, s12
 800e2ba:	eef0 0a66 	vmov.f32	s1, s13
 800e2be:	eeb0 1a47 	vmov.f32	s2, s14
 800e2c2:	eef0 1a67 	vmov.f32	s3, s15
 800e2c6:	68b8      	ldr	r0, [r7, #8]
 800e2c8:	f004 f929 	bl	801251e <nk_input_is_mouse_hovering_rect>
 800e2cc:	4603      	mov	r3, r0
 800e2ce:	2b00      	cmp	r3, #0
 800e2d0:	d032      	beq.n	800e338 <nk_button_behavior+0xe8>
        *state = NK_WIDGET_STATE_HOVERED;
 800e2d2:	69fb      	ldr	r3, [r7, #28]
 800e2d4:	2212      	movs	r2, #18
 800e2d6:	601a      	str	r2, [r3, #0]
        if (nk_input_is_mouse_down(i, NK_BUTTON_LEFT))
 800e2d8:	2100      	movs	r1, #0
 800e2da:	68b8      	ldr	r0, [r7, #8]
 800e2dc:	f004 f9c3 	bl	8012666 <nk_input_is_mouse_down>
 800e2e0:	4603      	mov	r3, r0
 800e2e2:	2b00      	cmp	r3, #0
 800e2e4:	d002      	beq.n	800e2ec <nk_button_behavior+0x9c>
            *state = NK_WIDGET_STATE_ACTIVE;
 800e2e6:	69fb      	ldr	r3, [r7, #28]
 800e2e8:	2222      	movs	r2, #34	; 0x22
 800e2ea:	601a      	str	r2, [r3, #0]
        if (nk_input_has_mouse_click_in_button_rect(i, NK_BUTTON_LEFT, r)) {
 800e2ec:	ed97 6a03 	vldr	s12, [r7, #12]
 800e2f0:	edd7 6a04 	vldr	s13, [r7, #16]
 800e2f4:	ed97 7a05 	vldr	s14, [r7, #20]
 800e2f8:	edd7 7a06 	vldr	s15, [r7, #24]
 800e2fc:	eeb0 0a46 	vmov.f32	s0, s12
 800e300:	eef0 0a66 	vmov.f32	s1, s13
 800e304:	eeb0 1a47 	vmov.f32	s2, s14
 800e308:	eef0 1a67 	vmov.f32	s3, s15
 800e30c:	2100      	movs	r1, #0
 800e30e:	68b8      	ldr	r0, [r7, #8]
 800e310:	f004 f843 	bl	801239a <nk_input_has_mouse_click_in_button_rect>
 800e314:	4603      	mov	r3, r0
 800e316:	2b00      	cmp	r3, #0
 800e318:	d00e      	beq.n	800e338 <nk_button_behavior+0xe8>
            ret = (behavior != NK_BUTTON_DEFAULT) ?
                nk_input_is_mouse_down(i, NK_BUTTON_LEFT):
 800e31a:	79fb      	ldrb	r3, [r7, #7]
 800e31c:	2b00      	cmp	r3, #0
 800e31e:	d005      	beq.n	800e32c <nk_button_behavior+0xdc>
 800e320:	2100      	movs	r1, #0
 800e322:	68b8      	ldr	r0, [r7, #8]
 800e324:	f004 f99f 	bl	8012666 <nk_input_is_mouse_down>
 800e328:	4603      	mov	r3, r0
 800e32a:	e004      	b.n	800e336 <nk_button_behavior+0xe6>
#ifdef NK_BUTTON_TRIGGER_ON_RELEASE
                nk_input_is_mouse_released(i, NK_BUTTON_LEFT);
#else
                nk_input_is_mouse_pressed(i, NK_BUTTON_LEFT);
 800e32c:	2100      	movs	r1, #0
 800e32e:	68b8      	ldr	r0, [r7, #8]
 800e330:	f004 f9b1 	bl	8012696 <nk_input_is_mouse_pressed>
 800e334:	4603      	mov	r3, r0
            ret = (behavior != NK_BUTTON_DEFAULT) ?
 800e336:	627b      	str	r3, [r7, #36]	; 0x24
#endif
        }
    }
    if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(i, r))
 800e338:	69fb      	ldr	r3, [r7, #28]
 800e33a:	681b      	ldr	r3, [r3, #0]
 800e33c:	f003 0310 	and.w	r3, r3, #16
 800e340:	2b00      	cmp	r3, #0
 800e342:	d01c      	beq.n	800e37e <nk_button_behavior+0x12e>
 800e344:	ed97 6a03 	vldr	s12, [r7, #12]
 800e348:	edd7 6a04 	vldr	s13, [r7, #16]
 800e34c:	ed97 7a05 	vldr	s14, [r7, #20]
 800e350:	edd7 7a06 	vldr	s15, [r7, #24]
 800e354:	eeb0 0a46 	vmov.f32	s0, s12
 800e358:	eef0 0a66 	vmov.f32	s1, s13
 800e35c:	eeb0 1a47 	vmov.f32	s2, s14
 800e360:	eef0 1a67 	vmov.f32	s3, s15
 800e364:	68b8      	ldr	r0, [r7, #8]
 800e366:	f004 f92c 	bl	80125c2 <nk_input_is_mouse_prev_hovering_rect>
 800e36a:	4603      	mov	r3, r0
 800e36c:	2b00      	cmp	r3, #0
 800e36e:	d106      	bne.n	800e37e <nk_button_behavior+0x12e>
        *state |= NK_WIDGET_STATE_ENTERED;
 800e370:	69fb      	ldr	r3, [r7, #28]
 800e372:	681b      	ldr	r3, [r3, #0]
 800e374:	f043 0208 	orr.w	r2, r3, #8
 800e378:	69fb      	ldr	r3, [r7, #28]
 800e37a:	601a      	str	r2, [r3, #0]
 800e37c:	e01b      	b.n	800e3b6 <nk_button_behavior+0x166>
    else if (nk_input_is_mouse_prev_hovering_rect(i, r))
 800e37e:	ed97 6a03 	vldr	s12, [r7, #12]
 800e382:	edd7 6a04 	vldr	s13, [r7, #16]
 800e386:	ed97 7a05 	vldr	s14, [r7, #20]
 800e38a:	edd7 7a06 	vldr	s15, [r7, #24]
 800e38e:	eeb0 0a46 	vmov.f32	s0, s12
 800e392:	eef0 0a66 	vmov.f32	s1, s13
 800e396:	eeb0 1a47 	vmov.f32	s2, s14
 800e39a:	eef0 1a67 	vmov.f32	s3, s15
 800e39e:	68b8      	ldr	r0, [r7, #8]
 800e3a0:	f004 f90f 	bl	80125c2 <nk_input_is_mouse_prev_hovering_rect>
 800e3a4:	4603      	mov	r3, r0
 800e3a6:	2b00      	cmp	r3, #0
 800e3a8:	d005      	beq.n	800e3b6 <nk_button_behavior+0x166>
        *state |= NK_WIDGET_STATE_LEFT;
 800e3aa:	69fb      	ldr	r3, [r7, #28]
 800e3ac:	681b      	ldr	r3, [r3, #0]
 800e3ae:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 800e3b2:	69fb      	ldr	r3, [r7, #28]
 800e3b4:	601a      	str	r2, [r3, #0]
    return ret;
 800e3b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 800e3b8:	4618      	mov	r0, r3
 800e3ba:	3728      	adds	r7, #40	; 0x28
 800e3bc:	46bd      	mov	sp, r7
 800e3be:	bd80      	pop	{r7, pc}

0800e3c0 <nk_draw_button>:
NK_LIB const struct nk_style_item*
nk_draw_button(struct nk_command_buffer *out,
    const struct nk_rect *bounds, nk_flags state,
    const struct nk_style_button *style)
{
 800e3c0:	b580      	push	{r7, lr}
 800e3c2:	b086      	sub	sp, #24
 800e3c4:	af00      	add	r7, sp, #0
 800e3c6:	60f8      	str	r0, [r7, #12]
 800e3c8:	60b9      	str	r1, [r7, #8]
 800e3ca:	607a      	str	r2, [r7, #4]
 800e3cc:	603b      	str	r3, [r7, #0]
    const struct nk_style_item *background;
    if (state & NK_WIDGET_STATE_HOVER)
 800e3ce:	687b      	ldr	r3, [r7, #4]
 800e3d0:	f003 0310 	and.w	r3, r3, #16
 800e3d4:	2b00      	cmp	r3, #0
 800e3d6:	d003      	beq.n	800e3e0 <nk_draw_button+0x20>
        background = &style->hover;
 800e3d8:	683b      	ldr	r3, [r7, #0]
 800e3da:	331c      	adds	r3, #28
 800e3dc:	617b      	str	r3, [r7, #20]
 800e3de:	e00a      	b.n	800e3f6 <nk_draw_button+0x36>
    else if (state & NK_WIDGET_STATE_ACTIVED)
 800e3e0:	687b      	ldr	r3, [r7, #4]
 800e3e2:	f003 0320 	and.w	r3, r3, #32
 800e3e6:	2b00      	cmp	r3, #0
 800e3e8:	d003      	beq.n	800e3f2 <nk_draw_button+0x32>
        background = &style->active;
 800e3ea:	683b      	ldr	r3, [r7, #0]
 800e3ec:	3338      	adds	r3, #56	; 0x38
 800e3ee:	617b      	str	r3, [r7, #20]
 800e3f0:	e001      	b.n	800e3f6 <nk_draw_button+0x36>
    else background = &style->normal;
 800e3f2:	683b      	ldr	r3, [r7, #0]
 800e3f4:	617b      	str	r3, [r7, #20]

    switch(background->type) {
 800e3f6:	697b      	ldr	r3, [r7, #20]
 800e3f8:	781b      	ldrb	r3, [r3, #0]
 800e3fa:	2b02      	cmp	r3, #2
 800e3fc:	d01e      	beq.n	800e43c <nk_draw_button+0x7c>
 800e3fe:	2b02      	cmp	r3, #2
 800e400:	dc71      	bgt.n	800e4e6 <nk_draw_button+0x126>
 800e402:	2b00      	cmp	r3, #0
 800e404:	d033      	beq.n	800e46e <nk_draw_button+0xae>
 800e406:	2b01      	cmp	r3, #1
 800e408:	d16d      	bne.n	800e4e6 <nk_draw_button+0x126>
        case NK_STYLE_ITEM_IMAGE:
            nk_draw_image(out, *bounds, &background->data.image, nk_white);
 800e40a:	697b      	ldr	r3, [r7, #20]
 800e40c:	1d19      	adds	r1, r3, #4
 800e40e:	4a38      	ldr	r2, [pc, #224]	; (800e4f0 <nk_draw_button+0x130>)
 800e410:	68bb      	ldr	r3, [r7, #8]
 800e412:	ed93 6a00 	vldr	s12, [r3]
 800e416:	edd3 6a01 	vldr	s13, [r3, #4]
 800e41a:	ed93 7a02 	vldr	s14, [r3, #8]
 800e41e:	edd3 7a03 	vldr	s15, [r3, #12]
 800e422:	6812      	ldr	r2, [r2, #0]
 800e424:	eeb0 0a46 	vmov.f32	s0, s12
 800e428:	eef0 0a66 	vmov.f32	s1, s13
 800e42c:	eeb0 1a47 	vmov.f32	s2, s14
 800e430:	eef0 1a67 	vmov.f32	s3, s15
 800e434:	68f8      	ldr	r0, [r7, #12]
 800e436:	f002 ff8b 	bl	8011350 <nk_draw_image>
            break;
 800e43a:	e054      	b.n	800e4e6 <nk_draw_button+0x126>
        case NK_STYLE_ITEM_NINE_SLICE:
            nk_draw_nine_slice(out, *bounds, &background->data.slice, nk_white);
 800e43c:	697b      	ldr	r3, [r7, #20]
 800e43e:	1d19      	adds	r1, r3, #4
 800e440:	4a2b      	ldr	r2, [pc, #172]	; (800e4f0 <nk_draw_button+0x130>)
 800e442:	68bb      	ldr	r3, [r7, #8]
 800e444:	ed93 6a00 	vldr	s12, [r3]
 800e448:	edd3 6a01 	vldr	s13, [r3, #4]
 800e44c:	ed93 7a02 	vldr	s14, [r3, #8]
 800e450:	edd3 7a03 	vldr	s15, [r3, #12]
 800e454:	6812      	ldr	r2, [r2, #0]
 800e456:	eeb0 0a46 	vmov.f32	s0, s12
 800e45a:	eef0 0a66 	vmov.f32	s1, s13
 800e45e:	eeb0 1a47 	vmov.f32	s2, s14
 800e462:	eef0 1a67 	vmov.f32	s3, s15
 800e466:	68f8      	ldr	r0, [r7, #12]
 800e468:	f003 f864 	bl	8011534 <nk_draw_nine_slice>
            break;
 800e46c:	e03b      	b.n	800e4e6 <nk_draw_button+0x126>
        case NK_STYLE_ITEM_COLOR:
            nk_fill_rect(out, *bounds, style->rounding, background->data.color);
 800e46e:	683b      	ldr	r3, [r7, #0]
 800e470:	edd3 5a1c 	vldr	s11, [r3, #112]	; 0x70
 800e474:	697a      	ldr	r2, [r7, #20]
 800e476:	68bb      	ldr	r3, [r7, #8]
 800e478:	ed93 6a00 	vldr	s12, [r3]
 800e47c:	edd3 6a01 	vldr	s13, [r3, #4]
 800e480:	ed93 7a02 	vldr	s14, [r3, #8]
 800e484:	edd3 7a03 	vldr	s15, [r3, #12]
 800e488:	6851      	ldr	r1, [r2, #4]
 800e48a:	eeb0 2a65 	vmov.f32	s4, s11
 800e48e:	eeb0 0a46 	vmov.f32	s0, s12
 800e492:	eef0 0a66 	vmov.f32	s1, s13
 800e496:	eeb0 1a47 	vmov.f32	s2, s14
 800e49a:	eef0 1a67 	vmov.f32	s3, s15
 800e49e:	68f8      	ldr	r0, [r7, #12]
 800e4a0:	f002 fbfc 	bl	8010c9c <nk_fill_rect>
            nk_stroke_rect(out, *bounds, style->rounding, style->border, style->border_color);
 800e4a4:	683b      	ldr	r3, [r7, #0]
 800e4a6:	edd3 5a1c 	vldr	s11, [r3, #112]	; 0x70
 800e4aa:	683b      	ldr	r3, [r7, #0]
 800e4ac:	ed93 5a1b 	vldr	s10, [r3, #108]	; 0x6c
 800e4b0:	683a      	ldr	r2, [r7, #0]
 800e4b2:	68bb      	ldr	r3, [r7, #8]
 800e4b4:	ed93 6a00 	vldr	s12, [r3]
 800e4b8:	edd3 6a01 	vldr	s13, [r3, #4]
 800e4bc:	ed93 7a02 	vldr	s14, [r3, #8]
 800e4c0:	edd3 7a03 	vldr	s15, [r3, #12]
 800e4c4:	6d51      	ldr	r1, [r2, #84]	; 0x54
 800e4c6:	eef0 2a45 	vmov.f32	s5, s10
 800e4ca:	eeb0 2a65 	vmov.f32	s4, s11
 800e4ce:	eeb0 0a46 	vmov.f32	s0, s12
 800e4d2:	eef0 0a66 	vmov.f32	s1, s13
 800e4d6:	eeb0 1a47 	vmov.f32	s2, s14
 800e4da:	eef0 1a67 	vmov.f32	s3, s15
 800e4de:	68f8      	ldr	r0, [r7, #12]
 800e4e0:	f002 fad4 	bl	8010a8c <nk_stroke_rect>
            break;
 800e4e4:	bf00      	nop
    }
    return background;
 800e4e6:	697b      	ldr	r3, [r7, #20]
}
 800e4e8:	4618      	mov	r0, r3
 800e4ea:	3718      	adds	r7, #24
 800e4ec:	46bd      	mov	sp, r7
 800e4ee:	bd80      	pop	{r7, pc}
 800e4f0:	080231cc 	.word	0x080231cc

0800e4f4 <nk_do_button>:
NK_LIB nk_bool
nk_do_button(nk_flags *state, struct nk_command_buffer *out, struct nk_rect r,
    const struct nk_style_button *style, const struct nk_input *in,
    enum nk_button_behavior behavior, struct nk_rect *content)
{
 800e4f4:	b580      	push	{r7, lr}
 800e4f6:	b08c      	sub	sp, #48	; 0x30
 800e4f8:	af00      	add	r7, sp, #0
 800e4fa:	61f8      	str	r0, [r7, #28]
 800e4fc:	61b9      	str	r1, [r7, #24]
 800e4fe:	eeb0 6a40 	vmov.f32	s12, s0
 800e502:	eef0 6a60 	vmov.f32	s13, s1
 800e506:	eeb0 7a41 	vmov.f32	s14, s2
 800e50a:	eef0 7a61 	vmov.f32	s15, s3
 800e50e:	607a      	str	r2, [r7, #4]
 800e510:	603b      	str	r3, [r7, #0]
 800e512:	ed87 6a02 	vstr	s12, [r7, #8]
 800e516:	edc7 6a03 	vstr	s13, [r7, #12]
 800e51a:	ed87 7a04 	vstr	s14, [r7, #16]
 800e51e:	edc7 7a05 	vstr	s15, [r7, #20]
    struct nk_rect bounds;
    NK_ASSERT(style);
 800e522:	687b      	ldr	r3, [r7, #4]
 800e524:	2b00      	cmp	r3, #0
 800e526:	d105      	bne.n	800e534 <nk_do_button+0x40>
 800e528:	4b5d      	ldr	r3, [pc, #372]	; (800e6a0 <nk_do_button+0x1ac>)
 800e52a:	4a5e      	ldr	r2, [pc, #376]	; (800e6a4 <nk_do_button+0x1b0>)
 800e52c:	2179      	movs	r1, #121	; 0x79
 800e52e:	485e      	ldr	r0, [pc, #376]	; (800e6a8 <nk_do_button+0x1b4>)
 800e530:	f00f fa72 	bl	801da18 <__assert_func>
    NK_ASSERT(state);
 800e534:	69fb      	ldr	r3, [r7, #28]
 800e536:	2b00      	cmp	r3, #0
 800e538:	d105      	bne.n	800e546 <nk_do_button+0x52>
 800e53a:	4b5c      	ldr	r3, [pc, #368]	; (800e6ac <nk_do_button+0x1b8>)
 800e53c:	4a59      	ldr	r2, [pc, #356]	; (800e6a4 <nk_do_button+0x1b0>)
 800e53e:	217a      	movs	r1, #122	; 0x7a
 800e540:	4859      	ldr	r0, [pc, #356]	; (800e6a8 <nk_do_button+0x1b4>)
 800e542:	f00f fa69 	bl	801da18 <__assert_func>
    NK_ASSERT(out);
 800e546:	69bb      	ldr	r3, [r7, #24]
 800e548:	2b00      	cmp	r3, #0
 800e54a:	d105      	bne.n	800e558 <nk_do_button+0x64>
 800e54c:	4b58      	ldr	r3, [pc, #352]	; (800e6b0 <nk_do_button+0x1bc>)
 800e54e:	4a55      	ldr	r2, [pc, #340]	; (800e6a4 <nk_do_button+0x1b0>)
 800e550:	217b      	movs	r1, #123	; 0x7b
 800e552:	4855      	ldr	r0, [pc, #340]	; (800e6a8 <nk_do_button+0x1b4>)
 800e554:	f00f fa60 	bl	801da18 <__assert_func>
    if (!out || !style)
 800e558:	69bb      	ldr	r3, [r7, #24]
 800e55a:	2b00      	cmp	r3, #0
 800e55c:	d002      	beq.n	800e564 <nk_do_button+0x70>
 800e55e:	687b      	ldr	r3, [r7, #4]
 800e560:	2b00      	cmp	r3, #0
 800e562:	d101      	bne.n	800e568 <nk_do_button+0x74>
        return nk_false;
 800e564:	2300      	movs	r3, #0
 800e566:	e097      	b.n	800e698 <nk_do_button+0x1a4>

    /* calculate button content space */
    content->x = r.x + style->padding.x + style->border + style->rounding;
 800e568:	ed97 7a02 	vldr	s14, [r7, #8]
 800e56c:	687b      	ldr	r3, [r7, #4]
 800e56e:	edd3 7a1d 	vldr	s15, [r3, #116]	; 0x74
 800e572:	ee37 7a27 	vadd.f32	s14, s14, s15
 800e576:	687b      	ldr	r3, [r7, #4]
 800e578:	edd3 7a1b 	vldr	s15, [r3, #108]	; 0x6c
 800e57c:	ee37 7a27 	vadd.f32	s14, s14, s15
 800e580:	687b      	ldr	r3, [r7, #4]
 800e582:	edd3 7a1c 	vldr	s15, [r3, #112]	; 0x70
 800e586:	ee77 7a27 	vadd.f32	s15, s14, s15
 800e58a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e58c:	edc3 7a00 	vstr	s15, [r3]
    content->y = r.y + style->padding.y + style->border + style->rounding;
 800e590:	ed97 7a03 	vldr	s14, [r7, #12]
 800e594:	687b      	ldr	r3, [r7, #4]
 800e596:	edd3 7a1e 	vldr	s15, [r3, #120]	; 0x78
 800e59a:	ee37 7a27 	vadd.f32	s14, s14, s15
 800e59e:	687b      	ldr	r3, [r7, #4]
 800e5a0:	edd3 7a1b 	vldr	s15, [r3, #108]	; 0x6c
 800e5a4:	ee37 7a27 	vadd.f32	s14, s14, s15
 800e5a8:	687b      	ldr	r3, [r7, #4]
 800e5aa:	edd3 7a1c 	vldr	s15, [r3, #112]	; 0x70
 800e5ae:	ee77 7a27 	vadd.f32	s15, s14, s15
 800e5b2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e5b4:	edc3 7a01 	vstr	s15, [r3, #4]
    content->w = r.w - (2 * style->padding.x + style->border + style->rounding*2);
 800e5b8:	ed97 7a04 	vldr	s14, [r7, #16]
 800e5bc:	687b      	ldr	r3, [r7, #4]
 800e5be:	edd3 7a1d 	vldr	s15, [r3, #116]	; 0x74
 800e5c2:	ee77 6aa7 	vadd.f32	s13, s15, s15
 800e5c6:	687b      	ldr	r3, [r7, #4]
 800e5c8:	edd3 7a1b 	vldr	s15, [r3, #108]	; 0x6c
 800e5cc:	ee76 6aa7 	vadd.f32	s13, s13, s15
 800e5d0:	687b      	ldr	r3, [r7, #4]
 800e5d2:	edd3 7a1c 	vldr	s15, [r3, #112]	; 0x70
 800e5d6:	ee77 7aa7 	vadd.f32	s15, s15, s15
 800e5da:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800e5de:	ee77 7a67 	vsub.f32	s15, s14, s15
 800e5e2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e5e4:	edc3 7a02 	vstr	s15, [r3, #8]
    content->h = r.h - (2 * style->padding.y + style->border + style->rounding*2);
 800e5e8:	ed97 7a05 	vldr	s14, [r7, #20]
 800e5ec:	687b      	ldr	r3, [r7, #4]
 800e5ee:	edd3 7a1e 	vldr	s15, [r3, #120]	; 0x78
 800e5f2:	ee77 6aa7 	vadd.f32	s13, s15, s15
 800e5f6:	687b      	ldr	r3, [r7, #4]
 800e5f8:	edd3 7a1b 	vldr	s15, [r3, #108]	; 0x6c
 800e5fc:	ee76 6aa7 	vadd.f32	s13, s13, s15
 800e600:	687b      	ldr	r3, [r7, #4]
 800e602:	edd3 7a1c 	vldr	s15, [r3, #112]	; 0x70
 800e606:	ee77 7aa7 	vadd.f32	s15, s15, s15
 800e60a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800e60e:	ee77 7a67 	vsub.f32	s15, s14, s15
 800e612:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e614:	edc3 7a03 	vstr	s15, [r3, #12]

    /* execute button behavior */
    bounds.x = r.x - style->touch_padding.x;
 800e618:	ed97 7a02 	vldr	s14, [r7, #8]
 800e61c:	687b      	ldr	r3, [r7, #4]
 800e61e:	edd3 7a21 	vldr	s15, [r3, #132]	; 0x84
 800e622:	ee77 7a67 	vsub.f32	s15, s14, s15
 800e626:	edc7 7a08 	vstr	s15, [r7, #32]
    bounds.y = r.y - style->touch_padding.y;
 800e62a:	ed97 7a03 	vldr	s14, [r7, #12]
 800e62e:	687b      	ldr	r3, [r7, #4]
 800e630:	edd3 7a22 	vldr	s15, [r3, #136]	; 0x88
 800e634:	ee77 7a67 	vsub.f32	s15, s14, s15
 800e638:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
    bounds.w = r.w + 2 * style->touch_padding.x;
 800e63c:	ed97 7a04 	vldr	s14, [r7, #16]
 800e640:	687b      	ldr	r3, [r7, #4]
 800e642:	edd3 7a21 	vldr	s15, [r3, #132]	; 0x84
 800e646:	ee77 7aa7 	vadd.f32	s15, s15, s15
 800e64a:	ee77 7a27 	vadd.f32	s15, s14, s15
 800e64e:	edc7 7a0a 	vstr	s15, [r7, #40]	; 0x28
    bounds.h = r.h + 2 * style->touch_padding.y;
 800e652:	ed97 7a05 	vldr	s14, [r7, #20]
 800e656:	687b      	ldr	r3, [r7, #4]
 800e658:	edd3 7a22 	vldr	s15, [r3, #136]	; 0x88
 800e65c:	ee77 7aa7 	vadd.f32	s15, s15, s15
 800e660:	ee77 7a27 	vadd.f32	s15, s14, s15
 800e664:	edc7 7a0b 	vstr	s15, [r7, #44]	; 0x2c
    return nk_button_behavior(state, bounds, in, behavior);
 800e668:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 800e66c:	ed97 6a08 	vldr	s12, [r7, #32]
 800e670:	edd7 6a09 	vldr	s13, [r7, #36]	; 0x24
 800e674:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
 800e678:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
 800e67c:	461a      	mov	r2, r3
 800e67e:	6839      	ldr	r1, [r7, #0]
 800e680:	eeb0 0a46 	vmov.f32	s0, s12
 800e684:	eef0 0a66 	vmov.f32	s1, s13
 800e688:	eeb0 1a47 	vmov.f32	s2, s14
 800e68c:	eef0 1a67 	vmov.f32	s3, s15
 800e690:	69f8      	ldr	r0, [r7, #28]
 800e692:	f7ff fddd 	bl	800e250 <nk_button_behavior>
 800e696:	4603      	mov	r3, r0
}
 800e698:	4618      	mov	r0, r3
 800e69a:	3730      	adds	r7, #48	; 0x30
 800e69c:	46bd      	mov	sp, r7
 800e69e:	bd80      	pop	{r7, pc}
 800e6a0:	080214d8 	.word	0x080214d8
 800e6a4:	080231d0 	.word	0x080231d0
 800e6a8:	080214e0 	.word	0x080214e0
 800e6ac:	080214fc 	.word	0x080214fc
 800e6b0:	08021504 	.word	0x08021504

0800e6b4 <nk_draw_button_text>:
NK_LIB void
nk_draw_button_text(struct nk_command_buffer *out,
    const struct nk_rect *bounds, const struct nk_rect *content, nk_flags state,
    const struct nk_style_button *style, const char *txt, int len,
    nk_flags text_alignment, const struct nk_user_font *font)
{
 800e6b4:	b580      	push	{r7, lr}
 800e6b6:	b08c      	sub	sp, #48	; 0x30
 800e6b8:	af02      	add	r7, sp, #8
 800e6ba:	60f8      	str	r0, [r7, #12]
 800e6bc:	60b9      	str	r1, [r7, #8]
 800e6be:	607a      	str	r2, [r7, #4]
 800e6c0:	603b      	str	r3, [r7, #0]
    struct nk_text text;
    const struct nk_style_item *background;
    background = nk_draw_button(out, bounds, state, style);
 800e6c2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e6c4:	683a      	ldr	r2, [r7, #0]
 800e6c6:	68b9      	ldr	r1, [r7, #8]
 800e6c8:	68f8      	ldr	r0, [r7, #12]
 800e6ca:	f7ff fe79 	bl	800e3c0 <nk_draw_button>
 800e6ce:	6278      	str	r0, [r7, #36]	; 0x24

    /* select correct colors/images */
    if (background->type == NK_STYLE_ITEM_COLOR)
 800e6d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e6d2:	781b      	ldrb	r3, [r3, #0]
 800e6d4:	2b00      	cmp	r3, #0
 800e6d6:	d103      	bne.n	800e6e0 <nk_draw_button_text+0x2c>
        text.background = background->data.color;
 800e6d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e6da:	685b      	ldr	r3, [r3, #4]
 800e6dc:	61fb      	str	r3, [r7, #28]
 800e6de:	e002      	b.n	800e6e6 <nk_draw_button_text+0x32>
    else text.background = style->text_background;
 800e6e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e6e2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800e6e4:	61fb      	str	r3, [r7, #28]
    if (state & NK_WIDGET_STATE_HOVER)
 800e6e6:	683b      	ldr	r3, [r7, #0]
 800e6e8:	f003 0310 	and.w	r3, r3, #16
 800e6ec:	2b00      	cmp	r3, #0
 800e6ee:	d003      	beq.n	800e6f8 <nk_draw_button_text+0x44>
        text.text = style->text_hover;
 800e6f0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e6f2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800e6f4:	623b      	str	r3, [r7, #32]
 800e6f6:	e00b      	b.n	800e710 <nk_draw_button_text+0x5c>
    else if (state & NK_WIDGET_STATE_ACTIVED)
 800e6f8:	683b      	ldr	r3, [r7, #0]
 800e6fa:	f003 0320 	and.w	r3, r3, #32
 800e6fe:	2b00      	cmp	r3, #0
 800e700:	d003      	beq.n	800e70a <nk_draw_button_text+0x56>
        text.text = style->text_active;
 800e702:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e704:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800e706:	623b      	str	r3, [r7, #32]
 800e708:	e002      	b.n	800e710 <nk_draw_button_text+0x5c>
    else text.text = style->text_normal;
 800e70a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e70c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e70e:	623b      	str	r3, [r7, #32]

    text.padding = nk_vec2(0,0);
 800e710:	eddf 0a17 	vldr	s1, [pc, #92]	; 800e770 <nk_draw_button_text+0xbc>
 800e714:	ed9f 0a16 	vldr	s0, [pc, #88]	; 800e770 <nk_draw_button_text+0xbc>
 800e718:	f005 f8ce 	bl	80138b8 <nk_vec2>
 800e71c:	eeb0 7a40 	vmov.f32	s14, s0
 800e720:	eef0 7a60 	vmov.f32	s15, s1
 800e724:	ed87 7a05 	vstr	s14, [r7, #20]
 800e728:	edc7 7a06 	vstr	s15, [r7, #24]
    nk_widget_text(out, *content, txt, len, &text, text_alignment, font);
 800e72c:	f107 0214 	add.w	r2, r7, #20
 800e730:	687b      	ldr	r3, [r7, #4]
 800e732:	ed93 6a00 	vldr	s12, [r3]
 800e736:	edd3 6a01 	vldr	s13, [r3, #4]
 800e73a:	ed93 7a02 	vldr	s14, [r3, #8]
 800e73e:	edd3 7a03 	vldr	s15, [r3, #12]
 800e742:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800e744:	9301      	str	r3, [sp, #4]
 800e746:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e748:	9300      	str	r3, [sp, #0]
 800e74a:	4613      	mov	r3, r2
 800e74c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800e74e:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800e750:	eeb0 0a46 	vmov.f32	s0, s12
 800e754:	eef0 0a66 	vmov.f32	s1, s13
 800e758:	eeb0 1a47 	vmov.f32	s2, s14
 800e75c:	eef0 1a67 	vmov.f32	s3, s15
 800e760:	68f8      	ldr	r0, [r7, #12]
 800e762:	f00c faa7 	bl	801acb4 <nk_widget_text>
}
 800e766:	bf00      	nop
 800e768:	3728      	adds	r7, #40	; 0x28
 800e76a:	46bd      	mov	sp, r7
 800e76c:	bd80      	pop	{r7, pc}
 800e76e:	bf00      	nop
 800e770:	00000000 	.word	0x00000000

0800e774 <nk_do_button_text>:
nk_do_button_text(nk_flags *state,
    struct nk_command_buffer *out, struct nk_rect bounds,
    const char *string, int len, nk_flags align, enum nk_button_behavior behavior,
    const struct nk_style_button *style, const struct nk_input *in,
    const struct nk_user_font *font)
{
 800e774:	b580      	push	{r7, lr}
 800e776:	b094      	sub	sp, #80	; 0x50
 800e778:	af06      	add	r7, sp, #24
 800e77a:	61f8      	str	r0, [r7, #28]
 800e77c:	61b9      	str	r1, [r7, #24]
 800e77e:	eeb0 6a40 	vmov.f32	s12, s0
 800e782:	eef0 6a60 	vmov.f32	s13, s1
 800e786:	eeb0 7a41 	vmov.f32	s14, s2
 800e78a:	eef0 7a61 	vmov.f32	s15, s3
 800e78e:	607a      	str	r2, [r7, #4]
 800e790:	603b      	str	r3, [r7, #0]
 800e792:	ed87 6a02 	vstr	s12, [r7, #8]
 800e796:	edc7 6a03 	vstr	s13, [r7, #12]
 800e79a:	ed87 7a04 	vstr	s14, [r7, #16]
 800e79e:	edc7 7a05 	vstr	s15, [r7, #20]
    struct nk_rect content;
    int ret = nk_false;
 800e7a2:	2300      	movs	r3, #0
 800e7a4:	637b      	str	r3, [r7, #52]	; 0x34

    NK_ASSERT(state);
 800e7a6:	69fb      	ldr	r3, [r7, #28]
 800e7a8:	2b00      	cmp	r3, #0
 800e7aa:	d105      	bne.n	800e7b8 <nk_do_button_text+0x44>
 800e7ac:	4b43      	ldr	r3, [pc, #268]	; (800e8bc <nk_do_button_text+0x148>)
 800e7ae:	4a44      	ldr	r2, [pc, #272]	; (800e8c0 <nk_do_button_text+0x14c>)
 800e7b0:	21ad      	movs	r1, #173	; 0xad
 800e7b2:	4844      	ldr	r0, [pc, #272]	; (800e8c4 <nk_do_button_text+0x150>)
 800e7b4:	f00f f930 	bl	801da18 <__assert_func>
    NK_ASSERT(style);
 800e7b8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e7ba:	2b00      	cmp	r3, #0
 800e7bc:	d105      	bne.n	800e7ca <nk_do_button_text+0x56>
 800e7be:	4b42      	ldr	r3, [pc, #264]	; (800e8c8 <nk_do_button_text+0x154>)
 800e7c0:	4a3f      	ldr	r2, [pc, #252]	; (800e8c0 <nk_do_button_text+0x14c>)
 800e7c2:	21ae      	movs	r1, #174	; 0xae
 800e7c4:	483f      	ldr	r0, [pc, #252]	; (800e8c4 <nk_do_button_text+0x150>)
 800e7c6:	f00f f927 	bl	801da18 <__assert_func>
    NK_ASSERT(out);
 800e7ca:	69bb      	ldr	r3, [r7, #24]
 800e7cc:	2b00      	cmp	r3, #0
 800e7ce:	d105      	bne.n	800e7dc <nk_do_button_text+0x68>
 800e7d0:	4b3e      	ldr	r3, [pc, #248]	; (800e8cc <nk_do_button_text+0x158>)
 800e7d2:	4a3b      	ldr	r2, [pc, #236]	; (800e8c0 <nk_do_button_text+0x14c>)
 800e7d4:	21af      	movs	r1, #175	; 0xaf
 800e7d6:	483b      	ldr	r0, [pc, #236]	; (800e8c4 <nk_do_button_text+0x150>)
 800e7d8:	f00f f91e 	bl	801da18 <__assert_func>
    NK_ASSERT(string);
 800e7dc:	687b      	ldr	r3, [r7, #4]
 800e7de:	2b00      	cmp	r3, #0
 800e7e0:	d105      	bne.n	800e7ee <nk_do_button_text+0x7a>
 800e7e2:	4b3b      	ldr	r3, [pc, #236]	; (800e8d0 <nk_do_button_text+0x15c>)
 800e7e4:	4a36      	ldr	r2, [pc, #216]	; (800e8c0 <nk_do_button_text+0x14c>)
 800e7e6:	21b0      	movs	r1, #176	; 0xb0
 800e7e8:	4836      	ldr	r0, [pc, #216]	; (800e8c4 <nk_do_button_text+0x150>)
 800e7ea:	f00f f915 	bl	801da18 <__assert_func>
    NK_ASSERT(font);
 800e7ee:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e7f0:	2b00      	cmp	r3, #0
 800e7f2:	d105      	bne.n	800e800 <nk_do_button_text+0x8c>
 800e7f4:	4b37      	ldr	r3, [pc, #220]	; (800e8d4 <nk_do_button_text+0x160>)
 800e7f6:	4a32      	ldr	r2, [pc, #200]	; (800e8c0 <nk_do_button_text+0x14c>)
 800e7f8:	21b1      	movs	r1, #177	; 0xb1
 800e7fa:	4832      	ldr	r0, [pc, #200]	; (800e8c4 <nk_do_button_text+0x150>)
 800e7fc:	f00f f90c 	bl	801da18 <__assert_func>
    if (!out || !style || !font || !string)
 800e800:	69bb      	ldr	r3, [r7, #24]
 800e802:	2b00      	cmp	r3, #0
 800e804:	d008      	beq.n	800e818 <nk_do_button_text+0xa4>
 800e806:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e808:	2b00      	cmp	r3, #0
 800e80a:	d005      	beq.n	800e818 <nk_do_button_text+0xa4>
 800e80c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e80e:	2b00      	cmp	r3, #0
 800e810:	d002      	beq.n	800e818 <nk_do_button_text+0xa4>
 800e812:	687b      	ldr	r3, [r7, #4]
 800e814:	2b00      	cmp	r3, #0
 800e816:	d101      	bne.n	800e81c <nk_do_button_text+0xa8>
        return nk_false;
 800e818:	2300      	movs	r3, #0
 800e81a:	e04b      	b.n	800e8b4 <nk_do_button_text+0x140>

    ret = nk_do_button(state, out, bounds, style, in, behavior, &content);
 800e81c:	ed97 6a02 	vldr	s12, [r7, #8]
 800e820:	edd7 6a03 	vldr	s13, [r7, #12]
 800e824:	ed97 7a04 	vldr	s14, [r7, #16]
 800e828:	edd7 7a05 	vldr	s15, [r7, #20]
 800e82c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800e830:	9301      	str	r3, [sp, #4]
 800e832:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
 800e836:	9300      	str	r3, [sp, #0]
 800e838:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e83a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800e83c:	eeb0 0a46 	vmov.f32	s0, s12
 800e840:	eef0 0a66 	vmov.f32	s1, s13
 800e844:	eeb0 1a47 	vmov.f32	s2, s14
 800e848:	eef0 1a67 	vmov.f32	s3, s15
 800e84c:	69b9      	ldr	r1, [r7, #24]
 800e84e:	69f8      	ldr	r0, [r7, #28]
 800e850:	f7ff fe50 	bl	800e4f4 <nk_do_button>
 800e854:	6378      	str	r0, [r7, #52]	; 0x34
    if (style->draw_begin) style->draw_begin(out, style->userdata);
 800e856:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e858:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800e85c:	2b00      	cmp	r3, #0
 800e85e:	d007      	beq.n	800e870 <nk_do_button_text+0xfc>
 800e860:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e862:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800e866:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800e868:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
 800e86c:	69b8      	ldr	r0, [r7, #24]
 800e86e:	4798      	blx	r3
    nk_draw_button_text(out, &bounds, &content, *state, style, string, len, align, font);
 800e870:	69fb      	ldr	r3, [r7, #28]
 800e872:	6818      	ldr	r0, [r3, #0]
 800e874:	f107 0224 	add.w	r2, r7, #36	; 0x24
 800e878:	f107 0108 	add.w	r1, r7, #8
 800e87c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e87e:	9304      	str	r3, [sp, #16]
 800e880:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800e882:	9303      	str	r3, [sp, #12]
 800e884:	683b      	ldr	r3, [r7, #0]
 800e886:	9302      	str	r3, [sp, #8]
 800e888:	687b      	ldr	r3, [r7, #4]
 800e88a:	9301      	str	r3, [sp, #4]
 800e88c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e88e:	9300      	str	r3, [sp, #0]
 800e890:	4603      	mov	r3, r0
 800e892:	69b8      	ldr	r0, [r7, #24]
 800e894:	f7ff ff0e 	bl	800e6b4 <nk_draw_button_text>
    if (style->draw_end) style->draw_end(out, style->userdata);
 800e898:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e89a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800e89e:	2b00      	cmp	r3, #0
 800e8a0:	d007      	beq.n	800e8b2 <nk_do_button_text+0x13e>
 800e8a2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e8a4:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800e8a8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800e8aa:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
 800e8ae:	69b8      	ldr	r0, [r7, #24]
 800e8b0:	4798      	blx	r3
    return ret;
 800e8b2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 800e8b4:	4618      	mov	r0, r3
 800e8b6:	3738      	adds	r7, #56	; 0x38
 800e8b8:	46bd      	mov	sp, r7
 800e8ba:	bd80      	pop	{r7, pc}
 800e8bc:	080214fc 	.word	0x080214fc
 800e8c0:	080231e0 	.word	0x080231e0
 800e8c4:	080214e0 	.word	0x080214e0
 800e8c8:	080214d8 	.word	0x080214d8
 800e8cc:	08021504 	.word	0x08021504
 800e8d0:	08021508 	.word	0x08021508
 800e8d4:	08021510 	.word	0x08021510

0800e8d8 <nk_draw_button_symbol>:
NK_LIB void
nk_draw_button_symbol(struct nk_command_buffer *out,
    const struct nk_rect *bounds, const struct nk_rect *content,
    nk_flags state, const struct nk_style_button *style,
    enum nk_symbol_type type, const struct nk_user_font *font)
{
 800e8d8:	b580      	push	{r7, lr}
 800e8da:	b08a      	sub	sp, #40	; 0x28
 800e8dc:	af02      	add	r7, sp, #8
 800e8de:	60f8      	str	r0, [r7, #12]
 800e8e0:	60b9      	str	r1, [r7, #8]
 800e8e2:	607a      	str	r2, [r7, #4]
 800e8e4:	603b      	str	r3, [r7, #0]
    struct nk_color sym, bg;
    const struct nk_style_item *background;

    /* select correct colors/images */
    background = nk_draw_button(out, bounds, state, style);
 800e8e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e8e8:	683a      	ldr	r2, [r7, #0]
 800e8ea:	68b9      	ldr	r1, [r7, #8]
 800e8ec:	68f8      	ldr	r0, [r7, #12]
 800e8ee:	f7ff fd67 	bl	800e3c0 <nk_draw_button>
 800e8f2:	61f8      	str	r0, [r7, #28]
    if (background->type == NK_STYLE_ITEM_COLOR)
 800e8f4:	69fb      	ldr	r3, [r7, #28]
 800e8f6:	781b      	ldrb	r3, [r3, #0]
 800e8f8:	2b00      	cmp	r3, #0
 800e8fa:	d103      	bne.n	800e904 <nk_draw_button_symbol+0x2c>
        bg = background->data.color;
 800e8fc:	69fb      	ldr	r3, [r7, #28]
 800e8fe:	685b      	ldr	r3, [r3, #4]
 800e900:	617b      	str	r3, [r7, #20]
 800e902:	e002      	b.n	800e90a <nk_draw_button_symbol+0x32>
    else bg = style->text_background;
 800e904:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e906:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800e908:	617b      	str	r3, [r7, #20]

    if (state & NK_WIDGET_STATE_HOVER)
 800e90a:	683b      	ldr	r3, [r7, #0]
 800e90c:	f003 0310 	and.w	r3, r3, #16
 800e910:	2b00      	cmp	r3, #0
 800e912:	d003      	beq.n	800e91c <nk_draw_button_symbol+0x44>
        sym = style->text_hover;
 800e914:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e916:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800e918:	61bb      	str	r3, [r7, #24]
 800e91a:	e00b      	b.n	800e934 <nk_draw_button_symbol+0x5c>
    else if (state & NK_WIDGET_STATE_ACTIVED)
 800e91c:	683b      	ldr	r3, [r7, #0]
 800e91e:	f003 0320 	and.w	r3, r3, #32
 800e922:	2b00      	cmp	r3, #0
 800e924:	d003      	beq.n	800e92e <nk_draw_button_symbol+0x56>
        sym = style->text_active;
 800e926:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e928:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800e92a:	61bb      	str	r3, [r7, #24]
 800e92c:	e002      	b.n	800e934 <nk_draw_button_symbol+0x5c>
    else sym = style->text_normal;
 800e92e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e930:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e932:	61bb      	str	r3, [r7, #24]
    nk_draw_symbol(out, type, *content, bg, sym, 1, font);
 800e934:	687b      	ldr	r3, [r7, #4]
 800e936:	ed93 6a00 	vldr	s12, [r3]
 800e93a:	edd3 6a01 	vldr	s13, [r3, #4]
 800e93e:	ed93 7a02 	vldr	s14, [r3, #8]
 800e942:	edd3 7a03 	vldr	s15, [r3, #12]
 800e946:	f897 102c 	ldrb.w	r1, [r7, #44]	; 0x2c
 800e94a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e94c:	9300      	str	r3, [sp, #0]
 800e94e:	eeb7 2a00 	vmov.f32	s4, #112	; 0x3f800000  1.0
 800e952:	69bb      	ldr	r3, [r7, #24]
 800e954:	697a      	ldr	r2, [r7, #20]
 800e956:	eeb0 0a46 	vmov.f32	s0, s12
 800e95a:	eef0 0a66 	vmov.f32	s1, s13
 800e95e:	eeb0 1a47 	vmov.f32	s2, s14
 800e962:	eef0 1a67 	vmov.f32	s3, s15
 800e966:	68f8      	ldr	r0, [r7, #12]
 800e968:	f7ff fae2 	bl	800df30 <nk_draw_symbol>
}
 800e96c:	bf00      	nop
 800e96e:	3720      	adds	r7, #32
 800e970:	46bd      	mov	sp, r7
 800e972:	bd80      	pop	{r7, pc}

0800e974 <nk_do_button_symbol>:
nk_do_button_symbol(nk_flags *state,
    struct nk_command_buffer *out, struct nk_rect bounds,
    enum nk_symbol_type symbol, enum nk_button_behavior behavior,
    const struct nk_style_button *style, const struct nk_input *in,
    const struct nk_user_font *font)
{
 800e974:	b580      	push	{r7, lr}
 800e976:	b092      	sub	sp, #72	; 0x48
 800e978:	af04      	add	r7, sp, #16
 800e97a:	61f8      	str	r0, [r7, #28]
 800e97c:	61b9      	str	r1, [r7, #24]
 800e97e:	eeb0 6a40 	vmov.f32	s12, s0
 800e982:	eef0 6a60 	vmov.f32	s13, s1
 800e986:	eeb0 7a41 	vmov.f32	s14, s2
 800e98a:	eef0 7a61 	vmov.f32	s15, s3
 800e98e:	4611      	mov	r1, r2
 800e990:	461a      	mov	r2, r3
 800e992:	ed87 6a02 	vstr	s12, [r7, #8]
 800e996:	edc7 6a03 	vstr	s13, [r7, #12]
 800e99a:	ed87 7a04 	vstr	s14, [r7, #16]
 800e99e:	edc7 7a05 	vstr	s15, [r7, #20]
 800e9a2:	460b      	mov	r3, r1
 800e9a4:	71fb      	strb	r3, [r7, #7]
 800e9a6:	4613      	mov	r3, r2
 800e9a8:	71bb      	strb	r3, [r7, #6]
    int ret;
    struct nk_rect content;

    NK_ASSERT(state);
 800e9aa:	69fb      	ldr	r3, [r7, #28]
 800e9ac:	2b00      	cmp	r3, #0
 800e9ae:	d105      	bne.n	800e9bc <nk_do_button_symbol+0x48>
 800e9b0:	4b3c      	ldr	r3, [pc, #240]	; (800eaa4 <nk_do_button_symbol+0x130>)
 800e9b2:	4a3d      	ldr	r2, [pc, #244]	; (800eaa8 <nk_do_button_symbol+0x134>)
 800e9b4:	21db      	movs	r1, #219	; 0xdb
 800e9b6:	483d      	ldr	r0, [pc, #244]	; (800eaac <nk_do_button_symbol+0x138>)
 800e9b8:	f00f f82e 	bl	801da18 <__assert_func>
    NK_ASSERT(style);
 800e9bc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800e9be:	2b00      	cmp	r3, #0
 800e9c0:	d105      	bne.n	800e9ce <nk_do_button_symbol+0x5a>
 800e9c2:	4b3b      	ldr	r3, [pc, #236]	; (800eab0 <nk_do_button_symbol+0x13c>)
 800e9c4:	4a38      	ldr	r2, [pc, #224]	; (800eaa8 <nk_do_button_symbol+0x134>)
 800e9c6:	21dc      	movs	r1, #220	; 0xdc
 800e9c8:	4838      	ldr	r0, [pc, #224]	; (800eaac <nk_do_button_symbol+0x138>)
 800e9ca:	f00f f825 	bl	801da18 <__assert_func>
    NK_ASSERT(font);
 800e9ce:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e9d0:	2b00      	cmp	r3, #0
 800e9d2:	d105      	bne.n	800e9e0 <nk_do_button_symbol+0x6c>
 800e9d4:	4b37      	ldr	r3, [pc, #220]	; (800eab4 <nk_do_button_symbol+0x140>)
 800e9d6:	4a34      	ldr	r2, [pc, #208]	; (800eaa8 <nk_do_button_symbol+0x134>)
 800e9d8:	21dd      	movs	r1, #221	; 0xdd
 800e9da:	4834      	ldr	r0, [pc, #208]	; (800eaac <nk_do_button_symbol+0x138>)
 800e9dc:	f00f f81c 	bl	801da18 <__assert_func>
    NK_ASSERT(out);
 800e9e0:	69bb      	ldr	r3, [r7, #24]
 800e9e2:	2b00      	cmp	r3, #0
 800e9e4:	d105      	bne.n	800e9f2 <nk_do_button_symbol+0x7e>
 800e9e6:	4b34      	ldr	r3, [pc, #208]	; (800eab8 <nk_do_button_symbol+0x144>)
 800e9e8:	4a2f      	ldr	r2, [pc, #188]	; (800eaa8 <nk_do_button_symbol+0x134>)
 800e9ea:	21de      	movs	r1, #222	; 0xde
 800e9ec:	482f      	ldr	r0, [pc, #188]	; (800eaac <nk_do_button_symbol+0x138>)
 800e9ee:	f00f f813 	bl	801da18 <__assert_func>
    if (!out || !style || !font || !state)
 800e9f2:	69bb      	ldr	r3, [r7, #24]
 800e9f4:	2b00      	cmp	r3, #0
 800e9f6:	d008      	beq.n	800ea0a <nk_do_button_symbol+0x96>
 800e9f8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800e9fa:	2b00      	cmp	r3, #0
 800e9fc:	d005      	beq.n	800ea0a <nk_do_button_symbol+0x96>
 800e9fe:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ea00:	2b00      	cmp	r3, #0
 800ea02:	d002      	beq.n	800ea0a <nk_do_button_symbol+0x96>
 800ea04:	69fb      	ldr	r3, [r7, #28]
 800ea06:	2b00      	cmp	r3, #0
 800ea08:	d101      	bne.n	800ea0e <nk_do_button_symbol+0x9a>
        return nk_false;
 800ea0a:	2300      	movs	r3, #0
 800ea0c:	e046      	b.n	800ea9c <nk_do_button_symbol+0x128>

    ret = nk_do_button(state, out, bounds, style, in, behavior, &content);
 800ea0e:	ed97 6a02 	vldr	s12, [r7, #8]
 800ea12:	edd7 6a03 	vldr	s13, [r7, #12]
 800ea16:	ed97 7a04 	vldr	s14, [r7, #16]
 800ea1a:	edd7 7a05 	vldr	s15, [r7, #20]
 800ea1e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800ea22:	9301      	str	r3, [sp, #4]
 800ea24:	79bb      	ldrb	r3, [r7, #6]
 800ea26:	9300      	str	r3, [sp, #0]
 800ea28:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ea2a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800ea2c:	eeb0 0a46 	vmov.f32	s0, s12
 800ea30:	eef0 0a66 	vmov.f32	s1, s13
 800ea34:	eeb0 1a47 	vmov.f32	s2, s14
 800ea38:	eef0 1a67 	vmov.f32	s3, s15
 800ea3c:	69b9      	ldr	r1, [r7, #24]
 800ea3e:	69f8      	ldr	r0, [r7, #28]
 800ea40:	f7ff fd58 	bl	800e4f4 <nk_do_button>
 800ea44:	6378      	str	r0, [r7, #52]	; 0x34
    if (style->draw_begin) style->draw_begin(out, style->userdata);
 800ea46:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ea48:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800ea4c:	2b00      	cmp	r3, #0
 800ea4e:	d007      	beq.n	800ea60 <nk_do_button_symbol+0xec>
 800ea50:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ea52:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800ea56:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800ea58:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
 800ea5c:	69b8      	ldr	r0, [r7, #24]
 800ea5e:	4798      	blx	r3
    nk_draw_button_symbol(out, &bounds, &content, *state, style, symbol, font);
 800ea60:	69fb      	ldr	r3, [r7, #28]
 800ea62:	6818      	ldr	r0, [r3, #0]
 800ea64:	f107 0224 	add.w	r2, r7, #36	; 0x24
 800ea68:	f107 0108 	add.w	r1, r7, #8
 800ea6c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ea6e:	9302      	str	r3, [sp, #8]
 800ea70:	79fb      	ldrb	r3, [r7, #7]
 800ea72:	9301      	str	r3, [sp, #4]
 800ea74:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ea76:	9300      	str	r3, [sp, #0]
 800ea78:	4603      	mov	r3, r0
 800ea7a:	69b8      	ldr	r0, [r7, #24]
 800ea7c:	f7ff ff2c 	bl	800e8d8 <nk_draw_button_symbol>
    if (style->draw_end) style->draw_end(out, style->userdata);
 800ea80:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ea82:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800ea86:	2b00      	cmp	r3, #0
 800ea88:	d007      	beq.n	800ea9a <nk_do_button_symbol+0x126>
 800ea8a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ea8c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800ea90:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800ea92:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
 800ea96:	69b8      	ldr	r0, [r7, #24]
 800ea98:	4798      	blx	r3
    return ret;
 800ea9a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 800ea9c:	4618      	mov	r0, r3
 800ea9e:	3738      	adds	r7, #56	; 0x38
 800eaa0:	46bd      	mov	sp, r7
 800eaa2:	bd80      	pop	{r7, pc}
 800eaa4:	080214fc 	.word	0x080214fc
 800eaa8:	080231f4 	.word	0x080231f4
 800eaac:	080214e0 	.word	0x080214e0
 800eab0:	080214d8 	.word	0x080214d8
 800eab4:	08021510 	.word	0x08021510
 800eab8:	08021504 	.word	0x08021504

0800eabc <nk_button_set_behavior>:
    if (style->draw_end) style->draw_end(out, style->userdata);
    return ret;
}
NK_API void
nk_button_set_behavior(struct nk_context *ctx, enum nk_button_behavior behavior)
{
 800eabc:	b580      	push	{r7, lr}
 800eabe:	b082      	sub	sp, #8
 800eac0:	af00      	add	r7, sp, #0
 800eac2:	6078      	str	r0, [r7, #4]
 800eac4:	460b      	mov	r3, r1
 800eac6:	70fb      	strb	r3, [r7, #3]
    NK_ASSERT(ctx);
 800eac8:	687b      	ldr	r3, [r7, #4]
 800eaca:	2b00      	cmp	r3, #0
 800eacc:	d106      	bne.n	800eadc <nk_button_set_behavior+0x20>
 800eace:	4b0b      	ldr	r3, [pc, #44]	; (800eafc <nk_button_set_behavior+0x40>)
 800ead0:	4a0b      	ldr	r2, [pc, #44]	; (800eb00 <nk_button_set_behavior+0x44>)
 800ead2:	f240 118b 	movw	r1, #395	; 0x18b
 800ead6:	480b      	ldr	r0, [pc, #44]	; (800eb04 <nk_button_set_behavior+0x48>)
 800ead8:	f00e ff9e 	bl	801da18 <__assert_func>
    if (!ctx) return;
 800eadc:	687b      	ldr	r3, [r7, #4]
 800eade:	2b00      	cmp	r3, #0
 800eae0:	d007      	beq.n	800eaf2 <nk_button_set_behavior+0x36>
    ctx->button_behavior = behavior;
 800eae2:	687b      	ldr	r3, [r7, #4]
 800eae4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800eae8:	461a      	mov	r2, r3
 800eaea:	78fb      	ldrb	r3, [r7, #3]
 800eaec:	f882 3ad8 	strb.w	r3, [r2, #2776]	; 0xad8
 800eaf0:	e000      	b.n	800eaf4 <nk_button_set_behavior+0x38>
    if (!ctx) return;
 800eaf2:	bf00      	nop
}
 800eaf4:	3708      	adds	r7, #8
 800eaf6:	46bd      	mov	sp, r7
 800eaf8:	bd80      	pop	{r7, pc}
 800eafa:	bf00      	nop
 800eafc:	08021518 	.word	0x08021518
 800eb00:	08023208 	.word	0x08023208
 800eb04:	080214e0 	.word	0x080214e0

0800eb08 <nk_button_text_styled>:
    return 1;
}
NK_API nk_bool
nk_button_text_styled(struct nk_context *ctx,
    const struct nk_style_button *style, const char *title, int len)
{
 800eb08:	b590      	push	{r4, r7, lr}
 800eb0a:	b093      	sub	sp, #76	; 0x4c
 800eb0c:	af06      	add	r7, sp, #24
 800eb0e:	60f8      	str	r0, [r7, #12]
 800eb10:	60b9      	str	r1, [r7, #8]
 800eb12:	607a      	str	r2, [r7, #4]
 800eb14:	603b      	str	r3, [r7, #0]
    const struct nk_input *in;

    struct nk_rect bounds;
    enum nk_widget_layout_states state;

    NK_ASSERT(ctx);
 800eb16:	68fb      	ldr	r3, [r7, #12]
 800eb18:	2b00      	cmp	r3, #0
 800eb1a:	d106      	bne.n	800eb2a <nk_button_text_styled+0x22>
 800eb1c:	4b4f      	ldr	r3, [pc, #316]	; (800ec5c <nk_button_text_styled+0x154>)
 800eb1e:	4a50      	ldr	r2, [pc, #320]	; (800ec60 <nk_button_text_styled+0x158>)
 800eb20:	f44f 71e0 	mov.w	r1, #448	; 0x1c0
 800eb24:	484f      	ldr	r0, [pc, #316]	; (800ec64 <nk_button_text_styled+0x15c>)
 800eb26:	f00e ff77 	bl	801da18 <__assert_func>
    NK_ASSERT(style);
 800eb2a:	68bb      	ldr	r3, [r7, #8]
 800eb2c:	2b00      	cmp	r3, #0
 800eb2e:	d106      	bne.n	800eb3e <nk_button_text_styled+0x36>
 800eb30:	4b4d      	ldr	r3, [pc, #308]	; (800ec68 <nk_button_text_styled+0x160>)
 800eb32:	4a4b      	ldr	r2, [pc, #300]	; (800ec60 <nk_button_text_styled+0x158>)
 800eb34:	f240 11c1 	movw	r1, #449	; 0x1c1
 800eb38:	484a      	ldr	r0, [pc, #296]	; (800ec64 <nk_button_text_styled+0x15c>)
 800eb3a:	f00e ff6d 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 800eb3e:	68fb      	ldr	r3, [r7, #12]
 800eb40:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800eb44:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800eb48:	2b00      	cmp	r3, #0
 800eb4a:	d106      	bne.n	800eb5a <nk_button_text_styled+0x52>
 800eb4c:	4b47      	ldr	r3, [pc, #284]	; (800ec6c <nk_button_text_styled+0x164>)
 800eb4e:	4a44      	ldr	r2, [pc, #272]	; (800ec60 <nk_button_text_styled+0x158>)
 800eb50:	f44f 71e1 	mov.w	r1, #450	; 0x1c2
 800eb54:	4843      	ldr	r0, [pc, #268]	; (800ec64 <nk_button_text_styled+0x15c>)
 800eb56:	f00e ff5f 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 800eb5a:	68fb      	ldr	r3, [r7, #12]
 800eb5c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800eb60:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800eb64:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800eb68:	2b00      	cmp	r3, #0
 800eb6a:	d106      	bne.n	800eb7a <nk_button_text_styled+0x72>
 800eb6c:	4b40      	ldr	r3, [pc, #256]	; (800ec70 <nk_button_text_styled+0x168>)
 800eb6e:	4a3c      	ldr	r2, [pc, #240]	; (800ec60 <nk_button_text_styled+0x158>)
 800eb70:	f240 11c3 	movw	r1, #451	; 0x1c3
 800eb74:	483b      	ldr	r0, [pc, #236]	; (800ec64 <nk_button_text_styled+0x15c>)
 800eb76:	f00e ff4f 	bl	801da18 <__assert_func>
    if (!style || !ctx || !ctx->current || !ctx->current->layout) return 0;
 800eb7a:	68bb      	ldr	r3, [r7, #8]
 800eb7c:	2b00      	cmp	r3, #0
 800eb7e:	d012      	beq.n	800eba6 <nk_button_text_styled+0x9e>
 800eb80:	68fb      	ldr	r3, [r7, #12]
 800eb82:	2b00      	cmp	r3, #0
 800eb84:	d00f      	beq.n	800eba6 <nk_button_text_styled+0x9e>
 800eb86:	68fb      	ldr	r3, [r7, #12]
 800eb88:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800eb8c:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800eb90:	2b00      	cmp	r3, #0
 800eb92:	d008      	beq.n	800eba6 <nk_button_text_styled+0x9e>
 800eb94:	68fb      	ldr	r3, [r7, #12]
 800eb96:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800eb9a:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800eb9e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800eba2:	2b00      	cmp	r3, #0
 800eba4:	d101      	bne.n	800ebaa <nk_button_text_styled+0xa2>
 800eba6:	2300      	movs	r3, #0
 800eba8:	e054      	b.n	800ec54 <nk_button_text_styled+0x14c>

    win = ctx->current;
 800ebaa:	68fb      	ldr	r3, [r7, #12]
 800ebac:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800ebb0:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800ebb4:	62fb      	str	r3, [r7, #44]	; 0x2c
    layout = win->layout;
 800ebb6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ebb8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800ebbc:	62bb      	str	r3, [r7, #40]	; 0x28
    state = nk_widget(&bounds, ctx);
 800ebbe:	f107 0310 	add.w	r3, r7, #16
 800ebc2:	68f9      	ldr	r1, [r7, #12]
 800ebc4:	4618      	mov	r0, r3
 800ebc6:	f00d fc3f 	bl	801c448 <nk_widget>
 800ebca:	4603      	mov	r3, r0
 800ebcc:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

    if (!state) return 0;
 800ebd0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800ebd4:	2b00      	cmp	r3, #0
 800ebd6:	d101      	bne.n	800ebdc <nk_button_text_styled+0xd4>
 800ebd8:	2300      	movs	r3, #0
 800ebda:	e03b      	b.n	800ec54 <nk_button_text_styled+0x14c>
    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
 800ebdc:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800ebe0:	2b02      	cmp	r3, #2
 800ebe2:	d007      	beq.n	800ebf4 <nk_button_text_styled+0xec>
 800ebe4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ebe6:	685b      	ldr	r3, [r3, #4]
 800ebe8:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 800ebec:	2b00      	cmp	r3, #0
 800ebee:	d101      	bne.n	800ebf4 <nk_button_text_styled+0xec>
 800ebf0:	68fb      	ldr	r3, [r7, #12]
 800ebf2:	e000      	b.n	800ebf6 <nk_button_text_styled+0xee>
 800ebf4:	2300      	movs	r3, #0
 800ebf6:	623b      	str	r3, [r7, #32]
    return nk_do_button_text(&ctx->last_widget_state, &win->buffer, bounds,
 800ebf8:	68fb      	ldr	r3, [r7, #12]
 800ebfa:	f503 50d6 	add.w	r0, r3, #6848	; 0x1ac0
 800ebfe:	3014      	adds	r0, #20
 800ec00:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ec02:	f103 0464 	add.w	r4, r3, #100	; 0x64
                    title, len, style->text_alignment, ctx->button_behavior,
 800ec06:	68bb      	ldr	r3, [r7, #8]
 800ec08:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    return nk_do_button_text(&ctx->last_widget_state, &win->buffer, bounds,
 800ec0a:	68fa      	ldr	r2, [r7, #12]
 800ec0c:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 800ec10:	f892 2ad8 	ldrb.w	r2, [r2, #2776]	; 0xad8
 800ec14:	68f9      	ldr	r1, [r7, #12]
 800ec16:	f8d1 1168 	ldr.w	r1, [r1, #360]	; 0x168
 800ec1a:	ed97 6a04 	vldr	s12, [r7, #16]
 800ec1e:	edd7 6a05 	vldr	s13, [r7, #20]
 800ec22:	ed97 7a06 	vldr	s14, [r7, #24]
 800ec26:	edd7 7a07 	vldr	s15, [r7, #28]
 800ec2a:	9104      	str	r1, [sp, #16]
 800ec2c:	6a39      	ldr	r1, [r7, #32]
 800ec2e:	9103      	str	r1, [sp, #12]
 800ec30:	68b9      	ldr	r1, [r7, #8]
 800ec32:	9102      	str	r1, [sp, #8]
 800ec34:	9201      	str	r2, [sp, #4]
 800ec36:	9300      	str	r3, [sp, #0]
 800ec38:	683b      	ldr	r3, [r7, #0]
 800ec3a:	687a      	ldr	r2, [r7, #4]
 800ec3c:	eeb0 0a46 	vmov.f32	s0, s12
 800ec40:	eef0 0a66 	vmov.f32	s1, s13
 800ec44:	eeb0 1a47 	vmov.f32	s2, s14
 800ec48:	eef0 1a67 	vmov.f32	s3, s15
 800ec4c:	4621      	mov	r1, r4
 800ec4e:	f7ff fd91 	bl	800e774 <nk_do_button_text>
 800ec52:	4603      	mov	r3, r0
                    style, in, ctx->style.font);
}
 800ec54:	4618      	mov	r0, r3
 800ec56:	3734      	adds	r7, #52	; 0x34
 800ec58:	46bd      	mov	sp, r7
 800ec5a:	bd90      	pop	{r4, r7, pc}
 800ec5c:	08021518 	.word	0x08021518
 800ec60:	08023220 	.word	0x08023220
 800ec64:	080214e0 	.word	0x080214e0
 800ec68:	080214d8 	.word	0x080214d8
 800ec6c:	08021594 	.word	0x08021594
 800ec70:	080215a4 	.word	0x080215a4

0800ec74 <nk_button_text>:
NK_API nk_bool
nk_button_text(struct nk_context *ctx, const char *title, int len)
{
 800ec74:	b580      	push	{r7, lr}
 800ec76:	b084      	sub	sp, #16
 800ec78:	af00      	add	r7, sp, #0
 800ec7a:	60f8      	str	r0, [r7, #12]
 800ec7c:	60b9      	str	r1, [r7, #8]
 800ec7e:	607a      	str	r2, [r7, #4]
    NK_ASSERT(ctx);
 800ec80:	68fb      	ldr	r3, [r7, #12]
 800ec82:	2b00      	cmp	r3, #0
 800ec84:	d106      	bne.n	800ec94 <nk_button_text+0x20>
 800ec86:	4b0c      	ldr	r3, [pc, #48]	; (800ecb8 <nk_button_text+0x44>)
 800ec88:	4a0c      	ldr	r2, [pc, #48]	; (800ecbc <nk_button_text+0x48>)
 800ec8a:	f240 11d3 	movw	r1, #467	; 0x1d3
 800ec8e:	480c      	ldr	r0, [pc, #48]	; (800ecc0 <nk_button_text+0x4c>)
 800ec90:	f00e fec2 	bl	801da18 <__assert_func>
    if (!ctx) return 0;
 800ec94:	68fb      	ldr	r3, [r7, #12]
 800ec96:	2b00      	cmp	r3, #0
 800ec98:	d101      	bne.n	800ec9e <nk_button_text+0x2a>
 800ec9a:	2300      	movs	r3, #0
 800ec9c:	e008      	b.n	800ecb0 <nk_button_text+0x3c>
    return nk_button_text_styled(ctx, &ctx->style.button, title, len);
 800ec9e:	68fb      	ldr	r3, [r7, #12]
 800eca0:	f503 71d0 	add.w	r1, r3, #416	; 0x1a0
 800eca4:	687b      	ldr	r3, [r7, #4]
 800eca6:	68ba      	ldr	r2, [r7, #8]
 800eca8:	68f8      	ldr	r0, [r7, #12]
 800ecaa:	f7ff ff2d 	bl	800eb08 <nk_button_text_styled>
 800ecae:	4603      	mov	r3, r0
}
 800ecb0:	4618      	mov	r0, r3
 800ecb2:	3710      	adds	r7, #16
 800ecb4:	46bd      	mov	sp, r7
 800ecb6:	bd80      	pop	{r7, pc}
 800ecb8:	08021518 	.word	0x08021518
 800ecbc:	08023238 	.word	0x08023238
 800ecc0:	080214e0 	.word	0x080214e0

0800ecc4 <nk_button_label>:
    const struct nk_style_button *style, const char *title)
{
    return nk_button_text_styled(ctx, style, title, nk_strlen(title));
}
NK_API nk_bool nk_button_label(struct nk_context *ctx, const char *title)
{
 800ecc4:	b580      	push	{r7, lr}
 800ecc6:	b082      	sub	sp, #8
 800ecc8:	af00      	add	r7, sp, #0
 800ecca:	6078      	str	r0, [r7, #4]
 800eccc:	6039      	str	r1, [r7, #0]
    return nk_button_text(ctx, title, nk_strlen(title));
 800ecce:	6838      	ldr	r0, [r7, #0]
 800ecd0:	f00d f9c8 	bl	801c064 <nk_strlen>
 800ecd4:	4603      	mov	r3, r0
 800ecd6:	461a      	mov	r2, r3
 800ecd8:	6839      	ldr	r1, [r7, #0]
 800ecda:	6878      	ldr	r0, [r7, #4]
 800ecdc:	f7ff ffca 	bl	800ec74 <nk_button_text>
 800ece0:	4603      	mov	r3, r0
}
 800ece2:	4618      	mov	r0, r3
 800ece4:	3708      	adds	r7, #8
 800ece6:	46bd      	mov	sp, r7
 800ece8:	bd80      	pop	{r7, pc}
	...

0800ecec <nk_button_symbol_styled>:
    return ret;
}
NK_API nk_bool
nk_button_symbol_styled(struct nk_context *ctx,
    const struct nk_style_button *style, enum nk_symbol_type symbol)
{
 800ecec:	b590      	push	{r4, r7, lr}
 800ecee:	b091      	sub	sp, #68	; 0x44
 800ecf0:	af04      	add	r7, sp, #16
 800ecf2:	60f8      	str	r0, [r7, #12]
 800ecf4:	60b9      	str	r1, [r7, #8]
 800ecf6:	4613      	mov	r3, r2
 800ecf8:	71fb      	strb	r3, [r7, #7]
    const struct nk_input *in;

    struct nk_rect bounds;
    enum nk_widget_layout_states state;

    NK_ASSERT(ctx);
 800ecfa:	68fb      	ldr	r3, [r7, #12]
 800ecfc:	2b00      	cmp	r3, #0
 800ecfe:	d106      	bne.n	800ed0e <nk_button_symbol_styled+0x22>
 800ed00:	4b46      	ldr	r3, [pc, #280]	; (800ee1c <nk_button_symbol_styled+0x130>)
 800ed02:	4a47      	ldr	r2, [pc, #284]	; (800ee20 <nk_button_symbol_styled+0x134>)
 800ed04:	f240 210e 	movw	r1, #526	; 0x20e
 800ed08:	4846      	ldr	r0, [pc, #280]	; (800ee24 <nk_button_symbol_styled+0x138>)
 800ed0a:	f00e fe85 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 800ed0e:	68fb      	ldr	r3, [r7, #12]
 800ed10:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800ed14:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800ed18:	2b00      	cmp	r3, #0
 800ed1a:	d106      	bne.n	800ed2a <nk_button_symbol_styled+0x3e>
 800ed1c:	4b42      	ldr	r3, [pc, #264]	; (800ee28 <nk_button_symbol_styled+0x13c>)
 800ed1e:	4a40      	ldr	r2, [pc, #256]	; (800ee20 <nk_button_symbol_styled+0x134>)
 800ed20:	f240 210f 	movw	r1, #527	; 0x20f
 800ed24:	483f      	ldr	r0, [pc, #252]	; (800ee24 <nk_button_symbol_styled+0x138>)
 800ed26:	f00e fe77 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 800ed2a:	68fb      	ldr	r3, [r7, #12]
 800ed2c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800ed30:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800ed34:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800ed38:	2b00      	cmp	r3, #0
 800ed3a:	d106      	bne.n	800ed4a <nk_button_symbol_styled+0x5e>
 800ed3c:	4b3b      	ldr	r3, [pc, #236]	; (800ee2c <nk_button_symbol_styled+0x140>)
 800ed3e:	4a38      	ldr	r2, [pc, #224]	; (800ee20 <nk_button_symbol_styled+0x134>)
 800ed40:	f44f 7104 	mov.w	r1, #528	; 0x210
 800ed44:	4837      	ldr	r0, [pc, #220]	; (800ee24 <nk_button_symbol_styled+0x138>)
 800ed46:	f00e fe67 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout)
 800ed4a:	68fb      	ldr	r3, [r7, #12]
 800ed4c:	2b00      	cmp	r3, #0
 800ed4e:	d00f      	beq.n	800ed70 <nk_button_symbol_styled+0x84>
 800ed50:	68fb      	ldr	r3, [r7, #12]
 800ed52:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800ed56:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800ed5a:	2b00      	cmp	r3, #0
 800ed5c:	d008      	beq.n	800ed70 <nk_button_symbol_styled+0x84>
 800ed5e:	68fb      	ldr	r3, [r7, #12]
 800ed60:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800ed64:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800ed68:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800ed6c:	2b00      	cmp	r3, #0
 800ed6e:	d101      	bne.n	800ed74 <nk_button_symbol_styled+0x88>
        return 0;
 800ed70:	2300      	movs	r3, #0
 800ed72:	e04f      	b.n	800ee14 <nk_button_symbol_styled+0x128>

    win = ctx->current;
 800ed74:	68fb      	ldr	r3, [r7, #12]
 800ed76:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800ed7a:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800ed7e:	62fb      	str	r3, [r7, #44]	; 0x2c
    layout = win->layout;
 800ed80:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ed82:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800ed86:	62bb      	str	r3, [r7, #40]	; 0x28
    state = nk_widget(&bounds, ctx);
 800ed88:	f107 0310 	add.w	r3, r7, #16
 800ed8c:	68f9      	ldr	r1, [r7, #12]
 800ed8e:	4618      	mov	r0, r3
 800ed90:	f00d fb5a 	bl	801c448 <nk_widget>
 800ed94:	4603      	mov	r3, r0
 800ed96:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    if (!state) return 0;
 800ed9a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800ed9e:	2b00      	cmp	r3, #0
 800eda0:	d101      	bne.n	800eda6 <nk_button_symbol_styled+0xba>
 800eda2:	2300      	movs	r3, #0
 800eda4:	e036      	b.n	800ee14 <nk_button_symbol_styled+0x128>
    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
 800eda6:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800edaa:	2b02      	cmp	r3, #2
 800edac:	d007      	beq.n	800edbe <nk_button_symbol_styled+0xd2>
 800edae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800edb0:	685b      	ldr	r3, [r3, #4]
 800edb2:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 800edb6:	2b00      	cmp	r3, #0
 800edb8:	d101      	bne.n	800edbe <nk_button_symbol_styled+0xd2>
 800edba:	68fb      	ldr	r3, [r7, #12]
 800edbc:	e000      	b.n	800edc0 <nk_button_symbol_styled+0xd4>
 800edbe:	2300      	movs	r3, #0
 800edc0:	623b      	str	r3, [r7, #32]
    return nk_do_button_symbol(&ctx->last_widget_state, &win->buffer, bounds,
 800edc2:	68fb      	ldr	r3, [r7, #12]
 800edc4:	f503 50d6 	add.w	r0, r3, #6848	; 0x1ac0
 800edc8:	3014      	adds	r0, #20
 800edca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800edcc:	f103 0164 	add.w	r1, r3, #100	; 0x64
 800edd0:	68fb      	ldr	r3, [r7, #12]
 800edd2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800edd6:	f893 4ad8 	ldrb.w	r4, [r3, #2776]	; 0xad8
 800edda:	68fb      	ldr	r3, [r7, #12]
 800eddc:	f8d3 3168 	ldr.w	r3, [r3, #360]	; 0x168
 800ede0:	79fa      	ldrb	r2, [r7, #7]
 800ede2:	ed97 6a04 	vldr	s12, [r7, #16]
 800ede6:	edd7 6a05 	vldr	s13, [r7, #20]
 800edea:	ed97 7a06 	vldr	s14, [r7, #24]
 800edee:	edd7 7a07 	vldr	s15, [r7, #28]
 800edf2:	9302      	str	r3, [sp, #8]
 800edf4:	6a3b      	ldr	r3, [r7, #32]
 800edf6:	9301      	str	r3, [sp, #4]
 800edf8:	68bb      	ldr	r3, [r7, #8]
 800edfa:	9300      	str	r3, [sp, #0]
 800edfc:	4623      	mov	r3, r4
 800edfe:	eeb0 0a46 	vmov.f32	s0, s12
 800ee02:	eef0 0a66 	vmov.f32	s1, s13
 800ee06:	eeb0 1a47 	vmov.f32	s2, s14
 800ee0a:	eef0 1a67 	vmov.f32	s3, s15
 800ee0e:	f7ff fdb1 	bl	800e974 <nk_do_button_symbol>
 800ee12:	4603      	mov	r3, r0
            symbol, ctx->button_behavior, style, in, ctx->style.font);
}
 800ee14:	4618      	mov	r0, r3
 800ee16:	3734      	adds	r7, #52	; 0x34
 800ee18:	46bd      	mov	sp, r7
 800ee1a:	bd90      	pop	{r4, r7, pc}
 800ee1c:	08021518 	.word	0x08021518
 800ee20:	08023248 	.word	0x08023248
 800ee24:	080214e0 	.word	0x080214e0
 800ee28:	08021594 	.word	0x08021594
 800ee2c:	080215a4 	.word	0x080215a4

0800ee30 <nk_button_symbol>:
NK_API nk_bool
nk_button_symbol(struct nk_context *ctx, enum nk_symbol_type symbol)
{
 800ee30:	b580      	push	{r7, lr}
 800ee32:	b082      	sub	sp, #8
 800ee34:	af00      	add	r7, sp, #0
 800ee36:	6078      	str	r0, [r7, #4]
 800ee38:	460b      	mov	r3, r1
 800ee3a:	70fb      	strb	r3, [r7, #3]
    NK_ASSERT(ctx);
 800ee3c:	687b      	ldr	r3, [r7, #4]
 800ee3e:	2b00      	cmp	r3, #0
 800ee40:	d106      	bne.n	800ee50 <nk_button_symbol+0x20>
 800ee42:	4b0c      	ldr	r3, [pc, #48]	; (800ee74 <nk_button_symbol+0x44>)
 800ee44:	4a0c      	ldr	r2, [pc, #48]	; (800ee78 <nk_button_symbol+0x48>)
 800ee46:	f240 211f 	movw	r1, #543	; 0x21f
 800ee4a:	480c      	ldr	r0, [pc, #48]	; (800ee7c <nk_button_symbol+0x4c>)
 800ee4c:	f00e fde4 	bl	801da18 <__assert_func>
    if (!ctx) return 0;
 800ee50:	687b      	ldr	r3, [r7, #4]
 800ee52:	2b00      	cmp	r3, #0
 800ee54:	d101      	bne.n	800ee5a <nk_button_symbol+0x2a>
 800ee56:	2300      	movs	r3, #0
 800ee58:	e008      	b.n	800ee6c <nk_button_symbol+0x3c>
    return nk_button_symbol_styled(ctx, &ctx->style.button, symbol);
 800ee5a:	687b      	ldr	r3, [r7, #4]
 800ee5c:	f503 73d0 	add.w	r3, r3, #416	; 0x1a0
 800ee60:	78fa      	ldrb	r2, [r7, #3]
 800ee62:	4619      	mov	r1, r3
 800ee64:	6878      	ldr	r0, [r7, #4]
 800ee66:	f7ff ff41 	bl	800ecec <nk_button_symbol_styled>
 800ee6a:	4603      	mov	r3, r0
}
 800ee6c:	4618      	mov	r0, r3
 800ee6e:	3708      	adds	r7, #8
 800ee70:	46bd      	mov	sp, r7
 800ee72:	bd80      	pop	{r7, pc}
 800ee74:	08021518 	.word	0x08021518
 800ee78:	08023260 	.word	0x08023260
 800ee7c:	080214e0 	.word	0x080214e0

0800ee80 <nk_rgba>:
    }
    return i;
}
NK_API struct nk_color
nk_rgba(int r, int g, int b, int a)
{
 800ee80:	b480      	push	{r7}
 800ee82:	b087      	sub	sp, #28
 800ee84:	af00      	add	r7, sp, #0
 800ee86:	60f8      	str	r0, [r7, #12]
 800ee88:	60b9      	str	r1, [r7, #8]
 800ee8a:	607a      	str	r2, [r7, #4]
 800ee8c:	603b      	str	r3, [r7, #0]
    struct nk_color ret;
    ret.r = (nk_byte)NK_CLAMP(0, r, 255);
 800ee8e:	68fb      	ldr	r3, [r7, #12]
 800ee90:	2b00      	cmp	r3, #0
 800ee92:	db07      	blt.n	800eea4 <nk_rgba+0x24>
 800ee94:	68fb      	ldr	r3, [r7, #12]
 800ee96:	2bfe      	cmp	r3, #254	; 0xfe
 800ee98:	dc02      	bgt.n	800eea0 <nk_rgba+0x20>
 800ee9a:	68fb      	ldr	r3, [r7, #12]
 800ee9c:	b2db      	uxtb	r3, r3
 800ee9e:	e002      	b.n	800eea6 <nk_rgba+0x26>
 800eea0:	23ff      	movs	r3, #255	; 0xff
 800eea2:	e000      	b.n	800eea6 <nk_rgba+0x26>
 800eea4:	2300      	movs	r3, #0
 800eea6:	743b      	strb	r3, [r7, #16]
    ret.g = (nk_byte)NK_CLAMP(0, g, 255);
 800eea8:	68bb      	ldr	r3, [r7, #8]
 800eeaa:	2b00      	cmp	r3, #0
 800eeac:	db07      	blt.n	800eebe <nk_rgba+0x3e>
 800eeae:	68bb      	ldr	r3, [r7, #8]
 800eeb0:	2bfe      	cmp	r3, #254	; 0xfe
 800eeb2:	dc02      	bgt.n	800eeba <nk_rgba+0x3a>
 800eeb4:	68bb      	ldr	r3, [r7, #8]
 800eeb6:	b2db      	uxtb	r3, r3
 800eeb8:	e002      	b.n	800eec0 <nk_rgba+0x40>
 800eeba:	23ff      	movs	r3, #255	; 0xff
 800eebc:	e000      	b.n	800eec0 <nk_rgba+0x40>
 800eebe:	2300      	movs	r3, #0
 800eec0:	747b      	strb	r3, [r7, #17]
    ret.b = (nk_byte)NK_CLAMP(0, b, 255);
 800eec2:	687b      	ldr	r3, [r7, #4]
 800eec4:	2b00      	cmp	r3, #0
 800eec6:	db07      	blt.n	800eed8 <nk_rgba+0x58>
 800eec8:	687b      	ldr	r3, [r7, #4]
 800eeca:	2bfe      	cmp	r3, #254	; 0xfe
 800eecc:	dc02      	bgt.n	800eed4 <nk_rgba+0x54>
 800eece:	687b      	ldr	r3, [r7, #4]
 800eed0:	b2db      	uxtb	r3, r3
 800eed2:	e002      	b.n	800eeda <nk_rgba+0x5a>
 800eed4:	23ff      	movs	r3, #255	; 0xff
 800eed6:	e000      	b.n	800eeda <nk_rgba+0x5a>
 800eed8:	2300      	movs	r3, #0
 800eeda:	74bb      	strb	r3, [r7, #18]
    ret.a = (nk_byte)NK_CLAMP(0, a, 255);
 800eedc:	683b      	ldr	r3, [r7, #0]
 800eede:	2b00      	cmp	r3, #0
 800eee0:	db07      	blt.n	800eef2 <nk_rgba+0x72>
 800eee2:	683b      	ldr	r3, [r7, #0]
 800eee4:	2bfe      	cmp	r3, #254	; 0xfe
 800eee6:	dc02      	bgt.n	800eeee <nk_rgba+0x6e>
 800eee8:	683b      	ldr	r3, [r7, #0]
 800eeea:	b2db      	uxtb	r3, r3
 800eeec:	e002      	b.n	800eef4 <nk_rgba+0x74>
 800eeee:	23ff      	movs	r3, #255	; 0xff
 800eef0:	e000      	b.n	800eef4 <nk_rgba+0x74>
 800eef2:	2300      	movs	r3, #0
 800eef4:	74fb      	strb	r3, [r7, #19]
    return ret;
 800eef6:	693b      	ldr	r3, [r7, #16]
 800eef8:	617b      	str	r3, [r7, #20]
 800eefa:	2300      	movs	r3, #0
 800eefc:	7d3a      	ldrb	r2, [r7, #20]
 800eefe:	f362 0307 	bfi	r3, r2, #0, #8
 800ef02:	7d7a      	ldrb	r2, [r7, #21]
 800ef04:	f362 230f 	bfi	r3, r2, #8, #8
 800ef08:	7dba      	ldrb	r2, [r7, #22]
 800ef0a:	f362 4317 	bfi	r3, r2, #16, #8
 800ef0e:	7dfa      	ldrb	r2, [r7, #23]
 800ef10:	f362 631f 	bfi	r3, r2, #24, #8
}
 800ef14:	4618      	mov	r0, r3
 800ef16:	371c      	adds	r7, #28
 800ef18:	46bd      	mov	sp, r7
 800ef1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ef1e:	4770      	bx	lr

0800ef20 <nk_rgb>:
{
    return nk_rgba(c[0], c[1], c[2], c[3]);
}
NK_API struct nk_color
nk_rgb(int r, int g, int b)
{
 800ef20:	b480      	push	{r7}
 800ef22:	b087      	sub	sp, #28
 800ef24:	af00      	add	r7, sp, #0
 800ef26:	60f8      	str	r0, [r7, #12]
 800ef28:	60b9      	str	r1, [r7, #8]
 800ef2a:	607a      	str	r2, [r7, #4]
    struct nk_color ret;
    ret.r = (nk_byte)NK_CLAMP(0, r, 255);
 800ef2c:	68fb      	ldr	r3, [r7, #12]
 800ef2e:	2b00      	cmp	r3, #0
 800ef30:	db07      	blt.n	800ef42 <nk_rgb+0x22>
 800ef32:	68fb      	ldr	r3, [r7, #12]
 800ef34:	2bfe      	cmp	r3, #254	; 0xfe
 800ef36:	dc02      	bgt.n	800ef3e <nk_rgb+0x1e>
 800ef38:	68fb      	ldr	r3, [r7, #12]
 800ef3a:	b2db      	uxtb	r3, r3
 800ef3c:	e002      	b.n	800ef44 <nk_rgb+0x24>
 800ef3e:	23ff      	movs	r3, #255	; 0xff
 800ef40:	e000      	b.n	800ef44 <nk_rgb+0x24>
 800ef42:	2300      	movs	r3, #0
 800ef44:	743b      	strb	r3, [r7, #16]
    ret.g = (nk_byte)NK_CLAMP(0, g, 255);
 800ef46:	68bb      	ldr	r3, [r7, #8]
 800ef48:	2b00      	cmp	r3, #0
 800ef4a:	db07      	blt.n	800ef5c <nk_rgb+0x3c>
 800ef4c:	68bb      	ldr	r3, [r7, #8]
 800ef4e:	2bfe      	cmp	r3, #254	; 0xfe
 800ef50:	dc02      	bgt.n	800ef58 <nk_rgb+0x38>
 800ef52:	68bb      	ldr	r3, [r7, #8]
 800ef54:	b2db      	uxtb	r3, r3
 800ef56:	e002      	b.n	800ef5e <nk_rgb+0x3e>
 800ef58:	23ff      	movs	r3, #255	; 0xff
 800ef5a:	e000      	b.n	800ef5e <nk_rgb+0x3e>
 800ef5c:	2300      	movs	r3, #0
 800ef5e:	747b      	strb	r3, [r7, #17]
    ret.b = (nk_byte)NK_CLAMP(0, b, 255);
 800ef60:	687b      	ldr	r3, [r7, #4]
 800ef62:	2b00      	cmp	r3, #0
 800ef64:	db07      	blt.n	800ef76 <nk_rgb+0x56>
 800ef66:	687b      	ldr	r3, [r7, #4]
 800ef68:	2bfe      	cmp	r3, #254	; 0xfe
 800ef6a:	dc02      	bgt.n	800ef72 <nk_rgb+0x52>
 800ef6c:	687b      	ldr	r3, [r7, #4]
 800ef6e:	b2db      	uxtb	r3, r3
 800ef70:	e002      	b.n	800ef78 <nk_rgb+0x58>
 800ef72:	23ff      	movs	r3, #255	; 0xff
 800ef74:	e000      	b.n	800ef78 <nk_rgb+0x58>
 800ef76:	2300      	movs	r3, #0
 800ef78:	74bb      	strb	r3, [r7, #18]
    ret.a = (nk_byte)255;
 800ef7a:	23ff      	movs	r3, #255	; 0xff
 800ef7c:	74fb      	strb	r3, [r7, #19]
    return ret;
 800ef7e:	693b      	ldr	r3, [r7, #16]
 800ef80:	617b      	str	r3, [r7, #20]
 800ef82:	2300      	movs	r3, #0
 800ef84:	7d3a      	ldrb	r2, [r7, #20]
 800ef86:	f362 0307 	bfi	r3, r2, #0, #8
 800ef8a:	7d7a      	ldrb	r2, [r7, #21]
 800ef8c:	f362 230f 	bfi	r3, r2, #8, #8
 800ef90:	7dba      	ldrb	r2, [r7, #22]
 800ef92:	f362 4317 	bfi	r3, r2, #16, #8
 800ef96:	7dfa      	ldrb	r2, [r7, #23]
 800ef98:	f362 631f 	bfi	r3, r2, #24, #8
}
 800ef9c:	4618      	mov	r0, r3
 800ef9e:	371c      	adds	r7, #28
 800efa0:	46bd      	mov	sp, r7
 800efa2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800efa6:	4770      	bx	lr

0800efa8 <nk_combo_begin>:
 *
 * ===============================================================*/
NK_INTERN nk_bool
nk_combo_begin(struct nk_context *ctx, struct nk_window *win,
    struct nk_vec2 size, nk_bool is_clicked, struct nk_rect header)
{
 800efa8:	b590      	push	{r4, r7, lr}
 800efaa:	b097      	sub	sp, #92	; 0x5c
 800efac:	af00      	add	r7, sp, #0
 800efae:	6278      	str	r0, [r7, #36]	; 0x24
 800efb0:	6239      	str	r1, [r7, #32]
 800efb2:	eeb0 5a40 	vmov.f32	s10, s0
 800efb6:	eef0 5a60 	vmov.f32	s11, s1
 800efba:	617a      	str	r2, [r7, #20]
 800efbc:	eeb0 6a41 	vmov.f32	s12, s2
 800efc0:	eef0 6a61 	vmov.f32	s13, s3
 800efc4:	eeb0 7a42 	vmov.f32	s14, s4
 800efc8:	eef0 7a62 	vmov.f32	s15, s5
 800efcc:	ed87 5a06 	vstr	s10, [r7, #24]
 800efd0:	edc7 5a07 	vstr	s11, [r7, #28]
 800efd4:	ed87 6a01 	vstr	s12, [r7, #4]
 800efd8:	edc7 6a02 	vstr	s13, [r7, #8]
 800efdc:	ed87 7a03 	vstr	s14, [r7, #12]
 800efe0:	edc7 7a04 	vstr	s15, [r7, #16]
    struct nk_window *popup;
    int is_open = 0;
 800efe4:	2300      	movs	r3, #0
 800efe6:	657b      	str	r3, [r7, #84]	; 0x54
    int is_active = 0;
 800efe8:	2300      	movs	r3, #0
 800efea:	653b      	str	r3, [r7, #80]	; 0x50
    struct nk_rect body;
    nk_hash hash;

    NK_ASSERT(ctx);
 800efec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800efee:	2b00      	cmp	r3, #0
 800eff0:	d105      	bne.n	800effe <nk_combo_begin+0x56>
 800eff2:	4b75      	ldr	r3, [pc, #468]	; (800f1c8 <nk_combo_begin+0x220>)
 800eff4:	4a75      	ldr	r2, [pc, #468]	; (800f1cc <nk_combo_begin+0x224>)
 800eff6:	2113      	movs	r1, #19
 800eff8:	4875      	ldr	r0, [pc, #468]	; (800f1d0 <nk_combo_begin+0x228>)
 800effa:	f00e fd0d 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 800effe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f000:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800f004:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800f008:	2b00      	cmp	r3, #0
 800f00a:	d105      	bne.n	800f018 <nk_combo_begin+0x70>
 800f00c:	4b71      	ldr	r3, [pc, #452]	; (800f1d4 <nk_combo_begin+0x22c>)
 800f00e:	4a6f      	ldr	r2, [pc, #444]	; (800f1cc <nk_combo_begin+0x224>)
 800f010:	2114      	movs	r1, #20
 800f012:	486f      	ldr	r0, [pc, #444]	; (800f1d0 <nk_combo_begin+0x228>)
 800f014:	f00e fd00 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 800f018:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f01a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800f01e:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800f022:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800f026:	2b00      	cmp	r3, #0
 800f028:	d105      	bne.n	800f036 <nk_combo_begin+0x8e>
 800f02a:	4b6b      	ldr	r3, [pc, #428]	; (800f1d8 <nk_combo_begin+0x230>)
 800f02c:	4a67      	ldr	r2, [pc, #412]	; (800f1cc <nk_combo_begin+0x224>)
 800f02e:	2115      	movs	r1, #21
 800f030:	4867      	ldr	r0, [pc, #412]	; (800f1d0 <nk_combo_begin+0x228>)
 800f032:	f00e fcf1 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout)
 800f036:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f038:	2b00      	cmp	r3, #0
 800f03a:	d00f      	beq.n	800f05c <nk_combo_begin+0xb4>
 800f03c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f03e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800f042:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800f046:	2b00      	cmp	r3, #0
 800f048:	d008      	beq.n	800f05c <nk_combo_begin+0xb4>
 800f04a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f04c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800f050:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800f054:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800f058:	2b00      	cmp	r3, #0
 800f05a:	d101      	bne.n	800f060 <nk_combo_begin+0xb8>
        return 0;
 800f05c:	2300      	movs	r3, #0
 800f05e:	e0af      	b.n	800f1c0 <nk_combo_begin+0x218>

    popup = win->popup.win;
 800f060:	6a3b      	ldr	r3, [r7, #32]
 800f062:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 800f066:	64fb      	str	r3, [r7, #76]	; 0x4c
    body.x = header.x;
 800f068:	687b      	ldr	r3, [r7, #4]
 800f06a:	62bb      	str	r3, [r7, #40]	; 0x28
    body.w = size.x;
 800f06c:	69bb      	ldr	r3, [r7, #24]
 800f06e:	633b      	str	r3, [r7, #48]	; 0x30
    body.y = header.y + header.h-ctx->style.window.combo_border;
 800f070:	ed97 7a02 	vldr	s14, [r7, #8]
 800f074:	edd7 7a04 	vldr	s15, [r7, #16]
 800f078:	ee37 7a27 	vadd.f32	s14, s14, s15
 800f07c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f07e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f082:	f603 231c 	addw	r3, r3, #2588	; 0xa1c
 800f086:	edd3 7a00 	vldr	s15, [r3]
 800f08a:	ee77 7a67 	vsub.f32	s15, s14, s15
 800f08e:	edc7 7a0b 	vstr	s15, [r7, #44]	; 0x2c
    body.h = size.y;
 800f092:	69fb      	ldr	r3, [r7, #28]
 800f094:	637b      	str	r3, [r7, #52]	; 0x34

    hash = win->popup.combo_count++;
 800f096:	6a3b      	ldr	r3, [r7, #32]
 800f098:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
 800f09c:	1c59      	adds	r1, r3, #1
 800f09e:	6a3a      	ldr	r2, [r7, #32]
 800f0a0:	f8c2 1120 	str.w	r1, [r2, #288]	; 0x120
 800f0a4:	64bb      	str	r3, [r7, #72]	; 0x48
    is_open = (popup) ? nk_true:nk_false;
 800f0a6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f0a8:	2b00      	cmp	r3, #0
 800f0aa:	bf14      	ite	ne
 800f0ac:	2301      	movne	r3, #1
 800f0ae:	2300      	moveq	r3, #0
 800f0b0:	b2db      	uxtb	r3, r3
 800f0b2:	657b      	str	r3, [r7, #84]	; 0x54
    is_active = (popup && (win->popup.name == hash) && win->popup.type == NK_PANEL_COMBO);
 800f0b4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f0b6:	2b00      	cmp	r3, #0
 800f0b8:	d00c      	beq.n	800f0d4 <nk_combo_begin+0x12c>
 800f0ba:	6a3b      	ldr	r3, [r7, #32]
 800f0bc:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800f0c0:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800f0c2:	429a      	cmp	r2, r3
 800f0c4:	d106      	bne.n	800f0d4 <nk_combo_begin+0x12c>
 800f0c6:	6a3b      	ldr	r3, [r7, #32]
 800f0c8:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
 800f0cc:	2b20      	cmp	r3, #32
 800f0ce:	d101      	bne.n	800f0d4 <nk_combo_begin+0x12c>
 800f0d0:	2301      	movs	r3, #1
 800f0d2:	e000      	b.n	800f0d6 <nk_combo_begin+0x12e>
 800f0d4:	2300      	movs	r3, #0
 800f0d6:	653b      	str	r3, [r7, #80]	; 0x50
    if ((is_clicked && is_open && !is_active) || (is_open && !is_active) ||
 800f0d8:	697b      	ldr	r3, [r7, #20]
 800f0da:	2b00      	cmp	r3, #0
 800f0dc:	d005      	beq.n	800f0ea <nk_combo_begin+0x142>
 800f0de:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f0e0:	2b00      	cmp	r3, #0
 800f0e2:	d002      	beq.n	800f0ea <nk_combo_begin+0x142>
 800f0e4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f0e6:	2b00      	cmp	r3, #0
 800f0e8:	d00e      	beq.n	800f108 <nk_combo_begin+0x160>
 800f0ea:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f0ec:	2b00      	cmp	r3, #0
 800f0ee:	d002      	beq.n	800f0f6 <nk_combo_begin+0x14e>
 800f0f0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f0f2:	2b00      	cmp	r3, #0
 800f0f4:	d008      	beq.n	800f108 <nk_combo_begin+0x160>
 800f0f6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f0f8:	2b00      	cmp	r3, #0
 800f0fa:	d107      	bne.n	800f10c <nk_combo_begin+0x164>
        (!is_open && !is_active && !is_clicked)) return 0;
 800f0fc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f0fe:	2b00      	cmp	r3, #0
 800f100:	d104      	bne.n	800f10c <nk_combo_begin+0x164>
 800f102:	697b      	ldr	r3, [r7, #20]
 800f104:	2b00      	cmp	r3, #0
 800f106:	d101      	bne.n	800f10c <nk_combo_begin+0x164>
 800f108:	2300      	movs	r3, #0
 800f10a:	e059      	b.n	800f1c0 <nk_combo_begin+0x218>
    if (!nk_nonblock_begin(ctx, 0, body,
 800f10c:	697b      	ldr	r3, [r7, #20]
 800f10e:	2b00      	cmp	r3, #0
 800f110:	d01d      	beq.n	800f14e <nk_combo_begin+0x1a6>
        (is_clicked && is_open)?nk_rect(0,0,0,0):header, NK_PANEL_COMBO)) return 0;
 800f112:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f114:	2b00      	cmp	r3, #0
 800f116:	d01a      	beq.n	800f14e <nk_combo_begin+0x1a6>
 800f118:	eddf 1a30 	vldr	s3, [pc, #192]	; 800f1dc <nk_combo_begin+0x234>
 800f11c:	ed9f 1a2f 	vldr	s2, [pc, #188]	; 800f1dc <nk_combo_begin+0x234>
 800f120:	eddf 0a2e 	vldr	s1, [pc, #184]	; 800f1dc <nk_combo_begin+0x234>
 800f124:	ed9f 0a2d 	vldr	s0, [pc, #180]	; 800f1dc <nk_combo_begin+0x234>
 800f128:	f004 fb14 	bl	8013754 <nk_rect>
 800f12c:	eeb0 6a40 	vmov.f32	s12, s0
 800f130:	eef0 6a60 	vmov.f32	s13, s1
 800f134:	eeb0 7a41 	vmov.f32	s14, s2
 800f138:	eef0 7a61 	vmov.f32	s15, s3
 800f13c:	ed87 6a0e 	vstr	s12, [r7, #56]	; 0x38
 800f140:	edc7 6a0f 	vstr	s13, [r7, #60]	; 0x3c
 800f144:	ed87 7a10 	vstr	s14, [r7, #64]	; 0x40
 800f148:	edc7 7a11 	vstr	s15, [r7, #68]	; 0x44
    if (!nk_nonblock_begin(ctx, 0, body,
 800f14c:	e005      	b.n	800f15a <nk_combo_begin+0x1b2>
 800f14e:	f107 0438 	add.w	r4, r7, #56	; 0x38
 800f152:	1d3b      	adds	r3, r7, #4
 800f154:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800f156:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 800f15a:	ed97 4a0e 	vldr	s8, [r7, #56]	; 0x38
 800f15e:	edd7 4a0f 	vldr	s9, [r7, #60]	; 0x3c
 800f162:	ed97 5a10 	vldr	s10, [r7, #64]	; 0x40
 800f166:	edd7 5a11 	vldr	s11, [r7, #68]	; 0x44
 800f16a:	ed97 6a0a 	vldr	s12, [r7, #40]	; 0x28
 800f16e:	edd7 6a0b 	vldr	s13, [r7, #44]	; 0x2c
 800f172:	ed97 7a0c 	vldr	s14, [r7, #48]	; 0x30
 800f176:	edd7 7a0d 	vldr	s15, [r7, #52]	; 0x34
 800f17a:	2220      	movs	r2, #32
 800f17c:	eeb0 2a44 	vmov.f32	s4, s8
 800f180:	eef0 2a64 	vmov.f32	s5, s9
 800f184:	eeb0 3a45 	vmov.f32	s6, s10
 800f188:	eef0 3a65 	vmov.f32	s7, s11
 800f18c:	eeb0 0a46 	vmov.f32	s0, s12
 800f190:	eef0 0a66 	vmov.f32	s1, s13
 800f194:	eeb0 1a47 	vmov.f32	s2, s14
 800f198:	eef0 1a67 	vmov.f32	s3, s15
 800f19c:	2100      	movs	r1, #0
 800f19e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800f1a0:	f007 f93a 	bl	8016418 <nk_nonblock_begin>
 800f1a4:	4603      	mov	r3, r0
 800f1a6:	2b00      	cmp	r3, #0
 800f1a8:	d101      	bne.n	800f1ae <nk_combo_begin+0x206>
        (is_clicked && is_open)?nk_rect(0,0,0,0):header, NK_PANEL_COMBO)) return 0;
 800f1aa:	2300      	movs	r3, #0
 800f1ac:	e008      	b.n	800f1c0 <nk_combo_begin+0x218>

    win->popup.type = NK_PANEL_COMBO;
 800f1ae:	6a3b      	ldr	r3, [r7, #32]
 800f1b0:	2220      	movs	r2, #32
 800f1b2:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100
    win->popup.name = hash;
 800f1b6:	6a3b      	ldr	r3, [r7, #32]
 800f1b8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800f1ba:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
    return 1;
 800f1be:	2301      	movs	r3, #1
}
 800f1c0:	4618      	mov	r0, r3
 800f1c2:	375c      	adds	r7, #92	; 0x5c
 800f1c4:	46bd      	mov	sp, r7
 800f1c6:	bd90      	pop	{r4, r7, pc}
 800f1c8:	080215bc 	.word	0x080215bc
 800f1cc:	08023278 	.word	0x08023278
 800f1d0:	080215c0 	.word	0x080215c0
 800f1d4:	080215dc 	.word	0x080215dc
 800f1d8:	080215ec 	.word	0x080215ec
 800f1dc:	00000000 	.word	0x00000000

0800f1e0 <nk_combo_begin_text>:
NK_API nk_bool
nk_combo_begin_text(struct nk_context *ctx, const char *selected, int len,
    struct nk_vec2 size)
{
 800f1e0:	b5b0      	push	{r4, r5, r7, lr}
 800f1e2:	b0a6      	sub	sp, #152	; 0x98
 800f1e4:	af04      	add	r7, sp, #16
 800f1e6:	6178      	str	r0, [r7, #20]
 800f1e8:	6139      	str	r1, [r7, #16]
 800f1ea:	60fa      	str	r2, [r7, #12]
 800f1ec:	eeb0 7a40 	vmov.f32	s14, s0
 800f1f0:	eef0 7a60 	vmov.f32	s15, s1
 800f1f4:	ed87 7a01 	vstr	s14, [r7, #4]
 800f1f8:	edc7 7a02 	vstr	s15, [r7, #8]
    const struct nk_input *in;
    struct nk_window *win;
    struct nk_style *style;

    enum nk_widget_layout_states s;
    int is_clicked = nk_false;
 800f1fc:	2300      	movs	r3, #0
 800f1fe:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
    struct nk_rect header;
    const struct nk_style_item *background;
    struct nk_text text;

    NK_ASSERT(ctx);
 800f202:	697b      	ldr	r3, [r7, #20]
 800f204:	2b00      	cmp	r3, #0
 800f206:	d105      	bne.n	800f214 <nk_combo_begin_text+0x34>
 800f208:	4bc3      	ldr	r3, [pc, #780]	; (800f518 <nk_combo_begin_text+0x338>)
 800f20a:	4ac4      	ldr	r2, [pc, #784]	; (800f51c <nk_combo_begin_text+0x33c>)
 800f20c:	2139      	movs	r1, #57	; 0x39
 800f20e:	48c4      	ldr	r0, [pc, #784]	; (800f520 <nk_combo_begin_text+0x340>)
 800f210:	f00e fc02 	bl	801da18 <__assert_func>
    NK_ASSERT(selected);
 800f214:	693b      	ldr	r3, [r7, #16]
 800f216:	2b00      	cmp	r3, #0
 800f218:	d105      	bne.n	800f226 <nk_combo_begin_text+0x46>
 800f21a:	4bc2      	ldr	r3, [pc, #776]	; (800f524 <nk_combo_begin_text+0x344>)
 800f21c:	4abf      	ldr	r2, [pc, #764]	; (800f51c <nk_combo_begin_text+0x33c>)
 800f21e:	213a      	movs	r1, #58	; 0x3a
 800f220:	48bf      	ldr	r0, [pc, #764]	; (800f520 <nk_combo_begin_text+0x340>)
 800f222:	f00e fbf9 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 800f226:	697b      	ldr	r3, [r7, #20]
 800f228:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800f22c:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800f230:	2b00      	cmp	r3, #0
 800f232:	d105      	bne.n	800f240 <nk_combo_begin_text+0x60>
 800f234:	4bbc      	ldr	r3, [pc, #752]	; (800f528 <nk_combo_begin_text+0x348>)
 800f236:	4ab9      	ldr	r2, [pc, #740]	; (800f51c <nk_combo_begin_text+0x33c>)
 800f238:	213b      	movs	r1, #59	; 0x3b
 800f23a:	48b9      	ldr	r0, [pc, #740]	; (800f520 <nk_combo_begin_text+0x340>)
 800f23c:	f00e fbec 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 800f240:	697b      	ldr	r3, [r7, #20]
 800f242:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800f246:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800f24a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800f24e:	2b00      	cmp	r3, #0
 800f250:	d105      	bne.n	800f25e <nk_combo_begin_text+0x7e>
 800f252:	4bb6      	ldr	r3, [pc, #728]	; (800f52c <nk_combo_begin_text+0x34c>)
 800f254:	4ab1      	ldr	r2, [pc, #708]	; (800f51c <nk_combo_begin_text+0x33c>)
 800f256:	213c      	movs	r1, #60	; 0x3c
 800f258:	48b1      	ldr	r0, [pc, #708]	; (800f520 <nk_combo_begin_text+0x340>)
 800f25a:	f00e fbdd 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout || !selected)
 800f25e:	697b      	ldr	r3, [r7, #20]
 800f260:	2b00      	cmp	r3, #0
 800f262:	d012      	beq.n	800f28a <nk_combo_begin_text+0xaa>
 800f264:	697b      	ldr	r3, [r7, #20]
 800f266:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800f26a:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800f26e:	2b00      	cmp	r3, #0
 800f270:	d00b      	beq.n	800f28a <nk_combo_begin_text+0xaa>
 800f272:	697b      	ldr	r3, [r7, #20]
 800f274:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800f278:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800f27c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800f280:	2b00      	cmp	r3, #0
 800f282:	d002      	beq.n	800f28a <nk_combo_begin_text+0xaa>
 800f284:	693b      	ldr	r3, [r7, #16]
 800f286:	2b00      	cmp	r3, #0
 800f288:	d101      	bne.n	800f28e <nk_combo_begin_text+0xae>
        return 0;
 800f28a:	2300      	movs	r3, #0
 800f28c:	e28f      	b.n	800f7ae <nk_combo_begin_text+0x5ce>

    win = ctx->current;
 800f28e:	697b      	ldr	r3, [r7, #20]
 800f290:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800f294:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800f298:	67bb      	str	r3, [r7, #120]	; 0x78
    style = &ctx->style;
 800f29a:	697b      	ldr	r3, [r7, #20]
 800f29c:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 800f2a0:	677b      	str	r3, [r7, #116]	; 0x74
    s = nk_widget(&header, ctx);
 800f2a2:	f107 0358 	add.w	r3, r7, #88	; 0x58
 800f2a6:	6979      	ldr	r1, [r7, #20]
 800f2a8:	4618      	mov	r0, r3
 800f2aa:	f00d f8cd 	bl	801c448 <nk_widget>
 800f2ae:	4603      	mov	r3, r0
 800f2b0:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
    if (s == NK_WIDGET_INVALID)
 800f2b4:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800f2b8:	2b00      	cmp	r3, #0
 800f2ba:	d101      	bne.n	800f2c0 <nk_combo_begin_text+0xe0>
        return 0;
 800f2bc:	2300      	movs	r3, #0
 800f2be:	e276      	b.n	800f7ae <nk_combo_begin_text+0x5ce>

    in = (win->layout->flags & NK_WINDOW_ROM || s == NK_WIDGET_ROM)? 0: &ctx->input;
 800f2c0:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800f2c2:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800f2c6:	685b      	ldr	r3, [r3, #4]
 800f2c8:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 800f2cc:	2b00      	cmp	r3, #0
 800f2ce:	d105      	bne.n	800f2dc <nk_combo_begin_text+0xfc>
 800f2d0:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800f2d4:	2b02      	cmp	r3, #2
 800f2d6:	d001      	beq.n	800f2dc <nk_combo_begin_text+0xfc>
 800f2d8:	697b      	ldr	r3, [r7, #20]
 800f2da:	e000      	b.n	800f2de <nk_combo_begin_text+0xfe>
 800f2dc:	2300      	movs	r3, #0
 800f2de:	66fb      	str	r3, [r7, #108]	; 0x6c
    if (nk_button_behavior(&ctx->last_widget_state, header, in, NK_BUTTON_DEFAULT))
 800f2e0:	697b      	ldr	r3, [r7, #20]
 800f2e2:	f503 53d6 	add.w	r3, r3, #6848	; 0x1ac0
 800f2e6:	3314      	adds	r3, #20
 800f2e8:	ed97 6a16 	vldr	s12, [r7, #88]	; 0x58
 800f2ec:	edd7 6a17 	vldr	s13, [r7, #92]	; 0x5c
 800f2f0:	ed97 7a18 	vldr	s14, [r7, #96]	; 0x60
 800f2f4:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
 800f2f8:	2200      	movs	r2, #0
 800f2fa:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
 800f2fc:	eeb0 0a46 	vmov.f32	s0, s12
 800f300:	eef0 0a66 	vmov.f32	s1, s13
 800f304:	eeb0 1a47 	vmov.f32	s2, s14
 800f308:	eef0 1a67 	vmov.f32	s3, s15
 800f30c:	4618      	mov	r0, r3
 800f30e:	f7fe ff9f 	bl	800e250 <nk_button_behavior>
 800f312:	4603      	mov	r3, r0
 800f314:	2b00      	cmp	r3, #0
 800f316:	d002      	beq.n	800f31e <nk_combo_begin_text+0x13e>
        is_clicked = nk_true;
 800f318:	2301      	movs	r3, #1
 800f31a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84

    /* draw combo box header background and border */
    if (ctx->last_widget_state & NK_WIDGET_STATE_ACTIVED) {
 800f31e:	697b      	ldr	r3, [r7, #20]
 800f320:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f324:	f8d3 3ad4 	ldr.w	r3, [r3, #2772]	; 0xad4
 800f328:	f003 0320 	and.w	r3, r3, #32
 800f32c:	2b00      	cmp	r3, #0
 800f32e:	d00c      	beq.n	800f34a <nk_combo_begin_text+0x16a>
        background = &style->combo.active;
 800f330:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f332:	f503 53ad 	add.w	r3, r3, #5536	; 0x15a0
 800f336:	3318      	adds	r3, #24
 800f338:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
        text.text = style->combo.label_active;
 800f33c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f33e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f342:	f8d3 35e0 	ldr.w	r3, [r3, #1504]	; 0x5e0
 800f346:	657b      	str	r3, [r7, #84]	; 0x54
 800f348:	e020      	b.n	800f38c <nk_combo_begin_text+0x1ac>
    } else if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER) {
 800f34a:	697b      	ldr	r3, [r7, #20]
 800f34c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f350:	f8d3 3ad4 	ldr.w	r3, [r3, #2772]	; 0xad4
 800f354:	f003 0310 	and.w	r3, r3, #16
 800f358:	2b00      	cmp	r3, #0
 800f35a:	d00c      	beq.n	800f376 <nk_combo_begin_text+0x196>
        background = &style->combo.hover;
 800f35c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f35e:	f503 53ac 	add.w	r3, r3, #5504	; 0x1580
 800f362:	331c      	adds	r3, #28
 800f364:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
        text.text = style->combo.label_hover;
 800f368:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f36a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f36e:	f8d3 35dc 	ldr.w	r3, [r3, #1500]	; 0x5dc
 800f372:	657b      	str	r3, [r7, #84]	; 0x54
 800f374:	e00a      	b.n	800f38c <nk_combo_begin_text+0x1ac>
    } else {
        background = &style->combo.normal;
 800f376:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f378:	f503 53ac 	add.w	r3, r3, #5504	; 0x1580
 800f37c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
        text.text = style->combo.label_normal;
 800f380:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f382:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f386:	f8d3 35d8 	ldr.w	r3, [r3, #1496]	; 0x5d8
 800f38a:	657b      	str	r3, [r7, #84]	; 0x54
    }

    switch(background->type) {
 800f38c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800f390:	781b      	ldrb	r3, [r3, #0]
 800f392:	2b02      	cmp	r3, #2
 800f394:	d02b      	beq.n	800f3ee <nk_combo_begin_text+0x20e>
 800f396:	2b02      	cmp	r3, #2
 800f398:	f300 80a1 	bgt.w	800f4de <nk_combo_begin_text+0x2fe>
 800f39c:	2b00      	cmp	r3, #0
 800f39e:	d04a      	beq.n	800f436 <nk_combo_begin_text+0x256>
 800f3a0:	2b01      	cmp	r3, #1
 800f3a2:	f040 809c 	bne.w	800f4de <nk_combo_begin_text+0x2fe>
        case NK_STYLE_ITEM_IMAGE:
            text.background = nk_rgba(0, 0, 0, 0);
 800f3a6:	2300      	movs	r3, #0
 800f3a8:	2200      	movs	r2, #0
 800f3aa:	2100      	movs	r1, #0
 800f3ac:	2000      	movs	r0, #0
 800f3ae:	f7ff fd67 	bl	800ee80 <nk_rgba>
 800f3b2:	4603      	mov	r3, r0
 800f3b4:	653b      	str	r3, [r7, #80]	; 0x50
            nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
 800f3b6:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800f3b8:	f103 0064 	add.w	r0, r3, #100	; 0x64
 800f3bc:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800f3c0:	3304      	adds	r3, #4
 800f3c2:	4a5b      	ldr	r2, [pc, #364]	; (800f530 <nk_combo_begin_text+0x350>)
 800f3c4:	ed97 6a16 	vldr	s12, [r7, #88]	; 0x58
 800f3c8:	edd7 6a17 	vldr	s13, [r7, #92]	; 0x5c
 800f3cc:	ed97 7a18 	vldr	s14, [r7, #96]	; 0x60
 800f3d0:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
 800f3d4:	6812      	ldr	r2, [r2, #0]
 800f3d6:	4619      	mov	r1, r3
 800f3d8:	eeb0 0a46 	vmov.f32	s0, s12
 800f3dc:	eef0 0a66 	vmov.f32	s1, s13
 800f3e0:	eeb0 1a47 	vmov.f32	s2, s14
 800f3e4:	eef0 1a67 	vmov.f32	s3, s15
 800f3e8:	f001 ffb2 	bl	8011350 <nk_draw_image>
            break;
 800f3ec:	e077      	b.n	800f4de <nk_combo_begin_text+0x2fe>
        case NK_STYLE_ITEM_NINE_SLICE:
            text.background = nk_rgba(0, 0, 0, 0);
 800f3ee:	2300      	movs	r3, #0
 800f3f0:	2200      	movs	r2, #0
 800f3f2:	2100      	movs	r1, #0
 800f3f4:	2000      	movs	r0, #0
 800f3f6:	f7ff fd43 	bl	800ee80 <nk_rgba>
 800f3fa:	4603      	mov	r3, r0
 800f3fc:	653b      	str	r3, [r7, #80]	; 0x50
            nk_draw_nine_slice(&win->buffer, header, &background->data.slice, nk_white);
 800f3fe:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800f400:	f103 0064 	add.w	r0, r3, #100	; 0x64
 800f404:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800f408:	3304      	adds	r3, #4
 800f40a:	4a49      	ldr	r2, [pc, #292]	; (800f530 <nk_combo_begin_text+0x350>)
 800f40c:	ed97 6a16 	vldr	s12, [r7, #88]	; 0x58
 800f410:	edd7 6a17 	vldr	s13, [r7, #92]	; 0x5c
 800f414:	ed97 7a18 	vldr	s14, [r7, #96]	; 0x60
 800f418:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
 800f41c:	6812      	ldr	r2, [r2, #0]
 800f41e:	4619      	mov	r1, r3
 800f420:	eeb0 0a46 	vmov.f32	s0, s12
 800f424:	eef0 0a66 	vmov.f32	s1, s13
 800f428:	eeb0 1a47 	vmov.f32	s2, s14
 800f42c:	eef0 1a67 	vmov.f32	s3, s15
 800f430:	f002 f880 	bl	8011534 <nk_draw_nine_slice>
            break;
 800f434:	e053      	b.n	800f4de <nk_combo_begin_text+0x2fe>
        case NK_STYLE_ITEM_COLOR:
            text.background = background->data.color;
 800f436:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800f43a:	685b      	ldr	r3, [r3, #4]
 800f43c:	653b      	str	r3, [r7, #80]	; 0x50
            nk_fill_rect(&win->buffer, header, style->combo.rounding, background->data.color);
 800f43e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800f440:	f103 0264 	add.w	r2, r3, #100	; 0x64
 800f444:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f446:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f44a:	f503 63d2 	add.w	r3, r3, #1680	; 0x690
 800f44e:	edd3 5a00 	vldr	s11, [r3]
 800f452:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800f456:	ed97 6a16 	vldr	s12, [r7, #88]	; 0x58
 800f45a:	edd7 6a17 	vldr	s13, [r7, #92]	; 0x5c
 800f45e:	ed97 7a18 	vldr	s14, [r7, #96]	; 0x60
 800f462:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
 800f466:	6859      	ldr	r1, [r3, #4]
 800f468:	eeb0 2a65 	vmov.f32	s4, s11
 800f46c:	eeb0 0a46 	vmov.f32	s0, s12
 800f470:	eef0 0a66 	vmov.f32	s1, s13
 800f474:	eeb0 1a47 	vmov.f32	s2, s14
 800f478:	eef0 1a67 	vmov.f32	s3, s15
 800f47c:	4610      	mov	r0, r2
 800f47e:	f001 fc0d 	bl	8010c9c <nk_fill_rect>
            nk_stroke_rect(&win->buffer, header, style->combo.rounding, style->combo.border, style->combo.border_color);
 800f482:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800f484:	f103 0264 	add.w	r2, r3, #100	; 0x64
 800f488:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f48a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f48e:	f503 63d2 	add.w	r3, r3, #1680	; 0x690
 800f492:	edd3 5a00 	vldr	s11, [r3]
 800f496:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f498:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f49c:	f203 638c 	addw	r3, r3, #1676	; 0x68c
 800f4a0:	ed93 5a00 	vldr	s10, [r3]
 800f4a4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f4a6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f4aa:	ed97 6a16 	vldr	s12, [r7, #88]	; 0x58
 800f4ae:	edd7 6a17 	vldr	s13, [r7, #92]	; 0x5c
 800f4b2:	ed97 7a18 	vldr	s14, [r7, #96]	; 0x60
 800f4b6:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
 800f4ba:	f8d3 15d4 	ldr.w	r1, [r3, #1492]	; 0x5d4
 800f4be:	eef0 2a45 	vmov.f32	s5, s10
 800f4c2:	eeb0 2a65 	vmov.f32	s4, s11
 800f4c6:	eeb0 0a46 	vmov.f32	s0, s12
 800f4ca:	eef0 0a66 	vmov.f32	s1, s13
 800f4ce:	eeb0 1a47 	vmov.f32	s2, s14
 800f4d2:	eef0 1a67 	vmov.f32	s3, s15
 800f4d6:	4610      	mov	r0, r2
 800f4d8:	f001 fad8 	bl	8010a8c <nk_stroke_rect>
            break;
 800f4dc:	bf00      	nop
        struct nk_rect button;
        struct nk_rect content;
        int draw_button_symbol;

        enum nk_symbol_type sym;
        if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
 800f4de:	697b      	ldr	r3, [r7, #20]
 800f4e0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f4e4:	f8d3 3ad4 	ldr.w	r3, [r3, #2772]	; 0xad4
 800f4e8:	f003 0310 	and.w	r3, r3, #16
 800f4ec:	2b00      	cmp	r3, #0
 800f4ee:	d007      	beq.n	800f500 <nk_combo_begin_text+0x320>
            sym = style->combo.sym_hover;
 800f4f0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f4f2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f4f6:	f893 3689 	ldrb.w	r3, [r3, #1673]	; 0x689
 800f4fa:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
 800f4fe:	e022      	b.n	800f546 <nk_combo_begin_text+0x366>
        else if (is_clicked)
 800f500:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800f504:	2b00      	cmp	r3, #0
 800f506:	d017      	beq.n	800f538 <nk_combo_begin_text+0x358>
            sym = style->combo.sym_active;
 800f508:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f50a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f50e:	f893 368a 	ldrb.w	r3, [r3, #1674]	; 0x68a
 800f512:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
 800f516:	e016      	b.n	800f546 <nk_combo_begin_text+0x366>
 800f518:	080215bc 	.word	0x080215bc
 800f51c:	08023288 	.word	0x08023288
 800f520:	080215c0 	.word	0x080215c0
 800f524:	08021604 	.word	0x08021604
 800f528:	080215dc 	.word	0x080215dc
 800f52c:	080215ec 	.word	0x080215ec
 800f530:	08023274 	.word	0x08023274
 800f534:	00000000 	.word	0x00000000
        else
            sym = style->combo.sym_normal;
 800f538:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f53a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f53e:	f893 3688 	ldrb.w	r3, [r3, #1672]	; 0x688
 800f542:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f

        /* represents whether or not the combo's button symbol should be drawn */
        draw_button_symbol = sym != NK_SYMBOL_NONE;
 800f546:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
 800f54a:	2b00      	cmp	r3, #0
 800f54c:	bf14      	ite	ne
 800f54e:	2301      	movne	r3, #1
 800f550:	2300      	moveq	r3, #0
 800f552:	b2db      	uxtb	r3, r3
 800f554:	66bb      	str	r3, [r7, #104]	; 0x68

        /* calculate button */
        button.w = header.h - 2 * style->combo.button_padding.y;
 800f556:	ed97 7a19 	vldr	s14, [r7, #100]	; 0x64
 800f55a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f55c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f560:	f503 63d4 	add.w	r3, r3, #1696	; 0x6a0
 800f564:	edd3 7a00 	vldr	s15, [r3]
 800f568:	ee77 7aa7 	vadd.f32	s15, s15, s15
 800f56c:	ee77 7a67 	vsub.f32	s15, s14, s15
 800f570:	edc7 7a0c 	vstr	s15, [r7, #48]	; 0x30
        button.x = (header.x + header.w - header.h) - style->combo.button_padding.x;
 800f574:	ed97 7a16 	vldr	s14, [r7, #88]	; 0x58
 800f578:	edd7 7a18 	vldr	s15, [r7, #96]	; 0x60
 800f57c:	ee37 7a27 	vadd.f32	s14, s14, s15
 800f580:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
 800f584:	ee37 7a67 	vsub.f32	s14, s14, s15
 800f588:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f58a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f58e:	f203 639c 	addw	r3, r3, #1692	; 0x69c
 800f592:	edd3 7a00 	vldr	s15, [r3]
 800f596:	ee77 7a67 	vsub.f32	s15, s14, s15
 800f59a:	edc7 7a0a 	vstr	s15, [r7, #40]	; 0x28
        button.y = header.y + style->combo.button_padding.y;
 800f59e:	ed97 7a17 	vldr	s14, [r7, #92]	; 0x5c
 800f5a2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f5a4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f5a8:	f503 63d4 	add.w	r3, r3, #1696	; 0x6a0
 800f5ac:	edd3 7a00 	vldr	s15, [r3]
 800f5b0:	ee77 7a27 	vadd.f32	s15, s14, s15
 800f5b4:	edc7 7a0b 	vstr	s15, [r7, #44]	; 0x2c
        button.h = button.w;
 800f5b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f5ba:	637b      	str	r3, [r7, #52]	; 0x34

        content.x = button.x + style->combo.button.padding.x;
 800f5bc:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
 800f5c0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f5c2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f5c6:	f203 6364 	addw	r3, r3, #1636	; 0x664
 800f5ca:	edd3 7a00 	vldr	s15, [r3]
 800f5ce:	ee77 7a27 	vadd.f32	s15, s14, s15
 800f5d2:	edc7 7a06 	vstr	s15, [r7, #24]
        content.y = button.y + style->combo.button.padding.y;
 800f5d6:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
 800f5da:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f5dc:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f5e0:	f503 63cd 	add.w	r3, r3, #1640	; 0x668
 800f5e4:	edd3 7a00 	vldr	s15, [r3]
 800f5e8:	ee77 7a27 	vadd.f32	s15, s14, s15
 800f5ec:	edc7 7a07 	vstr	s15, [r7, #28]
        content.w = button.w - 2 * style->combo.button.padding.x;
 800f5f0:	ed97 7a0c 	vldr	s14, [r7, #48]	; 0x30
 800f5f4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f5f6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f5fa:	f203 6364 	addw	r3, r3, #1636	; 0x664
 800f5fe:	edd3 7a00 	vldr	s15, [r3]
 800f602:	ee77 7aa7 	vadd.f32	s15, s15, s15
 800f606:	ee77 7a67 	vsub.f32	s15, s14, s15
 800f60a:	edc7 7a08 	vstr	s15, [r7, #32]
        content.h = button.h - 2 * style->combo.button.padding.y;
 800f60e:	ed97 7a0d 	vldr	s14, [r7, #52]	; 0x34
 800f612:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f614:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f618:	f503 63cd 	add.w	r3, r3, #1640	; 0x668
 800f61c:	edd3 7a00 	vldr	s15, [r3]
 800f620:	ee77 7aa7 	vadd.f32	s15, s15, s15
 800f624:	ee77 7a67 	vsub.f32	s15, s14, s15
 800f628:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24

        /* draw selected label */
        text.padding = nk_vec2(0,0);
 800f62c:	ed5f 0a3f 	vldr	s1, [pc, #-252]	; 800f534 <nk_combo_begin_text+0x354>
 800f630:	ed1f 0a40 	vldr	s0, [pc, #-256]	; 800f534 <nk_combo_begin_text+0x354>
 800f634:	f004 f940 	bl	80138b8 <nk_vec2>
 800f638:	eeb0 7a40 	vmov.f32	s14, s0
 800f63c:	eef0 7a60 	vmov.f32	s15, s1
 800f640:	ed87 7a12 	vstr	s14, [r7, #72]	; 0x48
 800f644:	edc7 7a13 	vstr	s15, [r7, #76]	; 0x4c
        label.x = header.x + style->combo.content_padding.x;
 800f648:	ed97 7a16 	vldr	s14, [r7, #88]	; 0x58
 800f64c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f64e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f652:	f203 6394 	addw	r3, r3, #1684	; 0x694
 800f656:	edd3 7a00 	vldr	s15, [r3]
 800f65a:	ee77 7a27 	vadd.f32	s15, s14, s15
 800f65e:	edc7 7a0e 	vstr	s15, [r7, #56]	; 0x38
        label.y = header.y + style->combo.content_padding.y;
 800f662:	ed97 7a17 	vldr	s14, [r7, #92]	; 0x5c
 800f666:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f668:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f66c:	f503 63d3 	add.w	r3, r3, #1688	; 0x698
 800f670:	edd3 7a00 	vldr	s15, [r3]
 800f674:	ee77 7a27 	vadd.f32	s15, s14, s15
 800f678:	edc7 7a0f 	vstr	s15, [r7, #60]	; 0x3c
        label.h = header.h - 2 * style->combo.content_padding.y;
 800f67c:	ed97 7a19 	vldr	s14, [r7, #100]	; 0x64
 800f680:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f682:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f686:	f503 63d3 	add.w	r3, r3, #1688	; 0x698
 800f68a:	edd3 7a00 	vldr	s15, [r3]
 800f68e:	ee77 7aa7 	vadd.f32	s15, s15, s15
 800f692:	ee77 7a67 	vsub.f32	s15, s14, s15
 800f696:	edc7 7a11 	vstr	s15, [r7, #68]	; 0x44
        if (draw_button_symbol)
 800f69a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f69c:	2b00      	cmp	r3, #0
 800f69e:	d01a      	beq.n	800f6d6 <nk_combo_begin_text+0x4f6>
            label.w = button.x - (style->combo.content_padding.x + style->combo.spacing.x) - label.x;
 800f6a0:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
 800f6a4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f6a6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f6aa:	f203 6394 	addw	r3, r3, #1684	; 0x694
 800f6ae:	edd3 6a00 	vldr	s13, [r3]
 800f6b2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f6b4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f6b8:	f203 63a4 	addw	r3, r3, #1700	; 0x6a4
 800f6bc:	edd3 7a00 	vldr	s15, [r3]
 800f6c0:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800f6c4:	ee37 7a67 	vsub.f32	s14, s14, s15
 800f6c8:	edd7 7a0e 	vldr	s15, [r7, #56]	; 0x38
 800f6cc:	ee77 7a67 	vsub.f32	s15, s14, s15
 800f6d0:	edc7 7a10 	vstr	s15, [r7, #64]	; 0x40
 800f6d4:	e00e      	b.n	800f6f4 <nk_combo_begin_text+0x514>
        else
            label.w = header.w - 2 * style->combo.content_padding.x;
 800f6d6:	ed97 7a18 	vldr	s14, [r7, #96]	; 0x60
 800f6da:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f6dc:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f6e0:	f203 6394 	addw	r3, r3, #1684	; 0x694
 800f6e4:	edd3 7a00 	vldr	s15, [r3]
 800f6e8:	ee77 7aa7 	vadd.f32	s15, s15, s15
 800f6ec:	ee77 7a67 	vsub.f32	s15, s14, s15
 800f6f0:	edc7 7a10 	vstr	s15, [r7, #64]	; 0x40
        nk_widget_text(&win->buffer, label, selected, len, &text,
 800f6f4:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800f6f6:	f103 0064 	add.w	r0, r3, #100	; 0x64
 800f6fa:	697b      	ldr	r3, [r7, #20]
 800f6fc:	f8d3 3168 	ldr.w	r3, [r3, #360]	; 0x168
 800f700:	f107 0248 	add.w	r2, r7, #72	; 0x48
 800f704:	ed97 6a0e 	vldr	s12, [r7, #56]	; 0x38
 800f708:	edd7 6a0f 	vldr	s13, [r7, #60]	; 0x3c
 800f70c:	ed97 7a10 	vldr	s14, [r7, #64]	; 0x40
 800f710:	edd7 7a11 	vldr	s15, [r7, #68]	; 0x44
 800f714:	9301      	str	r3, [sp, #4]
 800f716:	2311      	movs	r3, #17
 800f718:	9300      	str	r3, [sp, #0]
 800f71a:	4613      	mov	r3, r2
 800f71c:	68fa      	ldr	r2, [r7, #12]
 800f71e:	6939      	ldr	r1, [r7, #16]
 800f720:	eeb0 0a46 	vmov.f32	s0, s12
 800f724:	eef0 0a66 	vmov.f32	s1, s13
 800f728:	eeb0 1a47 	vmov.f32	s2, s14
 800f72c:	eef0 1a67 	vmov.f32	s3, s15
 800f730:	f00b fac0 	bl	801acb4 <nk_widget_text>
            NK_TEXT_LEFT, ctx->style.font);

        /* draw open/close button */
        if (draw_button_symbol)
 800f734:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f736:	2b00      	cmp	r3, #0
 800f738:	d01a      	beq.n	800f770 <nk_combo_begin_text+0x590>
            nk_draw_button_symbol(&win->buffer, &button, &content, ctx->last_widget_state,
 800f73a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800f73c:	f103 0064 	add.w	r0, r3, #100	; 0x64
 800f740:	697b      	ldr	r3, [r7, #20]
 800f742:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f746:	f8d3 5ad4 	ldr.w	r5, [r3, #2772]	; 0xad4
                &ctx->style.combo.button, sym, style->font);
 800f74a:	697b      	ldr	r3, [r7, #20]
 800f74c:	f503 53ba 	add.w	r3, r3, #5952	; 0x1740
 800f750:	3318      	adds	r3, #24
            nk_draw_button_symbol(&win->buffer, &button, &content, ctx->last_widget_state,
 800f752:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800f754:	6812      	ldr	r2, [r2, #0]
 800f756:	f107 0418 	add.w	r4, r7, #24
 800f75a:	f107 0128 	add.w	r1, r7, #40	; 0x28
 800f75e:	9202      	str	r2, [sp, #8]
 800f760:	f897 207f 	ldrb.w	r2, [r7, #127]	; 0x7f
 800f764:	9201      	str	r2, [sp, #4]
 800f766:	9300      	str	r3, [sp, #0]
 800f768:	462b      	mov	r3, r5
 800f76a:	4622      	mov	r2, r4
 800f76c:	f7ff f8b4 	bl	800e8d8 <nk_draw_button_symbol>
    }
    return nk_combo_begin(ctx, win, size, is_clicked, header);
 800f770:	ed97 5a16 	vldr	s10, [r7, #88]	; 0x58
 800f774:	edd7 5a17 	vldr	s11, [r7, #92]	; 0x5c
 800f778:	ed97 6a18 	vldr	s12, [r7, #96]	; 0x60
 800f77c:	edd7 6a19 	vldr	s13, [r7, #100]	; 0x64
 800f780:	ed97 7a01 	vldr	s14, [r7, #4]
 800f784:	edd7 7a02 	vldr	s15, [r7, #8]
 800f788:	eeb0 1a45 	vmov.f32	s2, s10
 800f78c:	eef0 1a65 	vmov.f32	s3, s11
 800f790:	eeb0 2a46 	vmov.f32	s4, s12
 800f794:	eef0 2a66 	vmov.f32	s5, s13
 800f798:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800f79c:	eeb0 0a47 	vmov.f32	s0, s14
 800f7a0:	eef0 0a67 	vmov.f32	s1, s15
 800f7a4:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 800f7a6:	6978      	ldr	r0, [r7, #20]
 800f7a8:	f7ff fbfe 	bl	800efa8 <nk_combo_begin>
 800f7ac:	4603      	mov	r3, r0
}
 800f7ae:	4618      	mov	r0, r3
 800f7b0:	3788      	adds	r7, #136	; 0x88
 800f7b2:	46bd      	mov	sp, r7
 800f7b4:	bdb0      	pop	{r4, r5, r7, pc}
 800f7b6:	bf00      	nop

0800f7b8 <nk_combo_begin_label>:
NK_API nk_bool
nk_combo_begin_label(struct nk_context *ctx, const char *selected, struct nk_vec2 size)
{
 800f7b8:	b580      	push	{r7, lr}
 800f7ba:	b084      	sub	sp, #16
 800f7bc:	af00      	add	r7, sp, #0
 800f7be:	60f8      	str	r0, [r7, #12]
 800f7c0:	60b9      	str	r1, [r7, #8]
 800f7c2:	eeb0 7a40 	vmov.f32	s14, s0
 800f7c6:	eef0 7a60 	vmov.f32	s15, s1
 800f7ca:	ed87 7a00 	vstr	s14, [r7]
 800f7ce:	edc7 7a01 	vstr	s15, [r7, #4]
    return nk_combo_begin_text(ctx, selected, nk_strlen(selected), size);
 800f7d2:	68b8      	ldr	r0, [r7, #8]
 800f7d4:	f00c fc46 	bl	801c064 <nk_strlen>
 800f7d8:	4603      	mov	r3, r0
 800f7da:	ed97 7a00 	vldr	s14, [r7]
 800f7de:	edd7 7a01 	vldr	s15, [r7, #4]
 800f7e2:	eeb0 0a47 	vmov.f32	s0, s14
 800f7e6:	eef0 0a67 	vmov.f32	s1, s15
 800f7ea:	461a      	mov	r2, r3
 800f7ec:	68b9      	ldr	r1, [r7, #8]
 800f7ee:	68f8      	ldr	r0, [r7, #12]
 800f7f0:	f7ff fcf6 	bl	800f1e0 <nk_combo_begin_text>
 800f7f4:	4603      	mov	r3, r0
}
 800f7f6:	4618      	mov	r0, r3
 800f7f8:	3710      	adds	r7, #16
 800f7fa:	46bd      	mov	sp, r7
 800f7fc:	bd80      	pop	{r7, pc}

0800f7fe <nk_combo_item_label>:
{
    return nk_contextual_item_text(ctx, text, len, align);
}
NK_API nk_bool
nk_combo_item_label(struct nk_context *ctx, const char *label, nk_flags align)
{
 800f7fe:	b580      	push	{r7, lr}
 800f800:	b084      	sub	sp, #16
 800f802:	af00      	add	r7, sp, #0
 800f804:	60f8      	str	r0, [r7, #12]
 800f806:	60b9      	str	r1, [r7, #8]
 800f808:	607a      	str	r2, [r7, #4]
    return nk_contextual_item_label(ctx, label, align);
 800f80a:	687a      	ldr	r2, [r7, #4]
 800f80c:	68b9      	ldr	r1, [r7, #8]
 800f80e:	68f8      	ldr	r0, [r7, #12]
 800f810:	f000 feaa 	bl	8010568 <nk_contextual_item_label>
 800f814:	4603      	mov	r3, r0
}
 800f816:	4618      	mov	r0, r3
 800f818:	3710      	adds	r7, #16
 800f81a:	46bd      	mov	sp, r7
 800f81c:	bd80      	pop	{r7, pc}

0800f81e <nk_combo_end>:
    const char *label, nk_flags alignment)
{
    return nk_contextual_item_symbol_label(ctx, sym, label, alignment);
}
NK_API void nk_combo_end(struct nk_context *ctx)
{
 800f81e:	b580      	push	{r7, lr}
 800f820:	b082      	sub	sp, #8
 800f822:	af00      	add	r7, sp, #0
 800f824:	6078      	str	r0, [r7, #4]
    nk_contextual_end(ctx);
 800f826:	6878      	ldr	r0, [r7, #4]
 800f828:	f000 ff00 	bl	801062c <nk_contextual_end>
}
 800f82c:	bf00      	nop
 800f82e:	3708      	adds	r7, #8
 800f830:	46bd      	mov	sp, r7
 800f832:	bd80      	pop	{r7, pc}

0800f834 <nk_combo>:
    nk_contextual_close(ctx);
}
NK_API int
nk_combo(struct nk_context *ctx, const char **items, int count,
    int selected, int item_height, struct nk_vec2 size)
{
 800f834:	b580      	push	{r7, lr}
 800f836:	b08c      	sub	sp, #48	; 0x30
 800f838:	af00      	add	r7, sp, #0
 800f83a:	6178      	str	r0, [r7, #20]
 800f83c:	6139      	str	r1, [r7, #16]
 800f83e:	60fa      	str	r2, [r7, #12]
 800f840:	60bb      	str	r3, [r7, #8]
 800f842:	eeb0 7a40 	vmov.f32	s14, s0
 800f846:	eef0 7a60 	vmov.f32	s15, s1
 800f84a:	ed87 7a00 	vstr	s14, [r7]
 800f84e:	edc7 7a01 	vstr	s15, [r7, #4]
    int i = 0;
 800f852:	2300      	movs	r3, #0
 800f854:	62fb      	str	r3, [r7, #44]	; 0x2c
    int max_height;
    struct nk_vec2 item_spacing;
    struct nk_vec2 window_padding;

    NK_ASSERT(ctx);
 800f856:	697b      	ldr	r3, [r7, #20]
 800f858:	2b00      	cmp	r3, #0
 800f85a:	d106      	bne.n	800f86a <nk_combo+0x36>
 800f85c:	4b61      	ldr	r3, [pc, #388]	; (800f9e4 <nk_combo+0x1b0>)
 800f85e:	4a62      	ldr	r2, [pc, #392]	; (800f9e8 <nk_combo+0x1b4>)
 800f860:	f44f 7130 	mov.w	r1, #704	; 0x2c0
 800f864:	4861      	ldr	r0, [pc, #388]	; (800f9ec <nk_combo+0x1b8>)
 800f866:	f00e f8d7 	bl	801da18 <__assert_func>
    NK_ASSERT(items);
 800f86a:	693b      	ldr	r3, [r7, #16]
 800f86c:	2b00      	cmp	r3, #0
 800f86e:	d106      	bne.n	800f87e <nk_combo+0x4a>
 800f870:	4b5f      	ldr	r3, [pc, #380]	; (800f9f0 <nk_combo+0x1bc>)
 800f872:	4a5d      	ldr	r2, [pc, #372]	; (800f9e8 <nk_combo+0x1b4>)
 800f874:	f240 21c1 	movw	r1, #705	; 0x2c1
 800f878:	485c      	ldr	r0, [pc, #368]	; (800f9ec <nk_combo+0x1b8>)
 800f87a:	f00e f8cd 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 800f87e:	697b      	ldr	r3, [r7, #20]
 800f880:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800f884:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800f888:	2b00      	cmp	r3, #0
 800f88a:	d106      	bne.n	800f89a <nk_combo+0x66>
 800f88c:	4b59      	ldr	r3, [pc, #356]	; (800f9f4 <nk_combo+0x1c0>)
 800f88e:	4a56      	ldr	r2, [pc, #344]	; (800f9e8 <nk_combo+0x1b4>)
 800f890:	f240 21c2 	movw	r1, #706	; 0x2c2
 800f894:	4855      	ldr	r0, [pc, #340]	; (800f9ec <nk_combo+0x1b8>)
 800f896:	f00e f8bf 	bl	801da18 <__assert_func>
    if (!ctx || !items ||!count)
 800f89a:	697b      	ldr	r3, [r7, #20]
 800f89c:	2b00      	cmp	r3, #0
 800f89e:	d005      	beq.n	800f8ac <nk_combo+0x78>
 800f8a0:	693b      	ldr	r3, [r7, #16]
 800f8a2:	2b00      	cmp	r3, #0
 800f8a4:	d002      	beq.n	800f8ac <nk_combo+0x78>
 800f8a6:	68fb      	ldr	r3, [r7, #12]
 800f8a8:	2b00      	cmp	r3, #0
 800f8aa:	d101      	bne.n	800f8b0 <nk_combo+0x7c>
        return selected;
 800f8ac:	68bb      	ldr	r3, [r7, #8]
 800f8ae:	e094      	b.n	800f9da <nk_combo+0x1a6>

    item_spacing = ctx->style.window.spacing;
 800f8b0:	697b      	ldr	r3, [r7, #20]
 800f8b2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800f8b6:	461a      	mov	r2, r3
 800f8b8:	f107 0320 	add.w	r3, r7, #32
 800f8bc:	f602 223c 	addw	r2, r2, #2620	; 0xa3c
 800f8c0:	e892 0003 	ldmia.w	r2, {r0, r1}
 800f8c4:	e883 0003 	stmia.w	r3, {r0, r1}
    window_padding = nk_panel_get_padding(&ctx->style, ctx->current->layout->type);
 800f8c8:	697b      	ldr	r3, [r7, #20]
 800f8ca:	f503 72b4 	add.w	r2, r3, #360	; 0x168
 800f8ce:	697b      	ldr	r3, [r7, #20]
 800f8d0:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800f8d4:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 800f8d8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800f8dc:	781b      	ldrb	r3, [r3, #0]
 800f8de:	4619      	mov	r1, r3
 800f8e0:	4610      	mov	r0, r2
 800f8e2:	f004 fba3 	bl	801402c <nk_panel_get_padding>
 800f8e6:	eeb0 7a40 	vmov.f32	s14, s0
 800f8ea:	eef0 7a60 	vmov.f32	s15, s1
 800f8ee:	ed87 7a06 	vstr	s14, [r7, #24]
 800f8f2:	edc7 7a07 	vstr	s15, [r7, #28]
    max_height = count * item_height + count * (int)item_spacing.y;
 800f8f6:	68fb      	ldr	r3, [r7, #12]
 800f8f8:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800f8fa:	fb03 f202 	mul.w	r2, r3, r2
 800f8fe:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 800f902:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800f906:	ee17 1a90 	vmov	r1, s15
 800f90a:	68fb      	ldr	r3, [r7, #12]
 800f90c:	fb01 f303 	mul.w	r3, r1, r3
 800f910:	4413      	add	r3, r2
 800f912:	62bb      	str	r3, [r7, #40]	; 0x28
    max_height += (int)item_spacing.y * 2 + (int)window_padding.y * 2;
 800f914:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 800f918:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800f91c:	ee17 2a90 	vmov	r2, s15
 800f920:	edd7 7a07 	vldr	s15, [r7, #28]
 800f924:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800f928:	ee17 3a90 	vmov	r3, s15
 800f92c:	4413      	add	r3, r2
 800f92e:	005b      	lsls	r3, r3, #1
 800f930:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800f932:	4413      	add	r3, r2
 800f934:	62bb      	str	r3, [r7, #40]	; 0x28
    size.y = NK_MIN(size.y, (float)max_height);
 800f936:	ed97 7a01 	vldr	s14, [r7, #4]
 800f93a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f93c:	ee07 3a90 	vmov	s15, r3
 800f940:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800f944:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800f948:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800f94c:	d502      	bpl.n	800f954 <nk_combo+0x120>
 800f94e:	edd7 7a01 	vldr	s15, [r7, #4]
 800f952:	e004      	b.n	800f95e <nk_combo+0x12a>
 800f954:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f956:	ee07 3a90 	vmov	s15, r3
 800f95a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800f95e:	edc7 7a01 	vstr	s15, [r7, #4]
    if (nk_combo_begin_label(ctx, items[selected], size)) {
 800f962:	68bb      	ldr	r3, [r7, #8]
 800f964:	009b      	lsls	r3, r3, #2
 800f966:	693a      	ldr	r2, [r7, #16]
 800f968:	4413      	add	r3, r2
 800f96a:	681b      	ldr	r3, [r3, #0]
 800f96c:	ed97 7a00 	vldr	s14, [r7]
 800f970:	edd7 7a01 	vldr	s15, [r7, #4]
 800f974:	eeb0 0a47 	vmov.f32	s0, s14
 800f978:	eef0 0a67 	vmov.f32	s1, s15
 800f97c:	4619      	mov	r1, r3
 800f97e:	6978      	ldr	r0, [r7, #20]
 800f980:	f7ff ff1a 	bl	800f7b8 <nk_combo_begin_label>
 800f984:	4603      	mov	r3, r0
 800f986:	2b00      	cmp	r3, #0
 800f988:	d026      	beq.n	800f9d8 <nk_combo+0x1a4>
        nk_layout_row_dynamic(ctx, (float)item_height, 1);
 800f98a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f98c:	ee07 3a90 	vmov	s15, r3
 800f990:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800f994:	2101      	movs	r1, #1
 800f996:	eeb0 0a67 	vmov.f32	s0, s15
 800f99a:	6978      	ldr	r0, [r7, #20]
 800f99c:	f003 f972 	bl	8012c84 <nk_layout_row_dynamic>
        for (i = 0; i < count; ++i) {
 800f9a0:	2300      	movs	r3, #0
 800f9a2:	62fb      	str	r3, [r7, #44]	; 0x2c
 800f9a4:	e011      	b.n	800f9ca <nk_combo+0x196>
            if (nk_combo_item_label(ctx, items[i], NK_TEXT_LEFT))
 800f9a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f9a8:	009b      	lsls	r3, r3, #2
 800f9aa:	693a      	ldr	r2, [r7, #16]
 800f9ac:	4413      	add	r3, r2
 800f9ae:	681b      	ldr	r3, [r3, #0]
 800f9b0:	2211      	movs	r2, #17
 800f9b2:	4619      	mov	r1, r3
 800f9b4:	6978      	ldr	r0, [r7, #20]
 800f9b6:	f7ff ff22 	bl	800f7fe <nk_combo_item_label>
 800f9ba:	4603      	mov	r3, r0
 800f9bc:	2b00      	cmp	r3, #0
 800f9be:	d001      	beq.n	800f9c4 <nk_combo+0x190>
                selected = i;
 800f9c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f9c2:	60bb      	str	r3, [r7, #8]
        for (i = 0; i < count; ++i) {
 800f9c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f9c6:	3301      	adds	r3, #1
 800f9c8:	62fb      	str	r3, [r7, #44]	; 0x2c
 800f9ca:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800f9cc:	68fb      	ldr	r3, [r7, #12]
 800f9ce:	429a      	cmp	r2, r3
 800f9d0:	dbe9      	blt.n	800f9a6 <nk_combo+0x172>
        }
        nk_combo_end(ctx);
 800f9d2:	6978      	ldr	r0, [r7, #20]
 800f9d4:	f7ff ff23 	bl	800f81e <nk_combo_end>
    }
    return selected;
 800f9d8:	68bb      	ldr	r3, [r7, #8]
}
 800f9da:	4618      	mov	r0, r3
 800f9dc:	3730      	adds	r7, #48	; 0x30
 800f9de:	46bd      	mov	sp, r7
 800f9e0:	bd80      	pop	{r7, pc}
 800f9e2:	bf00      	nop
 800f9e4:	080215bc 	.word	0x080215bc
 800f9e8:	0802329c 	.word	0x0802329c
 800f9ec:	080215c0 	.word	0x080215c0
 800f9f0:	08021610 	.word	0x08021610
 800f9f4:	080215dc 	.word	0x080215dc

0800f9f8 <nk_setup>:
 *                          CONTEXT
 *
 * ===============================================================*/
NK_INTERN void
nk_setup(struct nk_context *ctx, const struct nk_user_font *font)
{
 800f9f8:	b580      	push	{r7, lr}
 800f9fa:	b082      	sub	sp, #8
 800f9fc:	af00      	add	r7, sp, #0
 800f9fe:	6078      	str	r0, [r7, #4]
 800fa00:	6039      	str	r1, [r7, #0]
    NK_ASSERT(ctx);
 800fa02:	687b      	ldr	r3, [r7, #4]
 800fa04:	2b00      	cmp	r3, #0
 800fa06:	d105      	bne.n	800fa14 <nk_setup+0x1c>
 800fa08:	4b11      	ldr	r3, [pc, #68]	; (800fa50 <nk_setup+0x58>)
 800fa0a:	4a12      	ldr	r2, [pc, #72]	; (800fa54 <nk_setup+0x5c>)
 800fa0c:	210c      	movs	r1, #12
 800fa0e:	4812      	ldr	r0, [pc, #72]	; (800fa58 <nk_setup+0x60>)
 800fa10:	f00e f802 	bl	801da18 <__assert_func>
    if (!ctx) return;
 800fa14:	687b      	ldr	r3, [r7, #4]
 800fa16:	2b00      	cmp	r3, #0
 800fa18:	d016      	beq.n	800fa48 <nk_setup+0x50>
    nk_zero_struct(*ctx);
 800fa1a:	f243 6168 	movw	r1, #13928	; 0x3668
 800fa1e:	6878      	ldr	r0, [r7, #4]
 800fa20:	f00c fb02 	bl	801c028 <nk_zero>
    nk_style_default(ctx);
 800fa24:	6878      	ldr	r0, [r7, #4]
 800fa26:	f008 ff1b 	bl	8018860 <nk_style_default>
    ctx->seq = 1;
 800fa2a:	687b      	ldr	r3, [r7, #4]
 800fa2c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800fa30:	461a      	mov	r2, r3
 800fa32:	2301      	movs	r3, #1
 800fa34:	f8c2 3664 	str.w	r3, [r2, #1636]	; 0x664
    if (font) ctx->style.font = font;
 800fa38:	683b      	ldr	r3, [r7, #0]
 800fa3a:	2b00      	cmp	r3, #0
 800fa3c:	d005      	beq.n	800fa4a <nk_setup+0x52>
 800fa3e:	687b      	ldr	r3, [r7, #4]
 800fa40:	683a      	ldr	r2, [r7, #0]
 800fa42:	f8c3 2168 	str.w	r2, [r3, #360]	; 0x168
 800fa46:	e000      	b.n	800fa4a <nk_setup+0x52>
    if (!ctx) return;
 800fa48:	bf00      	nop
#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT
    nk_draw_list_init(&ctx->draw_list);
#endif
}
 800fa4a:	3708      	adds	r7, #8
 800fa4c:	46bd      	mov	sp, r7
 800fa4e:	bd80      	pop	{r7, pc}
 800fa50:	08021644 	.word	0x08021644
 800fa54:	080232bc 	.word	0x080232bc
 800fa58:	08021648 	.word	0x08021648

0800fa5c <nk_init_custom>:
    return 1;
}
NK_API nk_bool
nk_init_custom(struct nk_context *ctx, struct nk_buffer *cmds,
    struct nk_buffer *pool, const struct nk_user_font *font)
{
 800fa5c:	b5b0      	push	{r4, r5, r7, lr}
 800fa5e:	b086      	sub	sp, #24
 800fa60:	af00      	add	r7, sp, #0
 800fa62:	60f8      	str	r0, [r7, #12]
 800fa64:	60b9      	str	r1, [r7, #8]
 800fa66:	607a      	str	r2, [r7, #4]
 800fa68:	603b      	str	r3, [r7, #0]
    NK_ASSERT(cmds);
 800fa6a:	68bb      	ldr	r3, [r7, #8]
 800fa6c:	2b00      	cmp	r3, #0
 800fa6e:	d105      	bne.n	800fa7c <nk_init_custom+0x20>
 800fa70:	4b2a      	ldr	r3, [pc, #168]	; (800fb1c <nk_init_custom+0xc0>)
 800fa72:	4a2b      	ldr	r2, [pc, #172]	; (800fb20 <nk_init_custom+0xc4>)
 800fa74:	2130      	movs	r1, #48	; 0x30
 800fa76:	482b      	ldr	r0, [pc, #172]	; (800fb24 <nk_init_custom+0xc8>)
 800fa78:	f00d ffce 	bl	801da18 <__assert_func>
    NK_ASSERT(pool);
 800fa7c:	687b      	ldr	r3, [r7, #4]
 800fa7e:	2b00      	cmp	r3, #0
 800fa80:	d105      	bne.n	800fa8e <nk_init_custom+0x32>
 800fa82:	4b29      	ldr	r3, [pc, #164]	; (800fb28 <nk_init_custom+0xcc>)
 800fa84:	4a26      	ldr	r2, [pc, #152]	; (800fb20 <nk_init_custom+0xc4>)
 800fa86:	2131      	movs	r1, #49	; 0x31
 800fa88:	4826      	ldr	r0, [pc, #152]	; (800fb24 <nk_init_custom+0xc8>)
 800fa8a:	f00d ffc5 	bl	801da18 <__assert_func>
    if (!cmds || !pool) return 0;
 800fa8e:	68bb      	ldr	r3, [r7, #8]
 800fa90:	2b00      	cmp	r3, #0
 800fa92:	d002      	beq.n	800fa9a <nk_init_custom+0x3e>
 800fa94:	687b      	ldr	r3, [r7, #4]
 800fa96:	2b00      	cmp	r3, #0
 800fa98:	d101      	bne.n	800fa9e <nk_init_custom+0x42>
 800fa9a:	2300      	movs	r3, #0
 800fa9c:	e039      	b.n	800fb12 <nk_init_custom+0xb6>

    nk_setup(ctx, font);
 800fa9e:	6839      	ldr	r1, [r7, #0]
 800faa0:	68f8      	ldr	r0, [r7, #12]
 800faa2:	f7ff ffa9 	bl	800f9f8 <nk_setup>
    ctx->memory = *cmds;
 800faa6:	68fb      	ldr	r3, [r7, #12]
 800faa8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800faac:	461a      	mov	r2, r3
 800faae:	68bb      	ldr	r3, [r7, #8]
 800fab0:	f602 248c 	addw	r4, r2, #2700	; 0xa8c
 800fab4:	461d      	mov	r5, r3
 800fab6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800fab8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800faba:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800fabc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800fabe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800fac0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800fac2:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 800fac6:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    if (pool->type == NK_BUFFER_FIXED) {
 800faca:	687b      	ldr	r3, [r7, #4]
 800facc:	7f1b      	ldrb	r3, [r3, #28]
 800face:	2b00      	cmp	r3, #0
 800fad0:	d10b      	bne.n	800faea <nk_init_custom+0x8e>
        /* take memory from buffer and alloc fixed pool */
        nk_pool_init_fixed(&ctx->pool, pool->memory.ptr, pool->memory.size);
 800fad2:	68fb      	ldr	r3, [r7, #12]
 800fad4:	f503 5358 	add.w	r3, r3, #13824	; 0x3600
 800fad8:	3324      	adds	r3, #36	; 0x24
 800fada:	687a      	ldr	r2, [r7, #4]
 800fadc:	6a11      	ldr	r1, [r2, #32]
 800fade:	687a      	ldr	r2, [r7, #4]
 800fae0:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800fae2:	4618      	mov	r0, r3
 800fae4:	f006 fbf4 	bl	80162d0 <nk_pool_init_fixed>
 800fae8:	e00b      	b.n	800fb02 <nk_init_custom+0xa6>
    } else {
        /* create dynamic pool from buffer allocator */
        struct nk_allocator *alloc = &pool->pool;
 800faea:	687b      	ldr	r3, [r7, #4]
 800faec:	3310      	adds	r3, #16
 800faee:	617b      	str	r3, [r7, #20]
        nk_pool_init(&ctx->pool, alloc, NK_POOL_DEFAULT_CAPACITY);
 800faf0:	68fb      	ldr	r3, [r7, #12]
 800faf2:	f503 5358 	add.w	r3, r3, #13824	; 0x3600
 800faf6:	3324      	adds	r3, #36	; 0x24
 800faf8:	2210      	movs	r2, #16
 800fafa:	6979      	ldr	r1, [r7, #20]
 800fafc:	4618      	mov	r0, r3
 800fafe:	f006 fbbb 	bl	8016278 <nk_pool_init>
    }
    ctx->use_pool = nk_true;
 800fb02:	68fb      	ldr	r3, [r7, #12]
 800fb04:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800fb08:	461a      	mov	r2, r3
 800fb0a:	2301      	movs	r3, #1
 800fb0c:	f8c2 3620 	str.w	r3, [r2, #1568]	; 0x620
    return 1;
 800fb10:	2301      	movs	r3, #1
}
 800fb12:	4618      	mov	r0, r3
 800fb14:	3718      	adds	r7, #24
 800fb16:	46bd      	mov	sp, r7
 800fb18:	bdb0      	pop	{r4, r5, r7, pc}
 800fb1a:	bf00      	nop
 800fb1c:	08021670 	.word	0x08021670
 800fb20:	080232c8 	.word	0x080232c8
 800fb24:	08021648 	.word	0x08021648
 800fb28:	08021678 	.word	0x08021678

0800fb2c <nk_clear>:
    ctx->freelist = 0;
    ctx->count = 0;
}
NK_API void
nk_clear(struct nk_context *ctx)
{
 800fb2c:	b580      	push	{r7, lr}
 800fb2e:	b086      	sub	sp, #24
 800fb30:	af00      	add	r7, sp, #0
 800fb32:	6078      	str	r0, [r7, #4]
    struct nk_window *iter;
    struct nk_window *next;
    NK_ASSERT(ctx);
 800fb34:	687b      	ldr	r3, [r7, #4]
 800fb36:	2b00      	cmp	r3, #0
 800fb38:	d105      	bne.n	800fb46 <nk_clear+0x1a>
 800fb3a:	4b96      	ldr	r3, [pc, #600]	; (800fd94 <nk_clear+0x268>)
 800fb3c:	4a96      	ldr	r2, [pc, #600]	; (800fd98 <nk_clear+0x26c>)
 800fb3e:	2172      	movs	r1, #114	; 0x72
 800fb40:	4896      	ldr	r0, [pc, #600]	; (800fd9c <nk_clear+0x270>)
 800fb42:	f00d ff69 	bl	801da18 <__assert_func>

    if (!ctx) return;
 800fb46:	687b      	ldr	r3, [r7, #4]
 800fb48:	2b00      	cmp	r3, #0
 800fb4a:	f000 811e 	beq.w	800fd8a <nk_clear+0x25e>
    if (ctx->use_pool)
 800fb4e:	687b      	ldr	r3, [r7, #4]
 800fb50:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800fb54:	f8d3 3620 	ldr.w	r3, [r3, #1568]	; 0x620
 800fb58:	2b00      	cmp	r3, #0
 800fb5a:	d007      	beq.n	800fb6c <nk_clear+0x40>
        nk_buffer_clear(&ctx->memory);
 800fb5c:	687b      	ldr	r3, [r7, #4]
 800fb5e:	f503 53d4 	add.w	r3, r3, #6784	; 0x1a80
 800fb62:	330c      	adds	r3, #12
 800fb64:	4618      	mov	r0, r3
 800fb66:	f7fe f9bb 	bl	800dee0 <nk_buffer_clear>
 800fb6a:	e007      	b.n	800fb7c <nk_clear+0x50>
    else nk_buffer_reset(&ctx->memory, NK_BUFFER_FRONT);
 800fb6c:	687b      	ldr	r3, [r7, #4]
 800fb6e:	f503 53d4 	add.w	r3, r3, #6784	; 0x1a80
 800fb72:	330c      	adds	r3, #12
 800fb74:	2100      	movs	r1, #0
 800fb76:	4618      	mov	r0, r3
 800fb78:	f7fe f94a 	bl	800de10 <nk_buffer_reset>

    ctx->build = 0;
 800fb7c:	687b      	ldr	r3, [r7, #4]
 800fb7e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800fb82:	461a      	mov	r2, r3
 800fb84:	2300      	movs	r3, #0
 800fb86:	f8c2 361c 	str.w	r3, [r2, #1564]	; 0x61c
    ctx->memory.calls = 0;
 800fb8a:	687b      	ldr	r3, [r7, #4]
 800fb8c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800fb90:	461a      	mov	r2, r3
 800fb92:	2300      	movs	r3, #0
 800fb94:	f8c2 3ac0 	str.w	r3, [r2, #2752]	; 0xac0
    ctx->last_widget_state = 0;
 800fb98:	687b      	ldr	r3, [r7, #4]
 800fb9a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800fb9e:	461a      	mov	r2, r3
 800fba0:	2300      	movs	r3, #0
 800fba2:	f8c2 3ad4 	str.w	r3, [r2, #2772]	; 0xad4
    ctx->style.cursor_active = ctx->style.cursors[NK_CURSOR_ARROW];
 800fba6:	687b      	ldr	r3, [r7, #4]
 800fba8:	f8d3 216c 	ldr.w	r2, [r3, #364]	; 0x16c
 800fbac:	687b      	ldr	r3, [r7, #4]
 800fbae:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
    NK_MEMSET(&ctx->overlay, 0, sizeof(ctx->overlay));
 800fbb2:	687b      	ldr	r3, [r7, #4]
 800fbb4:	f503 5357 	add.w	r3, r3, #13760	; 0x35c0
 800fbb8:	3334      	adds	r3, #52	; 0x34
 800fbba:	2228      	movs	r2, #40	; 0x28
 800fbbc:	2100      	movs	r1, #0
 800fbbe:	4618      	mov	r0, r3
 800fbc0:	f00c f9c1 	bl	801bf46 <nk_memset>

    /* garbage collector */
    iter = ctx->begin;
 800fbc4:	687b      	ldr	r3, [r7, #4]
 800fbc6:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800fbca:	f8d3 364c 	ldr.w	r3, [r3, #1612]	; 0x64c
 800fbce:	617b      	str	r3, [r7, #20]
    while (iter) {
 800fbd0:	e0cb      	b.n	800fd6a <nk_clear+0x23e>
        /* make sure valid minimized windows do not get removed */
        if ((iter->flags & NK_WINDOW_MINIMIZED) &&
 800fbd2:	697b      	ldr	r3, [r7, #20]
 800fbd4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800fbd6:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800fbda:	2b00      	cmp	r3, #0
 800fbdc:	d013      	beq.n	800fc06 <nk_clear+0xda>
            !(iter->flags & NK_WINDOW_CLOSED) &&
 800fbde:	697b      	ldr	r3, [r7, #20]
 800fbe0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800fbe2:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
        if ((iter->flags & NK_WINDOW_MINIMIZED) &&
 800fbe6:	2b00      	cmp	r3, #0
 800fbe8:	d10d      	bne.n	800fc06 <nk_clear+0xda>
            iter->seq == ctx->seq) {
 800fbea:	697b      	ldr	r3, [r7, #20]
 800fbec:	681a      	ldr	r2, [r3, #0]
 800fbee:	687b      	ldr	r3, [r7, #4]
 800fbf0:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800fbf4:	f8d3 3664 	ldr.w	r3, [r3, #1636]	; 0x664
            !(iter->flags & NK_WINDOW_CLOSED) &&
 800fbf8:	429a      	cmp	r2, r3
 800fbfa:	d104      	bne.n	800fc06 <nk_clear+0xda>
            iter = iter->next;
 800fbfc:	697b      	ldr	r3, [r7, #20]
 800fbfe:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 800fc02:	617b      	str	r3, [r7, #20]
            continue;
 800fc04:	e0b1      	b.n	800fd6a <nk_clear+0x23e>
        }
        /* remove hotness from hidden or closed windows*/
        if (((iter->flags & NK_WINDOW_HIDDEN) ||
 800fc06:	697b      	ldr	r3, [r7, #20]
 800fc08:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800fc0a:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 800fc0e:	2b00      	cmp	r3, #0
 800fc10:	d105      	bne.n	800fc1e <nk_clear+0xf2>
            (iter->flags & NK_WINDOW_CLOSED)) &&
 800fc12:	697b      	ldr	r3, [r7, #20]
 800fc14:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800fc16:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
        if (((iter->flags & NK_WINDOW_HIDDEN) ||
 800fc1a:	2b00      	cmp	r3, #0
 800fc1c:	d03a      	beq.n	800fc94 <nk_clear+0x168>
            iter == ctx->active) {
 800fc1e:	687b      	ldr	r3, [r7, #4]
 800fc20:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800fc24:	f8d3 3654 	ldr.w	r3, [r3, #1620]	; 0x654
            (iter->flags & NK_WINDOW_CLOSED)) &&
 800fc28:	697a      	ldr	r2, [r7, #20]
 800fc2a:	429a      	cmp	r2, r3
 800fc2c:	d132      	bne.n	800fc94 <nk_clear+0x168>
            ctx->active = iter->prev;
 800fc2e:	697b      	ldr	r3, [r7, #20]
 800fc30:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
 800fc34:	687a      	ldr	r2, [r7, #4]
 800fc36:	f502 5240 	add.w	r2, r2, #12288	; 0x3000
 800fc3a:	f8c2 3654 	str.w	r3, [r2, #1620]	; 0x654
            ctx->end = iter->prev;
 800fc3e:	697b      	ldr	r3, [r7, #20]
 800fc40:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
 800fc44:	687a      	ldr	r2, [r7, #4]
 800fc46:	f502 5240 	add.w	r2, r2, #12288	; 0x3000
 800fc4a:	f8c2 3650 	str.w	r3, [r2, #1616]	; 0x650
            if (!ctx->end)
 800fc4e:	687b      	ldr	r3, [r7, #4]
 800fc50:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800fc54:	f8d3 3650 	ldr.w	r3, [r3, #1616]	; 0x650
 800fc58:	2b00      	cmp	r3, #0
 800fc5a:	d106      	bne.n	800fc6a <nk_clear+0x13e>
                ctx->begin = 0;
 800fc5c:	687b      	ldr	r3, [r7, #4]
 800fc5e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800fc62:	461a      	mov	r2, r3
 800fc64:	2300      	movs	r3, #0
 800fc66:	f8c2 364c 	str.w	r3, [r2, #1612]	; 0x64c
            if (ctx->active)
 800fc6a:	687b      	ldr	r3, [r7, #4]
 800fc6c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800fc70:	f8d3 3654 	ldr.w	r3, [r3, #1620]	; 0x654
 800fc74:	2b00      	cmp	r3, #0
 800fc76:	d00d      	beq.n	800fc94 <nk_clear+0x168>
                ctx->active->flags &= ~(unsigned)NK_WINDOW_ROM;
 800fc78:	687b      	ldr	r3, [r7, #4]
 800fc7a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800fc7e:	f8d3 3654 	ldr.w	r3, [r3, #1620]	; 0x654
 800fc82:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800fc84:	687b      	ldr	r3, [r7, #4]
 800fc86:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800fc8a:	f8d3 3654 	ldr.w	r3, [r3, #1620]	; 0x654
 800fc8e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800fc92:	649a      	str	r2, [r3, #72]	; 0x48
        }
        /* free unused popup windows */
        if (iter->popup.win && iter->popup.win->seq != ctx->seq) {
 800fc94:	697b      	ldr	r3, [r7, #20]
 800fc96:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 800fc9a:	2b00      	cmp	r3, #0
 800fc9c:	d015      	beq.n	800fcca <nk_clear+0x19e>
 800fc9e:	697b      	ldr	r3, [r7, #20]
 800fca0:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 800fca4:	681a      	ldr	r2, [r3, #0]
 800fca6:	687b      	ldr	r3, [r7, #4]
 800fca8:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800fcac:	f8d3 3664 	ldr.w	r3, [r3, #1636]	; 0x664
 800fcb0:	429a      	cmp	r2, r3
 800fcb2:	d00a      	beq.n	800fcca <nk_clear+0x19e>
            nk_free_window(ctx, iter->popup.win);
 800fcb4:	697b      	ldr	r3, [r7, #20]
 800fcb6:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 800fcba:	4619      	mov	r1, r3
 800fcbc:	6878      	ldr	r0, [r7, #4]
 800fcbe:	f00c fde4 	bl	801c88a <nk_free_window>
            iter->popup.win = 0;
 800fcc2:	697b      	ldr	r3, [r7, #20]
 800fcc4:	2200      	movs	r2, #0
 800fcc6:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
        }
        /* remove unused window state tables */
        {struct nk_table *n, *it = iter->tables;
 800fcca:	697b      	ldr	r3, [r7, #20]
 800fccc:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
 800fcd0:	613b      	str	r3, [r7, #16]
        while (it) {
 800fcd2:	e025      	b.n	800fd20 <nk_clear+0x1f4>
            n = it->next;
 800fcd4:	693b      	ldr	r3, [r7, #16]
 800fcd6:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800fcda:	60bb      	str	r3, [r7, #8]
            if (it->seq != ctx->seq) {
 800fcdc:	693b      	ldr	r3, [r7, #16]
 800fcde:	681a      	ldr	r2, [r3, #0]
 800fce0:	687b      	ldr	r3, [r7, #4]
 800fce2:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800fce6:	f8d3 3664 	ldr.w	r3, [r3, #1636]	; 0x664
 800fcea:	429a      	cmp	r2, r3
 800fcec:	d016      	beq.n	800fd1c <nk_clear+0x1f0>
                nk_remove_table(iter, it);
 800fcee:	6939      	ldr	r1, [r7, #16]
 800fcf0:	6978      	ldr	r0, [r7, #20]
 800fcf2:	f00a fef0 	bl	801aad6 <nk_remove_table>
                nk_zero(it, sizeof(union nk_page_data));
 800fcf6:	f44f 71d4 	mov.w	r1, #424	; 0x1a8
 800fcfa:	6938      	ldr	r0, [r7, #16]
 800fcfc:	f00c f994 	bl	801c028 <nk_zero>
                nk_free_table(ctx, it);
 800fd00:	6939      	ldr	r1, [r7, #16]
 800fd02:	6878      	ldr	r0, [r7, #4]
 800fd04:	f00a fe95 	bl	801aa32 <nk_free_table>
                if (it == iter->tables)
 800fd08:	697b      	ldr	r3, [r7, #20]
 800fd0a:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
 800fd0e:	693a      	ldr	r2, [r7, #16]
 800fd10:	429a      	cmp	r2, r3
 800fd12:	d103      	bne.n	800fd1c <nk_clear+0x1f0>
                    iter->tables = n;
 800fd14:	697b      	ldr	r3, [r7, #20]
 800fd16:	68ba      	ldr	r2, [r7, #8]
 800fd18:	f8c3 2170 	str.w	r2, [r3, #368]	; 0x170
            } it = n;
 800fd1c:	68bb      	ldr	r3, [r7, #8]
 800fd1e:	613b      	str	r3, [r7, #16]
        while (it) {
 800fd20:	693b      	ldr	r3, [r7, #16]
 800fd22:	2b00      	cmp	r3, #0
 800fd24:	d1d6      	bne.n	800fcd4 <nk_clear+0x1a8>
        }}
        /* window itself is not used anymore so free */
        if (iter->seq != ctx->seq || iter->flags & NK_WINDOW_CLOSED) {
 800fd26:	697b      	ldr	r3, [r7, #20]
 800fd28:	681a      	ldr	r2, [r3, #0]
 800fd2a:	687b      	ldr	r3, [r7, #4]
 800fd2c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800fd30:	f8d3 3664 	ldr.w	r3, [r3, #1636]	; 0x664
 800fd34:	429a      	cmp	r2, r3
 800fd36:	d105      	bne.n	800fd44 <nk_clear+0x218>
 800fd38:	697b      	ldr	r3, [r7, #20]
 800fd3a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800fd3c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800fd40:	2b00      	cmp	r3, #0
 800fd42:	d00e      	beq.n	800fd62 <nk_clear+0x236>
            next = iter->next;
 800fd44:	697b      	ldr	r3, [r7, #20]
 800fd46:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 800fd4a:	60fb      	str	r3, [r7, #12]
            nk_remove_window(ctx, iter);
 800fd4c:	6979      	ldr	r1, [r7, #20]
 800fd4e:	6878      	ldr	r0, [r7, #4]
 800fd50:	f00c ff1c 	bl	801cb8c <nk_remove_window>
            nk_free_window(ctx, iter);
 800fd54:	6979      	ldr	r1, [r7, #20]
 800fd56:	6878      	ldr	r0, [r7, #4]
 800fd58:	f00c fd97 	bl	801c88a <nk_free_window>
            iter = next;
 800fd5c:	68fb      	ldr	r3, [r7, #12]
 800fd5e:	617b      	str	r3, [r7, #20]
 800fd60:	e003      	b.n	800fd6a <nk_clear+0x23e>
        } else iter = iter->next;
 800fd62:	697b      	ldr	r3, [r7, #20]
 800fd64:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 800fd68:	617b      	str	r3, [r7, #20]
    while (iter) {
 800fd6a:	697b      	ldr	r3, [r7, #20]
 800fd6c:	2b00      	cmp	r3, #0
 800fd6e:	f47f af30 	bne.w	800fbd2 <nk_clear+0xa6>
    }
    ctx->seq++;
 800fd72:	687b      	ldr	r3, [r7, #4]
 800fd74:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800fd78:	f8d3 3664 	ldr.w	r3, [r3, #1636]	; 0x664
 800fd7c:	3301      	adds	r3, #1
 800fd7e:	687a      	ldr	r2, [r7, #4]
 800fd80:	f502 5240 	add.w	r2, r2, #12288	; 0x3000
 800fd84:	f8c2 3664 	str.w	r3, [r2, #1636]	; 0x664
 800fd88:	e000      	b.n	800fd8c <nk_clear+0x260>
    if (!ctx) return;
 800fd8a:	bf00      	nop
}
 800fd8c:	3718      	adds	r7, #24
 800fd8e:	46bd      	mov	sp, r7
 800fd90:	bd80      	pop	{r7, pc}
 800fd92:	bf00      	nop
 800fd94:	08021644 	.word	0x08021644
 800fd98:	080232d8 	.word	0x080232d8
 800fd9c:	08021648 	.word	0x08021648

0800fda0 <nk_start_buffer>:
NK_LIB void
nk_start_buffer(struct nk_context *ctx, struct nk_command_buffer *buffer)
{
 800fda0:	b590      	push	{r4, r7, lr}
 800fda2:	b083      	sub	sp, #12
 800fda4:	af00      	add	r7, sp, #0
 800fda6:	6078      	str	r0, [r7, #4]
 800fda8:	6039      	str	r1, [r7, #0]
    NK_ASSERT(ctx);
 800fdaa:	687b      	ldr	r3, [r7, #4]
 800fdac:	2b00      	cmp	r3, #0
 800fdae:	d105      	bne.n	800fdbc <nk_start_buffer+0x1c>
 800fdb0:	4b17      	ldr	r3, [pc, #92]	; (800fe10 <nk_start_buffer+0x70>)
 800fdb2:	4a18      	ldr	r2, [pc, #96]	; (800fe14 <nk_start_buffer+0x74>)
 800fdb4:	21b2      	movs	r1, #178	; 0xb2
 800fdb6:	4818      	ldr	r0, [pc, #96]	; (800fe18 <nk_start_buffer+0x78>)
 800fdb8:	f00d fe2e 	bl	801da18 <__assert_func>
    NK_ASSERT(buffer);
 800fdbc:	683b      	ldr	r3, [r7, #0]
 800fdbe:	2b00      	cmp	r3, #0
 800fdc0:	d105      	bne.n	800fdce <nk_start_buffer+0x2e>
 800fdc2:	4b16      	ldr	r3, [pc, #88]	; (800fe1c <nk_start_buffer+0x7c>)
 800fdc4:	4a13      	ldr	r2, [pc, #76]	; (800fe14 <nk_start_buffer+0x74>)
 800fdc6:	21b3      	movs	r1, #179	; 0xb3
 800fdc8:	4813      	ldr	r0, [pc, #76]	; (800fe18 <nk_start_buffer+0x78>)
 800fdca:	f00d fe25 	bl	801da18 <__assert_func>
    if (!ctx || !buffer) return;
 800fdce:	687b      	ldr	r3, [r7, #4]
 800fdd0:	2b00      	cmp	r3, #0
 800fdd2:	d019      	beq.n	800fe08 <nk_start_buffer+0x68>
 800fdd4:	683b      	ldr	r3, [r7, #0]
 800fdd6:	2b00      	cmp	r3, #0
 800fdd8:	d016      	beq.n	800fe08 <nk_start_buffer+0x68>
    buffer->begin = ctx->memory.allocated;
 800fdda:	687b      	ldr	r3, [r7, #4]
 800fddc:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800fde0:	f8d3 2ab8 	ldr.w	r2, [r3, #2744]	; 0xab8
 800fde4:	683b      	ldr	r3, [r7, #0]
 800fde6:	61da      	str	r2, [r3, #28]
    buffer->end = buffer->begin;
 800fde8:	683b      	ldr	r3, [r7, #0]
 800fdea:	69da      	ldr	r2, [r3, #28]
 800fdec:	683b      	ldr	r3, [r7, #0]
 800fdee:	621a      	str	r2, [r3, #32]
    buffer->last = buffer->begin;
 800fdf0:	683b      	ldr	r3, [r7, #0]
 800fdf2:	69da      	ldr	r2, [r3, #28]
 800fdf4:	683b      	ldr	r3, [r7, #0]
 800fdf6:	625a      	str	r2, [r3, #36]	; 0x24
    buffer->clip = nk_null_rect;
 800fdf8:	683b      	ldr	r3, [r7, #0]
 800fdfa:	4a09      	ldr	r2, [pc, #36]	; (800fe20 <nk_start_buffer+0x80>)
 800fdfc:	1d1c      	adds	r4, r3, #4
 800fdfe:	4613      	mov	r3, r2
 800fe00:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800fe02:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 800fe06:	e000      	b.n	800fe0a <nk_start_buffer+0x6a>
    if (!ctx || !buffer) return;
 800fe08:	bf00      	nop
}
 800fe0a:	370c      	adds	r7, #12
 800fe0c:	46bd      	mov	sp, r7
 800fe0e:	bd90      	pop	{r4, r7, pc}
 800fe10:	08021644 	.word	0x08021644
 800fe14:	080232e4 	.word	0x080232e4
 800fe18:	08021648 	.word	0x08021648
 800fe1c:	08021688 	.word	0x08021688
 800fe20:	080232a8 	.word	0x080232a8

0800fe24 <nk_start>:
NK_LIB void
nk_start(struct nk_context *ctx, struct nk_window *win)
{
 800fe24:	b580      	push	{r7, lr}
 800fe26:	b082      	sub	sp, #8
 800fe28:	af00      	add	r7, sp, #0
 800fe2a:	6078      	str	r0, [r7, #4]
 800fe2c:	6039      	str	r1, [r7, #0]
    NK_ASSERT(ctx);
 800fe2e:	687b      	ldr	r3, [r7, #4]
 800fe30:	2b00      	cmp	r3, #0
 800fe32:	d105      	bne.n	800fe40 <nk_start+0x1c>
 800fe34:	4b0c      	ldr	r3, [pc, #48]	; (800fe68 <nk_start+0x44>)
 800fe36:	4a0d      	ldr	r2, [pc, #52]	; (800fe6c <nk_start+0x48>)
 800fe38:	21bd      	movs	r1, #189	; 0xbd
 800fe3a:	480d      	ldr	r0, [pc, #52]	; (800fe70 <nk_start+0x4c>)
 800fe3c:	f00d fdec 	bl	801da18 <__assert_func>
    NK_ASSERT(win);
 800fe40:	683b      	ldr	r3, [r7, #0]
 800fe42:	2b00      	cmp	r3, #0
 800fe44:	d105      	bne.n	800fe52 <nk_start+0x2e>
 800fe46:	4b0b      	ldr	r3, [pc, #44]	; (800fe74 <nk_start+0x50>)
 800fe48:	4a08      	ldr	r2, [pc, #32]	; (800fe6c <nk_start+0x48>)
 800fe4a:	21be      	movs	r1, #190	; 0xbe
 800fe4c:	4808      	ldr	r0, [pc, #32]	; (800fe70 <nk_start+0x4c>)
 800fe4e:	f00d fde3 	bl	801da18 <__assert_func>
    nk_start_buffer(ctx, &win->buffer);
 800fe52:	683b      	ldr	r3, [r7, #0]
 800fe54:	3364      	adds	r3, #100	; 0x64
 800fe56:	4619      	mov	r1, r3
 800fe58:	6878      	ldr	r0, [r7, #4]
 800fe5a:	f7ff ffa1 	bl	800fda0 <nk_start_buffer>
}
 800fe5e:	bf00      	nop
 800fe60:	3708      	adds	r7, #8
 800fe62:	46bd      	mov	sp, r7
 800fe64:	bd80      	pop	{r7, pc}
 800fe66:	bf00      	nop
 800fe68:	08021644 	.word	0x08021644
 800fe6c:	080232f4 	.word	0x080232f4
 800fe70:	08021648 	.word	0x08021648
 800fe74:	08021690 	.word	0x08021690

0800fe78 <nk_start_popup>:
NK_LIB void
nk_start_popup(struct nk_context *ctx, struct nk_window *win)
{
 800fe78:	b580      	push	{r7, lr}
 800fe7a:	b084      	sub	sp, #16
 800fe7c:	af00      	add	r7, sp, #0
 800fe7e:	6078      	str	r0, [r7, #4]
 800fe80:	6039      	str	r1, [r7, #0]
    struct nk_popup_buffer *buf;
    NK_ASSERT(ctx);
 800fe82:	687b      	ldr	r3, [r7, #4]
 800fe84:	2b00      	cmp	r3, #0
 800fe86:	d105      	bne.n	800fe94 <nk_start_popup+0x1c>
 800fe88:	4b19      	ldr	r3, [pc, #100]	; (800fef0 <nk_start_popup+0x78>)
 800fe8a:	4a1a      	ldr	r2, [pc, #104]	; (800fef4 <nk_start_popup+0x7c>)
 800fe8c:	21c5      	movs	r1, #197	; 0xc5
 800fe8e:	481a      	ldr	r0, [pc, #104]	; (800fef8 <nk_start_popup+0x80>)
 800fe90:	f00d fdc2 	bl	801da18 <__assert_func>
    NK_ASSERT(win);
 800fe94:	683b      	ldr	r3, [r7, #0]
 800fe96:	2b00      	cmp	r3, #0
 800fe98:	d105      	bne.n	800fea6 <nk_start_popup+0x2e>
 800fe9a:	4b18      	ldr	r3, [pc, #96]	; (800fefc <nk_start_popup+0x84>)
 800fe9c:	4a15      	ldr	r2, [pc, #84]	; (800fef4 <nk_start_popup+0x7c>)
 800fe9e:	21c6      	movs	r1, #198	; 0xc6
 800fea0:	4815      	ldr	r0, [pc, #84]	; (800fef8 <nk_start_popup+0x80>)
 800fea2:	f00d fdb9 	bl	801da18 <__assert_func>
    if (!ctx || !win) return;
 800fea6:	687b      	ldr	r3, [r7, #4]
 800fea8:	2b00      	cmp	r3, #0
 800feaa:	d01d      	beq.n	800fee8 <nk_start_popup+0x70>
 800feac:	683b      	ldr	r3, [r7, #0]
 800feae:	2b00      	cmp	r3, #0
 800feb0:	d01a      	beq.n	800fee8 <nk_start_popup+0x70>

    /* save buffer fill state for popup */
    buf = &win->popup.buf;
 800feb2:	683b      	ldr	r3, [r7, #0]
 800feb4:	f503 7382 	add.w	r3, r3, #260	; 0x104
 800feb8:	60fb      	str	r3, [r7, #12]
    buf->begin = win->buffer.end;
 800feba:	683b      	ldr	r3, [r7, #0]
 800febc:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 800fec0:	68fb      	ldr	r3, [r7, #12]
 800fec2:	601a      	str	r2, [r3, #0]
    buf->end = win->buffer.end;
 800fec4:	683b      	ldr	r3, [r7, #0]
 800fec6:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 800feca:	68fb      	ldr	r3, [r7, #12]
 800fecc:	60da      	str	r2, [r3, #12]
    buf->parent = win->buffer.last;
 800fece:	683b      	ldr	r3, [r7, #0]
 800fed0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800fed4:	68fb      	ldr	r3, [r7, #12]
 800fed6:	605a      	str	r2, [r3, #4]
    buf->last = buf->begin;
 800fed8:	68fb      	ldr	r3, [r7, #12]
 800feda:	681a      	ldr	r2, [r3, #0]
 800fedc:	68fb      	ldr	r3, [r7, #12]
 800fede:	609a      	str	r2, [r3, #8]
    buf->active = nk_true;
 800fee0:	68fb      	ldr	r3, [r7, #12]
 800fee2:	2201      	movs	r2, #1
 800fee4:	611a      	str	r2, [r3, #16]
 800fee6:	e000      	b.n	800feea <nk_start_popup+0x72>
    if (!ctx || !win) return;
 800fee8:	bf00      	nop
}
 800feea:	3710      	adds	r7, #16
 800feec:	46bd      	mov	sp, r7
 800feee:	bd80      	pop	{r7, pc}
 800fef0:	08021644 	.word	0x08021644
 800fef4:	08023300 	.word	0x08023300
 800fef8:	08021648 	.word	0x08021648
 800fefc:	08021690 	.word	0x08021690

0800ff00 <nk_finish_popup>:
NK_LIB void
nk_finish_popup(struct nk_context *ctx, struct nk_window *win)
{
 800ff00:	b580      	push	{r7, lr}
 800ff02:	b084      	sub	sp, #16
 800ff04:	af00      	add	r7, sp, #0
 800ff06:	6078      	str	r0, [r7, #4]
 800ff08:	6039      	str	r1, [r7, #0]
    struct nk_popup_buffer *buf;
    NK_ASSERT(ctx);
 800ff0a:	687b      	ldr	r3, [r7, #4]
 800ff0c:	2b00      	cmp	r3, #0
 800ff0e:	d105      	bne.n	800ff1c <nk_finish_popup+0x1c>
 800ff10:	4b13      	ldr	r3, [pc, #76]	; (800ff60 <nk_finish_popup+0x60>)
 800ff12:	4a14      	ldr	r2, [pc, #80]	; (800ff64 <nk_finish_popup+0x64>)
 800ff14:	21d5      	movs	r1, #213	; 0xd5
 800ff16:	4814      	ldr	r0, [pc, #80]	; (800ff68 <nk_finish_popup+0x68>)
 800ff18:	f00d fd7e 	bl	801da18 <__assert_func>
    NK_ASSERT(win);
 800ff1c:	683b      	ldr	r3, [r7, #0]
 800ff1e:	2b00      	cmp	r3, #0
 800ff20:	d105      	bne.n	800ff2e <nk_finish_popup+0x2e>
 800ff22:	4b12      	ldr	r3, [pc, #72]	; (800ff6c <nk_finish_popup+0x6c>)
 800ff24:	4a0f      	ldr	r2, [pc, #60]	; (800ff64 <nk_finish_popup+0x64>)
 800ff26:	21d6      	movs	r1, #214	; 0xd6
 800ff28:	480f      	ldr	r0, [pc, #60]	; (800ff68 <nk_finish_popup+0x68>)
 800ff2a:	f00d fd75 	bl	801da18 <__assert_func>
    if (!ctx || !win) return;
 800ff2e:	687b      	ldr	r3, [r7, #4]
 800ff30:	2b00      	cmp	r3, #0
 800ff32:	d011      	beq.n	800ff58 <nk_finish_popup+0x58>
 800ff34:	683b      	ldr	r3, [r7, #0]
 800ff36:	2b00      	cmp	r3, #0
 800ff38:	d00e      	beq.n	800ff58 <nk_finish_popup+0x58>

    buf = &win->popup.buf;
 800ff3a:	683b      	ldr	r3, [r7, #0]
 800ff3c:	f503 7382 	add.w	r3, r3, #260	; 0x104
 800ff40:	60fb      	str	r3, [r7, #12]
    buf->last = win->buffer.last;
 800ff42:	683b      	ldr	r3, [r7, #0]
 800ff44:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800ff48:	68fb      	ldr	r3, [r7, #12]
 800ff4a:	609a      	str	r2, [r3, #8]
    buf->end = win->buffer.end;
 800ff4c:	683b      	ldr	r3, [r7, #0]
 800ff4e:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 800ff52:	68fb      	ldr	r3, [r7, #12]
 800ff54:	60da      	str	r2, [r3, #12]
 800ff56:	e000      	b.n	800ff5a <nk_finish_popup+0x5a>
    if (!ctx || !win) return;
 800ff58:	bf00      	nop
}
 800ff5a:	3710      	adds	r7, #16
 800ff5c:	46bd      	mov	sp, r7
 800ff5e:	bd80      	pop	{r7, pc}
 800ff60:	08021644 	.word	0x08021644
 800ff64:	08023310 	.word	0x08023310
 800ff68:	08021648 	.word	0x08021648
 800ff6c:	08021690 	.word	0x08021690

0800ff70 <nk_finish_buffer>:
NK_LIB void
nk_finish_buffer(struct nk_context *ctx, struct nk_command_buffer *buffer)
{
 800ff70:	b580      	push	{r7, lr}
 800ff72:	b082      	sub	sp, #8
 800ff74:	af00      	add	r7, sp, #0
 800ff76:	6078      	str	r0, [r7, #4]
 800ff78:	6039      	str	r1, [r7, #0]
    NK_ASSERT(ctx);
 800ff7a:	687b      	ldr	r3, [r7, #4]
 800ff7c:	2b00      	cmp	r3, #0
 800ff7e:	d105      	bne.n	800ff8c <nk_finish_buffer+0x1c>
 800ff80:	4b10      	ldr	r3, [pc, #64]	; (800ffc4 <nk_finish_buffer+0x54>)
 800ff82:	4a11      	ldr	r2, [pc, #68]	; (800ffc8 <nk_finish_buffer+0x58>)
 800ff84:	21e0      	movs	r1, #224	; 0xe0
 800ff86:	4811      	ldr	r0, [pc, #68]	; (800ffcc <nk_finish_buffer+0x5c>)
 800ff88:	f00d fd46 	bl	801da18 <__assert_func>
    NK_ASSERT(buffer);
 800ff8c:	683b      	ldr	r3, [r7, #0]
 800ff8e:	2b00      	cmp	r3, #0
 800ff90:	d105      	bne.n	800ff9e <nk_finish_buffer+0x2e>
 800ff92:	4b0f      	ldr	r3, [pc, #60]	; (800ffd0 <nk_finish_buffer+0x60>)
 800ff94:	4a0c      	ldr	r2, [pc, #48]	; (800ffc8 <nk_finish_buffer+0x58>)
 800ff96:	21e1      	movs	r1, #225	; 0xe1
 800ff98:	480c      	ldr	r0, [pc, #48]	; (800ffcc <nk_finish_buffer+0x5c>)
 800ff9a:	f00d fd3d 	bl	801da18 <__assert_func>
    if (!ctx || !buffer) return;
 800ff9e:	687b      	ldr	r3, [r7, #4]
 800ffa0:	2b00      	cmp	r3, #0
 800ffa2:	d00a      	beq.n	800ffba <nk_finish_buffer+0x4a>
 800ffa4:	683b      	ldr	r3, [r7, #0]
 800ffa6:	2b00      	cmp	r3, #0
 800ffa8:	d007      	beq.n	800ffba <nk_finish_buffer+0x4a>
    buffer->end = ctx->memory.allocated;
 800ffaa:	687b      	ldr	r3, [r7, #4]
 800ffac:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800ffb0:	f8d3 2ab8 	ldr.w	r2, [r3, #2744]	; 0xab8
 800ffb4:	683b      	ldr	r3, [r7, #0]
 800ffb6:	621a      	str	r2, [r3, #32]
 800ffb8:	e000      	b.n	800ffbc <nk_finish_buffer+0x4c>
    if (!ctx || !buffer) return;
 800ffba:	bf00      	nop
}
 800ffbc:	3708      	adds	r7, #8
 800ffbe:	46bd      	mov	sp, r7
 800ffc0:	bd80      	pop	{r7, pc}
 800ffc2:	bf00      	nop
 800ffc4:	08021644 	.word	0x08021644
 800ffc8:	08023320 	.word	0x08023320
 800ffcc:	08021648 	.word	0x08021648
 800ffd0:	08021688 	.word	0x08021688

0800ffd4 <nk_finish>:
NK_LIB void
nk_finish(struct nk_context *ctx, struct nk_window *win)
{
 800ffd4:	b580      	push	{r7, lr}
 800ffd6:	b086      	sub	sp, #24
 800ffd8:	af00      	add	r7, sp, #0
 800ffda:	6078      	str	r0, [r7, #4]
 800ffdc:	6039      	str	r1, [r7, #0]
    struct nk_popup_buffer *buf;
    struct nk_command *parent_last;
    void *memory;

    NK_ASSERT(ctx);
 800ffde:	687b      	ldr	r3, [r7, #4]
 800ffe0:	2b00      	cmp	r3, #0
 800ffe2:	d105      	bne.n	800fff0 <nk_finish+0x1c>
 800ffe4:	4b1c      	ldr	r3, [pc, #112]	; (8010058 <nk_finish+0x84>)
 800ffe6:	4a1d      	ldr	r2, [pc, #116]	; (801005c <nk_finish+0x88>)
 800ffe8:	21ec      	movs	r1, #236	; 0xec
 800ffea:	481d      	ldr	r0, [pc, #116]	; (8010060 <nk_finish+0x8c>)
 800ffec:	f00d fd14 	bl	801da18 <__assert_func>
    NK_ASSERT(win);
 800fff0:	683b      	ldr	r3, [r7, #0]
 800fff2:	2b00      	cmp	r3, #0
 800fff4:	d105      	bne.n	8010002 <nk_finish+0x2e>
 800fff6:	4b1b      	ldr	r3, [pc, #108]	; (8010064 <nk_finish+0x90>)
 800fff8:	4a18      	ldr	r2, [pc, #96]	; (801005c <nk_finish+0x88>)
 800fffa:	21ed      	movs	r1, #237	; 0xed
 800fffc:	4818      	ldr	r0, [pc, #96]	; (8010060 <nk_finish+0x8c>)
 800fffe:	f00d fd0b 	bl	801da18 <__assert_func>
    if (!ctx || !win) return;
 8010002:	687b      	ldr	r3, [r7, #4]
 8010004:	2b00      	cmp	r3, #0
 8010006:	d021      	beq.n	801004c <nk_finish+0x78>
 8010008:	683b      	ldr	r3, [r7, #0]
 801000a:	2b00      	cmp	r3, #0
 801000c:	d01e      	beq.n	801004c <nk_finish+0x78>
    nk_finish_buffer(ctx, &win->buffer);
 801000e:	683b      	ldr	r3, [r7, #0]
 8010010:	3364      	adds	r3, #100	; 0x64
 8010012:	4619      	mov	r1, r3
 8010014:	6878      	ldr	r0, [r7, #4]
 8010016:	f7ff ffab 	bl	800ff70 <nk_finish_buffer>
    if (!win->popup.buf.active) return;
 801001a:	683b      	ldr	r3, [r7, #0]
 801001c:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 8010020:	2b00      	cmp	r3, #0
 8010022:	d015      	beq.n	8010050 <nk_finish+0x7c>

    buf = &win->popup.buf;
 8010024:	683b      	ldr	r3, [r7, #0]
 8010026:	f503 7382 	add.w	r3, r3, #260	; 0x104
 801002a:	617b      	str	r3, [r7, #20]
    memory = ctx->memory.memory.ptr;
 801002c:	687b      	ldr	r3, [r7, #4]
 801002e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8010032:	f8d3 3aac 	ldr.w	r3, [r3, #2732]	; 0xaac
 8010036:	613b      	str	r3, [r7, #16]
    parent_last = nk_ptr_add(struct nk_command, memory, buf->parent);
 8010038:	697b      	ldr	r3, [r7, #20]
 801003a:	685b      	ldr	r3, [r3, #4]
 801003c:	693a      	ldr	r2, [r7, #16]
 801003e:	4413      	add	r3, r2
 8010040:	60fb      	str	r3, [r7, #12]
    parent_last->next = buf->end;
 8010042:	697b      	ldr	r3, [r7, #20]
 8010044:	68da      	ldr	r2, [r3, #12]
 8010046:	68fb      	ldr	r3, [r7, #12]
 8010048:	605a      	str	r2, [r3, #4]
 801004a:	e002      	b.n	8010052 <nk_finish+0x7e>
    if (!ctx || !win) return;
 801004c:	bf00      	nop
 801004e:	e000      	b.n	8010052 <nk_finish+0x7e>
    if (!win->popup.buf.active) return;
 8010050:	bf00      	nop
}
 8010052:	3718      	adds	r7, #24
 8010054:	46bd      	mov	sp, r7
 8010056:	bd80      	pop	{r7, pc}
 8010058:	08021644 	.word	0x08021644
 801005c:	08023334 	.word	0x08023334
 8010060:	08021648 	.word	0x08021648
 8010064:	08021690 	.word	0x08021690

08010068 <nk_build>:
NK_LIB void
nk_build(struct nk_context *ctx)
{
 8010068:	b580      	push	{r7, lr}
 801006a:	b08e      	sub	sp, #56	; 0x38
 801006c:	af00      	add	r7, sp, #0
 801006e:	6078      	str	r0, [r7, #4]
    struct nk_window *it = 0;
 8010070:	2300      	movs	r3, #0
 8010072:	637b      	str	r3, [r7, #52]	; 0x34
    struct nk_command *cmd = 0;
 8010074:	2300      	movs	r3, #0
 8010076:	633b      	str	r3, [r7, #48]	; 0x30
    nk_byte *buffer = 0;
 8010078:	2300      	movs	r3, #0
 801007a:	62bb      	str	r3, [r7, #40]	; 0x28

    /* draw cursor overlay */
    if (!ctx->style.cursor_active)
 801007c:	687b      	ldr	r3, [r7, #4]
 801007e:	f8d3 3188 	ldr.w	r3, [r3, #392]	; 0x188
 8010082:	2b00      	cmp	r3, #0
 8010084:	d105      	bne.n	8010092 <nk_build+0x2a>
        ctx->style.cursor_active = ctx->style.cursors[NK_CURSOR_ARROW];
 8010086:	687b      	ldr	r3, [r7, #4]
 8010088:	f8d3 216c 	ldr.w	r2, [r3, #364]	; 0x16c
 801008c:	687b      	ldr	r3, [r7, #4]
 801008e:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
    if (ctx->style.cursor_active && !ctx->input.mouse.grabbed && ctx->style.cursor_visible) {
 8010092:	687b      	ldr	r3, [r7, #4]
 8010094:	f8d3 3188 	ldr.w	r3, [r3, #392]	; 0x188
 8010098:	2b00      	cmp	r3, #0
 801009a:	d05d      	beq.n	8010158 <nk_build+0xf0>
 801009c:	687b      	ldr	r3, [r7, #4]
 801009e:	f893 3165 	ldrb.w	r3, [r3, #357]	; 0x165
 80100a2:	2b00      	cmp	r3, #0
 80100a4:	d158      	bne.n	8010158 <nk_build+0xf0>
 80100a6:	687b      	ldr	r3, [r7, #4]
 80100a8:	f8d3 3190 	ldr.w	r3, [r3, #400]	; 0x190
 80100ac:	2b00      	cmp	r3, #0
 80100ae:	d053      	beq.n	8010158 <nk_build+0xf0>
        struct nk_rect mouse_bounds;
        const struct nk_cursor *cursor = ctx->style.cursor_active;
 80100b0:	687b      	ldr	r3, [r7, #4]
 80100b2:	f8d3 3188 	ldr.w	r3, [r3, #392]	; 0x188
 80100b6:	627b      	str	r3, [r7, #36]	; 0x24
        nk_command_buffer_init(&ctx->overlay, &ctx->memory, NK_CLIPPING_OFF);
 80100b8:	687b      	ldr	r3, [r7, #4]
 80100ba:	f503 5357 	add.w	r3, r3, #13760	; 0x35c0
 80100be:	3334      	adds	r3, #52	; 0x34
 80100c0:	687a      	ldr	r2, [r7, #4]
 80100c2:	f502 51d4 	add.w	r1, r2, #6784	; 0x1a80
 80100c6:	310c      	adds	r1, #12
 80100c8:	2200      	movs	r2, #0
 80100ca:	4618      	mov	r0, r3
 80100cc:	f000 fb94 	bl	80107f8 <nk_command_buffer_init>
        nk_start_buffer(ctx, &ctx->overlay);
 80100d0:	687b      	ldr	r3, [r7, #4]
 80100d2:	f503 5357 	add.w	r3, r3, #13760	; 0x35c0
 80100d6:	3334      	adds	r3, #52	; 0x34
 80100d8:	4619      	mov	r1, r3
 80100da:	6878      	ldr	r0, [r7, #4]
 80100dc:	f7ff fe60 	bl	800fda0 <nk_start_buffer>

        mouse_bounds.x = ctx->input.mouse.pos.x - cursor->offset.x;
 80100e0:	687b      	ldr	r3, [r7, #4]
 80100e2:	ed93 7a51 	vldr	s14, [r3, #324]	; 0x144
 80100e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80100e8:	edd3 7a06 	vldr	s15, [r3, #24]
 80100ec:	ee77 7a67 	vsub.f32	s15, s14, s15
 80100f0:	edc7 7a03 	vstr	s15, [r7, #12]
        mouse_bounds.y = ctx->input.mouse.pos.y - cursor->offset.y;
 80100f4:	687b      	ldr	r3, [r7, #4]
 80100f6:	ed93 7a52 	vldr	s14, [r3, #328]	; 0x148
 80100fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80100fc:	edd3 7a07 	vldr	s15, [r3, #28]
 8010100:	ee77 7a67 	vsub.f32	s15, s14, s15
 8010104:	edc7 7a04 	vstr	s15, [r7, #16]
        mouse_bounds.w = cursor->size.x;
 8010108:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801010a:	691b      	ldr	r3, [r3, #16]
 801010c:	617b      	str	r3, [r7, #20]
        mouse_bounds.h = cursor->size.y;
 801010e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010110:	695b      	ldr	r3, [r3, #20]
 8010112:	61bb      	str	r3, [r7, #24]

        nk_draw_image(&ctx->overlay, mouse_bounds, &cursor->img, nk_white);
 8010114:	687b      	ldr	r3, [r7, #4]
 8010116:	f503 5357 	add.w	r3, r3, #13760	; 0x35c0
 801011a:	3334      	adds	r3, #52	; 0x34
 801011c:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801011e:	4a62      	ldr	r2, [pc, #392]	; (80102a8 <nk_build+0x240>)
 8010120:	ed97 6a03 	vldr	s12, [r7, #12]
 8010124:	edd7 6a04 	vldr	s13, [r7, #16]
 8010128:	ed97 7a05 	vldr	s14, [r7, #20]
 801012c:	edd7 7a06 	vldr	s15, [r7, #24]
 8010130:	6812      	ldr	r2, [r2, #0]
 8010132:	eeb0 0a46 	vmov.f32	s0, s12
 8010136:	eef0 0a66 	vmov.f32	s1, s13
 801013a:	eeb0 1a47 	vmov.f32	s2, s14
 801013e:	eef0 1a67 	vmov.f32	s3, s15
 8010142:	4618      	mov	r0, r3
 8010144:	f001 f904 	bl	8011350 <nk_draw_image>
        nk_finish_buffer(ctx, &ctx->overlay);
 8010148:	687b      	ldr	r3, [r7, #4]
 801014a:	f503 5357 	add.w	r3, r3, #13760	; 0x35c0
 801014e:	3334      	adds	r3, #52	; 0x34
 8010150:	4619      	mov	r1, r3
 8010152:	6878      	ldr	r0, [r7, #4]
 8010154:	f7ff ff0c 	bl	800ff70 <nk_finish_buffer>
    }
    /* build one big draw command list out of all window buffers */
    it = ctx->begin;
 8010158:	687b      	ldr	r3, [r7, #4]
 801015a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801015e:	f8d3 364c 	ldr.w	r3, [r3, #1612]	; 0x64c
 8010162:	637b      	str	r3, [r7, #52]	; 0x34
    buffer = (nk_byte*)ctx->memory.memory.ptr;
 8010164:	687b      	ldr	r3, [r7, #4]
 8010166:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801016a:	f8d3 3aac 	ldr.w	r3, [r3, #2732]	; 0xaac
 801016e:	62bb      	str	r3, [r7, #40]	; 0x28
    while (it != 0) {
 8010170:	e04d      	b.n	801020e <nk_build+0x1a6>
        struct nk_window *next = it->next;
 8010172:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010174:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 8010178:	62fb      	str	r3, [r7, #44]	; 0x2c
        if (it->buffer.last == it->buffer.begin || (it->flags & NK_WINDOW_HIDDEN)||
 801017a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801017c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8010180:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010182:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8010186:	429a      	cmp	r2, r3
 8010188:	d03c      	beq.n	8010204 <nk_build+0x19c>
 801018a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801018c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801018e:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8010192:	2b00      	cmp	r3, #0
 8010194:	d136      	bne.n	8010204 <nk_build+0x19c>
            it->seq != ctx->seq)
 8010196:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010198:	681a      	ldr	r2, [r3, #0]
 801019a:	687b      	ldr	r3, [r7, #4]
 801019c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80101a0:	f8d3 3664 	ldr.w	r3, [r3, #1636]	; 0x664
        if (it->buffer.last == it->buffer.begin || (it->flags & NK_WINDOW_HIDDEN)||
 80101a4:	429a      	cmp	r2, r3
 80101a6:	d12d      	bne.n	8010204 <nk_build+0x19c>
            goto cont;

        cmd = nk_ptr_add(struct nk_command, buffer, it->buffer.last);
 80101a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80101aa:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80101ae:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80101b0:	4413      	add	r3, r2
 80101b2:	633b      	str	r3, [r7, #48]	; 0x30
        while (next && ((next->buffer.last == next->buffer.begin) ||
 80101b4:	e003      	b.n	80101be <nk_build+0x156>
            (next->flags & NK_WINDOW_HIDDEN) || next->seq != ctx->seq))
            next = next->next; /* skip empty command buffers */
 80101b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80101b8:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 80101bc:	62fb      	str	r3, [r7, #44]	; 0x2c
        while (next && ((next->buffer.last == next->buffer.begin) ||
 80101be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80101c0:	2b00      	cmp	r3, #0
 80101c2:	d016      	beq.n	80101f2 <nk_build+0x18a>
 80101c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80101c6:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80101ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80101cc:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80101d0:	429a      	cmp	r2, r3
 80101d2:	d0f0      	beq.n	80101b6 <nk_build+0x14e>
            (next->flags & NK_WINDOW_HIDDEN) || next->seq != ctx->seq))
 80101d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80101d6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80101d8:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
        while (next && ((next->buffer.last == next->buffer.begin) ||
 80101dc:	2b00      	cmp	r3, #0
 80101de:	d1ea      	bne.n	80101b6 <nk_build+0x14e>
            (next->flags & NK_WINDOW_HIDDEN) || next->seq != ctx->seq))
 80101e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80101e2:	681a      	ldr	r2, [r3, #0]
 80101e4:	687b      	ldr	r3, [r7, #4]
 80101e6:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80101ea:	f8d3 3664 	ldr.w	r3, [r3, #1636]	; 0x664
 80101ee:	429a      	cmp	r2, r3
 80101f0:	d1e1      	bne.n	80101b6 <nk_build+0x14e>

        if (next) cmd->next = next->buffer.begin;
 80101f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80101f4:	2b00      	cmp	r3, #0
 80101f6:	d007      	beq.n	8010208 <nk_build+0x1a0>
 80101f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80101fa:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 80101fe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010200:	605a      	str	r2, [r3, #4]
 8010202:	e002      	b.n	801020a <nk_build+0x1a2>
            goto cont;
 8010204:	bf00      	nop
 8010206:	e000      	b.n	801020a <nk_build+0x1a2>
        cont: it = next;
 8010208:	bf00      	nop
 801020a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801020c:	637b      	str	r3, [r7, #52]	; 0x34
    while (it != 0) {
 801020e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010210:	2b00      	cmp	r3, #0
 8010212:	d1ae      	bne.n	8010172 <nk_build+0x10a>
    }
    /* append all popup draw commands into lists */
    it = ctx->begin;
 8010214:	687b      	ldr	r3, [r7, #4]
 8010216:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801021a:	f8d3 364c 	ldr.w	r3, [r3, #1612]	; 0x64c
 801021e:	637b      	str	r3, [r7, #52]	; 0x34
    while (it != 0) {
 8010220:	e01c      	b.n	801025c <nk_build+0x1f4>
        struct nk_window *next = it->next;
 8010222:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010224:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 8010228:	623b      	str	r3, [r7, #32]
        struct nk_popup_buffer *buf;
        if (!it->popup.buf.active)
 801022a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801022c:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 8010230:	2b00      	cmp	r3, #0
 8010232:	d010      	beq.n	8010256 <nk_build+0x1ee>
            goto skip;

        buf = &it->popup.buf;
 8010234:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010236:	f503 7382 	add.w	r3, r3, #260	; 0x104
 801023a:	61fb      	str	r3, [r7, #28]
        cmd->next = buf->begin;
 801023c:	69fb      	ldr	r3, [r7, #28]
 801023e:	681a      	ldr	r2, [r3, #0]
 8010240:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010242:	605a      	str	r2, [r3, #4]
        cmd = nk_ptr_add(struct nk_command, buffer, buf->last);
 8010244:	69fb      	ldr	r3, [r7, #28]
 8010246:	689b      	ldr	r3, [r3, #8]
 8010248:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801024a:	4413      	add	r3, r2
 801024c:	633b      	str	r3, [r7, #48]	; 0x30
        buf->active = nk_false;
 801024e:	69fb      	ldr	r3, [r7, #28]
 8010250:	2200      	movs	r2, #0
 8010252:	611a      	str	r2, [r3, #16]
 8010254:	e000      	b.n	8010258 <nk_build+0x1f0>
            goto skip;
 8010256:	bf00      	nop
        skip: it = next;
 8010258:	6a3b      	ldr	r3, [r7, #32]
 801025a:	637b      	str	r3, [r7, #52]	; 0x34
    while (it != 0) {
 801025c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801025e:	2b00      	cmp	r3, #0
 8010260:	d1df      	bne.n	8010222 <nk_build+0x1ba>
    }
    if (cmd) {
 8010262:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010264:	2b00      	cmp	r3, #0
 8010266:	d01a      	beq.n	801029e <nk_build+0x236>
        /* append overlay commands */
        if (ctx->overlay.end != ctx->overlay.begin)
 8010268:	687b      	ldr	r3, [r7, #4]
 801026a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801026e:	f8d3 2614 	ldr.w	r2, [r3, #1556]	; 0x614
 8010272:	687b      	ldr	r3, [r7, #4]
 8010274:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8010278:	f8d3 3610 	ldr.w	r3, [r3, #1552]	; 0x610
 801027c:	429a      	cmp	r2, r3
 801027e:	d007      	beq.n	8010290 <nk_build+0x228>
            cmd->next = ctx->overlay.begin;
 8010280:	687b      	ldr	r3, [r7, #4]
 8010282:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8010286:	f8d3 2610 	ldr.w	r2, [r3, #1552]	; 0x610
 801028a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801028c:	605a      	str	r2, [r3, #4]
        else cmd->next = ctx->memory.allocated;
    }
}
 801028e:	e006      	b.n	801029e <nk_build+0x236>
        else cmd->next = ctx->memory.allocated;
 8010290:	687b      	ldr	r3, [r7, #4]
 8010292:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8010296:	f8d3 2ab8 	ldr.w	r2, [r3, #2744]	; 0xab8
 801029a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801029c:	605a      	str	r2, [r3, #4]
}
 801029e:	bf00      	nop
 80102a0:	3738      	adds	r7, #56	; 0x38
 80102a2:	46bd      	mov	sp, r7
 80102a4:	bd80      	pop	{r7, pc}
 80102a6:	bf00      	nop
 80102a8:	080232b8 	.word	0x080232b8

080102ac <nk__begin>:
NK_API const struct nk_command*
nk__begin(struct nk_context *ctx)
{
 80102ac:	b580      	push	{r7, lr}
 80102ae:	b084      	sub	sp, #16
 80102b0:	af00      	add	r7, sp, #0
 80102b2:	6078      	str	r0, [r7, #4]
    struct nk_window *iter;
    nk_byte *buffer;
    NK_ASSERT(ctx);
 80102b4:	687b      	ldr	r3, [r7, #4]
 80102b6:	2b00      	cmp	r3, #0
 80102b8:	d106      	bne.n	80102c8 <nk__begin+0x1c>
 80102ba:	4b2f      	ldr	r3, [pc, #188]	; (8010378 <nk__begin+0xcc>)
 80102bc:	4a2f      	ldr	r2, [pc, #188]	; (801037c <nk__begin+0xd0>)
 80102be:	f44f 719d 	mov.w	r1, #314	; 0x13a
 80102c2:	482f      	ldr	r0, [pc, #188]	; (8010380 <nk__begin+0xd4>)
 80102c4:	f00d fba8 	bl	801da18 <__assert_func>
    if (!ctx) return 0;
 80102c8:	687b      	ldr	r3, [r7, #4]
 80102ca:	2b00      	cmp	r3, #0
 80102cc:	d101      	bne.n	80102d2 <nk__begin+0x26>
 80102ce:	2300      	movs	r3, #0
 80102d0:	e04e      	b.n	8010370 <nk__begin+0xc4>
    if (!ctx->count) return 0;
 80102d2:	687b      	ldr	r3, [r7, #4]
 80102d4:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80102d8:	f8d3 3660 	ldr.w	r3, [r3, #1632]	; 0x660
 80102dc:	2b00      	cmp	r3, #0
 80102de:	d101      	bne.n	80102e4 <nk__begin+0x38>
 80102e0:	2300      	movs	r3, #0
 80102e2:	e045      	b.n	8010370 <nk__begin+0xc4>

    buffer = (nk_byte*)ctx->memory.memory.ptr;
 80102e4:	687b      	ldr	r3, [r7, #4]
 80102e6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80102ea:	f8d3 3aac 	ldr.w	r3, [r3, #2732]	; 0xaac
 80102ee:	60bb      	str	r3, [r7, #8]
    if (!ctx->build) {
 80102f0:	687b      	ldr	r3, [r7, #4]
 80102f2:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80102f6:	f8d3 361c 	ldr.w	r3, [r3, #1564]	; 0x61c
 80102fa:	2b00      	cmp	r3, #0
 80102fc:	d109      	bne.n	8010312 <nk__begin+0x66>
        nk_build(ctx);
 80102fe:	6878      	ldr	r0, [r7, #4]
 8010300:	f7ff feb2 	bl	8010068 <nk_build>
        ctx->build = nk_true;
 8010304:	687b      	ldr	r3, [r7, #4]
 8010306:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801030a:	461a      	mov	r2, r3
 801030c:	2301      	movs	r3, #1
 801030e:	f8c2 361c 	str.w	r3, [r2, #1564]	; 0x61c
    }
    iter = ctx->begin;
 8010312:	687b      	ldr	r3, [r7, #4]
 8010314:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8010318:	f8d3 364c 	ldr.w	r3, [r3, #1612]	; 0x64c
 801031c:	60fb      	str	r3, [r7, #12]
    while (iter && ((iter->buffer.begin == iter->buffer.end) ||
 801031e:	e003      	b.n	8010328 <nk__begin+0x7c>
        (iter->flags & NK_WINDOW_HIDDEN) || iter->seq != ctx->seq))
        iter = iter->next;
 8010320:	68fb      	ldr	r3, [r7, #12]
 8010322:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 8010326:	60fb      	str	r3, [r7, #12]
    while (iter && ((iter->buffer.begin == iter->buffer.end) ||
 8010328:	68fb      	ldr	r3, [r7, #12]
 801032a:	2b00      	cmp	r3, #0
 801032c:	d016      	beq.n	801035c <nk__begin+0xb0>
 801032e:	68fb      	ldr	r3, [r7, #12]
 8010330:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8010334:	68fb      	ldr	r3, [r7, #12]
 8010336:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 801033a:	429a      	cmp	r2, r3
 801033c:	d0f0      	beq.n	8010320 <nk__begin+0x74>
        (iter->flags & NK_WINDOW_HIDDEN) || iter->seq != ctx->seq))
 801033e:	68fb      	ldr	r3, [r7, #12]
 8010340:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8010342:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
    while (iter && ((iter->buffer.begin == iter->buffer.end) ||
 8010346:	2b00      	cmp	r3, #0
 8010348:	d1ea      	bne.n	8010320 <nk__begin+0x74>
        (iter->flags & NK_WINDOW_HIDDEN) || iter->seq != ctx->seq))
 801034a:	68fb      	ldr	r3, [r7, #12]
 801034c:	681a      	ldr	r2, [r3, #0]
 801034e:	687b      	ldr	r3, [r7, #4]
 8010350:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8010354:	f8d3 3664 	ldr.w	r3, [r3, #1636]	; 0x664
 8010358:	429a      	cmp	r2, r3
 801035a:	d1e1      	bne.n	8010320 <nk__begin+0x74>
    if (!iter) return 0;
 801035c:	68fb      	ldr	r3, [r7, #12]
 801035e:	2b00      	cmp	r3, #0
 8010360:	d101      	bne.n	8010366 <nk__begin+0xba>
 8010362:	2300      	movs	r3, #0
 8010364:	e004      	b.n	8010370 <nk__begin+0xc4>
    return nk_ptr_add_const(struct nk_command, buffer, iter->buffer.begin);
 8010366:	68fb      	ldr	r3, [r7, #12]
 8010368:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 801036c:	68ba      	ldr	r2, [r7, #8]
 801036e:	4413      	add	r3, r2
}
 8010370:	4618      	mov	r0, r3
 8010372:	3710      	adds	r7, #16
 8010374:	46bd      	mov	sp, r7
 8010376:	bd80      	pop	{r7, pc}
 8010378:	08021644 	.word	0x08021644
 801037c:	08023340 	.word	0x08023340
 8010380:	08021648 	.word	0x08021648

08010384 <nk__next>:

NK_API const struct nk_command*
nk__next(struct nk_context *ctx, const struct nk_command *cmd)
{
 8010384:	b580      	push	{r7, lr}
 8010386:	b084      	sub	sp, #16
 8010388:	af00      	add	r7, sp, #0
 801038a:	6078      	str	r0, [r7, #4]
 801038c:	6039      	str	r1, [r7, #0]
    nk_byte *buffer;
    const struct nk_command *next;
    NK_ASSERT(ctx);
 801038e:	687b      	ldr	r3, [r7, #4]
 8010390:	2b00      	cmp	r3, #0
 8010392:	d106      	bne.n	80103a2 <nk__next+0x1e>
 8010394:	4b18      	ldr	r3, [pc, #96]	; (80103f8 <nk__next+0x74>)
 8010396:	4a19      	ldr	r2, [pc, #100]	; (80103fc <nk__next+0x78>)
 8010398:	f44f 71a8 	mov.w	r1, #336	; 0x150
 801039c:	4818      	ldr	r0, [pc, #96]	; (8010400 <nk__next+0x7c>)
 801039e:	f00d fb3b 	bl	801da18 <__assert_func>
    if (!ctx || !cmd || !ctx->count) return 0;
 80103a2:	687b      	ldr	r3, [r7, #4]
 80103a4:	2b00      	cmp	r3, #0
 80103a6:	d009      	beq.n	80103bc <nk__next+0x38>
 80103a8:	683b      	ldr	r3, [r7, #0]
 80103aa:	2b00      	cmp	r3, #0
 80103ac:	d006      	beq.n	80103bc <nk__next+0x38>
 80103ae:	687b      	ldr	r3, [r7, #4]
 80103b0:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80103b4:	f8d3 3660 	ldr.w	r3, [r3, #1632]	; 0x660
 80103b8:	2b00      	cmp	r3, #0
 80103ba:	d101      	bne.n	80103c0 <nk__next+0x3c>
 80103bc:	2300      	movs	r3, #0
 80103be:	e016      	b.n	80103ee <nk__next+0x6a>
    if (cmd->next >= ctx->memory.allocated) return 0;
 80103c0:	683b      	ldr	r3, [r7, #0]
 80103c2:	685a      	ldr	r2, [r3, #4]
 80103c4:	687b      	ldr	r3, [r7, #4]
 80103c6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80103ca:	f8d3 3ab8 	ldr.w	r3, [r3, #2744]	; 0xab8
 80103ce:	429a      	cmp	r2, r3
 80103d0:	d301      	bcc.n	80103d6 <nk__next+0x52>
 80103d2:	2300      	movs	r3, #0
 80103d4:	e00b      	b.n	80103ee <nk__next+0x6a>
    buffer = (nk_byte*)ctx->memory.memory.ptr;
 80103d6:	687b      	ldr	r3, [r7, #4]
 80103d8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80103dc:	f8d3 3aac 	ldr.w	r3, [r3, #2732]	; 0xaac
 80103e0:	60fb      	str	r3, [r7, #12]
    next = nk_ptr_add_const(struct nk_command, buffer, cmd->next);
 80103e2:	683b      	ldr	r3, [r7, #0]
 80103e4:	685b      	ldr	r3, [r3, #4]
 80103e6:	68fa      	ldr	r2, [r7, #12]
 80103e8:	4413      	add	r3, r2
 80103ea:	60bb      	str	r3, [r7, #8]
    return next;
 80103ec:	68bb      	ldr	r3, [r7, #8]
}
 80103ee:	4618      	mov	r0, r3
 80103f0:	3710      	adds	r7, #16
 80103f2:	46bd      	mov	sp, r7
 80103f4:	bd80      	pop	{r7, pc}
 80103f6:	bf00      	nop
 80103f8:	08021644 	.word	0x08021644
 80103fc:	0802334c 	.word	0x0802334c
 8010400:	08021648 	.word	0x08021648

08010404 <nk_contextual_item_text>:
    return ret;
}
NK_API nk_bool
nk_contextual_item_text(struct nk_context *ctx, const char *text, int len,
    nk_flags alignment)
{
 8010404:	b580      	push	{r7, lr}
 8010406:	b092      	sub	sp, #72	; 0x48
 8010408:	af06      	add	r7, sp, #24
 801040a:	60f8      	str	r0, [r7, #12]
 801040c:	60b9      	str	r1, [r7, #8]
 801040e:	607a      	str	r2, [r7, #4]
 8010410:	603b      	str	r3, [r7, #0]
    const struct nk_style *style;

    struct nk_rect bounds;
    enum nk_widget_layout_states state;

    NK_ASSERT(ctx);
 8010412:	68fb      	ldr	r3, [r7, #12]
 8010414:	2b00      	cmp	r3, #0
 8010416:	d105      	bne.n	8010424 <nk_contextual_item_text+0x20>
 8010418:	4b4e      	ldr	r3, [pc, #312]	; (8010554 <nk_contextual_item_text+0x150>)
 801041a:	4a4f      	ldr	r2, [pc, #316]	; (8010558 <nk_contextual_item_text+0x154>)
 801041c:	214f      	movs	r1, #79	; 0x4f
 801041e:	484f      	ldr	r0, [pc, #316]	; (801055c <nk_contextual_item_text+0x158>)
 8010420:	f00d fafa 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 8010424:	68fb      	ldr	r3, [r7, #12]
 8010426:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801042a:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801042e:	2b00      	cmp	r3, #0
 8010430:	d105      	bne.n	801043e <nk_contextual_item_text+0x3a>
 8010432:	4b4b      	ldr	r3, [pc, #300]	; (8010560 <nk_contextual_item_text+0x15c>)
 8010434:	4a48      	ldr	r2, [pc, #288]	; (8010558 <nk_contextual_item_text+0x154>)
 8010436:	2150      	movs	r1, #80	; 0x50
 8010438:	4848      	ldr	r0, [pc, #288]	; (801055c <nk_contextual_item_text+0x158>)
 801043a:	f00d faed 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 801043e:	68fb      	ldr	r3, [r7, #12]
 8010440:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8010444:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8010448:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801044c:	2b00      	cmp	r3, #0
 801044e:	d105      	bne.n	801045c <nk_contextual_item_text+0x58>
 8010450:	4b44      	ldr	r3, [pc, #272]	; (8010564 <nk_contextual_item_text+0x160>)
 8010452:	4a41      	ldr	r2, [pc, #260]	; (8010558 <nk_contextual_item_text+0x154>)
 8010454:	2151      	movs	r1, #81	; 0x51
 8010456:	4841      	ldr	r0, [pc, #260]	; (801055c <nk_contextual_item_text+0x158>)
 8010458:	f00d fade 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout)
 801045c:	68fb      	ldr	r3, [r7, #12]
 801045e:	2b00      	cmp	r3, #0
 8010460:	d00f      	beq.n	8010482 <nk_contextual_item_text+0x7e>
 8010462:	68fb      	ldr	r3, [r7, #12]
 8010464:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8010468:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801046c:	2b00      	cmp	r3, #0
 801046e:	d008      	beq.n	8010482 <nk_contextual_item_text+0x7e>
 8010470:	68fb      	ldr	r3, [r7, #12]
 8010472:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8010476:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801047a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801047e:	2b00      	cmp	r3, #0
 8010480:	d101      	bne.n	8010486 <nk_contextual_item_text+0x82>
        return 0;
 8010482:	2300      	movs	r3, #0
 8010484:	e061      	b.n	801054a <nk_contextual_item_text+0x146>

    win = ctx->current;
 8010486:	68fb      	ldr	r3, [r7, #12]
 8010488:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801048c:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8010490:	62fb      	str	r3, [r7, #44]	; 0x2c
    style = &ctx->style;
 8010492:	68fb      	ldr	r3, [r7, #12]
 8010494:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 8010498:	62bb      	str	r3, [r7, #40]	; 0x28
    state = nk_widget_fitting(&bounds, ctx, style->contextual_button.padding);
 801049a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801049c:	ed93 7a51 	vldr	s14, [r3, #324]	; 0x144
 80104a0:	edd3 7a52 	vldr	s15, [r3, #328]	; 0x148
 80104a4:	f107 0310 	add.w	r3, r7, #16
 80104a8:	eeb0 0a47 	vmov.f32	s0, s14
 80104ac:	eef0 0a67 	vmov.f32	s1, s15
 80104b0:	68f9      	ldr	r1, [r7, #12]
 80104b2:	4618      	mov	r0, r3
 80104b4:	f00c f974 	bl	801c7a0 <nk_widget_fitting>
 80104b8:	4603      	mov	r3, r0
 80104ba:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    if (!state) return nk_false;
 80104be:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80104c2:	2b00      	cmp	r3, #0
 80104c4:	d101      	bne.n	80104ca <nk_contextual_item_text+0xc6>
 80104c6:	2300      	movs	r3, #0
 80104c8:	e03f      	b.n	801054a <nk_contextual_item_text+0x146>

    in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
 80104ca:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80104ce:	2b02      	cmp	r3, #2
 80104d0:	d009      	beq.n	80104e6 <nk_contextual_item_text+0xe2>
 80104d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80104d4:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80104d8:	685b      	ldr	r3, [r3, #4]
 80104da:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80104de:	2b00      	cmp	r3, #0
 80104e0:	d101      	bne.n	80104e6 <nk_contextual_item_text+0xe2>
 80104e2:	68fb      	ldr	r3, [r7, #12]
 80104e4:	e000      	b.n	80104e8 <nk_contextual_item_text+0xe4>
 80104e6:	2300      	movs	r3, #0
 80104e8:	623b      	str	r3, [r7, #32]
    if (nk_do_button_text(&ctx->last_widget_state, &win->buffer, bounds,
 80104ea:	68fb      	ldr	r3, [r7, #12]
 80104ec:	f503 50d6 	add.w	r0, r3, #6848	; 0x1ac0
 80104f0:	3014      	adds	r0, #20
 80104f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80104f4:	f103 0164 	add.w	r1, r3, #100	; 0x64
 80104f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80104fa:	33d0      	adds	r3, #208	; 0xd0
        text, len, alignment, NK_BUTTON_DEFAULT, &style->contextual_button, in, style->font)) {
 80104fc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80104fe:	6812      	ldr	r2, [r2, #0]
    if (nk_do_button_text(&ctx->last_widget_state, &win->buffer, bounds,
 8010500:	ed97 6a04 	vldr	s12, [r7, #16]
 8010504:	edd7 6a05 	vldr	s13, [r7, #20]
 8010508:	ed97 7a06 	vldr	s14, [r7, #24]
 801050c:	edd7 7a07 	vldr	s15, [r7, #28]
 8010510:	9204      	str	r2, [sp, #16]
 8010512:	6a3a      	ldr	r2, [r7, #32]
 8010514:	9203      	str	r2, [sp, #12]
 8010516:	9302      	str	r3, [sp, #8]
 8010518:	2300      	movs	r3, #0
 801051a:	9301      	str	r3, [sp, #4]
 801051c:	683b      	ldr	r3, [r7, #0]
 801051e:	9300      	str	r3, [sp, #0]
 8010520:	687b      	ldr	r3, [r7, #4]
 8010522:	68ba      	ldr	r2, [r7, #8]
 8010524:	eeb0 0a46 	vmov.f32	s0, s12
 8010528:	eef0 0a66 	vmov.f32	s1, s13
 801052c:	eeb0 1a47 	vmov.f32	s2, s14
 8010530:	eef0 1a67 	vmov.f32	s3, s15
 8010534:	f7fe f91e 	bl	800e774 <nk_do_button_text>
 8010538:	4603      	mov	r3, r0
 801053a:	2b00      	cmp	r3, #0
 801053c:	d004      	beq.n	8010548 <nk_contextual_item_text+0x144>
        nk_contextual_close(ctx);
 801053e:	68f8      	ldr	r0, [r7, #12]
 8010540:	f000 f826 	bl	8010590 <nk_contextual_close>
        return nk_true;
 8010544:	2301      	movs	r3, #1
 8010546:	e000      	b.n	801054a <nk_contextual_item_text+0x146>
    }
    return nk_false;
 8010548:	2300      	movs	r3, #0
}
 801054a:	4618      	mov	r0, r3
 801054c:	3730      	adds	r7, #48	; 0x30
 801054e:	46bd      	mov	sp, r7
 8010550:	bd80      	pop	{r7, pc}
 8010552:	bf00      	nop
 8010554:	08021694 	.word	0x08021694
 8010558:	08023358 	.word	0x08023358
 801055c:	08021698 	.word	0x08021698
 8010560:	080216b8 	.word	0x080216b8
 8010564:	080216c8 	.word	0x080216c8

08010568 <nk_contextual_item_label>:
NK_API nk_bool
nk_contextual_item_label(struct nk_context *ctx, const char *label, nk_flags align)
{
 8010568:	b580      	push	{r7, lr}
 801056a:	b084      	sub	sp, #16
 801056c:	af00      	add	r7, sp, #0
 801056e:	60f8      	str	r0, [r7, #12]
 8010570:	60b9      	str	r1, [r7, #8]
 8010572:	607a      	str	r2, [r7, #4]
    return nk_contextual_item_text(ctx, label, nk_strlen(label), align);
 8010574:	68b8      	ldr	r0, [r7, #8]
 8010576:	f00b fd75 	bl	801c064 <nk_strlen>
 801057a:	4602      	mov	r2, r0
 801057c:	687b      	ldr	r3, [r7, #4]
 801057e:	68b9      	ldr	r1, [r7, #8]
 8010580:	68f8      	ldr	r0, [r7, #12]
 8010582:	f7ff ff3f 	bl	8010404 <nk_contextual_item_text>
 8010586:	4603      	mov	r3, r0
}
 8010588:	4618      	mov	r0, r3
 801058a:	3710      	adds	r7, #16
 801058c:	46bd      	mov	sp, r7
 801058e:	bd80      	pop	{r7, pc}

08010590 <nk_contextual_close>:
{
    return nk_contextual_item_symbol_text(ctx, symbol, text, nk_strlen(text), align);
}
NK_API void
nk_contextual_close(struct nk_context *ctx)
{
 8010590:	b580      	push	{r7, lr}
 8010592:	b082      	sub	sp, #8
 8010594:	af00      	add	r7, sp, #0
 8010596:	6078      	str	r0, [r7, #4]
    NK_ASSERT(ctx);
 8010598:	687b      	ldr	r3, [r7, #4]
 801059a:	2b00      	cmp	r3, #0
 801059c:	d105      	bne.n	80105aa <nk_contextual_close+0x1a>
 801059e:	4b1e      	ldr	r3, [pc, #120]	; (8010618 <nk_contextual_close+0x88>)
 80105a0:	4a1e      	ldr	r2, [pc, #120]	; (801061c <nk_contextual_close+0x8c>)
 80105a2:	21b2      	movs	r1, #178	; 0xb2
 80105a4:	481e      	ldr	r0, [pc, #120]	; (8010620 <nk_contextual_close+0x90>)
 80105a6:	f00d fa37 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 80105aa:	687b      	ldr	r3, [r7, #4]
 80105ac:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80105b0:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 80105b4:	2b00      	cmp	r3, #0
 80105b6:	d105      	bne.n	80105c4 <nk_contextual_close+0x34>
 80105b8:	4b1a      	ldr	r3, [pc, #104]	; (8010624 <nk_contextual_close+0x94>)
 80105ba:	4a18      	ldr	r2, [pc, #96]	; (801061c <nk_contextual_close+0x8c>)
 80105bc:	21b3      	movs	r1, #179	; 0xb3
 80105be:	4818      	ldr	r0, [pc, #96]	; (8010620 <nk_contextual_close+0x90>)
 80105c0:	f00d fa2a 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 80105c4:	687b      	ldr	r3, [r7, #4]
 80105c6:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80105ca:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 80105ce:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80105d2:	2b00      	cmp	r3, #0
 80105d4:	d105      	bne.n	80105e2 <nk_contextual_close+0x52>
 80105d6:	4b14      	ldr	r3, [pc, #80]	; (8010628 <nk_contextual_close+0x98>)
 80105d8:	4a10      	ldr	r2, [pc, #64]	; (801061c <nk_contextual_close+0x8c>)
 80105da:	21b4      	movs	r1, #180	; 0xb4
 80105dc:	4810      	ldr	r0, [pc, #64]	; (8010620 <nk_contextual_close+0x90>)
 80105de:	f00d fa1b 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout) return;
 80105e2:	687b      	ldr	r3, [r7, #4]
 80105e4:	2b00      	cmp	r3, #0
 80105e6:	d013      	beq.n	8010610 <nk_contextual_close+0x80>
 80105e8:	687b      	ldr	r3, [r7, #4]
 80105ea:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80105ee:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 80105f2:	2b00      	cmp	r3, #0
 80105f4:	d00c      	beq.n	8010610 <nk_contextual_close+0x80>
 80105f6:	687b      	ldr	r3, [r7, #4]
 80105f8:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80105fc:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8010600:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8010604:	2b00      	cmp	r3, #0
 8010606:	d003      	beq.n	8010610 <nk_contextual_close+0x80>
    nk_popup_close(ctx);
 8010608:	6878      	ldr	r0, [r7, #4]
 801060a:	f006 f8b3 	bl	8016774 <nk_popup_close>
 801060e:	e000      	b.n	8010612 <nk_contextual_close+0x82>
    if (!ctx || !ctx->current || !ctx->current->layout) return;
 8010610:	bf00      	nop
}
 8010612:	3708      	adds	r7, #8
 8010614:	46bd      	mov	sp, r7
 8010616:	bd80      	pop	{r7, pc}
 8010618:	08021694 	.word	0x08021694
 801061c:	08023370 	.word	0x08023370
 8010620:	08021698 	.word	0x08021698
 8010624:	080216b8 	.word	0x080216b8
 8010628:	080216c8 	.word	0x080216c8

0801062c <nk_contextual_end>:
NK_API void
nk_contextual_end(struct nk_context *ctx)
{
 801062c:	b590      	push	{r4, r7, lr}
 801062e:	b08d      	sub	sp, #52	; 0x34
 8010630:	af00      	add	r7, sp, #0
 8010632:	6078      	str	r0, [r7, #4]
    struct nk_window *popup;
    struct nk_panel *panel;
    NK_ASSERT(ctx);
 8010634:	687b      	ldr	r3, [r7, #4]
 8010636:	2b00      	cmp	r3, #0
 8010638:	d105      	bne.n	8010646 <nk_contextual_end+0x1a>
 801063a:	4b69      	ldr	r3, [pc, #420]	; (80107e0 <nk_contextual_end+0x1b4>)
 801063c:	4a69      	ldr	r2, [pc, #420]	; (80107e4 <nk_contextual_end+0x1b8>)
 801063e:	21bd      	movs	r1, #189	; 0xbd
 8010640:	4869      	ldr	r0, [pc, #420]	; (80107e8 <nk_contextual_end+0x1bc>)
 8010642:	f00d f9e9 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 8010646:	687b      	ldr	r3, [r7, #4]
 8010648:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801064c:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8010650:	2b00      	cmp	r3, #0
 8010652:	d105      	bne.n	8010660 <nk_contextual_end+0x34>
 8010654:	4b65      	ldr	r3, [pc, #404]	; (80107ec <nk_contextual_end+0x1c0>)
 8010656:	4a63      	ldr	r2, [pc, #396]	; (80107e4 <nk_contextual_end+0x1b8>)
 8010658:	21be      	movs	r1, #190	; 0xbe
 801065a:	4863      	ldr	r0, [pc, #396]	; (80107e8 <nk_contextual_end+0x1bc>)
 801065c:	f00d f9dc 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current) return;
 8010660:	687b      	ldr	r3, [r7, #4]
 8010662:	2b00      	cmp	r3, #0
 8010664:	f000 80b8 	beq.w	80107d8 <nk_contextual_end+0x1ac>
 8010668:	687b      	ldr	r3, [r7, #4]
 801066a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801066e:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8010672:	2b00      	cmp	r3, #0
 8010674:	f000 80b0 	beq.w	80107d8 <nk_contextual_end+0x1ac>

    popup = ctx->current;
 8010678:	687b      	ldr	r3, [r7, #4]
 801067a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801067e:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8010682:	62fb      	str	r3, [r7, #44]	; 0x2c
    panel = popup->layout;
 8010684:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010686:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801068a:	62bb      	str	r3, [r7, #40]	; 0x28
    NK_ASSERT(popup->parent);
 801068c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801068e:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 8010692:	2b00      	cmp	r3, #0
 8010694:	d105      	bne.n	80106a2 <nk_contextual_end+0x76>
 8010696:	4b56      	ldr	r3, [pc, #344]	; (80107f0 <nk_contextual_end+0x1c4>)
 8010698:	4a52      	ldr	r2, [pc, #328]	; (80107e4 <nk_contextual_end+0x1b8>)
 801069a:	21c3      	movs	r1, #195	; 0xc3
 801069c:	4852      	ldr	r0, [pc, #328]	; (80107e8 <nk_contextual_end+0x1bc>)
 801069e:	f00d f9bb 	bl	801da18 <__assert_func>
    NK_ASSERT(panel->type & NK_PANEL_SET_POPUP);
 80106a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80106a4:	781b      	ldrb	r3, [r3, #0]
 80106a6:	f003 03f4 	and.w	r3, r3, #244	; 0xf4
 80106aa:	2b00      	cmp	r3, #0
 80106ac:	d105      	bne.n	80106ba <nk_contextual_end+0x8e>
 80106ae:	4b51      	ldr	r3, [pc, #324]	; (80107f4 <nk_contextual_end+0x1c8>)
 80106b0:	4a4c      	ldr	r2, [pc, #304]	; (80107e4 <nk_contextual_end+0x1b8>)
 80106b2:	21c4      	movs	r1, #196	; 0xc4
 80106b4:	484c      	ldr	r0, [pc, #304]	; (80107e8 <nk_contextual_end+0x1bc>)
 80106b6:	f00d f9af 	bl	801da18 <__assert_func>
    if (panel->flags & NK_WINDOW_DYNAMIC) {
 80106ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80106bc:	685b      	ldr	r3, [r3, #4]
 80106be:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80106c2:	2b00      	cmp	r3, #0
 80106c4:	d07b      	beq.n	80107be <nk_contextual_end+0x192>
        /* Close behavior
        This is a bit of a hack solution since we do not know before we end our popup
        how big it will be. We therefore do not directly know when a
        click outside the non-blocking popup must close it at that direct frame.
        Instead it will be closed in the next frame.*/
        struct nk_rect body = {0,0,0,0};
 80106c6:	f107 0310 	add.w	r3, r7, #16
 80106ca:	2200      	movs	r2, #0
 80106cc:	601a      	str	r2, [r3, #0]
 80106ce:	605a      	str	r2, [r3, #4]
 80106d0:	609a      	str	r2, [r3, #8]
 80106d2:	60da      	str	r2, [r3, #12]
        if (panel->at_y < (panel->bounds.y + panel->bounds.h)) {
 80106d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80106d6:	ed93 7a09 	vldr	s14, [r3, #36]	; 0x24
 80106da:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80106dc:	edd3 6a03 	vldr	s13, [r3, #12]
 80106e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80106e2:	edd3 7a05 	vldr	s15, [r3, #20]
 80106e6:	ee76 7aa7 	vadd.f32	s15, s13, s15
 80106ea:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80106ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80106f2:	d53d      	bpl.n	8010770 <nk_contextual_end+0x144>
            struct nk_vec2 padding = nk_panel_get_padding(&ctx->style, panel->type);
 80106f4:	687b      	ldr	r3, [r7, #4]
 80106f6:	f503 72b4 	add.w	r2, r3, #360	; 0x168
 80106fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80106fc:	781b      	ldrb	r3, [r3, #0]
 80106fe:	4619      	mov	r1, r3
 8010700:	4610      	mov	r0, r2
 8010702:	f003 fc93 	bl	801402c <nk_panel_get_padding>
 8010706:	eeb0 7a40 	vmov.f32	s14, s0
 801070a:	eef0 7a60 	vmov.f32	s15, s1
 801070e:	ed87 7a02 	vstr	s14, [r7, #8]
 8010712:	edc7 7a03 	vstr	s15, [r7, #12]
            body = panel->bounds;
 8010716:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010718:	f107 0410 	add.w	r4, r7, #16
 801071c:	3308      	adds	r3, #8
 801071e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8010720:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
            body.y = (panel->at_y + panel->footer_height + panel->border + padding.y + panel->row.height);
 8010724:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010726:	ed93 7a09 	vldr	s14, [r3, #36]	; 0x24
 801072a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801072c:	edd3 7a0b 	vldr	s15, [r3, #44]	; 0x2c
 8010730:	ee37 7a27 	vadd.f32	s14, s14, s15
 8010734:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010736:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
 801073a:	ee37 7a27 	vadd.f32	s14, s14, s15
 801073e:	edd7 7a03 	vldr	s15, [r7, #12]
 8010742:	ee37 7a27 	vadd.f32	s14, s14, s15
 8010746:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010748:	edd3 7a1b 	vldr	s15, [r3, #108]	; 0x6c
 801074c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8010750:	edc7 7a05 	vstr	s15, [r7, #20]
            body.h = (panel->bounds.y + panel->bounds.h) - body.y;
 8010754:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010756:	ed93 7a03 	vldr	s14, [r3, #12]
 801075a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801075c:	edd3 7a05 	vldr	s15, [r3, #20]
 8010760:	ee37 7a27 	vadd.f32	s14, s14, s15
 8010764:	edd7 7a05 	vldr	s15, [r7, #20]
 8010768:	ee77 7a67 	vsub.f32	s15, s14, s15
 801076c:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        {int pressed = nk_input_is_mouse_pressed(&ctx->input, NK_BUTTON_LEFT);
 8010770:	687b      	ldr	r3, [r7, #4]
 8010772:	2100      	movs	r1, #0
 8010774:	4618      	mov	r0, r3
 8010776:	f001 ff8e 	bl	8012696 <nk_input_is_mouse_pressed>
 801077a:	6278      	str	r0, [r7, #36]	; 0x24
        int in_body = nk_input_is_mouse_hovering_rect(&ctx->input, body);
 801077c:	687b      	ldr	r3, [r7, #4]
 801077e:	ed97 6a04 	vldr	s12, [r7, #16]
 8010782:	edd7 6a05 	vldr	s13, [r7, #20]
 8010786:	ed97 7a06 	vldr	s14, [r7, #24]
 801078a:	edd7 7a07 	vldr	s15, [r7, #28]
 801078e:	eeb0 0a46 	vmov.f32	s0, s12
 8010792:	eef0 0a66 	vmov.f32	s1, s13
 8010796:	eeb0 1a47 	vmov.f32	s2, s14
 801079a:	eef0 1a67 	vmov.f32	s3, s15
 801079e:	4618      	mov	r0, r3
 80107a0:	f001 febd 	bl	801251e <nk_input_is_mouse_hovering_rect>
 80107a4:	6238      	str	r0, [r7, #32]
        if (pressed && in_body)
 80107a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80107a8:	2b00      	cmp	r3, #0
 80107aa:	d008      	beq.n	80107be <nk_contextual_end+0x192>
 80107ac:	6a3b      	ldr	r3, [r7, #32]
 80107ae:	2b00      	cmp	r3, #0
 80107b0:	d005      	beq.n	80107be <nk_contextual_end+0x192>
            popup->flags |= NK_WINDOW_HIDDEN;
 80107b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80107b4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80107b6:	f443 5200 	orr.w	r2, r3, #8192	; 0x2000
 80107ba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80107bc:	649a      	str	r2, [r3, #72]	; 0x48
        }
    }
    if (popup->flags & NK_WINDOW_HIDDEN)
 80107be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80107c0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80107c2:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 80107c6:	2b00      	cmp	r3, #0
 80107c8:	d002      	beq.n	80107d0 <nk_contextual_end+0x1a4>
        popup->seq = 0;
 80107ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80107cc:	2200      	movs	r2, #0
 80107ce:	601a      	str	r2, [r3, #0]
    nk_popup_end(ctx);
 80107d0:	6878      	ldr	r0, [r7, #4]
 80107d2:	f006 f81b 	bl	801680c <nk_popup_end>
    return;
 80107d6:	e000      	b.n	80107da <nk_contextual_end+0x1ae>
    if (!ctx || !ctx->current) return;
 80107d8:	bf00      	nop
}
 80107da:	3734      	adds	r7, #52	; 0x34
 80107dc:	46bd      	mov	sp, r7
 80107de:	bd90      	pop	{r4, r7, pc}
 80107e0:	08021694 	.word	0x08021694
 80107e4:	08023384 	.word	0x08023384
 80107e8:	08021698 	.word	0x08021698
 80107ec:	080216b8 	.word	0x080216b8
 80107f0:	080216e0 	.word	0x080216e0
 80107f4:	080216f0 	.word	0x080216f0

080107f8 <nk_command_buffer_init>:
 *
 * ===============================================================*/
NK_LIB void
nk_command_buffer_init(struct nk_command_buffer *cb,
    struct nk_buffer *b, enum nk_command_clipping clip)
{
 80107f8:	b580      	push	{r7, lr}
 80107fa:	b084      	sub	sp, #16
 80107fc:	af00      	add	r7, sp, #0
 80107fe:	60f8      	str	r0, [r7, #12]
 8010800:	60b9      	str	r1, [r7, #8]
 8010802:	4613      	mov	r3, r2
 8010804:	71fb      	strb	r3, [r7, #7]
    NK_ASSERT(cb);
 8010806:	68fb      	ldr	r3, [r7, #12]
 8010808:	2b00      	cmp	r3, #0
 801080a:	d105      	bne.n	8010818 <nk_command_buffer_init+0x20>
 801080c:	4b15      	ldr	r3, [pc, #84]	; (8010864 <nk_command_buffer_init+0x6c>)
 801080e:	4a16      	ldr	r2, [pc, #88]	; (8010868 <nk_command_buffer_init+0x70>)
 8010810:	210d      	movs	r1, #13
 8010812:	4816      	ldr	r0, [pc, #88]	; (801086c <nk_command_buffer_init+0x74>)
 8010814:	f00d f900 	bl	801da18 <__assert_func>
    NK_ASSERT(b);
 8010818:	68bb      	ldr	r3, [r7, #8]
 801081a:	2b00      	cmp	r3, #0
 801081c:	d105      	bne.n	801082a <nk_command_buffer_init+0x32>
 801081e:	4b14      	ldr	r3, [pc, #80]	; (8010870 <nk_command_buffer_init+0x78>)
 8010820:	4a11      	ldr	r2, [pc, #68]	; (8010868 <nk_command_buffer_init+0x70>)
 8010822:	210e      	movs	r1, #14
 8010824:	4811      	ldr	r0, [pc, #68]	; (801086c <nk_command_buffer_init+0x74>)
 8010826:	f00d f8f7 	bl	801da18 <__assert_func>
    if (!cb || !b) return;
 801082a:	68fb      	ldr	r3, [r7, #12]
 801082c:	2b00      	cmp	r3, #0
 801082e:	d015      	beq.n	801085c <nk_command_buffer_init+0x64>
 8010830:	68bb      	ldr	r3, [r7, #8]
 8010832:	2b00      	cmp	r3, #0
 8010834:	d012      	beq.n	801085c <nk_command_buffer_init+0x64>
    cb->base = b;
 8010836:	68fb      	ldr	r3, [r7, #12]
 8010838:	68ba      	ldr	r2, [r7, #8]
 801083a:	601a      	str	r2, [r3, #0]
    cb->use_clipping = (int)clip;
 801083c:	79fa      	ldrb	r2, [r7, #7]
 801083e:	68fb      	ldr	r3, [r7, #12]
 8010840:	615a      	str	r2, [r3, #20]
    cb->begin = b->allocated;
 8010842:	68bb      	ldr	r3, [r7, #8]
 8010844:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8010846:	68fb      	ldr	r3, [r7, #12]
 8010848:	61da      	str	r2, [r3, #28]
    cb->end = b->allocated;
 801084a:	68bb      	ldr	r3, [r7, #8]
 801084c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801084e:	68fb      	ldr	r3, [r7, #12]
 8010850:	621a      	str	r2, [r3, #32]
    cb->last = b->allocated;
 8010852:	68bb      	ldr	r3, [r7, #8]
 8010854:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8010856:	68fb      	ldr	r3, [r7, #12]
 8010858:	625a      	str	r2, [r3, #36]	; 0x24
 801085a:	e000      	b.n	801085e <nk_command_buffer_init+0x66>
    if (!cb || !b) return;
 801085c:	bf00      	nop
}
 801085e:	3710      	adds	r7, #16
 8010860:	46bd      	mov	sp, r7
 8010862:	bd80      	pop	{r7, pc}
 8010864:	08021714 	.word	0x08021714
 8010868:	080233a8 	.word	0x080233a8
 801086c:	08021718 	.word	0x08021718
 8010870:	08021734 	.word	0x08021734

08010874 <nk_command_buffer_reset>:
NK_LIB void
nk_command_buffer_reset(struct nk_command_buffer *b)
{
 8010874:	b590      	push	{r4, r7, lr}
 8010876:	b083      	sub	sp, #12
 8010878:	af00      	add	r7, sp, #0
 801087a:	6078      	str	r0, [r7, #4]
    NK_ASSERT(b);
 801087c:	687b      	ldr	r3, [r7, #4]
 801087e:	2b00      	cmp	r3, #0
 8010880:	d105      	bne.n	801088e <nk_command_buffer_reset+0x1a>
 8010882:	4b0f      	ldr	r3, [pc, #60]	; (80108c0 <nk_command_buffer_reset+0x4c>)
 8010884:	4a0f      	ldr	r2, [pc, #60]	; (80108c4 <nk_command_buffer_reset+0x50>)
 8010886:	2119      	movs	r1, #25
 8010888:	480f      	ldr	r0, [pc, #60]	; (80108c8 <nk_command_buffer_reset+0x54>)
 801088a:	f00d f8c5 	bl	801da18 <__assert_func>
    if (!b) return;
 801088e:	687b      	ldr	r3, [r7, #4]
 8010890:	2b00      	cmp	r3, #0
 8010892:	d010      	beq.n	80108b6 <nk_command_buffer_reset+0x42>
    b->begin = 0;
 8010894:	687b      	ldr	r3, [r7, #4]
 8010896:	2200      	movs	r2, #0
 8010898:	61da      	str	r2, [r3, #28]
    b->end = 0;
 801089a:	687b      	ldr	r3, [r7, #4]
 801089c:	2200      	movs	r2, #0
 801089e:	621a      	str	r2, [r3, #32]
    b->last = 0;
 80108a0:	687b      	ldr	r3, [r7, #4]
 80108a2:	2200      	movs	r2, #0
 80108a4:	625a      	str	r2, [r3, #36]	; 0x24
    b->clip = nk_null_rect;
 80108a6:	687b      	ldr	r3, [r7, #4]
 80108a8:	4a08      	ldr	r2, [pc, #32]	; (80108cc <nk_command_buffer_reset+0x58>)
 80108aa:	1d1c      	adds	r4, r3, #4
 80108ac:	4613      	mov	r3, r2
 80108ae:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80108b0:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 80108b4:	e000      	b.n	80108b8 <nk_command_buffer_reset+0x44>
    if (!b) return;
 80108b6:	bf00      	nop
#ifdef NK_INCLUDE_COMMAND_USERDATA
    b->userdata.ptr = 0;
#endif
}
 80108b8:	370c      	adds	r7, #12
 80108ba:	46bd      	mov	sp, r7
 80108bc:	bd90      	pop	{r4, r7, pc}
 80108be:	bf00      	nop
 80108c0:	08021734 	.word	0x08021734
 80108c4:	080233c0 	.word	0x080233c0
 80108c8:	08021718 	.word	0x08021718
 80108cc:	08023398 	.word	0x08023398

080108d0 <nk_command_buffer_push>:
NK_LIB void*
nk_command_buffer_push(struct nk_command_buffer* b,
    enum nk_command_type t, nk_size size)
{
 80108d0:	b580      	push	{r7, lr}
 80108d2:	b088      	sub	sp, #32
 80108d4:	af00      	add	r7, sp, #0
 80108d6:	60f8      	str	r0, [r7, #12]
 80108d8:	460b      	mov	r3, r1
 80108da:	607a      	str	r2, [r7, #4]
 80108dc:	72fb      	strb	r3, [r7, #11]
    struct nk_command *cmd;
    nk_size alignment;
    void *unaligned;
    void *memory;

    NK_ASSERT(b);
 80108de:	68fb      	ldr	r3, [r7, #12]
 80108e0:	2b00      	cmp	r3, #0
 80108e2:	d105      	bne.n	80108f0 <nk_command_buffer_push+0x20>
 80108e4:	4b28      	ldr	r3, [pc, #160]	; (8010988 <nk_command_buffer_push+0xb8>)
 80108e6:	4a29      	ldr	r2, [pc, #164]	; (801098c <nk_command_buffer_push+0xbc>)
 80108e8:	212d      	movs	r1, #45	; 0x2d
 80108ea:	4829      	ldr	r0, [pc, #164]	; (8010990 <nk_command_buffer_push+0xc0>)
 80108ec:	f00d f894 	bl	801da18 <__assert_func>
    NK_ASSERT(b->base);
 80108f0:	68fb      	ldr	r3, [r7, #12]
 80108f2:	681b      	ldr	r3, [r3, #0]
 80108f4:	2b00      	cmp	r3, #0
 80108f6:	d105      	bne.n	8010904 <nk_command_buffer_push+0x34>
 80108f8:	4b26      	ldr	r3, [pc, #152]	; (8010994 <nk_command_buffer_push+0xc4>)
 80108fa:	4a24      	ldr	r2, [pc, #144]	; (801098c <nk_command_buffer_push+0xbc>)
 80108fc:	212e      	movs	r1, #46	; 0x2e
 80108fe:	4824      	ldr	r0, [pc, #144]	; (8010990 <nk_command_buffer_push+0xc0>)
 8010900:	f00d f88a 	bl	801da18 <__assert_func>
    if (!b) return 0;
 8010904:	68fb      	ldr	r3, [r7, #12]
 8010906:	2b00      	cmp	r3, #0
 8010908:	d101      	bne.n	801090e <nk_command_buffer_push+0x3e>
 801090a:	2300      	movs	r3, #0
 801090c:	e037      	b.n	801097e <nk_command_buffer_push+0xae>
    cmd = (struct nk_command*)nk_buffer_alloc(b->base,NK_BUFFER_FRONT,size,align);
 801090e:	68fb      	ldr	r3, [r7, #12]
 8010910:	6818      	ldr	r0, [r3, #0]
 8010912:	4b21      	ldr	r3, [pc, #132]	; (8010998 <nk_command_buffer_push+0xc8>)
 8010914:	681b      	ldr	r3, [r3, #0]
 8010916:	687a      	ldr	r2, [r7, #4]
 8010918:	2100      	movs	r1, #0
 801091a:	f7fd f96f 	bl	800dbfc <nk_buffer_alloc>
 801091e:	61f8      	str	r0, [r7, #28]
    if (!cmd) return 0;
 8010920:	69fb      	ldr	r3, [r7, #28]
 8010922:	2b00      	cmp	r3, #0
 8010924:	d101      	bne.n	801092a <nk_command_buffer_push+0x5a>
 8010926:	2300      	movs	r3, #0
 8010928:	e029      	b.n	801097e <nk_command_buffer_push+0xae>

    /* make sure the offset to the next command is aligned */
    b->last = (nk_size)((nk_byte*)cmd - (nk_byte*)b->base->memory.ptr);
 801092a:	68fb      	ldr	r3, [r7, #12]
 801092c:	681b      	ldr	r3, [r3, #0]
 801092e:	6a1b      	ldr	r3, [r3, #32]
 8010930:	69fa      	ldr	r2, [r7, #28]
 8010932:	1ad3      	subs	r3, r2, r3
 8010934:	461a      	mov	r2, r3
 8010936:	68fb      	ldr	r3, [r7, #12]
 8010938:	625a      	str	r2, [r3, #36]	; 0x24
    unaligned = (nk_byte*)cmd + size;
 801093a:	69fa      	ldr	r2, [r7, #28]
 801093c:	687b      	ldr	r3, [r7, #4]
 801093e:	4413      	add	r3, r2
 8010940:	61bb      	str	r3, [r7, #24]
    memory = NK_ALIGN_PTR(unaligned, align);
 8010942:	4b15      	ldr	r3, [pc, #84]	; (8010998 <nk_command_buffer_push+0xc8>)
 8010944:	681b      	ldr	r3, [r3, #0]
 8010946:	3b01      	subs	r3, #1
 8010948:	69ba      	ldr	r2, [r7, #24]
 801094a:	4413      	add	r3, r2
 801094c:	461a      	mov	r2, r3
 801094e:	4b12      	ldr	r3, [pc, #72]	; (8010998 <nk_command_buffer_push+0xc8>)
 8010950:	681b      	ldr	r3, [r3, #0]
 8010952:	425b      	negs	r3, r3
 8010954:	4013      	ands	r3, r2
 8010956:	617b      	str	r3, [r7, #20]
    alignment = (nk_size)((nk_byte*)memory - (nk_byte*)unaligned);
 8010958:	697a      	ldr	r2, [r7, #20]
 801095a:	69bb      	ldr	r3, [r7, #24]
 801095c:	1ad3      	subs	r3, r2, r3
 801095e:	613b      	str	r3, [r7, #16]
#ifdef NK_ZERO_COMMAND_MEMORY
    NK_MEMSET(cmd, 0, size + alignment);
#endif

    cmd->type = t;
 8010960:	69fb      	ldr	r3, [r7, #28]
 8010962:	7afa      	ldrb	r2, [r7, #11]
 8010964:	701a      	strb	r2, [r3, #0]
    cmd->next = b->base->allocated + alignment;
 8010966:	68fb      	ldr	r3, [r7, #12]
 8010968:	681b      	ldr	r3, [r3, #0]
 801096a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801096c:	693b      	ldr	r3, [r7, #16]
 801096e:	441a      	add	r2, r3
 8010970:	69fb      	ldr	r3, [r7, #28]
 8010972:	605a      	str	r2, [r3, #4]
#ifdef NK_INCLUDE_COMMAND_USERDATA
    cmd->userdata = b->userdata;
#endif
    b->end = cmd->next;
 8010974:	69fb      	ldr	r3, [r7, #28]
 8010976:	685a      	ldr	r2, [r3, #4]
 8010978:	68fb      	ldr	r3, [r7, #12]
 801097a:	621a      	str	r2, [r3, #32]
    return cmd;
 801097c:	69fb      	ldr	r3, [r7, #28]
}
 801097e:	4618      	mov	r0, r3
 8010980:	3720      	adds	r7, #32
 8010982:	46bd      	mov	sp, r7
 8010984:	bd80      	pop	{r7, pc}
 8010986:	bf00      	nop
 8010988:	08021734 	.word	0x08021734
 801098c:	080233d8 	.word	0x080233d8
 8010990:	08021718 	.word	0x08021718
 8010994:	08021738 	.word	0x08021738
 8010998:	080233f0 	.word	0x080233f0

0801099c <nk_push_scissor>:
NK_API void
nk_push_scissor(struct nk_command_buffer *b, struct nk_rect r)
{
 801099c:	b580      	push	{r7, lr}
 801099e:	b088      	sub	sp, #32
 80109a0:	af00      	add	r7, sp, #0
 80109a2:	6178      	str	r0, [r7, #20]
 80109a4:	eeb0 6a40 	vmov.f32	s12, s0
 80109a8:	eef0 6a60 	vmov.f32	s13, s1
 80109ac:	eeb0 7a41 	vmov.f32	s14, s2
 80109b0:	eef0 7a61 	vmov.f32	s15, s3
 80109b4:	ed87 6a01 	vstr	s12, [r7, #4]
 80109b8:	edc7 6a02 	vstr	s13, [r7, #8]
 80109bc:	ed87 7a03 	vstr	s14, [r7, #12]
 80109c0:	edc7 7a04 	vstr	s15, [r7, #16]
    struct nk_command_scissor *cmd;
    NK_ASSERT(b);
 80109c4:	697b      	ldr	r3, [r7, #20]
 80109c6:	2b00      	cmp	r3, #0
 80109c8:	d105      	bne.n	80109d6 <nk_push_scissor+0x3a>
 80109ca:	4b2d      	ldr	r3, [pc, #180]	; (8010a80 <nk_push_scissor+0xe4>)
 80109cc:	4a2d      	ldr	r2, [pc, #180]	; (8010a84 <nk_push_scissor+0xe8>)
 80109ce:	2148      	movs	r1, #72	; 0x48
 80109d0:	482d      	ldr	r0, [pc, #180]	; (8010a88 <nk_push_scissor+0xec>)
 80109d2:	f00d f821 	bl	801da18 <__assert_func>
    if (!b) return;
 80109d6:	697b      	ldr	r3, [r7, #20]
 80109d8:	2b00      	cmp	r3, #0
 80109da:	d04b      	beq.n	8010a74 <nk_push_scissor+0xd8>

    b->clip.x = r.x;
 80109dc:	687a      	ldr	r2, [r7, #4]
 80109de:	697b      	ldr	r3, [r7, #20]
 80109e0:	605a      	str	r2, [r3, #4]
    b->clip.y = r.y;
 80109e2:	68ba      	ldr	r2, [r7, #8]
 80109e4:	697b      	ldr	r3, [r7, #20]
 80109e6:	609a      	str	r2, [r3, #8]
    b->clip.w = r.w;
 80109e8:	68fa      	ldr	r2, [r7, #12]
 80109ea:	697b      	ldr	r3, [r7, #20]
 80109ec:	60da      	str	r2, [r3, #12]
    b->clip.h = r.h;
 80109ee:	693a      	ldr	r2, [r7, #16]
 80109f0:	697b      	ldr	r3, [r7, #20]
 80109f2:	611a      	str	r2, [r3, #16]
    cmd = (struct nk_command_scissor*)
        nk_command_buffer_push(b, NK_COMMAND_SCISSOR, sizeof(*cmd));
 80109f4:	2210      	movs	r2, #16
 80109f6:	2101      	movs	r1, #1
 80109f8:	6978      	ldr	r0, [r7, #20]
 80109fa:	f7ff ff69 	bl	80108d0 <nk_command_buffer_push>
 80109fe:	61f8      	str	r0, [r7, #28]

    if (!cmd) return;
 8010a00:	69fb      	ldr	r3, [r7, #28]
 8010a02:	2b00      	cmp	r3, #0
 8010a04:	d038      	beq.n	8010a78 <nk_push_scissor+0xdc>
    cmd->x = (short)r.x;
 8010a06:	edd7 7a01 	vldr	s15, [r7, #4]
 8010a0a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8010a0e:	ee17 3a90 	vmov	r3, s15
 8010a12:	b21a      	sxth	r2, r3
 8010a14:	69fb      	ldr	r3, [r7, #28]
 8010a16:	811a      	strh	r2, [r3, #8]
    cmd->y = (short)r.y;
 8010a18:	edd7 7a02 	vldr	s15, [r7, #8]
 8010a1c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8010a20:	ee17 3a90 	vmov	r3, s15
 8010a24:	b21a      	sxth	r2, r3
 8010a26:	69fb      	ldr	r3, [r7, #28]
 8010a28:	815a      	strh	r2, [r3, #10]
    cmd->w = (unsigned short)NK_MAX(0, r.w);
 8010a2a:	edd7 7a03 	vldr	s15, [r7, #12]
 8010a2e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8010a32:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010a36:	dd07      	ble.n	8010a48 <nk_push_scissor+0xac>
 8010a38:	edd7 7a03 	vldr	s15, [r7, #12]
 8010a3c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8010a40:	ee17 3a90 	vmov	r3, s15
 8010a44:	b29a      	uxth	r2, r3
 8010a46:	e000      	b.n	8010a4a <nk_push_scissor+0xae>
 8010a48:	2200      	movs	r2, #0
 8010a4a:	69fb      	ldr	r3, [r7, #28]
 8010a4c:	819a      	strh	r2, [r3, #12]
    cmd->h = (unsigned short)NK_MAX(0, r.h);
 8010a4e:	edd7 7a04 	vldr	s15, [r7, #16]
 8010a52:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8010a56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010a5a:	dd07      	ble.n	8010a6c <nk_push_scissor+0xd0>
 8010a5c:	edd7 7a04 	vldr	s15, [r7, #16]
 8010a60:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8010a64:	ee17 3a90 	vmov	r3, s15
 8010a68:	b29a      	uxth	r2, r3
 8010a6a:	e000      	b.n	8010a6e <nk_push_scissor+0xd2>
 8010a6c:	2200      	movs	r2, #0
 8010a6e:	69fb      	ldr	r3, [r7, #28]
 8010a70:	81da      	strh	r2, [r3, #14]
 8010a72:	e002      	b.n	8010a7a <nk_push_scissor+0xde>
    if (!b) return;
 8010a74:	bf00      	nop
 8010a76:	e000      	b.n	8010a7a <nk_push_scissor+0xde>
    if (!cmd) return;
 8010a78:	bf00      	nop
}
 8010a7a:	3720      	adds	r7, #32
 8010a7c:	46bd      	mov	sp, r7
 8010a7e:	bd80      	pop	{r7, pc}
 8010a80:	08021734 	.word	0x08021734
 8010a84:	080233f4 	.word	0x080233f4
 8010a88:	08021718 	.word	0x08021718

08010a8c <nk_stroke_rect>:
    cmd->color = col;
}
NK_API void
nk_stroke_rect(struct nk_command_buffer *b, struct nk_rect rect,
    float rounding, float line_thickness, struct nk_color c)
{
 8010a8c:	b580      	push	{r7, lr}
 8010a8e:	b08a      	sub	sp, #40	; 0x28
 8010a90:	af00      	add	r7, sp, #0
 8010a92:	61f8      	str	r0, [r7, #28]
 8010a94:	eeb0 6a40 	vmov.f32	s12, s0
 8010a98:	eef0 6a60 	vmov.f32	s13, s1
 8010a9c:	eeb0 7a41 	vmov.f32	s14, s2
 8010aa0:	eef0 7a61 	vmov.f32	s15, s3
 8010aa4:	ed87 2a02 	vstr	s4, [r7, #8]
 8010aa8:	edc7 2a01 	vstr	s5, [r7, #4]
 8010aac:	6039      	str	r1, [r7, #0]
 8010aae:	ed87 6a03 	vstr	s12, [r7, #12]
 8010ab2:	edc7 6a04 	vstr	s13, [r7, #16]
 8010ab6:	ed87 7a05 	vstr	s14, [r7, #20]
 8010aba:	edc7 7a06 	vstr	s15, [r7, #24]
    struct nk_command_rect *cmd;
    NK_ASSERT(b);
 8010abe:	69fb      	ldr	r3, [r7, #28]
 8010ac0:	2b00      	cmp	r3, #0
 8010ac2:	d105      	bne.n	8010ad0 <nk_stroke_rect+0x44>
 8010ac4:	4b72      	ldr	r3, [pc, #456]	; (8010c90 <nk_stroke_rect+0x204>)
 8010ac6:	4a73      	ldr	r2, [pc, #460]	; (8010c94 <nk_stroke_rect+0x208>)
 8010ac8:	2185      	movs	r1, #133	; 0x85
 8010aca:	4873      	ldr	r0, [pc, #460]	; (8010c98 <nk_stroke_rect+0x20c>)
 8010acc:	f00c ffa4 	bl	801da18 <__assert_func>
    if (!b || c.a == 0 || rect.w == 0 || rect.h == 0 || line_thickness <= 0) return;
 8010ad0:	69fb      	ldr	r3, [r7, #28]
 8010ad2:	2b00      	cmp	r3, #0
 8010ad4:	f000 80d4 	beq.w	8010c80 <nk_stroke_rect+0x1f4>
 8010ad8:	78fb      	ldrb	r3, [r7, #3]
 8010ada:	2b00      	cmp	r3, #0
 8010adc:	f000 80d0 	beq.w	8010c80 <nk_stroke_rect+0x1f4>
 8010ae0:	edd7 7a05 	vldr	s15, [r7, #20]
 8010ae4:	eef5 7a40 	vcmp.f32	s15, #0.0
 8010ae8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010aec:	f000 80c8 	beq.w	8010c80 <nk_stroke_rect+0x1f4>
 8010af0:	edd7 7a06 	vldr	s15, [r7, #24]
 8010af4:	eef5 7a40 	vcmp.f32	s15, #0.0
 8010af8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010afc:	f000 80c0 	beq.w	8010c80 <nk_stroke_rect+0x1f4>
 8010b00:	edd7 7a01 	vldr	s15, [r7, #4]
 8010b04:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8010b08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010b0c:	f240 80b8 	bls.w	8010c80 <nk_stroke_rect+0x1f4>
    if (b->use_clipping) {
 8010b10:	69fb      	ldr	r3, [r7, #28]
 8010b12:	695b      	ldr	r3, [r3, #20]
 8010b14:	2b00      	cmp	r3, #0
 8010b16:	d05e      	beq.n	8010bd6 <nk_stroke_rect+0x14a>
        const struct nk_rect *clip = &b->clip;
 8010b18:	69fb      	ldr	r3, [r7, #28]
 8010b1a:	3304      	adds	r3, #4
 8010b1c:	627b      	str	r3, [r7, #36]	; 0x24
        if (!NK_INTERSECT(rect.x, rect.y, rect.w, rect.h,
 8010b1e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010b20:	ed93 7a00 	vldr	s14, [r3]
 8010b24:	edd7 6a03 	vldr	s13, [r7, #12]
 8010b28:	edd7 7a05 	vldr	s15, [r7, #20]
 8010b2c:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8010b30:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8010b34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010b38:	bf4c      	ite	mi
 8010b3a:	2301      	movmi	r3, #1
 8010b3c:	2300      	movpl	r3, #0
 8010b3e:	b2db      	uxtb	r3, r3
 8010b40:	f083 0301 	eor.w	r3, r3, #1
 8010b44:	b2db      	uxtb	r3, r3
 8010b46:	2b00      	cmp	r3, #0
 8010b48:	f040 809c 	bne.w	8010c84 <nk_stroke_rect+0x1f8>
 8010b4c:	ed97 7a03 	vldr	s14, [r7, #12]
 8010b50:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010b52:	edd3 6a00 	vldr	s13, [r3]
 8010b56:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010b58:	edd3 7a02 	vldr	s15, [r3, #8]
 8010b5c:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8010b60:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8010b64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010b68:	bf4c      	ite	mi
 8010b6a:	2301      	movmi	r3, #1
 8010b6c:	2300      	movpl	r3, #0
 8010b6e:	b2db      	uxtb	r3, r3
 8010b70:	f083 0301 	eor.w	r3, r3, #1
 8010b74:	b2db      	uxtb	r3, r3
 8010b76:	2b00      	cmp	r3, #0
 8010b78:	f040 8084 	bne.w	8010c84 <nk_stroke_rect+0x1f8>
 8010b7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010b7e:	ed93 7a01 	vldr	s14, [r3, #4]
 8010b82:	edd7 6a04 	vldr	s13, [r7, #16]
 8010b86:	edd7 7a06 	vldr	s15, [r7, #24]
 8010b8a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8010b8e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8010b92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010b96:	bf4c      	ite	mi
 8010b98:	2301      	movmi	r3, #1
 8010b9a:	2300      	movpl	r3, #0
 8010b9c:	b2db      	uxtb	r3, r3
 8010b9e:	f083 0301 	eor.w	r3, r3, #1
 8010ba2:	b2db      	uxtb	r3, r3
 8010ba4:	2b00      	cmp	r3, #0
 8010ba6:	d16d      	bne.n	8010c84 <nk_stroke_rect+0x1f8>
 8010ba8:	ed97 7a04 	vldr	s14, [r7, #16]
 8010bac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010bae:	edd3 6a01 	vldr	s13, [r3, #4]
 8010bb2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010bb4:	edd3 7a03 	vldr	s15, [r3, #12]
 8010bb8:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8010bbc:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8010bc0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010bc4:	bf4c      	ite	mi
 8010bc6:	2301      	movmi	r3, #1
 8010bc8:	2300      	movpl	r3, #0
 8010bca:	b2db      	uxtb	r3, r3
 8010bcc:	f083 0301 	eor.w	r3, r3, #1
 8010bd0:	b2db      	uxtb	r3, r3
 8010bd2:	2b00      	cmp	r3, #0
 8010bd4:	d156      	bne.n	8010c84 <nk_stroke_rect+0x1f8>
            clip->x, clip->y, clip->w, clip->h)) return;
    }
    cmd = (struct nk_command_rect*)
        nk_command_buffer_push(b, NK_COMMAND_RECT, sizeof(*cmd));
 8010bd6:	2218      	movs	r2, #24
 8010bd8:	2104      	movs	r1, #4
 8010bda:	69f8      	ldr	r0, [r7, #28]
 8010bdc:	f7ff fe78 	bl	80108d0 <nk_command_buffer_push>
 8010be0:	6238      	str	r0, [r7, #32]
    if (!cmd) return;
 8010be2:	6a3b      	ldr	r3, [r7, #32]
 8010be4:	2b00      	cmp	r3, #0
 8010be6:	d04f      	beq.n	8010c88 <nk_stroke_rect+0x1fc>
    cmd->rounding = (unsigned short)rounding;
 8010be8:	edd7 7a02 	vldr	s15, [r7, #8]
 8010bec:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8010bf0:	ee17 3a90 	vmov	r3, s15
 8010bf4:	b29a      	uxth	r2, r3
 8010bf6:	6a3b      	ldr	r3, [r7, #32]
 8010bf8:	811a      	strh	r2, [r3, #8]
    cmd->line_thickness = (unsigned short)line_thickness;
 8010bfa:	edd7 7a01 	vldr	s15, [r7, #4]
 8010bfe:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8010c02:	ee17 3a90 	vmov	r3, s15
 8010c06:	b29a      	uxth	r2, r3
 8010c08:	6a3b      	ldr	r3, [r7, #32]
 8010c0a:	815a      	strh	r2, [r3, #10]
    cmd->x = (short)rect.x;
 8010c0c:	edd7 7a03 	vldr	s15, [r7, #12]
 8010c10:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8010c14:	ee17 3a90 	vmov	r3, s15
 8010c18:	b21a      	sxth	r2, r3
 8010c1a:	6a3b      	ldr	r3, [r7, #32]
 8010c1c:	819a      	strh	r2, [r3, #12]
    cmd->y = (short)rect.y;
 8010c1e:	edd7 7a04 	vldr	s15, [r7, #16]
 8010c22:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8010c26:	ee17 3a90 	vmov	r3, s15
 8010c2a:	b21a      	sxth	r2, r3
 8010c2c:	6a3b      	ldr	r3, [r7, #32]
 8010c2e:	81da      	strh	r2, [r3, #14]
    cmd->w = (unsigned short)NK_MAX(0, rect.w);
 8010c30:	edd7 7a05 	vldr	s15, [r7, #20]
 8010c34:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8010c38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010c3c:	dd07      	ble.n	8010c4e <nk_stroke_rect+0x1c2>
 8010c3e:	edd7 7a05 	vldr	s15, [r7, #20]
 8010c42:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8010c46:	ee17 3a90 	vmov	r3, s15
 8010c4a:	b29a      	uxth	r2, r3
 8010c4c:	e000      	b.n	8010c50 <nk_stroke_rect+0x1c4>
 8010c4e:	2200      	movs	r2, #0
 8010c50:	6a3b      	ldr	r3, [r7, #32]
 8010c52:	821a      	strh	r2, [r3, #16]
    cmd->h = (unsigned short)NK_MAX(0, rect.h);
 8010c54:	edd7 7a06 	vldr	s15, [r7, #24]
 8010c58:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8010c5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010c60:	dd07      	ble.n	8010c72 <nk_stroke_rect+0x1e6>
 8010c62:	edd7 7a06 	vldr	s15, [r7, #24]
 8010c66:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8010c6a:	ee17 3a90 	vmov	r3, s15
 8010c6e:	b29a      	uxth	r2, r3
 8010c70:	e000      	b.n	8010c74 <nk_stroke_rect+0x1e8>
 8010c72:	2200      	movs	r2, #0
 8010c74:	6a3b      	ldr	r3, [r7, #32]
 8010c76:	825a      	strh	r2, [r3, #18]
    cmd->color = c;
 8010c78:	6a3b      	ldr	r3, [r7, #32]
 8010c7a:	683a      	ldr	r2, [r7, #0]
 8010c7c:	615a      	str	r2, [r3, #20]
 8010c7e:	e004      	b.n	8010c8a <nk_stroke_rect+0x1fe>
    if (!b || c.a == 0 || rect.w == 0 || rect.h == 0 || line_thickness <= 0) return;
 8010c80:	bf00      	nop
 8010c82:	e002      	b.n	8010c8a <nk_stroke_rect+0x1fe>
            clip->x, clip->y, clip->w, clip->h)) return;
 8010c84:	bf00      	nop
 8010c86:	e000      	b.n	8010c8a <nk_stroke_rect+0x1fe>
    if (!cmd) return;
 8010c88:	bf00      	nop
}
 8010c8a:	3728      	adds	r7, #40	; 0x28
 8010c8c:	46bd      	mov	sp, r7
 8010c8e:	bd80      	pop	{r7, pc}
 8010c90:	08021734 	.word	0x08021734
 8010c94:	08023404 	.word	0x08023404
 8010c98:	08021718 	.word	0x08021718

08010c9c <nk_fill_rect>:
NK_API void
nk_fill_rect(struct nk_command_buffer *b, struct nk_rect rect,
    float rounding, struct nk_color c)
{
 8010c9c:	b580      	push	{r7, lr}
 8010c9e:	b08a      	sub	sp, #40	; 0x28
 8010ca0:	af00      	add	r7, sp, #0
 8010ca2:	61f8      	str	r0, [r7, #28]
 8010ca4:	eeb0 6a40 	vmov.f32	s12, s0
 8010ca8:	eef0 6a60 	vmov.f32	s13, s1
 8010cac:	eeb0 7a41 	vmov.f32	s14, s2
 8010cb0:	eef0 7a61 	vmov.f32	s15, s3
 8010cb4:	ed87 2a02 	vstr	s4, [r7, #8]
 8010cb8:	6079      	str	r1, [r7, #4]
 8010cba:	ed87 6a03 	vstr	s12, [r7, #12]
 8010cbe:	edc7 6a04 	vstr	s13, [r7, #16]
 8010cc2:	ed87 7a05 	vstr	s14, [r7, #20]
 8010cc6:	edc7 7a06 	vstr	s15, [r7, #24]
    struct nk_command_rect_filled *cmd;
    NK_ASSERT(b);
 8010cca:	69fb      	ldr	r3, [r7, #28]
 8010ccc:	2b00      	cmp	r3, #0
 8010cce:	d105      	bne.n	8010cdc <nk_fill_rect+0x40>
 8010cd0:	4b6a      	ldr	r3, [pc, #424]	; (8010e7c <nk_fill_rect+0x1e0>)
 8010cd2:	4a6b      	ldr	r2, [pc, #428]	; (8010e80 <nk_fill_rect+0x1e4>)
 8010cd4:	219c      	movs	r1, #156	; 0x9c
 8010cd6:	486b      	ldr	r0, [pc, #428]	; (8010e84 <nk_fill_rect+0x1e8>)
 8010cd8:	f00c fe9e 	bl	801da18 <__assert_func>
    if (!b || c.a == 0 || rect.w == 0 || rect.h == 0) return;
 8010cdc:	69fb      	ldr	r3, [r7, #28]
 8010cde:	2b00      	cmp	r3, #0
 8010ce0:	f000 80c4 	beq.w	8010e6c <nk_fill_rect+0x1d0>
 8010ce4:	79fb      	ldrb	r3, [r7, #7]
 8010ce6:	2b00      	cmp	r3, #0
 8010ce8:	f000 80c0 	beq.w	8010e6c <nk_fill_rect+0x1d0>
 8010cec:	edd7 7a05 	vldr	s15, [r7, #20]
 8010cf0:	eef5 7a40 	vcmp.f32	s15, #0.0
 8010cf4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010cf8:	f000 80b8 	beq.w	8010e6c <nk_fill_rect+0x1d0>
 8010cfc:	edd7 7a06 	vldr	s15, [r7, #24]
 8010d00:	eef5 7a40 	vcmp.f32	s15, #0.0
 8010d04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010d08:	f000 80b0 	beq.w	8010e6c <nk_fill_rect+0x1d0>
    if (b->use_clipping) {
 8010d0c:	69fb      	ldr	r3, [r7, #28]
 8010d0e:	695b      	ldr	r3, [r3, #20]
 8010d10:	2b00      	cmp	r3, #0
 8010d12:	d05d      	beq.n	8010dd0 <nk_fill_rect+0x134>
        const struct nk_rect *clip = &b->clip;
 8010d14:	69fb      	ldr	r3, [r7, #28]
 8010d16:	3304      	adds	r3, #4
 8010d18:	627b      	str	r3, [r7, #36]	; 0x24
        if (!NK_INTERSECT(rect.x, rect.y, rect.w, rect.h,
 8010d1a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010d1c:	ed93 7a00 	vldr	s14, [r3]
 8010d20:	edd7 6a03 	vldr	s13, [r7, #12]
 8010d24:	edd7 7a05 	vldr	s15, [r7, #20]
 8010d28:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8010d2c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8010d30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010d34:	bf4c      	ite	mi
 8010d36:	2301      	movmi	r3, #1
 8010d38:	2300      	movpl	r3, #0
 8010d3a:	b2db      	uxtb	r3, r3
 8010d3c:	f083 0301 	eor.w	r3, r3, #1
 8010d40:	b2db      	uxtb	r3, r3
 8010d42:	2b00      	cmp	r3, #0
 8010d44:	f040 8094 	bne.w	8010e70 <nk_fill_rect+0x1d4>
 8010d48:	ed97 7a03 	vldr	s14, [r7, #12]
 8010d4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010d4e:	edd3 6a00 	vldr	s13, [r3]
 8010d52:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010d54:	edd3 7a02 	vldr	s15, [r3, #8]
 8010d58:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8010d5c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8010d60:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010d64:	bf4c      	ite	mi
 8010d66:	2301      	movmi	r3, #1
 8010d68:	2300      	movpl	r3, #0
 8010d6a:	b2db      	uxtb	r3, r3
 8010d6c:	f083 0301 	eor.w	r3, r3, #1
 8010d70:	b2db      	uxtb	r3, r3
 8010d72:	2b00      	cmp	r3, #0
 8010d74:	d17c      	bne.n	8010e70 <nk_fill_rect+0x1d4>
 8010d76:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010d78:	ed93 7a01 	vldr	s14, [r3, #4]
 8010d7c:	edd7 6a04 	vldr	s13, [r7, #16]
 8010d80:	edd7 7a06 	vldr	s15, [r7, #24]
 8010d84:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8010d88:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8010d8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010d90:	bf4c      	ite	mi
 8010d92:	2301      	movmi	r3, #1
 8010d94:	2300      	movpl	r3, #0
 8010d96:	b2db      	uxtb	r3, r3
 8010d98:	f083 0301 	eor.w	r3, r3, #1
 8010d9c:	b2db      	uxtb	r3, r3
 8010d9e:	2b00      	cmp	r3, #0
 8010da0:	d166      	bne.n	8010e70 <nk_fill_rect+0x1d4>
 8010da2:	ed97 7a04 	vldr	s14, [r7, #16]
 8010da6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010da8:	edd3 6a01 	vldr	s13, [r3, #4]
 8010dac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010dae:	edd3 7a03 	vldr	s15, [r3, #12]
 8010db2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8010db6:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8010dba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010dbe:	bf4c      	ite	mi
 8010dc0:	2301      	movmi	r3, #1
 8010dc2:	2300      	movpl	r3, #0
 8010dc4:	b2db      	uxtb	r3, r3
 8010dc6:	f083 0301 	eor.w	r3, r3, #1
 8010dca:	b2db      	uxtb	r3, r3
 8010dcc:	2b00      	cmp	r3, #0
 8010dce:	d14f      	bne.n	8010e70 <nk_fill_rect+0x1d4>
            clip->x, clip->y, clip->w, clip->h)) return;
    }

    cmd = (struct nk_command_rect_filled*)
        nk_command_buffer_push(b, NK_COMMAND_RECT_FILLED, sizeof(*cmd));
 8010dd0:	2218      	movs	r2, #24
 8010dd2:	2105      	movs	r1, #5
 8010dd4:	69f8      	ldr	r0, [r7, #28]
 8010dd6:	f7ff fd7b 	bl	80108d0 <nk_command_buffer_push>
 8010dda:	6238      	str	r0, [r7, #32]
    if (!cmd) return;
 8010ddc:	6a3b      	ldr	r3, [r7, #32]
 8010dde:	2b00      	cmp	r3, #0
 8010de0:	d048      	beq.n	8010e74 <nk_fill_rect+0x1d8>
    cmd->rounding = (unsigned short)rounding;
 8010de2:	edd7 7a02 	vldr	s15, [r7, #8]
 8010de6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8010dea:	ee17 3a90 	vmov	r3, s15
 8010dee:	b29a      	uxth	r2, r3
 8010df0:	6a3b      	ldr	r3, [r7, #32]
 8010df2:	811a      	strh	r2, [r3, #8]
    cmd->x = (short)rect.x;
 8010df4:	edd7 7a03 	vldr	s15, [r7, #12]
 8010df8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8010dfc:	ee17 3a90 	vmov	r3, s15
 8010e00:	b21a      	sxth	r2, r3
 8010e02:	6a3b      	ldr	r3, [r7, #32]
 8010e04:	815a      	strh	r2, [r3, #10]
    cmd->y = (short)rect.y;
 8010e06:	edd7 7a04 	vldr	s15, [r7, #16]
 8010e0a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8010e0e:	ee17 3a90 	vmov	r3, s15
 8010e12:	b21a      	sxth	r2, r3
 8010e14:	6a3b      	ldr	r3, [r7, #32]
 8010e16:	819a      	strh	r2, [r3, #12]
    cmd->w = (unsigned short)NK_MAX(0, rect.w);
 8010e18:	edd7 7a05 	vldr	s15, [r7, #20]
 8010e1c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8010e20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010e24:	dd07      	ble.n	8010e36 <nk_fill_rect+0x19a>
 8010e26:	edd7 7a05 	vldr	s15, [r7, #20]
 8010e2a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8010e2e:	ee17 3a90 	vmov	r3, s15
 8010e32:	b29a      	uxth	r2, r3
 8010e34:	e000      	b.n	8010e38 <nk_fill_rect+0x19c>
 8010e36:	2200      	movs	r2, #0
 8010e38:	6a3b      	ldr	r3, [r7, #32]
 8010e3a:	81da      	strh	r2, [r3, #14]
    cmd->h = (unsigned short)NK_MAX(0, rect.h);
 8010e3c:	edd7 7a06 	vldr	s15, [r7, #24]
 8010e40:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8010e44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010e48:	dd07      	ble.n	8010e5a <nk_fill_rect+0x1be>
 8010e4a:	edd7 7a06 	vldr	s15, [r7, #24]
 8010e4e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8010e52:	ee17 3a90 	vmov	r3, s15
 8010e56:	b29a      	uxth	r2, r3
 8010e58:	e000      	b.n	8010e5c <nk_fill_rect+0x1c0>
 8010e5a:	2200      	movs	r2, #0
 8010e5c:	6a3b      	ldr	r3, [r7, #32]
 8010e5e:	821a      	strh	r2, [r3, #16]
    cmd->color = c;
 8010e60:	6a3b      	ldr	r3, [r7, #32]
 8010e62:	3312      	adds	r3, #18
 8010e64:	1d3a      	adds	r2, r7, #4
 8010e66:	6810      	ldr	r0, [r2, #0]
 8010e68:	6018      	str	r0, [r3, #0]
 8010e6a:	e004      	b.n	8010e76 <nk_fill_rect+0x1da>
    if (!b || c.a == 0 || rect.w == 0 || rect.h == 0) return;
 8010e6c:	bf00      	nop
 8010e6e:	e002      	b.n	8010e76 <nk_fill_rect+0x1da>
            clip->x, clip->y, clip->w, clip->h)) return;
 8010e70:	bf00      	nop
 8010e72:	e000      	b.n	8010e76 <nk_fill_rect+0x1da>
    if (!cmd) return;
 8010e74:	bf00      	nop
}
 8010e76:	3728      	adds	r7, #40	; 0x28
 8010e78:	46bd      	mov	sp, r7
 8010e7a:	bd80      	pop	{r7, pc}
 8010e7c:	08021734 	.word	0x08021734
 8010e80:	08023414 	.word	0x08023414
 8010e84:	08021718 	.word	0x08021718

08010e88 <nk_fill_circle>:
    cmd->h = (unsigned short)NK_MAX(r.h, 0);
    cmd->color = c;
}
NK_API void
nk_fill_circle(struct nk_command_buffer *b, struct nk_rect r, struct nk_color c)
{
 8010e88:	b580      	push	{r7, lr}
 8010e8a:	b088      	sub	sp, #32
 8010e8c:	af00      	add	r7, sp, #0
 8010e8e:	6178      	str	r0, [r7, #20]
 8010e90:	eeb0 6a40 	vmov.f32	s12, s0
 8010e94:	eef0 6a60 	vmov.f32	s13, s1
 8010e98:	eeb0 7a41 	vmov.f32	s14, s2
 8010e9c:	eef0 7a61 	vmov.f32	s15, s3
 8010ea0:	6039      	str	r1, [r7, #0]
 8010ea2:	ed87 6a01 	vstr	s12, [r7, #4]
 8010ea6:	edc7 6a02 	vstr	s13, [r7, #8]
 8010eaa:	ed87 7a03 	vstr	s14, [r7, #12]
 8010eae:	edc7 7a04 	vstr	s15, [r7, #16]
    struct nk_command_circle_filled *cmd;
    NK_ASSERT(b);
 8010eb2:	697b      	ldr	r3, [r7, #20]
 8010eb4:	2b00      	cmp	r3, #0
 8010eb6:	d105      	bne.n	8010ec4 <nk_fill_circle+0x3c>
 8010eb8:	4b65      	ldr	r3, [pc, #404]	; (8011050 <nk_fill_circle+0x1c8>)
 8010eba:	4a66      	ldr	r2, [pc, #408]	; (8011054 <nk_fill_circle+0x1cc>)
 8010ebc:	21e2      	movs	r1, #226	; 0xe2
 8010ebe:	4866      	ldr	r0, [pc, #408]	; (8011058 <nk_fill_circle+0x1d0>)
 8010ec0:	f00c fdaa 	bl	801da18 <__assert_func>
    if (!b || c.a == 0 || r.w == 0 || r.h == 0) return;
 8010ec4:	697b      	ldr	r3, [r7, #20]
 8010ec6:	2b00      	cmp	r3, #0
 8010ec8:	f000 80b9 	beq.w	801103e <nk_fill_circle+0x1b6>
 8010ecc:	78fb      	ldrb	r3, [r7, #3]
 8010ece:	2b00      	cmp	r3, #0
 8010ed0:	f000 80b5 	beq.w	801103e <nk_fill_circle+0x1b6>
 8010ed4:	edd7 7a03 	vldr	s15, [r7, #12]
 8010ed8:	eef5 7a40 	vcmp.f32	s15, #0.0
 8010edc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010ee0:	f000 80ad 	beq.w	801103e <nk_fill_circle+0x1b6>
 8010ee4:	edd7 7a04 	vldr	s15, [r7, #16]
 8010ee8:	eef5 7a40 	vcmp.f32	s15, #0.0
 8010eec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010ef0:	f000 80a5 	beq.w	801103e <nk_fill_circle+0x1b6>
    if (b->use_clipping) {
 8010ef4:	697b      	ldr	r3, [r7, #20]
 8010ef6:	695b      	ldr	r3, [r3, #20]
 8010ef8:	2b00      	cmp	r3, #0
 8010efa:	d05d      	beq.n	8010fb8 <nk_fill_circle+0x130>
        const struct nk_rect *clip = &b->clip;
 8010efc:	697b      	ldr	r3, [r7, #20]
 8010efe:	3304      	adds	r3, #4
 8010f00:	61fb      	str	r3, [r7, #28]
        if (!NK_INTERSECT(r.x, r.y, r.w, r.h, clip->x, clip->y, clip->w, clip->h))
 8010f02:	69fb      	ldr	r3, [r7, #28]
 8010f04:	ed93 7a00 	vldr	s14, [r3]
 8010f08:	edd7 6a01 	vldr	s13, [r7, #4]
 8010f0c:	edd7 7a03 	vldr	s15, [r7, #12]
 8010f10:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8010f14:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8010f18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010f1c:	bf4c      	ite	mi
 8010f1e:	2301      	movmi	r3, #1
 8010f20:	2300      	movpl	r3, #0
 8010f22:	b2db      	uxtb	r3, r3
 8010f24:	f083 0301 	eor.w	r3, r3, #1
 8010f28:	b2db      	uxtb	r3, r3
 8010f2a:	2b00      	cmp	r3, #0
 8010f2c:	f040 8089 	bne.w	8011042 <nk_fill_circle+0x1ba>
 8010f30:	ed97 7a01 	vldr	s14, [r7, #4]
 8010f34:	69fb      	ldr	r3, [r7, #28]
 8010f36:	edd3 6a00 	vldr	s13, [r3]
 8010f3a:	69fb      	ldr	r3, [r7, #28]
 8010f3c:	edd3 7a02 	vldr	s15, [r3, #8]
 8010f40:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8010f44:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8010f48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010f4c:	bf4c      	ite	mi
 8010f4e:	2301      	movmi	r3, #1
 8010f50:	2300      	movpl	r3, #0
 8010f52:	b2db      	uxtb	r3, r3
 8010f54:	f083 0301 	eor.w	r3, r3, #1
 8010f58:	b2db      	uxtb	r3, r3
 8010f5a:	2b00      	cmp	r3, #0
 8010f5c:	d171      	bne.n	8011042 <nk_fill_circle+0x1ba>
 8010f5e:	69fb      	ldr	r3, [r7, #28]
 8010f60:	ed93 7a01 	vldr	s14, [r3, #4]
 8010f64:	edd7 6a02 	vldr	s13, [r7, #8]
 8010f68:	edd7 7a04 	vldr	s15, [r7, #16]
 8010f6c:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8010f70:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8010f74:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010f78:	bf4c      	ite	mi
 8010f7a:	2301      	movmi	r3, #1
 8010f7c:	2300      	movpl	r3, #0
 8010f7e:	b2db      	uxtb	r3, r3
 8010f80:	f083 0301 	eor.w	r3, r3, #1
 8010f84:	b2db      	uxtb	r3, r3
 8010f86:	2b00      	cmp	r3, #0
 8010f88:	d15b      	bne.n	8011042 <nk_fill_circle+0x1ba>
 8010f8a:	ed97 7a02 	vldr	s14, [r7, #8]
 8010f8e:	69fb      	ldr	r3, [r7, #28]
 8010f90:	edd3 6a01 	vldr	s13, [r3, #4]
 8010f94:	69fb      	ldr	r3, [r7, #28]
 8010f96:	edd3 7a03 	vldr	s15, [r3, #12]
 8010f9a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8010f9e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8010fa2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010fa6:	bf4c      	ite	mi
 8010fa8:	2301      	movmi	r3, #1
 8010faa:	2300      	movpl	r3, #0
 8010fac:	b2db      	uxtb	r3, r3
 8010fae:	f083 0301 	eor.w	r3, r3, #1
 8010fb2:	b2db      	uxtb	r3, r3
 8010fb4:	2b00      	cmp	r3, #0
 8010fb6:	d144      	bne.n	8011042 <nk_fill_circle+0x1ba>
            return;
    }

    cmd = (struct nk_command_circle_filled*)
        nk_command_buffer_push(b, NK_COMMAND_CIRCLE_FILLED, sizeof(*cmd));
 8010fb8:	2214      	movs	r2, #20
 8010fba:	2108      	movs	r1, #8
 8010fbc:	6978      	ldr	r0, [r7, #20]
 8010fbe:	f7ff fc87 	bl	80108d0 <nk_command_buffer_push>
 8010fc2:	61b8      	str	r0, [r7, #24]
    if (!cmd) return;
 8010fc4:	69bb      	ldr	r3, [r7, #24]
 8010fc6:	2b00      	cmp	r3, #0
 8010fc8:	d03d      	beq.n	8011046 <nk_fill_circle+0x1be>
    cmd->x = (short)r.x;
 8010fca:	edd7 7a01 	vldr	s15, [r7, #4]
 8010fce:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8010fd2:	ee17 3a90 	vmov	r3, s15
 8010fd6:	b21a      	sxth	r2, r3
 8010fd8:	69bb      	ldr	r3, [r7, #24]
 8010fda:	811a      	strh	r2, [r3, #8]
    cmd->y = (short)r.y;
 8010fdc:	edd7 7a02 	vldr	s15, [r7, #8]
 8010fe0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8010fe4:	ee17 3a90 	vmov	r3, s15
 8010fe8:	b21a      	sxth	r2, r3
 8010fea:	69bb      	ldr	r3, [r7, #24]
 8010fec:	815a      	strh	r2, [r3, #10]
    cmd->w = (unsigned short)NK_MAX(r.w, 0);
 8010fee:	edd7 7a03 	vldr	s15, [r7, #12]
 8010ff2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8010ff6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010ffa:	d501      	bpl.n	8011000 <nk_fill_circle+0x178>
 8010ffc:	2200      	movs	r2, #0
 8010ffe:	e006      	b.n	801100e <nk_fill_circle+0x186>
 8011000:	edd7 7a03 	vldr	s15, [r7, #12]
 8011004:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8011008:	ee17 3a90 	vmov	r3, s15
 801100c:	b29a      	uxth	r2, r3
 801100e:	69bb      	ldr	r3, [r7, #24]
 8011010:	819a      	strh	r2, [r3, #12]
    cmd->h = (unsigned short)NK_MAX(r.h, 0);
 8011012:	edd7 7a04 	vldr	s15, [r7, #16]
 8011016:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801101a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801101e:	d501      	bpl.n	8011024 <nk_fill_circle+0x19c>
 8011020:	2200      	movs	r2, #0
 8011022:	e006      	b.n	8011032 <nk_fill_circle+0x1aa>
 8011024:	edd7 7a04 	vldr	s15, [r7, #16]
 8011028:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801102c:	ee17 3a90 	vmov	r3, s15
 8011030:	b29a      	uxth	r2, r3
 8011032:	69bb      	ldr	r3, [r7, #24]
 8011034:	81da      	strh	r2, [r3, #14]
    cmd->color = c;
 8011036:	69bb      	ldr	r3, [r7, #24]
 8011038:	683a      	ldr	r2, [r7, #0]
 801103a:	611a      	str	r2, [r3, #16]
 801103c:	e004      	b.n	8011048 <nk_fill_circle+0x1c0>
    if (!b || c.a == 0 || r.w == 0 || r.h == 0) return;
 801103e:	bf00      	nop
 8011040:	e002      	b.n	8011048 <nk_fill_circle+0x1c0>
            return;
 8011042:	bf00      	nop
 8011044:	e000      	b.n	8011048 <nk_fill_circle+0x1c0>
    if (!cmd) return;
 8011046:	bf00      	nop
}
 8011048:	3720      	adds	r7, #32
 801104a:	46bd      	mov	sp, r7
 801104c:	bd80      	pop	{r7, pc}
 801104e:	bf00      	nop
 8011050:	08021734 	.word	0x08021734
 8011054:	08023424 	.word	0x08023424
 8011058:	08021718 	.word	0x08021718

0801105c <nk_fill_triangle>:
    cmd->color = c;
}
NK_API void
nk_fill_triangle(struct nk_command_buffer *b, float x0, float y0, float x1,
    float y1, float x2, float y2, struct nk_color c)
{
 801105c:	b580      	push	{r7, lr}
 801105e:	b08a      	sub	sp, #40	; 0x28
 8011060:	af00      	add	r7, sp, #0
 8011062:	61f8      	str	r0, [r7, #28]
 8011064:	ed87 0a06 	vstr	s0, [r7, #24]
 8011068:	edc7 0a05 	vstr	s1, [r7, #20]
 801106c:	ed87 1a04 	vstr	s2, [r7, #16]
 8011070:	edc7 1a03 	vstr	s3, [r7, #12]
 8011074:	ed87 2a02 	vstr	s4, [r7, #8]
 8011078:	edc7 2a01 	vstr	s5, [r7, #4]
 801107c:	6039      	str	r1, [r7, #0]
    struct nk_command_triangle_filled *cmd;
    NK_ASSERT(b);
 801107e:	69fb      	ldr	r3, [r7, #28]
 8011080:	2b00      	cmp	r3, #0
 8011082:	d106      	bne.n	8011092 <nk_fill_triangle+0x36>
 8011084:	4baf      	ldr	r3, [pc, #700]	; (8011344 <nk_fill_triangle+0x2e8>)
 8011086:	4ab0      	ldr	r2, [pc, #704]	; (8011348 <nk_fill_triangle+0x2ec>)
 8011088:	f240 1135 	movw	r1, #309	; 0x135
 801108c:	48af      	ldr	r0, [pc, #700]	; (801134c <nk_fill_triangle+0x2f0>)
 801108e:	f00c fcc3 	bl	801da18 <__assert_func>
    if (!b || c.a == 0) return;
 8011092:	69fb      	ldr	r3, [r7, #28]
 8011094:	2b00      	cmp	r3, #0
 8011096:	f000 814b 	beq.w	8011330 <nk_fill_triangle+0x2d4>
 801109a:	78fb      	ldrb	r3, [r7, #3]
 801109c:	2b00      	cmp	r3, #0
 801109e:	f000 8147 	beq.w	8011330 <nk_fill_triangle+0x2d4>
    if (!b) return;
 80110a2:	69fb      	ldr	r3, [r7, #28]
 80110a4:	2b00      	cmp	r3, #0
 80110a6:	f000 8145 	beq.w	8011334 <nk_fill_triangle+0x2d8>
    if (b->use_clipping) {
 80110aa:	69fb      	ldr	r3, [r7, #28]
 80110ac:	695b      	ldr	r3, [r3, #20]
 80110ae:	2b00      	cmp	r3, #0
 80110b0:	f000 80fb 	beq.w	80112aa <nk_fill_triangle+0x24e>
        const struct nk_rect *clip = &b->clip;
 80110b4:	69fb      	ldr	r3, [r7, #28]
 80110b6:	3304      	adds	r3, #4
 80110b8:	627b      	str	r3, [r7, #36]	; 0x24
        if (!NK_INBOX(x0, y0, clip->x, clip->y, clip->w, clip->h) &&
 80110ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80110bc:	edd3 7a00 	vldr	s15, [r3]
 80110c0:	ed97 7a06 	vldr	s14, [r7, #24]
 80110c4:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80110c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80110cc:	bfac      	ite	ge
 80110ce:	2301      	movge	r3, #1
 80110d0:	2300      	movlt	r3, #0
 80110d2:	b2db      	uxtb	r3, r3
 80110d4:	f083 0301 	eor.w	r3, r3, #1
 80110d8:	b2db      	uxtb	r3, r3
 80110da:	2b00      	cmp	r3, #0
 80110dc:	d140      	bne.n	8011160 <nk_fill_triangle+0x104>
 80110de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80110e0:	ed93 7a00 	vldr	s14, [r3]
 80110e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80110e6:	edd3 7a02 	vldr	s15, [r3, #8]
 80110ea:	ee77 7a27 	vadd.f32	s15, s14, s15
 80110ee:	ed97 7a06 	vldr	s14, [r7, #24]
 80110f2:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80110f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80110fa:	bf4c      	ite	mi
 80110fc:	2301      	movmi	r3, #1
 80110fe:	2300      	movpl	r3, #0
 8011100:	b2db      	uxtb	r3, r3
 8011102:	f083 0301 	eor.w	r3, r3, #1
 8011106:	b2db      	uxtb	r3, r3
 8011108:	2b00      	cmp	r3, #0
 801110a:	d129      	bne.n	8011160 <nk_fill_triangle+0x104>
 801110c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801110e:	edd3 7a01 	vldr	s15, [r3, #4]
 8011112:	ed97 7a05 	vldr	s14, [r7, #20]
 8011116:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801111a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801111e:	bfac      	ite	ge
 8011120:	2301      	movge	r3, #1
 8011122:	2300      	movlt	r3, #0
 8011124:	b2db      	uxtb	r3, r3
 8011126:	f083 0301 	eor.w	r3, r3, #1
 801112a:	b2db      	uxtb	r3, r3
 801112c:	2b00      	cmp	r3, #0
 801112e:	d117      	bne.n	8011160 <nk_fill_triangle+0x104>
 8011130:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011132:	ed93 7a01 	vldr	s14, [r3, #4]
 8011136:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011138:	edd3 7a03 	vldr	s15, [r3, #12]
 801113c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8011140:	ed97 7a05 	vldr	s14, [r7, #20]
 8011144:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8011148:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801114c:	bf4c      	ite	mi
 801114e:	2301      	movmi	r3, #1
 8011150:	2300      	movpl	r3, #0
 8011152:	b2db      	uxtb	r3, r3
 8011154:	f083 0301 	eor.w	r3, r3, #1
 8011158:	b2db      	uxtb	r3, r3
 801115a:	2b00      	cmp	r3, #0
 801115c:	f000 80a5 	beq.w	80112aa <nk_fill_triangle+0x24e>
            !NK_INBOX(x1, y1, clip->x, clip->y, clip->w, clip->h) &&
 8011160:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011162:	edd3 7a00 	vldr	s15, [r3]
 8011166:	ed97 7a04 	vldr	s14, [r7, #16]
 801116a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801116e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011172:	bfac      	ite	ge
 8011174:	2301      	movge	r3, #1
 8011176:	2300      	movlt	r3, #0
 8011178:	b2db      	uxtb	r3, r3
 801117a:	f083 0301 	eor.w	r3, r3, #1
 801117e:	b2db      	uxtb	r3, r3
        if (!NK_INBOX(x0, y0, clip->x, clip->y, clip->w, clip->h) &&
 8011180:	2b00      	cmp	r3, #0
 8011182:	d13f      	bne.n	8011204 <nk_fill_triangle+0x1a8>
            !NK_INBOX(x1, y1, clip->x, clip->y, clip->w, clip->h) &&
 8011184:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011186:	ed93 7a00 	vldr	s14, [r3]
 801118a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801118c:	edd3 7a02 	vldr	s15, [r3, #8]
 8011190:	ee77 7a27 	vadd.f32	s15, s14, s15
 8011194:	ed97 7a04 	vldr	s14, [r7, #16]
 8011198:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801119c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80111a0:	bf4c      	ite	mi
 80111a2:	2301      	movmi	r3, #1
 80111a4:	2300      	movpl	r3, #0
 80111a6:	b2db      	uxtb	r3, r3
 80111a8:	f083 0301 	eor.w	r3, r3, #1
 80111ac:	b2db      	uxtb	r3, r3
 80111ae:	2b00      	cmp	r3, #0
 80111b0:	d128      	bne.n	8011204 <nk_fill_triangle+0x1a8>
 80111b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80111b4:	edd3 7a01 	vldr	s15, [r3, #4]
 80111b8:	ed97 7a03 	vldr	s14, [r7, #12]
 80111bc:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80111c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80111c4:	bfac      	ite	ge
 80111c6:	2301      	movge	r3, #1
 80111c8:	2300      	movlt	r3, #0
 80111ca:	b2db      	uxtb	r3, r3
 80111cc:	f083 0301 	eor.w	r3, r3, #1
 80111d0:	b2db      	uxtb	r3, r3
 80111d2:	2b00      	cmp	r3, #0
 80111d4:	d116      	bne.n	8011204 <nk_fill_triangle+0x1a8>
 80111d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80111d8:	ed93 7a01 	vldr	s14, [r3, #4]
 80111dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80111de:	edd3 7a03 	vldr	s15, [r3, #12]
 80111e2:	ee77 7a27 	vadd.f32	s15, s14, s15
 80111e6:	ed97 7a03 	vldr	s14, [r7, #12]
 80111ea:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80111ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80111f2:	bf4c      	ite	mi
 80111f4:	2301      	movmi	r3, #1
 80111f6:	2300      	movpl	r3, #0
 80111f8:	b2db      	uxtb	r3, r3
 80111fa:	f083 0301 	eor.w	r3, r3, #1
 80111fe:	b2db      	uxtb	r3, r3
 8011200:	2b00      	cmp	r3, #0
 8011202:	d052      	beq.n	80112aa <nk_fill_triangle+0x24e>
            !NK_INBOX(x2, y2, clip->x, clip->y, clip->w, clip->h))
 8011204:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011206:	edd3 7a00 	vldr	s15, [r3]
 801120a:	ed97 7a02 	vldr	s14, [r7, #8]
 801120e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8011212:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011216:	bfac      	ite	ge
 8011218:	2301      	movge	r3, #1
 801121a:	2300      	movlt	r3, #0
 801121c:	b2db      	uxtb	r3, r3
 801121e:	f083 0301 	eor.w	r3, r3, #1
 8011222:	b2db      	uxtb	r3, r3
            !NK_INBOX(x1, y1, clip->x, clip->y, clip->w, clip->h) &&
 8011224:	2b00      	cmp	r3, #0
 8011226:	f040 8087 	bne.w	8011338 <nk_fill_triangle+0x2dc>
            !NK_INBOX(x2, y2, clip->x, clip->y, clip->w, clip->h))
 801122a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801122c:	ed93 7a00 	vldr	s14, [r3]
 8011230:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011232:	edd3 7a02 	vldr	s15, [r3, #8]
 8011236:	ee77 7a27 	vadd.f32	s15, s14, s15
 801123a:	ed97 7a02 	vldr	s14, [r7, #8]
 801123e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8011242:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011246:	bf4c      	ite	mi
 8011248:	2301      	movmi	r3, #1
 801124a:	2300      	movpl	r3, #0
 801124c:	b2db      	uxtb	r3, r3
 801124e:	f083 0301 	eor.w	r3, r3, #1
 8011252:	b2db      	uxtb	r3, r3
 8011254:	2b00      	cmp	r3, #0
 8011256:	d16f      	bne.n	8011338 <nk_fill_triangle+0x2dc>
 8011258:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801125a:	edd3 7a01 	vldr	s15, [r3, #4]
 801125e:	ed97 7a01 	vldr	s14, [r7, #4]
 8011262:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8011266:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801126a:	bfac      	ite	ge
 801126c:	2301      	movge	r3, #1
 801126e:	2300      	movlt	r3, #0
 8011270:	b2db      	uxtb	r3, r3
 8011272:	f083 0301 	eor.w	r3, r3, #1
 8011276:	b2db      	uxtb	r3, r3
 8011278:	2b00      	cmp	r3, #0
 801127a:	d15d      	bne.n	8011338 <nk_fill_triangle+0x2dc>
 801127c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801127e:	ed93 7a01 	vldr	s14, [r3, #4]
 8011282:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011284:	edd3 7a03 	vldr	s15, [r3, #12]
 8011288:	ee77 7a27 	vadd.f32	s15, s14, s15
 801128c:	ed97 7a01 	vldr	s14, [r7, #4]
 8011290:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8011294:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011298:	bf4c      	ite	mi
 801129a:	2301      	movmi	r3, #1
 801129c:	2300      	movpl	r3, #0
 801129e:	b2db      	uxtb	r3, r3
 80112a0:	f083 0301 	eor.w	r3, r3, #1
 80112a4:	b2db      	uxtb	r3, r3
 80112a6:	2b00      	cmp	r3, #0
 80112a8:	d146      	bne.n	8011338 <nk_fill_triangle+0x2dc>
            return;
    }

    cmd = (struct nk_command_triangle_filled*)
        nk_command_buffer_push(b, NK_COMMAND_TRIANGLE_FILLED, sizeof(*cmd));
 80112aa:	2218      	movs	r2, #24
 80112ac:	210c      	movs	r1, #12
 80112ae:	69f8      	ldr	r0, [r7, #28]
 80112b0:	f7ff fb0e 	bl	80108d0 <nk_command_buffer_push>
 80112b4:	6238      	str	r0, [r7, #32]
    if (!cmd) return;
 80112b6:	6a3b      	ldr	r3, [r7, #32]
 80112b8:	2b00      	cmp	r3, #0
 80112ba:	d03f      	beq.n	801133c <nk_fill_triangle+0x2e0>
    cmd->a.x = (short)x0;
 80112bc:	edd7 7a06 	vldr	s15, [r7, #24]
 80112c0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80112c4:	ee17 3a90 	vmov	r3, s15
 80112c8:	b21a      	sxth	r2, r3
 80112ca:	6a3b      	ldr	r3, [r7, #32]
 80112cc:	811a      	strh	r2, [r3, #8]
    cmd->a.y = (short)y0;
 80112ce:	edd7 7a05 	vldr	s15, [r7, #20]
 80112d2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80112d6:	ee17 3a90 	vmov	r3, s15
 80112da:	b21a      	sxth	r2, r3
 80112dc:	6a3b      	ldr	r3, [r7, #32]
 80112de:	815a      	strh	r2, [r3, #10]
    cmd->b.x = (short)x1;
 80112e0:	edd7 7a04 	vldr	s15, [r7, #16]
 80112e4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80112e8:	ee17 3a90 	vmov	r3, s15
 80112ec:	b21a      	sxth	r2, r3
 80112ee:	6a3b      	ldr	r3, [r7, #32]
 80112f0:	819a      	strh	r2, [r3, #12]
    cmd->b.y = (short)y1;
 80112f2:	edd7 7a03 	vldr	s15, [r7, #12]
 80112f6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80112fa:	ee17 3a90 	vmov	r3, s15
 80112fe:	b21a      	sxth	r2, r3
 8011300:	6a3b      	ldr	r3, [r7, #32]
 8011302:	81da      	strh	r2, [r3, #14]
    cmd->c.x = (short)x2;
 8011304:	edd7 7a02 	vldr	s15, [r7, #8]
 8011308:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801130c:	ee17 3a90 	vmov	r3, s15
 8011310:	b21a      	sxth	r2, r3
 8011312:	6a3b      	ldr	r3, [r7, #32]
 8011314:	821a      	strh	r2, [r3, #16]
    cmd->c.y = (short)y2;
 8011316:	edd7 7a01 	vldr	s15, [r7, #4]
 801131a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801131e:	ee17 3a90 	vmov	r3, s15
 8011322:	b21a      	sxth	r2, r3
 8011324:	6a3b      	ldr	r3, [r7, #32]
 8011326:	825a      	strh	r2, [r3, #18]
    cmd->color = c;
 8011328:	6a3b      	ldr	r3, [r7, #32]
 801132a:	683a      	ldr	r2, [r7, #0]
 801132c:	615a      	str	r2, [r3, #20]
 801132e:	e006      	b.n	801133e <nk_fill_triangle+0x2e2>
    if (!b || c.a == 0) return;
 8011330:	bf00      	nop
 8011332:	e004      	b.n	801133e <nk_fill_triangle+0x2e2>
    if (!b) return;
 8011334:	bf00      	nop
 8011336:	e002      	b.n	801133e <nk_fill_triangle+0x2e2>
            return;
 8011338:	bf00      	nop
 801133a:	e000      	b.n	801133e <nk_fill_triangle+0x2e2>
    if (!cmd) return;
 801133c:	bf00      	nop
}
 801133e:	3728      	adds	r7, #40	; 0x28
 8011340:	46bd      	mov	sp, r7
 8011342:	bd80      	pop	{r7, pc}
 8011344:	08021734 	.word	0x08021734
 8011348:	08023434 	.word	0x08023434
 801134c:	08021718 	.word	0x08021718

08011350 <nk_draw_image>:
    }
}
NK_API void
nk_draw_image(struct nk_command_buffer *b, struct nk_rect r,
    const struct nk_image *img, struct nk_color col)
{
 8011350:	b590      	push	{r4, r7, lr}
 8011352:	b08b      	sub	sp, #44	; 0x2c
 8011354:	af00      	add	r7, sp, #0
 8011356:	61f8      	str	r0, [r7, #28]
 8011358:	eeb0 6a40 	vmov.f32	s12, s0
 801135c:	eef0 6a60 	vmov.f32	s13, s1
 8011360:	eeb0 7a41 	vmov.f32	s14, s2
 8011364:	eef0 7a61 	vmov.f32	s15, s3
 8011368:	60b9      	str	r1, [r7, #8]
 801136a:	607a      	str	r2, [r7, #4]
 801136c:	ed87 6a03 	vstr	s12, [r7, #12]
 8011370:	edc7 6a04 	vstr	s13, [r7, #16]
 8011374:	ed87 7a05 	vstr	s14, [r7, #20]
 8011378:	edc7 7a06 	vstr	s15, [r7, #24]
    struct nk_command_image *cmd;
    NK_ASSERT(b);
 801137c:	69fb      	ldr	r3, [r7, #28]
 801137e:	2b00      	cmp	r3, #0
 8011380:	d106      	bne.n	8011390 <nk_draw_image+0x40>
 8011382:	4b69      	ldr	r3, [pc, #420]	; (8011528 <nk_draw_image+0x1d8>)
 8011384:	4a69      	ldr	r2, [pc, #420]	; (801152c <nk_draw_image+0x1dc>)
 8011386:	f240 118f 	movw	r1, #399	; 0x18f
 801138a:	4869      	ldr	r0, [pc, #420]	; (8011530 <nk_draw_image+0x1e0>)
 801138c:	f00c fb44 	bl	801da18 <__assert_func>
    if (!b) return;
 8011390:	69fb      	ldr	r3, [r7, #28]
 8011392:	2b00      	cmp	r3, #0
 8011394:	f000 80bf 	beq.w	8011516 <nk_draw_image+0x1c6>
    if (b->use_clipping) {
 8011398:	69fb      	ldr	r3, [r7, #28]
 801139a:	695b      	ldr	r3, [r3, #20]
 801139c:	2b00      	cmp	r3, #0
 801139e:	d06f      	beq.n	8011480 <nk_draw_image+0x130>
        const struct nk_rect *c = &b->clip;
 80113a0:	69fb      	ldr	r3, [r7, #28]
 80113a2:	3304      	adds	r3, #4
 80113a4:	627b      	str	r3, [r7, #36]	; 0x24
        if (c->w == 0 || c->h == 0 || !NK_INTERSECT(r.x, r.y, r.w, r.h, c->x, c->y, c->w, c->h))
 80113a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80113a8:	edd3 7a02 	vldr	s15, [r3, #8]
 80113ac:	eef5 7a40 	vcmp.f32	s15, #0.0
 80113b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80113b4:	f000 80b1 	beq.w	801151a <nk_draw_image+0x1ca>
 80113b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80113ba:	edd3 7a03 	vldr	s15, [r3, #12]
 80113be:	eef5 7a40 	vcmp.f32	s15, #0.0
 80113c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80113c6:	f000 80a8 	beq.w	801151a <nk_draw_image+0x1ca>
 80113ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80113cc:	ed93 7a00 	vldr	s14, [r3]
 80113d0:	edd7 6a03 	vldr	s13, [r7, #12]
 80113d4:	edd7 7a05 	vldr	s15, [r7, #20]
 80113d8:	ee76 7aa7 	vadd.f32	s15, s13, s15
 80113dc:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80113e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80113e4:	bf4c      	ite	mi
 80113e6:	2301      	movmi	r3, #1
 80113e8:	2300      	movpl	r3, #0
 80113ea:	b2db      	uxtb	r3, r3
 80113ec:	f083 0301 	eor.w	r3, r3, #1
 80113f0:	b2db      	uxtb	r3, r3
 80113f2:	2b00      	cmp	r3, #0
 80113f4:	f040 8091 	bne.w	801151a <nk_draw_image+0x1ca>
 80113f8:	ed97 7a03 	vldr	s14, [r7, #12]
 80113fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80113fe:	edd3 6a00 	vldr	s13, [r3]
 8011402:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011404:	edd3 7a02 	vldr	s15, [r3, #8]
 8011408:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801140c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8011410:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011414:	bf4c      	ite	mi
 8011416:	2301      	movmi	r3, #1
 8011418:	2300      	movpl	r3, #0
 801141a:	b2db      	uxtb	r3, r3
 801141c:	f083 0301 	eor.w	r3, r3, #1
 8011420:	b2db      	uxtb	r3, r3
 8011422:	2b00      	cmp	r3, #0
 8011424:	d179      	bne.n	801151a <nk_draw_image+0x1ca>
 8011426:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011428:	ed93 7a01 	vldr	s14, [r3, #4]
 801142c:	edd7 6a04 	vldr	s13, [r7, #16]
 8011430:	edd7 7a06 	vldr	s15, [r7, #24]
 8011434:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8011438:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801143c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011440:	bf4c      	ite	mi
 8011442:	2301      	movmi	r3, #1
 8011444:	2300      	movpl	r3, #0
 8011446:	b2db      	uxtb	r3, r3
 8011448:	f083 0301 	eor.w	r3, r3, #1
 801144c:	b2db      	uxtb	r3, r3
 801144e:	2b00      	cmp	r3, #0
 8011450:	d163      	bne.n	801151a <nk_draw_image+0x1ca>
 8011452:	ed97 7a04 	vldr	s14, [r7, #16]
 8011456:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011458:	edd3 6a01 	vldr	s13, [r3, #4]
 801145c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801145e:	edd3 7a03 	vldr	s15, [r3, #12]
 8011462:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8011466:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801146a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801146e:	bf4c      	ite	mi
 8011470:	2301      	movmi	r3, #1
 8011472:	2300      	movpl	r3, #0
 8011474:	b2db      	uxtb	r3, r3
 8011476:	f083 0301 	eor.w	r3, r3, #1
 801147a:	b2db      	uxtb	r3, r3
 801147c:	2b00      	cmp	r3, #0
 801147e:	d14c      	bne.n	801151a <nk_draw_image+0x1ca>
            return;
    }

    cmd = (struct nk_command_image*)
        nk_command_buffer_push(b, NK_COMMAND_IMAGE, sizeof(*cmd));
 8011480:	2224      	movs	r2, #36	; 0x24
 8011482:	2111      	movs	r1, #17
 8011484:	69f8      	ldr	r0, [r7, #28]
 8011486:	f7ff fa23 	bl	80108d0 <nk_command_buffer_push>
 801148a:	6238      	str	r0, [r7, #32]
    if (!cmd) return;
 801148c:	6a3b      	ldr	r3, [r7, #32]
 801148e:	2b00      	cmp	r3, #0
 8011490:	d045      	beq.n	801151e <nk_draw_image+0x1ce>
    cmd->x = (short)r.x;
 8011492:	edd7 7a03 	vldr	s15, [r7, #12]
 8011496:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801149a:	ee17 3a90 	vmov	r3, s15
 801149e:	b21a      	sxth	r2, r3
 80114a0:	6a3b      	ldr	r3, [r7, #32]
 80114a2:	811a      	strh	r2, [r3, #8]
    cmd->y = (short)r.y;
 80114a4:	edd7 7a04 	vldr	s15, [r7, #16]
 80114a8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80114ac:	ee17 3a90 	vmov	r3, s15
 80114b0:	b21a      	sxth	r2, r3
 80114b2:	6a3b      	ldr	r3, [r7, #32]
 80114b4:	815a      	strh	r2, [r3, #10]
    cmd->w = (unsigned short)NK_MAX(0, r.w);
 80114b6:	edd7 7a05 	vldr	s15, [r7, #20]
 80114ba:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80114be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80114c2:	dd07      	ble.n	80114d4 <nk_draw_image+0x184>
 80114c4:	edd7 7a05 	vldr	s15, [r7, #20]
 80114c8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80114cc:	ee17 3a90 	vmov	r3, s15
 80114d0:	b29a      	uxth	r2, r3
 80114d2:	e000      	b.n	80114d6 <nk_draw_image+0x186>
 80114d4:	2200      	movs	r2, #0
 80114d6:	6a3b      	ldr	r3, [r7, #32]
 80114d8:	819a      	strh	r2, [r3, #12]
    cmd->h = (unsigned short)NK_MAX(0, r.h);
 80114da:	edd7 7a06 	vldr	s15, [r7, #24]
 80114de:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80114e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80114e6:	dd07      	ble.n	80114f8 <nk_draw_image+0x1a8>
 80114e8:	edd7 7a06 	vldr	s15, [r7, #24]
 80114ec:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80114f0:	ee17 3a90 	vmov	r3, s15
 80114f4:	b29a      	uxth	r2, r3
 80114f6:	e000      	b.n	80114fa <nk_draw_image+0x1aa>
 80114f8:	2200      	movs	r2, #0
 80114fa:	6a3b      	ldr	r3, [r7, #32]
 80114fc:	81da      	strh	r2, [r3, #14]
    cmd->img = *img;
 80114fe:	6a3b      	ldr	r3, [r7, #32]
 8011500:	68ba      	ldr	r2, [r7, #8]
 8011502:	f103 0410 	add.w	r4, r3, #16
 8011506:	4613      	mov	r3, r2
 8011508:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801150a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    cmd->col = col;
 801150e:	6a3b      	ldr	r3, [r7, #32]
 8011510:	687a      	ldr	r2, [r7, #4]
 8011512:	621a      	str	r2, [r3, #32]
 8011514:	e004      	b.n	8011520 <nk_draw_image+0x1d0>
    if (!b) return;
 8011516:	bf00      	nop
 8011518:	e002      	b.n	8011520 <nk_draw_image+0x1d0>
            return;
 801151a:	bf00      	nop
 801151c:	e000      	b.n	8011520 <nk_draw_image+0x1d0>
    if (!cmd) return;
 801151e:	bf00      	nop
}
 8011520:	372c      	adds	r7, #44	; 0x2c
 8011522:	46bd      	mov	sp, r7
 8011524:	bd90      	pop	{r4, r7, pc}
 8011526:	bf00      	nop
 8011528:	08021734 	.word	0x08021734
 801152c:	08023448 	.word	0x08023448
 8011530:	08021718 	.word	0x08021718

08011534 <nk_draw_nine_slice>:
NK_API void
nk_draw_nine_slice(struct nk_command_buffer *b, struct nk_rect r,
    const struct nk_nine_slice *slc, struct nk_color col)
{
 8011534:	b580      	push	{r7, lr}
 8011536:	b0b4      	sub	sp, #208	; 0xd0
 8011538:	af00      	add	r7, sp, #0
 801153a:	61f8      	str	r0, [r7, #28]
 801153c:	eeb0 6a40 	vmov.f32	s12, s0
 8011540:	eef0 6a60 	vmov.f32	s13, s1
 8011544:	eeb0 7a41 	vmov.f32	s14, s2
 8011548:	eef0 7a61 	vmov.f32	s15, s3
 801154c:	60b9      	str	r1, [r7, #8]
 801154e:	607a      	str	r2, [r7, #4]
 8011550:	ed87 6a03 	vstr	s12, [r7, #12]
 8011554:	edc7 6a04 	vstr	s13, [r7, #16]
 8011558:	ed87 7a05 	vstr	s14, [r7, #20]
 801155c:	edc7 7a06 	vstr	s15, [r7, #24]
    struct nk_image img;
    const struct nk_image *slcimg = (const struct nk_image*)slc;
 8011560:	68bb      	ldr	r3, [r7, #8]
 8011562:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
    nk_ushort rgnX, rgnY, rgnW, rgnH;
    rgnX = slcimg->region[0];
 8011566:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 801156a:	891b      	ldrh	r3, [r3, #8]
 801156c:	f8a7 30ca 	strh.w	r3, [r7, #202]	; 0xca
    rgnY = slcimg->region[1];
 8011570:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8011574:	895b      	ldrh	r3, [r3, #10]
 8011576:	f8a7 30c8 	strh.w	r3, [r7, #200]	; 0xc8
    rgnW = slcimg->region[2];
 801157a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 801157e:	899b      	ldrh	r3, [r3, #12]
 8011580:	f8a7 30c6 	strh.w	r3, [r7, #198]	; 0xc6
    rgnH = slcimg->region[3];
 8011584:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8011588:	89db      	ldrh	r3, [r3, #14]
 801158a:	f8a7 30c4 	strh.w	r3, [r7, #196]	; 0xc4

    /* top-left */
    img.handle = slcimg->handle;
 801158e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8011592:	681b      	ldr	r3, [r3, #0]
 8011594:	627b      	str	r3, [r7, #36]	; 0x24
    img.w = slcimg->w;
 8011596:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 801159a:	889b      	ldrh	r3, [r3, #4]
 801159c:	853b      	strh	r3, [r7, #40]	; 0x28
    img.h = slcimg->h;
 801159e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80115a2:	88db      	ldrh	r3, [r3, #6]
 80115a4:	857b      	strh	r3, [r7, #42]	; 0x2a
    img.region[0] = rgnX;
 80115a6:	f8b7 30ca 	ldrh.w	r3, [r7, #202]	; 0xca
 80115aa:	85bb      	strh	r3, [r7, #44]	; 0x2c
    img.region[1] = rgnY;
 80115ac:	f8b7 30c8 	ldrh.w	r3, [r7, #200]	; 0xc8
 80115b0:	85fb      	strh	r3, [r7, #46]	; 0x2e
    img.region[2] = slc->l;
 80115b2:	68bb      	ldr	r3, [r7, #8]
 80115b4:	8a1b      	ldrh	r3, [r3, #16]
 80115b6:	863b      	strh	r3, [r7, #48]	; 0x30
    img.region[3] = slc->t;
 80115b8:	68bb      	ldr	r3, [r7, #8]
 80115ba:	8a5b      	ldrh	r3, [r3, #18]
 80115bc:	867b      	strh	r3, [r7, #50]	; 0x32

    nk_draw_image(b,
 80115be:	edd7 7a03 	vldr	s15, [r7, #12]
 80115c2:	ed97 7a04 	vldr	s14, [r7, #16]
        nk_rect(r.x, r.y, (float)slc->l, (float)slc->t),
 80115c6:	68bb      	ldr	r3, [r7, #8]
 80115c8:	8a1b      	ldrh	r3, [r3, #16]
    nk_draw_image(b,
 80115ca:	ee06 3a90 	vmov	s13, r3
 80115ce:	eef8 6a66 	vcvt.f32.u32	s13, s13
        nk_rect(r.x, r.y, (float)slc->l, (float)slc->t),
 80115d2:	68bb      	ldr	r3, [r7, #8]
 80115d4:	8a5b      	ldrh	r3, [r3, #18]
    nk_draw_image(b,
 80115d6:	ee06 3a10 	vmov	s12, r3
 80115da:	eeb8 6a46 	vcvt.f32.u32	s12, s12
 80115de:	eef0 1a46 	vmov.f32	s3, s12
 80115e2:	eeb0 1a66 	vmov.f32	s2, s13
 80115e6:	eef0 0a47 	vmov.f32	s1, s14
 80115ea:	eeb0 0a67 	vmov.f32	s0, s15
 80115ee:	f002 f8b1 	bl	8013754 <nk_rect>
 80115f2:	eeb0 6a40 	vmov.f32	s12, s0
 80115f6:	eef0 6a60 	vmov.f32	s13, s1
 80115fa:	eeb0 7a41 	vmov.f32	s14, s2
 80115fe:	eef0 7a61 	vmov.f32	s15, s3
 8011602:	ed87 6a0d 	vstr	s12, [r7, #52]	; 0x34
 8011606:	edc7 6a0e 	vstr	s13, [r7, #56]	; 0x38
 801160a:	ed87 7a0f 	vstr	s14, [r7, #60]	; 0x3c
 801160e:	edc7 7a10 	vstr	s15, [r7, #64]	; 0x40
 8011612:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8011616:	ed97 6a0d 	vldr	s12, [r7, #52]	; 0x34
 801161a:	edd7 6a0e 	vldr	s13, [r7, #56]	; 0x38
 801161e:	ed97 7a0f 	vldr	s14, [r7, #60]	; 0x3c
 8011622:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
 8011626:	687a      	ldr	r2, [r7, #4]
 8011628:	4619      	mov	r1, r3
 801162a:	eeb0 0a46 	vmov.f32	s0, s12
 801162e:	eef0 0a66 	vmov.f32	s1, s13
 8011632:	eeb0 1a47 	vmov.f32	s2, s14
 8011636:	eef0 1a67 	vmov.f32	s3, s15
 801163a:	69f8      	ldr	r0, [r7, #28]
 801163c:	f7ff fe88 	bl	8011350 <nk_draw_image>
        &img, col);

#define IMG_RGN(x, y, w, h) img.region[0] = (nk_ushort)(x); img.region[1] = (nk_ushort)(y); img.region[2] = (nk_ushort)(w); img.region[3] = (nk_ushort)(h);

    /* top-center */
    IMG_RGN(rgnX + slc->l, rgnY, rgnW - slc->l - slc->r, slc->t);
 8011640:	68bb      	ldr	r3, [r7, #8]
 8011642:	8a1a      	ldrh	r2, [r3, #16]
 8011644:	f8b7 30ca 	ldrh.w	r3, [r7, #202]	; 0xca
 8011648:	4413      	add	r3, r2
 801164a:	b29b      	uxth	r3, r3
 801164c:	85bb      	strh	r3, [r7, #44]	; 0x2c
 801164e:	f8b7 30c8 	ldrh.w	r3, [r7, #200]	; 0xc8
 8011652:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8011654:	68bb      	ldr	r3, [r7, #8]
 8011656:	8a1b      	ldrh	r3, [r3, #16]
 8011658:	f8b7 20c6 	ldrh.w	r2, [r7, #198]	; 0xc6
 801165c:	1ad3      	subs	r3, r2, r3
 801165e:	b29a      	uxth	r2, r3
 8011660:	68bb      	ldr	r3, [r7, #8]
 8011662:	8a9b      	ldrh	r3, [r3, #20]
 8011664:	1ad3      	subs	r3, r2, r3
 8011666:	b29b      	uxth	r3, r3
 8011668:	863b      	strh	r3, [r7, #48]	; 0x30
 801166a:	68bb      	ldr	r3, [r7, #8]
 801166c:	8a5b      	ldrh	r3, [r3, #18]
 801166e:	867b      	strh	r3, [r7, #50]	; 0x32
    nk_draw_image(b,
        nk_rect(r.x + (float)slc->l, r.y, (float)(r.w - slc->l - slc->r), (float)slc->t),
 8011670:	ed97 7a03 	vldr	s14, [r7, #12]
 8011674:	68bb      	ldr	r3, [r7, #8]
 8011676:	8a1b      	ldrh	r3, [r3, #16]
 8011678:	ee07 3a90 	vmov	s15, r3
 801167c:	eef8 7a67 	vcvt.f32.u32	s15, s15
    nk_draw_image(b,
 8011680:	ee77 6a27 	vadd.f32	s13, s14, s15
 8011684:	ed97 6a04 	vldr	s12, [r7, #16]
        nk_rect(r.x + (float)slc->l, r.y, (float)(r.w - slc->l - slc->r), (float)slc->t),
 8011688:	ed97 7a05 	vldr	s14, [r7, #20]
 801168c:	68bb      	ldr	r3, [r7, #8]
 801168e:	8a1b      	ldrh	r3, [r3, #16]
 8011690:	ee07 3a90 	vmov	s15, r3
 8011694:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8011698:	ee37 7a67 	vsub.f32	s14, s14, s15
 801169c:	68bb      	ldr	r3, [r7, #8]
 801169e:	8a9b      	ldrh	r3, [r3, #20]
 80116a0:	ee07 3a90 	vmov	s15, r3
    nk_draw_image(b,
 80116a4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80116a8:	ee77 7a67 	vsub.f32	s15, s14, s15
        nk_rect(r.x + (float)slc->l, r.y, (float)(r.w - slc->l - slc->r), (float)slc->t),
 80116ac:	68bb      	ldr	r3, [r7, #8]
 80116ae:	8a5b      	ldrh	r3, [r3, #18]
    nk_draw_image(b,
 80116b0:	ee07 3a10 	vmov	s14, r3
 80116b4:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 80116b8:	eef0 1a47 	vmov.f32	s3, s14
 80116bc:	eeb0 1a67 	vmov.f32	s2, s15
 80116c0:	eef0 0a46 	vmov.f32	s1, s12
 80116c4:	eeb0 0a66 	vmov.f32	s0, s13
 80116c8:	f002 f844 	bl	8013754 <nk_rect>
 80116cc:	eeb0 6a40 	vmov.f32	s12, s0
 80116d0:	eef0 6a60 	vmov.f32	s13, s1
 80116d4:	eeb0 7a41 	vmov.f32	s14, s2
 80116d8:	eef0 7a61 	vmov.f32	s15, s3
 80116dc:	ed87 6a11 	vstr	s12, [r7, #68]	; 0x44
 80116e0:	edc7 6a12 	vstr	s13, [r7, #72]	; 0x48
 80116e4:	ed87 7a13 	vstr	s14, [r7, #76]	; 0x4c
 80116e8:	edc7 7a14 	vstr	s15, [r7, #80]	; 0x50
 80116ec:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80116f0:	ed97 6a11 	vldr	s12, [r7, #68]	; 0x44
 80116f4:	edd7 6a12 	vldr	s13, [r7, #72]	; 0x48
 80116f8:	ed97 7a13 	vldr	s14, [r7, #76]	; 0x4c
 80116fc:	edd7 7a14 	vldr	s15, [r7, #80]	; 0x50
 8011700:	687a      	ldr	r2, [r7, #4]
 8011702:	4619      	mov	r1, r3
 8011704:	eeb0 0a46 	vmov.f32	s0, s12
 8011708:	eef0 0a66 	vmov.f32	s1, s13
 801170c:	eeb0 1a47 	vmov.f32	s2, s14
 8011710:	eef0 1a67 	vmov.f32	s3, s15
 8011714:	69f8      	ldr	r0, [r7, #28]
 8011716:	f7ff fe1b 	bl	8011350 <nk_draw_image>
        &img, col);

    /* top-right */
    IMG_RGN(rgnX + rgnW - slc->r, rgnY, slc->r, slc->t);
 801171a:	f8b7 20ca 	ldrh.w	r2, [r7, #202]	; 0xca
 801171e:	f8b7 30c6 	ldrh.w	r3, [r7, #198]	; 0xc6
 8011722:	4413      	add	r3, r2
 8011724:	b29a      	uxth	r2, r3
 8011726:	68bb      	ldr	r3, [r7, #8]
 8011728:	8a9b      	ldrh	r3, [r3, #20]
 801172a:	1ad3      	subs	r3, r2, r3
 801172c:	b29b      	uxth	r3, r3
 801172e:	85bb      	strh	r3, [r7, #44]	; 0x2c
 8011730:	f8b7 30c8 	ldrh.w	r3, [r7, #200]	; 0xc8
 8011734:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8011736:	68bb      	ldr	r3, [r7, #8]
 8011738:	8a9b      	ldrh	r3, [r3, #20]
 801173a:	863b      	strh	r3, [r7, #48]	; 0x30
 801173c:	68bb      	ldr	r3, [r7, #8]
 801173e:	8a5b      	ldrh	r3, [r3, #18]
 8011740:	867b      	strh	r3, [r7, #50]	; 0x32
    nk_draw_image(b,
        nk_rect(r.x + r.w - (float)slc->r, r.y, (float)slc->r, (float)slc->t),
 8011742:	ed97 7a03 	vldr	s14, [r7, #12]
 8011746:	edd7 7a05 	vldr	s15, [r7, #20]
 801174a:	ee37 7a27 	vadd.f32	s14, s14, s15
 801174e:	68bb      	ldr	r3, [r7, #8]
 8011750:	8a9b      	ldrh	r3, [r3, #20]
 8011752:	ee07 3a90 	vmov	s15, r3
 8011756:	eef8 7a67 	vcvt.f32.u32	s15, s15
    nk_draw_image(b,
 801175a:	ee77 7a67 	vsub.f32	s15, s14, s15
 801175e:	ed97 7a04 	vldr	s14, [r7, #16]
        nk_rect(r.x + r.w - (float)slc->r, r.y, (float)slc->r, (float)slc->t),
 8011762:	68bb      	ldr	r3, [r7, #8]
 8011764:	8a9b      	ldrh	r3, [r3, #20]
    nk_draw_image(b,
 8011766:	ee06 3a90 	vmov	s13, r3
 801176a:	eef8 6a66 	vcvt.f32.u32	s13, s13
        nk_rect(r.x + r.w - (float)slc->r, r.y, (float)slc->r, (float)slc->t),
 801176e:	68bb      	ldr	r3, [r7, #8]
 8011770:	8a5b      	ldrh	r3, [r3, #18]
    nk_draw_image(b,
 8011772:	ee06 3a10 	vmov	s12, r3
 8011776:	eeb8 6a46 	vcvt.f32.u32	s12, s12
 801177a:	eef0 1a46 	vmov.f32	s3, s12
 801177e:	eeb0 1a66 	vmov.f32	s2, s13
 8011782:	eef0 0a47 	vmov.f32	s1, s14
 8011786:	eeb0 0a67 	vmov.f32	s0, s15
 801178a:	f001 ffe3 	bl	8013754 <nk_rect>
 801178e:	eeb0 6a40 	vmov.f32	s12, s0
 8011792:	eef0 6a60 	vmov.f32	s13, s1
 8011796:	eeb0 7a41 	vmov.f32	s14, s2
 801179a:	eef0 7a61 	vmov.f32	s15, s3
 801179e:	ed87 6a15 	vstr	s12, [r7, #84]	; 0x54
 80117a2:	edc7 6a16 	vstr	s13, [r7, #88]	; 0x58
 80117a6:	ed87 7a17 	vstr	s14, [r7, #92]	; 0x5c
 80117aa:	edc7 7a18 	vstr	s15, [r7, #96]	; 0x60
 80117ae:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80117b2:	ed97 6a15 	vldr	s12, [r7, #84]	; 0x54
 80117b6:	edd7 6a16 	vldr	s13, [r7, #88]	; 0x58
 80117ba:	ed97 7a17 	vldr	s14, [r7, #92]	; 0x5c
 80117be:	edd7 7a18 	vldr	s15, [r7, #96]	; 0x60
 80117c2:	687a      	ldr	r2, [r7, #4]
 80117c4:	4619      	mov	r1, r3
 80117c6:	eeb0 0a46 	vmov.f32	s0, s12
 80117ca:	eef0 0a66 	vmov.f32	s1, s13
 80117ce:	eeb0 1a47 	vmov.f32	s2, s14
 80117d2:	eef0 1a67 	vmov.f32	s3, s15
 80117d6:	69f8      	ldr	r0, [r7, #28]
 80117d8:	f7ff fdba 	bl	8011350 <nk_draw_image>
        &img, col);

    /* center-left */
    IMG_RGN(rgnX, rgnY + slc->t, slc->l, rgnH - slc->t - slc->b);
 80117dc:	f8b7 30ca 	ldrh.w	r3, [r7, #202]	; 0xca
 80117e0:	85bb      	strh	r3, [r7, #44]	; 0x2c
 80117e2:	68bb      	ldr	r3, [r7, #8]
 80117e4:	8a5a      	ldrh	r2, [r3, #18]
 80117e6:	f8b7 30c8 	ldrh.w	r3, [r7, #200]	; 0xc8
 80117ea:	4413      	add	r3, r2
 80117ec:	b29b      	uxth	r3, r3
 80117ee:	85fb      	strh	r3, [r7, #46]	; 0x2e
 80117f0:	68bb      	ldr	r3, [r7, #8]
 80117f2:	8a1b      	ldrh	r3, [r3, #16]
 80117f4:	863b      	strh	r3, [r7, #48]	; 0x30
 80117f6:	68bb      	ldr	r3, [r7, #8]
 80117f8:	8a5b      	ldrh	r3, [r3, #18]
 80117fa:	f8b7 20c4 	ldrh.w	r2, [r7, #196]	; 0xc4
 80117fe:	1ad3      	subs	r3, r2, r3
 8011800:	b29a      	uxth	r2, r3
 8011802:	68bb      	ldr	r3, [r7, #8]
 8011804:	8adb      	ldrh	r3, [r3, #22]
 8011806:	1ad3      	subs	r3, r2, r3
 8011808:	b29b      	uxth	r3, r3
 801180a:	867b      	strh	r3, [r7, #50]	; 0x32
    nk_draw_image(b,
 801180c:	edd7 6a03 	vldr	s13, [r7, #12]
        nk_rect(r.x, r.y + (float)slc->t, (float)slc->l, (float)(r.h - slc->t - slc->b)),
 8011810:	ed97 7a04 	vldr	s14, [r7, #16]
 8011814:	68bb      	ldr	r3, [r7, #8]
 8011816:	8a5b      	ldrh	r3, [r3, #18]
 8011818:	ee07 3a90 	vmov	s15, r3
 801181c:	eef8 7a67 	vcvt.f32.u32	s15, s15
    nk_draw_image(b,
 8011820:	ee37 6a27 	vadd.f32	s12, s14, s15
        nk_rect(r.x, r.y + (float)slc->t, (float)slc->l, (float)(r.h - slc->t - slc->b)),
 8011824:	68bb      	ldr	r3, [r7, #8]
 8011826:	8a1b      	ldrh	r3, [r3, #16]
    nk_draw_image(b,
 8011828:	ee07 3a90 	vmov	s15, r3
 801182c:	eef8 5a67 	vcvt.f32.u32	s11, s15
        nk_rect(r.x, r.y + (float)slc->t, (float)slc->l, (float)(r.h - slc->t - slc->b)),
 8011830:	ed97 7a06 	vldr	s14, [r7, #24]
 8011834:	68bb      	ldr	r3, [r7, #8]
 8011836:	8a5b      	ldrh	r3, [r3, #18]
 8011838:	ee07 3a90 	vmov	s15, r3
 801183c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8011840:	ee37 7a67 	vsub.f32	s14, s14, s15
 8011844:	68bb      	ldr	r3, [r7, #8]
 8011846:	8adb      	ldrh	r3, [r3, #22]
 8011848:	ee07 3a90 	vmov	s15, r3
    nk_draw_image(b,
 801184c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8011850:	ee77 7a67 	vsub.f32	s15, s14, s15
 8011854:	eef0 1a67 	vmov.f32	s3, s15
 8011858:	eeb0 1a65 	vmov.f32	s2, s11
 801185c:	eef0 0a46 	vmov.f32	s1, s12
 8011860:	eeb0 0a66 	vmov.f32	s0, s13
 8011864:	f001 ff76 	bl	8013754 <nk_rect>
 8011868:	eeb0 6a40 	vmov.f32	s12, s0
 801186c:	eef0 6a60 	vmov.f32	s13, s1
 8011870:	eeb0 7a41 	vmov.f32	s14, s2
 8011874:	eef0 7a61 	vmov.f32	s15, s3
 8011878:	ed87 6a19 	vstr	s12, [r7, #100]	; 0x64
 801187c:	edc7 6a1a 	vstr	s13, [r7, #104]	; 0x68
 8011880:	ed87 7a1b 	vstr	s14, [r7, #108]	; 0x6c
 8011884:	edc7 7a1c 	vstr	s15, [r7, #112]	; 0x70
 8011888:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801188c:	ed97 6a19 	vldr	s12, [r7, #100]	; 0x64
 8011890:	edd7 6a1a 	vldr	s13, [r7, #104]	; 0x68
 8011894:	ed97 7a1b 	vldr	s14, [r7, #108]	; 0x6c
 8011898:	edd7 7a1c 	vldr	s15, [r7, #112]	; 0x70
 801189c:	687a      	ldr	r2, [r7, #4]
 801189e:	4619      	mov	r1, r3
 80118a0:	eeb0 0a46 	vmov.f32	s0, s12
 80118a4:	eef0 0a66 	vmov.f32	s1, s13
 80118a8:	eeb0 1a47 	vmov.f32	s2, s14
 80118ac:	eef0 1a67 	vmov.f32	s3, s15
 80118b0:	69f8      	ldr	r0, [r7, #28]
 80118b2:	f7ff fd4d 	bl	8011350 <nk_draw_image>
        &img, col);

    /* center */
    IMG_RGN(rgnX + slc->l, rgnY + slc->t, rgnW - slc->l - slc->r, rgnH - slc->t - slc->b);
 80118b6:	68bb      	ldr	r3, [r7, #8]
 80118b8:	8a1a      	ldrh	r2, [r3, #16]
 80118ba:	f8b7 30ca 	ldrh.w	r3, [r7, #202]	; 0xca
 80118be:	4413      	add	r3, r2
 80118c0:	b29b      	uxth	r3, r3
 80118c2:	85bb      	strh	r3, [r7, #44]	; 0x2c
 80118c4:	68bb      	ldr	r3, [r7, #8]
 80118c6:	8a5a      	ldrh	r2, [r3, #18]
 80118c8:	f8b7 30c8 	ldrh.w	r3, [r7, #200]	; 0xc8
 80118cc:	4413      	add	r3, r2
 80118ce:	b29b      	uxth	r3, r3
 80118d0:	85fb      	strh	r3, [r7, #46]	; 0x2e
 80118d2:	68bb      	ldr	r3, [r7, #8]
 80118d4:	8a1b      	ldrh	r3, [r3, #16]
 80118d6:	f8b7 20c6 	ldrh.w	r2, [r7, #198]	; 0xc6
 80118da:	1ad3      	subs	r3, r2, r3
 80118dc:	b29a      	uxth	r2, r3
 80118de:	68bb      	ldr	r3, [r7, #8]
 80118e0:	8a9b      	ldrh	r3, [r3, #20]
 80118e2:	1ad3      	subs	r3, r2, r3
 80118e4:	b29b      	uxth	r3, r3
 80118e6:	863b      	strh	r3, [r7, #48]	; 0x30
 80118e8:	68bb      	ldr	r3, [r7, #8]
 80118ea:	8a5b      	ldrh	r3, [r3, #18]
 80118ec:	f8b7 20c4 	ldrh.w	r2, [r7, #196]	; 0xc4
 80118f0:	1ad3      	subs	r3, r2, r3
 80118f2:	b29a      	uxth	r2, r3
 80118f4:	68bb      	ldr	r3, [r7, #8]
 80118f6:	8adb      	ldrh	r3, [r3, #22]
 80118f8:	1ad3      	subs	r3, r2, r3
 80118fa:	b29b      	uxth	r3, r3
 80118fc:	867b      	strh	r3, [r7, #50]	; 0x32
    nk_draw_image(b,
        nk_rect(r.x + (float)slc->l, r.y + (float)slc->t, (float)(r.w - slc->l - slc->r), (float)(r.h - slc->t - slc->b)),
 80118fe:	ed97 7a03 	vldr	s14, [r7, #12]
 8011902:	68bb      	ldr	r3, [r7, #8]
 8011904:	8a1b      	ldrh	r3, [r3, #16]
 8011906:	ee07 3a90 	vmov	s15, r3
 801190a:	eef8 7a67 	vcvt.f32.u32	s15, s15
    nk_draw_image(b,
 801190e:	ee77 6a27 	vadd.f32	s13, s14, s15
        nk_rect(r.x + (float)slc->l, r.y + (float)slc->t, (float)(r.w - slc->l - slc->r), (float)(r.h - slc->t - slc->b)),
 8011912:	ed97 7a04 	vldr	s14, [r7, #16]
 8011916:	68bb      	ldr	r3, [r7, #8]
 8011918:	8a5b      	ldrh	r3, [r3, #18]
 801191a:	ee07 3a90 	vmov	s15, r3
 801191e:	eef8 7a67 	vcvt.f32.u32	s15, s15
    nk_draw_image(b,
 8011922:	ee37 6a27 	vadd.f32	s12, s14, s15
        nk_rect(r.x + (float)slc->l, r.y + (float)slc->t, (float)(r.w - slc->l - slc->r), (float)(r.h - slc->t - slc->b)),
 8011926:	ed97 7a05 	vldr	s14, [r7, #20]
 801192a:	68bb      	ldr	r3, [r7, #8]
 801192c:	8a1b      	ldrh	r3, [r3, #16]
 801192e:	ee07 3a90 	vmov	s15, r3
 8011932:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8011936:	ee37 7a67 	vsub.f32	s14, s14, s15
 801193a:	68bb      	ldr	r3, [r7, #8]
 801193c:	8a9b      	ldrh	r3, [r3, #20]
 801193e:	ee07 3a90 	vmov	s15, r3
    nk_draw_image(b,
 8011942:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8011946:	ee77 5a67 	vsub.f32	s11, s14, s15
        nk_rect(r.x + (float)slc->l, r.y + (float)slc->t, (float)(r.w - slc->l - slc->r), (float)(r.h - slc->t - slc->b)),
 801194a:	ed97 7a06 	vldr	s14, [r7, #24]
 801194e:	68bb      	ldr	r3, [r7, #8]
 8011950:	8a5b      	ldrh	r3, [r3, #18]
 8011952:	ee07 3a90 	vmov	s15, r3
 8011956:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801195a:	ee37 7a67 	vsub.f32	s14, s14, s15
 801195e:	68bb      	ldr	r3, [r7, #8]
 8011960:	8adb      	ldrh	r3, [r3, #22]
 8011962:	ee07 3a90 	vmov	s15, r3
    nk_draw_image(b,
 8011966:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801196a:	ee77 7a67 	vsub.f32	s15, s14, s15
 801196e:	eef0 1a67 	vmov.f32	s3, s15
 8011972:	eeb0 1a65 	vmov.f32	s2, s11
 8011976:	eef0 0a46 	vmov.f32	s1, s12
 801197a:	eeb0 0a66 	vmov.f32	s0, s13
 801197e:	f001 fee9 	bl	8013754 <nk_rect>
 8011982:	eeb0 6a40 	vmov.f32	s12, s0
 8011986:	eef0 6a60 	vmov.f32	s13, s1
 801198a:	eeb0 7a41 	vmov.f32	s14, s2
 801198e:	eef0 7a61 	vmov.f32	s15, s3
 8011992:	ed87 6a1d 	vstr	s12, [r7, #116]	; 0x74
 8011996:	edc7 6a1e 	vstr	s13, [r7, #120]	; 0x78
 801199a:	ed87 7a1f 	vstr	s14, [r7, #124]	; 0x7c
 801199e:	edc7 7a20 	vstr	s15, [r7, #128]	; 0x80
 80119a2:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80119a6:	ed97 6a1d 	vldr	s12, [r7, #116]	; 0x74
 80119aa:	edd7 6a1e 	vldr	s13, [r7, #120]	; 0x78
 80119ae:	ed97 7a1f 	vldr	s14, [r7, #124]	; 0x7c
 80119b2:	edd7 7a20 	vldr	s15, [r7, #128]	; 0x80
 80119b6:	687a      	ldr	r2, [r7, #4]
 80119b8:	4619      	mov	r1, r3
 80119ba:	eeb0 0a46 	vmov.f32	s0, s12
 80119be:	eef0 0a66 	vmov.f32	s1, s13
 80119c2:	eeb0 1a47 	vmov.f32	s2, s14
 80119c6:	eef0 1a67 	vmov.f32	s3, s15
 80119ca:	69f8      	ldr	r0, [r7, #28]
 80119cc:	f7ff fcc0 	bl	8011350 <nk_draw_image>
        &img, col);

    /* center-right */
    IMG_RGN(rgnX + rgnW - slc->r, rgnY + slc->t, slc->r, rgnH - slc->t - slc->b);
 80119d0:	f8b7 20ca 	ldrh.w	r2, [r7, #202]	; 0xca
 80119d4:	f8b7 30c6 	ldrh.w	r3, [r7, #198]	; 0xc6
 80119d8:	4413      	add	r3, r2
 80119da:	b29a      	uxth	r2, r3
 80119dc:	68bb      	ldr	r3, [r7, #8]
 80119de:	8a9b      	ldrh	r3, [r3, #20]
 80119e0:	1ad3      	subs	r3, r2, r3
 80119e2:	b29b      	uxth	r3, r3
 80119e4:	85bb      	strh	r3, [r7, #44]	; 0x2c
 80119e6:	68bb      	ldr	r3, [r7, #8]
 80119e8:	8a5a      	ldrh	r2, [r3, #18]
 80119ea:	f8b7 30c8 	ldrh.w	r3, [r7, #200]	; 0xc8
 80119ee:	4413      	add	r3, r2
 80119f0:	b29b      	uxth	r3, r3
 80119f2:	85fb      	strh	r3, [r7, #46]	; 0x2e
 80119f4:	68bb      	ldr	r3, [r7, #8]
 80119f6:	8a9b      	ldrh	r3, [r3, #20]
 80119f8:	863b      	strh	r3, [r7, #48]	; 0x30
 80119fa:	68bb      	ldr	r3, [r7, #8]
 80119fc:	8a5b      	ldrh	r3, [r3, #18]
 80119fe:	f8b7 20c4 	ldrh.w	r2, [r7, #196]	; 0xc4
 8011a02:	1ad3      	subs	r3, r2, r3
 8011a04:	b29a      	uxth	r2, r3
 8011a06:	68bb      	ldr	r3, [r7, #8]
 8011a08:	8adb      	ldrh	r3, [r3, #22]
 8011a0a:	1ad3      	subs	r3, r2, r3
 8011a0c:	b29b      	uxth	r3, r3
 8011a0e:	867b      	strh	r3, [r7, #50]	; 0x32
    nk_draw_image(b,
        nk_rect(r.x + r.w - (float)slc->r, r.y + (float)slc->t, (float)slc->r, (float)(r.h - slc->t - slc->b)),
 8011a10:	ed97 7a03 	vldr	s14, [r7, #12]
 8011a14:	edd7 7a05 	vldr	s15, [r7, #20]
 8011a18:	ee37 7a27 	vadd.f32	s14, s14, s15
 8011a1c:	68bb      	ldr	r3, [r7, #8]
 8011a1e:	8a9b      	ldrh	r3, [r3, #20]
 8011a20:	ee07 3a90 	vmov	s15, r3
 8011a24:	eef8 7a67 	vcvt.f32.u32	s15, s15
    nk_draw_image(b,
 8011a28:	ee77 6a67 	vsub.f32	s13, s14, s15
        nk_rect(r.x + r.w - (float)slc->r, r.y + (float)slc->t, (float)slc->r, (float)(r.h - slc->t - slc->b)),
 8011a2c:	ed97 7a04 	vldr	s14, [r7, #16]
 8011a30:	68bb      	ldr	r3, [r7, #8]
 8011a32:	8a5b      	ldrh	r3, [r3, #18]
 8011a34:	ee07 3a90 	vmov	s15, r3
 8011a38:	eef8 7a67 	vcvt.f32.u32	s15, s15
    nk_draw_image(b,
 8011a3c:	ee37 6a27 	vadd.f32	s12, s14, s15
        nk_rect(r.x + r.w - (float)slc->r, r.y + (float)slc->t, (float)slc->r, (float)(r.h - slc->t - slc->b)),
 8011a40:	68bb      	ldr	r3, [r7, #8]
 8011a42:	8a9b      	ldrh	r3, [r3, #20]
    nk_draw_image(b,
 8011a44:	ee07 3a90 	vmov	s15, r3
 8011a48:	eef8 5a67 	vcvt.f32.u32	s11, s15
        nk_rect(r.x + r.w - (float)slc->r, r.y + (float)slc->t, (float)slc->r, (float)(r.h - slc->t - slc->b)),
 8011a4c:	ed97 7a06 	vldr	s14, [r7, #24]
 8011a50:	68bb      	ldr	r3, [r7, #8]
 8011a52:	8a5b      	ldrh	r3, [r3, #18]
 8011a54:	ee07 3a90 	vmov	s15, r3
 8011a58:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8011a5c:	ee37 7a67 	vsub.f32	s14, s14, s15
 8011a60:	68bb      	ldr	r3, [r7, #8]
 8011a62:	8adb      	ldrh	r3, [r3, #22]
 8011a64:	ee07 3a90 	vmov	s15, r3
    nk_draw_image(b,
 8011a68:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8011a6c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8011a70:	eef0 1a67 	vmov.f32	s3, s15
 8011a74:	eeb0 1a65 	vmov.f32	s2, s11
 8011a78:	eef0 0a46 	vmov.f32	s1, s12
 8011a7c:	eeb0 0a66 	vmov.f32	s0, s13
 8011a80:	f001 fe68 	bl	8013754 <nk_rect>
 8011a84:	eeb0 6a40 	vmov.f32	s12, s0
 8011a88:	eef0 6a60 	vmov.f32	s13, s1
 8011a8c:	eeb0 7a41 	vmov.f32	s14, s2
 8011a90:	eef0 7a61 	vmov.f32	s15, s3
 8011a94:	ed87 6a21 	vstr	s12, [r7, #132]	; 0x84
 8011a98:	edc7 6a22 	vstr	s13, [r7, #136]	; 0x88
 8011a9c:	ed87 7a23 	vstr	s14, [r7, #140]	; 0x8c
 8011aa0:	edc7 7a24 	vstr	s15, [r7, #144]	; 0x90
 8011aa4:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8011aa8:	ed97 6a21 	vldr	s12, [r7, #132]	; 0x84
 8011aac:	edd7 6a22 	vldr	s13, [r7, #136]	; 0x88
 8011ab0:	ed97 7a23 	vldr	s14, [r7, #140]	; 0x8c
 8011ab4:	edd7 7a24 	vldr	s15, [r7, #144]	; 0x90
 8011ab8:	687a      	ldr	r2, [r7, #4]
 8011aba:	4619      	mov	r1, r3
 8011abc:	eeb0 0a46 	vmov.f32	s0, s12
 8011ac0:	eef0 0a66 	vmov.f32	s1, s13
 8011ac4:	eeb0 1a47 	vmov.f32	s2, s14
 8011ac8:	eef0 1a67 	vmov.f32	s3, s15
 8011acc:	69f8      	ldr	r0, [r7, #28]
 8011ace:	f7ff fc3f 	bl	8011350 <nk_draw_image>
        &img, col);

    /* bottom-left */
    IMG_RGN(rgnX, rgnY + rgnH - slc->b, slc->l, slc->b);
 8011ad2:	f8b7 30ca 	ldrh.w	r3, [r7, #202]	; 0xca
 8011ad6:	85bb      	strh	r3, [r7, #44]	; 0x2c
 8011ad8:	f8b7 20c8 	ldrh.w	r2, [r7, #200]	; 0xc8
 8011adc:	f8b7 30c4 	ldrh.w	r3, [r7, #196]	; 0xc4
 8011ae0:	4413      	add	r3, r2
 8011ae2:	b29a      	uxth	r2, r3
 8011ae4:	68bb      	ldr	r3, [r7, #8]
 8011ae6:	8adb      	ldrh	r3, [r3, #22]
 8011ae8:	1ad3      	subs	r3, r2, r3
 8011aea:	b29b      	uxth	r3, r3
 8011aec:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8011aee:	68bb      	ldr	r3, [r7, #8]
 8011af0:	8a1b      	ldrh	r3, [r3, #16]
 8011af2:	863b      	strh	r3, [r7, #48]	; 0x30
 8011af4:	68bb      	ldr	r3, [r7, #8]
 8011af6:	8adb      	ldrh	r3, [r3, #22]
 8011af8:	867b      	strh	r3, [r7, #50]	; 0x32
    nk_draw_image(b,
 8011afa:	edd7 6a03 	vldr	s13, [r7, #12]
        nk_rect(r.x, r.y + r.h - (float)slc->b, (float)slc->l, (float)slc->b),
 8011afe:	ed97 7a04 	vldr	s14, [r7, #16]
 8011b02:	edd7 7a06 	vldr	s15, [r7, #24]
 8011b06:	ee37 7a27 	vadd.f32	s14, s14, s15
 8011b0a:	68bb      	ldr	r3, [r7, #8]
 8011b0c:	8adb      	ldrh	r3, [r3, #22]
 8011b0e:	ee07 3a90 	vmov	s15, r3
 8011b12:	eef8 7a67 	vcvt.f32.u32	s15, s15
    nk_draw_image(b,
 8011b16:	ee77 7a67 	vsub.f32	s15, s14, s15
        nk_rect(r.x, r.y + r.h - (float)slc->b, (float)slc->l, (float)slc->b),
 8011b1a:	68bb      	ldr	r3, [r7, #8]
 8011b1c:	8a1b      	ldrh	r3, [r3, #16]
    nk_draw_image(b,
 8011b1e:	ee07 3a10 	vmov	s14, r3
 8011b22:	eeb8 7a47 	vcvt.f32.u32	s14, s14
        nk_rect(r.x, r.y + r.h - (float)slc->b, (float)slc->l, (float)slc->b),
 8011b26:	68bb      	ldr	r3, [r7, #8]
 8011b28:	8adb      	ldrh	r3, [r3, #22]
    nk_draw_image(b,
 8011b2a:	ee06 3a10 	vmov	s12, r3
 8011b2e:	eeb8 6a46 	vcvt.f32.u32	s12, s12
 8011b32:	eef0 1a46 	vmov.f32	s3, s12
 8011b36:	eeb0 1a47 	vmov.f32	s2, s14
 8011b3a:	eef0 0a67 	vmov.f32	s1, s15
 8011b3e:	eeb0 0a66 	vmov.f32	s0, s13
 8011b42:	f001 fe07 	bl	8013754 <nk_rect>
 8011b46:	eeb0 6a40 	vmov.f32	s12, s0
 8011b4a:	eef0 6a60 	vmov.f32	s13, s1
 8011b4e:	eeb0 7a41 	vmov.f32	s14, s2
 8011b52:	eef0 7a61 	vmov.f32	s15, s3
 8011b56:	ed87 6a25 	vstr	s12, [r7, #148]	; 0x94
 8011b5a:	edc7 6a26 	vstr	s13, [r7, #152]	; 0x98
 8011b5e:	ed87 7a27 	vstr	s14, [r7, #156]	; 0x9c
 8011b62:	edc7 7a28 	vstr	s15, [r7, #160]	; 0xa0
 8011b66:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8011b6a:	ed97 6a25 	vldr	s12, [r7, #148]	; 0x94
 8011b6e:	edd7 6a26 	vldr	s13, [r7, #152]	; 0x98
 8011b72:	ed97 7a27 	vldr	s14, [r7, #156]	; 0x9c
 8011b76:	edd7 7a28 	vldr	s15, [r7, #160]	; 0xa0
 8011b7a:	687a      	ldr	r2, [r7, #4]
 8011b7c:	4619      	mov	r1, r3
 8011b7e:	eeb0 0a46 	vmov.f32	s0, s12
 8011b82:	eef0 0a66 	vmov.f32	s1, s13
 8011b86:	eeb0 1a47 	vmov.f32	s2, s14
 8011b8a:	eef0 1a67 	vmov.f32	s3, s15
 8011b8e:	69f8      	ldr	r0, [r7, #28]
 8011b90:	f7ff fbde 	bl	8011350 <nk_draw_image>
        &img, col);

    /* bottom-center */
    IMG_RGN(rgnX + slc->l, rgnY + rgnH - slc->b, rgnW - slc->l - slc->r, slc->b);
 8011b94:	68bb      	ldr	r3, [r7, #8]
 8011b96:	8a1a      	ldrh	r2, [r3, #16]
 8011b98:	f8b7 30ca 	ldrh.w	r3, [r7, #202]	; 0xca
 8011b9c:	4413      	add	r3, r2
 8011b9e:	b29b      	uxth	r3, r3
 8011ba0:	85bb      	strh	r3, [r7, #44]	; 0x2c
 8011ba2:	f8b7 20c8 	ldrh.w	r2, [r7, #200]	; 0xc8
 8011ba6:	f8b7 30c4 	ldrh.w	r3, [r7, #196]	; 0xc4
 8011baa:	4413      	add	r3, r2
 8011bac:	b29a      	uxth	r2, r3
 8011bae:	68bb      	ldr	r3, [r7, #8]
 8011bb0:	8adb      	ldrh	r3, [r3, #22]
 8011bb2:	1ad3      	subs	r3, r2, r3
 8011bb4:	b29b      	uxth	r3, r3
 8011bb6:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8011bb8:	68bb      	ldr	r3, [r7, #8]
 8011bba:	8a1b      	ldrh	r3, [r3, #16]
 8011bbc:	f8b7 20c6 	ldrh.w	r2, [r7, #198]	; 0xc6
 8011bc0:	1ad3      	subs	r3, r2, r3
 8011bc2:	b29a      	uxth	r2, r3
 8011bc4:	68bb      	ldr	r3, [r7, #8]
 8011bc6:	8a9b      	ldrh	r3, [r3, #20]
 8011bc8:	1ad3      	subs	r3, r2, r3
 8011bca:	b29b      	uxth	r3, r3
 8011bcc:	863b      	strh	r3, [r7, #48]	; 0x30
 8011bce:	68bb      	ldr	r3, [r7, #8]
 8011bd0:	8adb      	ldrh	r3, [r3, #22]
 8011bd2:	867b      	strh	r3, [r7, #50]	; 0x32
    nk_draw_image(b,
        nk_rect(r.x + (float)slc->l, r.y + r.h - (float)slc->b, (float)(r.w - slc->l - slc->r), (float)slc->b),
 8011bd4:	ed97 7a03 	vldr	s14, [r7, #12]
 8011bd8:	68bb      	ldr	r3, [r7, #8]
 8011bda:	8a1b      	ldrh	r3, [r3, #16]
 8011bdc:	ee07 3a90 	vmov	s15, r3
 8011be0:	eef8 7a67 	vcvt.f32.u32	s15, s15
    nk_draw_image(b,
 8011be4:	ee77 6a27 	vadd.f32	s13, s14, s15
        nk_rect(r.x + (float)slc->l, r.y + r.h - (float)slc->b, (float)(r.w - slc->l - slc->r), (float)slc->b),
 8011be8:	ed97 7a04 	vldr	s14, [r7, #16]
 8011bec:	edd7 7a06 	vldr	s15, [r7, #24]
 8011bf0:	ee37 7a27 	vadd.f32	s14, s14, s15
 8011bf4:	68bb      	ldr	r3, [r7, #8]
 8011bf6:	8adb      	ldrh	r3, [r3, #22]
 8011bf8:	ee07 3a90 	vmov	s15, r3
 8011bfc:	eef8 7a67 	vcvt.f32.u32	s15, s15
    nk_draw_image(b,
 8011c00:	ee37 6a67 	vsub.f32	s12, s14, s15
        nk_rect(r.x + (float)slc->l, r.y + r.h - (float)slc->b, (float)(r.w - slc->l - slc->r), (float)slc->b),
 8011c04:	ed97 7a05 	vldr	s14, [r7, #20]
 8011c08:	68bb      	ldr	r3, [r7, #8]
 8011c0a:	8a1b      	ldrh	r3, [r3, #16]
 8011c0c:	ee07 3a90 	vmov	s15, r3
 8011c10:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8011c14:	ee37 7a67 	vsub.f32	s14, s14, s15
 8011c18:	68bb      	ldr	r3, [r7, #8]
 8011c1a:	8a9b      	ldrh	r3, [r3, #20]
 8011c1c:	ee07 3a90 	vmov	s15, r3
    nk_draw_image(b,
 8011c20:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8011c24:	ee77 7a67 	vsub.f32	s15, s14, s15
        nk_rect(r.x + (float)slc->l, r.y + r.h - (float)slc->b, (float)(r.w - slc->l - slc->r), (float)slc->b),
 8011c28:	68bb      	ldr	r3, [r7, #8]
 8011c2a:	8adb      	ldrh	r3, [r3, #22]
    nk_draw_image(b,
 8011c2c:	ee07 3a10 	vmov	s14, r3
 8011c30:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 8011c34:	eef0 1a47 	vmov.f32	s3, s14
 8011c38:	eeb0 1a67 	vmov.f32	s2, s15
 8011c3c:	eef0 0a46 	vmov.f32	s1, s12
 8011c40:	eeb0 0a66 	vmov.f32	s0, s13
 8011c44:	f001 fd86 	bl	8013754 <nk_rect>
 8011c48:	eeb0 6a40 	vmov.f32	s12, s0
 8011c4c:	eef0 6a60 	vmov.f32	s13, s1
 8011c50:	eeb0 7a41 	vmov.f32	s14, s2
 8011c54:	eef0 7a61 	vmov.f32	s15, s3
 8011c58:	ed87 6a29 	vstr	s12, [r7, #164]	; 0xa4
 8011c5c:	edc7 6a2a 	vstr	s13, [r7, #168]	; 0xa8
 8011c60:	ed87 7a2b 	vstr	s14, [r7, #172]	; 0xac
 8011c64:	edc7 7a2c 	vstr	s15, [r7, #176]	; 0xb0
 8011c68:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8011c6c:	ed97 6a29 	vldr	s12, [r7, #164]	; 0xa4
 8011c70:	edd7 6a2a 	vldr	s13, [r7, #168]	; 0xa8
 8011c74:	ed97 7a2b 	vldr	s14, [r7, #172]	; 0xac
 8011c78:	edd7 7a2c 	vldr	s15, [r7, #176]	; 0xb0
 8011c7c:	687a      	ldr	r2, [r7, #4]
 8011c7e:	4619      	mov	r1, r3
 8011c80:	eeb0 0a46 	vmov.f32	s0, s12
 8011c84:	eef0 0a66 	vmov.f32	s1, s13
 8011c88:	eeb0 1a47 	vmov.f32	s2, s14
 8011c8c:	eef0 1a67 	vmov.f32	s3, s15
 8011c90:	69f8      	ldr	r0, [r7, #28]
 8011c92:	f7ff fb5d 	bl	8011350 <nk_draw_image>
        &img, col);

    /* bottom-right */
    IMG_RGN(rgnX + rgnW - slc->r, rgnY + rgnH - slc->b, slc->r, slc->b);
 8011c96:	f8b7 20ca 	ldrh.w	r2, [r7, #202]	; 0xca
 8011c9a:	f8b7 30c6 	ldrh.w	r3, [r7, #198]	; 0xc6
 8011c9e:	4413      	add	r3, r2
 8011ca0:	b29a      	uxth	r2, r3
 8011ca2:	68bb      	ldr	r3, [r7, #8]
 8011ca4:	8a9b      	ldrh	r3, [r3, #20]
 8011ca6:	1ad3      	subs	r3, r2, r3
 8011ca8:	b29b      	uxth	r3, r3
 8011caa:	85bb      	strh	r3, [r7, #44]	; 0x2c
 8011cac:	f8b7 20c8 	ldrh.w	r2, [r7, #200]	; 0xc8
 8011cb0:	f8b7 30c4 	ldrh.w	r3, [r7, #196]	; 0xc4
 8011cb4:	4413      	add	r3, r2
 8011cb6:	b29a      	uxth	r2, r3
 8011cb8:	68bb      	ldr	r3, [r7, #8]
 8011cba:	8adb      	ldrh	r3, [r3, #22]
 8011cbc:	1ad3      	subs	r3, r2, r3
 8011cbe:	b29b      	uxth	r3, r3
 8011cc0:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8011cc2:	68bb      	ldr	r3, [r7, #8]
 8011cc4:	8a9b      	ldrh	r3, [r3, #20]
 8011cc6:	863b      	strh	r3, [r7, #48]	; 0x30
 8011cc8:	68bb      	ldr	r3, [r7, #8]
 8011cca:	8adb      	ldrh	r3, [r3, #22]
 8011ccc:	867b      	strh	r3, [r7, #50]	; 0x32
    nk_draw_image(b,
        nk_rect(r.x + r.w - (float)slc->r, r.y + r.h - (float)slc->b, (float)slc->r, (float)slc->b),
 8011cce:	ed97 7a03 	vldr	s14, [r7, #12]
 8011cd2:	edd7 7a05 	vldr	s15, [r7, #20]
 8011cd6:	ee37 7a27 	vadd.f32	s14, s14, s15
 8011cda:	68bb      	ldr	r3, [r7, #8]
 8011cdc:	8a9b      	ldrh	r3, [r3, #20]
 8011cde:	ee07 3a90 	vmov	s15, r3
 8011ce2:	eef8 7a67 	vcvt.f32.u32	s15, s15
    nk_draw_image(b,
 8011ce6:	ee77 6a67 	vsub.f32	s13, s14, s15
        nk_rect(r.x + r.w - (float)slc->r, r.y + r.h - (float)slc->b, (float)slc->r, (float)slc->b),
 8011cea:	ed97 7a04 	vldr	s14, [r7, #16]
 8011cee:	edd7 7a06 	vldr	s15, [r7, #24]
 8011cf2:	ee37 7a27 	vadd.f32	s14, s14, s15
 8011cf6:	68bb      	ldr	r3, [r7, #8]
 8011cf8:	8adb      	ldrh	r3, [r3, #22]
 8011cfa:	ee07 3a90 	vmov	s15, r3
 8011cfe:	eef8 7a67 	vcvt.f32.u32	s15, s15
    nk_draw_image(b,
 8011d02:	ee77 7a67 	vsub.f32	s15, s14, s15
        nk_rect(r.x + r.w - (float)slc->r, r.y + r.h - (float)slc->b, (float)slc->r, (float)slc->b),
 8011d06:	68bb      	ldr	r3, [r7, #8]
 8011d08:	8a9b      	ldrh	r3, [r3, #20]
    nk_draw_image(b,
 8011d0a:	ee07 3a10 	vmov	s14, r3
 8011d0e:	eeb8 7a47 	vcvt.f32.u32	s14, s14
        nk_rect(r.x + r.w - (float)slc->r, r.y + r.h - (float)slc->b, (float)slc->r, (float)slc->b),
 8011d12:	68bb      	ldr	r3, [r7, #8]
 8011d14:	8adb      	ldrh	r3, [r3, #22]
    nk_draw_image(b,
 8011d16:	ee06 3a10 	vmov	s12, r3
 8011d1a:	eeb8 6a46 	vcvt.f32.u32	s12, s12
 8011d1e:	eef0 1a46 	vmov.f32	s3, s12
 8011d22:	eeb0 1a47 	vmov.f32	s2, s14
 8011d26:	eef0 0a67 	vmov.f32	s1, s15
 8011d2a:	eeb0 0a66 	vmov.f32	s0, s13
 8011d2e:	f001 fd11 	bl	8013754 <nk_rect>
 8011d32:	eeb0 6a40 	vmov.f32	s12, s0
 8011d36:	eef0 6a60 	vmov.f32	s13, s1
 8011d3a:	eeb0 7a41 	vmov.f32	s14, s2
 8011d3e:	eef0 7a61 	vmov.f32	s15, s3
 8011d42:	ed87 6a2d 	vstr	s12, [r7, #180]	; 0xb4
 8011d46:	edc7 6a2e 	vstr	s13, [r7, #184]	; 0xb8
 8011d4a:	ed87 7a2f 	vstr	s14, [r7, #188]	; 0xbc
 8011d4e:	edc7 7a30 	vstr	s15, [r7, #192]	; 0xc0
 8011d52:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8011d56:	ed97 6a2d 	vldr	s12, [r7, #180]	; 0xb4
 8011d5a:	edd7 6a2e 	vldr	s13, [r7, #184]	; 0xb8
 8011d5e:	ed97 7a2f 	vldr	s14, [r7, #188]	; 0xbc
 8011d62:	edd7 7a30 	vldr	s15, [r7, #192]	; 0xc0
 8011d66:	687a      	ldr	r2, [r7, #4]
 8011d68:	4619      	mov	r1, r3
 8011d6a:	eeb0 0a46 	vmov.f32	s0, s12
 8011d6e:	eef0 0a66 	vmov.f32	s1, s13
 8011d72:	eeb0 1a47 	vmov.f32	s2, s14
 8011d76:	eef0 1a67 	vmov.f32	s3, s15
 8011d7a:	69f8      	ldr	r0, [r7, #28]
 8011d7c:	f7ff fae8 	bl	8011350 <nk_draw_image>
        &img, col);

#undef IMG_RGN
}
 8011d80:	bf00      	nop
 8011d82:	37d0      	adds	r7, #208	; 0xd0
 8011d84:	46bd      	mov	sp, r7
 8011d86:	bd80      	pop	{r7, pc}

08011d88 <nk_draw_text>:
}
NK_API void
nk_draw_text(struct nk_command_buffer *b, struct nk_rect r,
    const char *string, int length, const struct nk_user_font *font,
    struct nk_color bg, struct nk_color fg)
{
 8011d88:	b580      	push	{r7, lr}
 8011d8a:	b092      	sub	sp, #72	; 0x48
 8011d8c:	af04      	add	r7, sp, #16
 8011d8e:	61f8      	str	r0, [r7, #28]
 8011d90:	eeb0 6a40 	vmov.f32	s12, s0
 8011d94:	eef0 6a60 	vmov.f32	s13, s1
 8011d98:	eeb0 7a41 	vmov.f32	s14, s2
 8011d9c:	eef0 7a61 	vmov.f32	s15, s3
 8011da0:	60b9      	str	r1, [r7, #8]
 8011da2:	607a      	str	r2, [r7, #4]
 8011da4:	603b      	str	r3, [r7, #0]
 8011da6:	ed87 6a03 	vstr	s12, [r7, #12]
 8011daa:	edc7 6a04 	vstr	s13, [r7, #16]
 8011dae:	ed87 7a05 	vstr	s14, [r7, #20]
 8011db2:	edc7 7a06 	vstr	s15, [r7, #24]
    float text_width = 0;
 8011db6:	f04f 0300 	mov.w	r3, #0
 8011dba:	637b      	str	r3, [r7, #52]	; 0x34
    struct nk_command_text *cmd;

    NK_ASSERT(b);
 8011dbc:	69fb      	ldr	r3, [r7, #28]
 8011dbe:	2b00      	cmp	r3, #0
 8011dc0:	d106      	bne.n	8011dd0 <nk_draw_text+0x48>
 8011dc2:	4b93      	ldr	r3, [pc, #588]	; (8012010 <nk_draw_text+0x288>)
 8011dc4:	4a93      	ldr	r2, [pc, #588]	; (8012014 <nk_draw_text+0x28c>)
 8011dc6:	f240 210d 	movw	r1, #525	; 0x20d
 8011dca:	4893      	ldr	r0, [pc, #588]	; (8012018 <nk_draw_text+0x290>)
 8011dcc:	f00b fe24 	bl	801da18 <__assert_func>
    NK_ASSERT(font);
 8011dd0:	683b      	ldr	r3, [r7, #0]
 8011dd2:	2b00      	cmp	r3, #0
 8011dd4:	d106      	bne.n	8011de4 <nk_draw_text+0x5c>
 8011dd6:	4b91      	ldr	r3, [pc, #580]	; (801201c <nk_draw_text+0x294>)
 8011dd8:	4a8e      	ldr	r2, [pc, #568]	; (8012014 <nk_draw_text+0x28c>)
 8011dda:	f240 210e 	movw	r1, #526	; 0x20e
 8011dde:	488e      	ldr	r0, [pc, #568]	; (8012018 <nk_draw_text+0x290>)
 8011de0:	f00b fe1a 	bl	801da18 <__assert_func>
    if (!b || !string || !length || (bg.a == 0 && fg.a == 0)) return;
 8011de4:	69fb      	ldr	r3, [r7, #28]
 8011de6:	2b00      	cmp	r3, #0
 8011de8:	f000 8107 	beq.w	8011ffa <nk_draw_text+0x272>
 8011dec:	68bb      	ldr	r3, [r7, #8]
 8011dee:	2b00      	cmp	r3, #0
 8011df0:	f000 8103 	beq.w	8011ffa <nk_draw_text+0x272>
 8011df4:	687b      	ldr	r3, [r7, #4]
 8011df6:	2b00      	cmp	r3, #0
 8011df8:	f000 80ff 	beq.w	8011ffa <nk_draw_text+0x272>
 8011dfc:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 8011e00:	2b00      	cmp	r3, #0
 8011e02:	d104      	bne.n	8011e0e <nk_draw_text+0x86>
 8011e04:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8011e08:	2b00      	cmp	r3, #0
 8011e0a:	f000 80f6 	beq.w	8011ffa <nk_draw_text+0x272>
    if (b->use_clipping) {
 8011e0e:	69fb      	ldr	r3, [r7, #28]
 8011e10:	695b      	ldr	r3, [r3, #20]
 8011e12:	2b00      	cmp	r3, #0
 8011e14:	d072      	beq.n	8011efc <nk_draw_text+0x174>
        const struct nk_rect *c = &b->clip;
 8011e16:	69fb      	ldr	r3, [r7, #28]
 8011e18:	3304      	adds	r3, #4
 8011e1a:	633b      	str	r3, [r7, #48]	; 0x30
        if (c->w == 0 || c->h == 0 || !NK_INTERSECT(r.x, r.y, r.w, r.h, c->x, c->y, c->w, c->h))
 8011e1c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011e1e:	edd3 7a02 	vldr	s15, [r3, #8]
 8011e22:	eef5 7a40 	vcmp.f32	s15, #0.0
 8011e26:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011e2a:	f000 80e8 	beq.w	8011ffe <nk_draw_text+0x276>
 8011e2e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011e30:	edd3 7a03 	vldr	s15, [r3, #12]
 8011e34:	eef5 7a40 	vcmp.f32	s15, #0.0
 8011e38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011e3c:	f000 80df 	beq.w	8011ffe <nk_draw_text+0x276>
 8011e40:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011e42:	ed93 7a00 	vldr	s14, [r3]
 8011e46:	edd7 6a03 	vldr	s13, [r7, #12]
 8011e4a:	edd7 7a05 	vldr	s15, [r7, #20]
 8011e4e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8011e52:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8011e56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011e5a:	bf4c      	ite	mi
 8011e5c:	2301      	movmi	r3, #1
 8011e5e:	2300      	movpl	r3, #0
 8011e60:	b2db      	uxtb	r3, r3
 8011e62:	f083 0301 	eor.w	r3, r3, #1
 8011e66:	b2db      	uxtb	r3, r3
 8011e68:	2b00      	cmp	r3, #0
 8011e6a:	f040 80c8 	bne.w	8011ffe <nk_draw_text+0x276>
 8011e6e:	ed97 7a03 	vldr	s14, [r7, #12]
 8011e72:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011e74:	edd3 6a00 	vldr	s13, [r3]
 8011e78:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011e7a:	edd3 7a02 	vldr	s15, [r3, #8]
 8011e7e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8011e82:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8011e86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011e8a:	bf4c      	ite	mi
 8011e8c:	2301      	movmi	r3, #1
 8011e8e:	2300      	movpl	r3, #0
 8011e90:	b2db      	uxtb	r3, r3
 8011e92:	f083 0301 	eor.w	r3, r3, #1
 8011e96:	b2db      	uxtb	r3, r3
 8011e98:	2b00      	cmp	r3, #0
 8011e9a:	f040 80b0 	bne.w	8011ffe <nk_draw_text+0x276>
 8011e9e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011ea0:	ed93 7a01 	vldr	s14, [r3, #4]
 8011ea4:	edd7 6a04 	vldr	s13, [r7, #16]
 8011ea8:	edd7 7a06 	vldr	s15, [r7, #24]
 8011eac:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8011eb0:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8011eb4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011eb8:	bf4c      	ite	mi
 8011eba:	2301      	movmi	r3, #1
 8011ebc:	2300      	movpl	r3, #0
 8011ebe:	b2db      	uxtb	r3, r3
 8011ec0:	f083 0301 	eor.w	r3, r3, #1
 8011ec4:	b2db      	uxtb	r3, r3
 8011ec6:	2b00      	cmp	r3, #0
 8011ec8:	f040 8099 	bne.w	8011ffe <nk_draw_text+0x276>
 8011ecc:	ed97 7a04 	vldr	s14, [r7, #16]
 8011ed0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011ed2:	edd3 6a01 	vldr	s13, [r3, #4]
 8011ed6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011ed8:	edd3 7a03 	vldr	s15, [r3, #12]
 8011edc:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8011ee0:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8011ee4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011ee8:	bf4c      	ite	mi
 8011eea:	2301      	movmi	r3, #1
 8011eec:	2300      	movpl	r3, #0
 8011eee:	b2db      	uxtb	r3, r3
 8011ef0:	f083 0301 	eor.w	r3, r3, #1
 8011ef4:	b2db      	uxtb	r3, r3
 8011ef6:	2b00      	cmp	r3, #0
 8011ef8:	f040 8081 	bne.w	8011ffe <nk_draw_text+0x276>
            return;
    }

    /* make sure text fits inside bounds */
    text_width = font->width(font->userdata, font->height, string, length);
 8011efc:	683b      	ldr	r3, [r7, #0]
 8011efe:	689b      	ldr	r3, [r3, #8]
 8011f00:	683a      	ldr	r2, [r7, #0]
 8011f02:	edd2 7a01 	vldr	s15, [r2, #4]
 8011f06:	6838      	ldr	r0, [r7, #0]
 8011f08:	687a      	ldr	r2, [r7, #4]
 8011f0a:	68b9      	ldr	r1, [r7, #8]
 8011f0c:	eeb0 0a67 	vmov.f32	s0, s15
 8011f10:	6800      	ldr	r0, [r0, #0]
 8011f12:	4798      	blx	r3
 8011f14:	ed87 0a0d 	vstr	s0, [r7, #52]	; 0x34
    if (text_width > r.w){
 8011f18:	edd7 7a05 	vldr	s15, [r7, #20]
 8011f1c:	ed97 7a0d 	vldr	s14, [r7, #52]	; 0x34
 8011f20:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8011f24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011f28:	dd17      	ble.n	8011f5a <nk_draw_text+0x1d2>
        int glyphs = 0;
 8011f2a:	2300      	movs	r3, #0
 8011f2c:	62bb      	str	r3, [r7, #40]	; 0x28
        float txt_width = (float)text_width;
 8011f2e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011f30:	627b      	str	r3, [r7, #36]	; 0x24
        length = nk_text_clamp(font, string, length, r.w, &glyphs, &txt_width, 0,0);
 8011f32:	edd7 7a05 	vldr	s15, [r7, #20]
 8011f36:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8011f3a:	2300      	movs	r3, #0
 8011f3c:	9302      	str	r3, [sp, #8]
 8011f3e:	2300      	movs	r3, #0
 8011f40:	9301      	str	r3, [sp, #4]
 8011f42:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8011f46:	9300      	str	r3, [sp, #0]
 8011f48:	4613      	mov	r3, r2
 8011f4a:	eeb0 0a67 	vmov.f32	s0, s15
 8011f4e:	687a      	ldr	r2, [r7, #4]
 8011f50:	68b9      	ldr	r1, [r7, #8]
 8011f52:	6838      	ldr	r0, [r7, #0]
 8011f54:	f00a f9d4 	bl	801c300 <nk_text_clamp>
 8011f58:	6078      	str	r0, [r7, #4]
    }

    if (!length) return;
 8011f5a:	687b      	ldr	r3, [r7, #4]
 8011f5c:	2b00      	cmp	r3, #0
 8011f5e:	d050      	beq.n	8012002 <nk_draw_text+0x27a>
    cmd = (struct nk_command_text*)
        nk_command_buffer_push(b, NK_COMMAND_TEXT, sizeof(*cmd) + (nk_size)(length + 1));
 8011f60:	687b      	ldr	r3, [r7, #4]
 8011f62:	3329      	adds	r3, #41	; 0x29
 8011f64:	461a      	mov	r2, r3
 8011f66:	2110      	movs	r1, #16
 8011f68:	69f8      	ldr	r0, [r7, #28]
 8011f6a:	f7fe fcb1 	bl	80108d0 <nk_command_buffer_push>
 8011f6e:	62f8      	str	r0, [r7, #44]	; 0x2c
    if (!cmd) return;
 8011f70:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011f72:	2b00      	cmp	r3, #0
 8011f74:	d047      	beq.n	8012006 <nk_draw_text+0x27e>
    cmd->x = (short)r.x;
 8011f76:	edd7 7a03 	vldr	s15, [r7, #12]
 8011f7a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8011f7e:	ee17 3a90 	vmov	r3, s15
 8011f82:	b21a      	sxth	r2, r3
 8011f84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011f86:	829a      	strh	r2, [r3, #20]
    cmd->y = (short)r.y;
 8011f88:	edd7 7a04 	vldr	s15, [r7, #16]
 8011f8c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8011f90:	ee17 3a90 	vmov	r3, s15
 8011f94:	b21a      	sxth	r2, r3
 8011f96:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011f98:	82da      	strh	r2, [r3, #22]
    cmd->w = (unsigned short)r.w;
 8011f9a:	edd7 7a05 	vldr	s15, [r7, #20]
 8011f9e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8011fa2:	ee17 3a90 	vmov	r3, s15
 8011fa6:	b29a      	uxth	r2, r3
 8011fa8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011faa:	831a      	strh	r2, [r3, #24]
    cmd->h = (unsigned short)r.h;
 8011fac:	edd7 7a06 	vldr	s15, [r7, #24]
 8011fb0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8011fb4:	ee17 3a90 	vmov	r3, s15
 8011fb8:	b29a      	uxth	r2, r3
 8011fba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011fbc:	835a      	strh	r2, [r3, #26]
    cmd->background = bg;
 8011fbe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011fc0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011fc2:	60da      	str	r2, [r3, #12]
    cmd->foreground = fg;
 8011fc4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011fc6:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8011fc8:	611a      	str	r2, [r3, #16]
    cmd->font = font;
 8011fca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011fcc:	683a      	ldr	r2, [r7, #0]
 8011fce:	609a      	str	r2, [r3, #8]
    cmd->length = length;
 8011fd0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011fd2:	687a      	ldr	r2, [r7, #4]
 8011fd4:	621a      	str	r2, [r3, #32]
    cmd->height = font->height;
 8011fd6:	683b      	ldr	r3, [r7, #0]
 8011fd8:	685a      	ldr	r2, [r3, #4]
 8011fda:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011fdc:	61da      	str	r2, [r3, #28]
    NK_MEMCPY(cmd->string, string, (nk_size)length);
 8011fde:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011fe0:	3324      	adds	r3, #36	; 0x24
 8011fe2:	687a      	ldr	r2, [r7, #4]
 8011fe4:	68b9      	ldr	r1, [r7, #8]
 8011fe6:	4618      	mov	r0, r3
 8011fe8:	f009 fece 	bl	801bd88 <nk_memcopy>
    cmd->string[length] = '\0';
 8011fec:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011fee:	687b      	ldr	r3, [r7, #4]
 8011ff0:	4413      	add	r3, r2
 8011ff2:	3324      	adds	r3, #36	; 0x24
 8011ff4:	2200      	movs	r2, #0
 8011ff6:	701a      	strb	r2, [r3, #0]
 8011ff8:	e006      	b.n	8012008 <nk_draw_text+0x280>
    if (!b || !string || !length || (bg.a == 0 && fg.a == 0)) return;
 8011ffa:	bf00      	nop
 8011ffc:	e004      	b.n	8012008 <nk_draw_text+0x280>
            return;
 8011ffe:	bf00      	nop
 8012000:	e002      	b.n	8012008 <nk_draw_text+0x280>
    if (!length) return;
 8012002:	bf00      	nop
 8012004:	e000      	b.n	8012008 <nk_draw_text+0x280>
    if (!cmd) return;
 8012006:	bf00      	nop
}
 8012008:	3738      	adds	r7, #56	; 0x38
 801200a:	46bd      	mov	sp, r7
 801200c:	bd80      	pop	{r7, pc}
 801200e:	bf00      	nop
 8012010:	08021734 	.word	0x08021734
 8012014:	08023458 	.word	0x08023458
 8012018:	08021718 	.word	0x08021718
 801201c:	08021740 	.word	0x08021740

08012020 <nk_handle_ptr>:
 *                          IMAGE
 *
 * ===============================================================*/
NK_API nk_handle
nk_handle_ptr(void *ptr)
{
 8012020:	b480      	push	{r7}
 8012022:	b085      	sub	sp, #20
 8012024:	af00      	add	r7, sp, #0
 8012026:	6078      	str	r0, [r7, #4]
    nk_handle handle = {0};
 8012028:	2300      	movs	r3, #0
 801202a:	60fb      	str	r3, [r7, #12]
    handle.ptr = ptr;
 801202c:	687b      	ldr	r3, [r7, #4]
 801202e:	60fb      	str	r3, [r7, #12]
    return handle;
 8012030:	68fb      	ldr	r3, [r7, #12]
}
 8012032:	4618      	mov	r0, r3
 8012034:	3714      	adds	r7, #20
 8012036:	46bd      	mov	sp, r7
 8012038:	f85d 7b04 	ldr.w	r7, [sp], #4
 801203c:	4770      	bx	lr
	...

08012040 <nk_input_begin>:
 *                          INPUT
 *
 * ===============================================================*/
NK_API void
nk_input_begin(struct nk_context *ctx)
{
 8012040:	b590      	push	{r4, r7, lr}
 8012042:	b085      	sub	sp, #20
 8012044:	af00      	add	r7, sp, #0
 8012046:	6078      	str	r0, [r7, #4]
    int i;
    struct nk_input *in;
    NK_ASSERT(ctx);
 8012048:	687b      	ldr	r3, [r7, #4]
 801204a:	2b00      	cmp	r3, #0
 801204c:	d105      	bne.n	801205a <nk_input_begin+0x1a>
 801204e:	4b2c      	ldr	r3, [pc, #176]	; (8012100 <nk_input_begin+0xc0>)
 8012050:	4a2c      	ldr	r2, [pc, #176]	; (8012104 <nk_input_begin+0xc4>)
 8012052:	210e      	movs	r1, #14
 8012054:	482c      	ldr	r0, [pc, #176]	; (8012108 <nk_input_begin+0xc8>)
 8012056:	f00b fcdf 	bl	801da18 <__assert_func>
    if (!ctx) return;
 801205a:	687b      	ldr	r3, [r7, #4]
 801205c:	2b00      	cmp	r3, #0
 801205e:	d04b      	beq.n	80120f8 <nk_input_begin+0xb8>
    in = &ctx->input;
 8012060:	687b      	ldr	r3, [r7, #4]
 8012062:	60bb      	str	r3, [r7, #8]
    for (i = 0; i < NK_BUTTON_MAX; ++i)
 8012064:	2300      	movs	r3, #0
 8012066:	60fb      	str	r3, [r7, #12]
 8012068:	e00a      	b.n	8012080 <nk_input_begin+0x40>
        in->mouse.buttons[i].clicked = 0;
 801206a:	68ba      	ldr	r2, [r7, #8]
 801206c:	68fb      	ldr	r3, [r7, #12]
 801206e:	3310      	adds	r3, #16
 8012070:	011b      	lsls	r3, r3, #4
 8012072:	4413      	add	r3, r2
 8012074:	3308      	adds	r3, #8
 8012076:	2200      	movs	r2, #0
 8012078:	601a      	str	r2, [r3, #0]
    for (i = 0; i < NK_BUTTON_MAX; ++i)
 801207a:	68fb      	ldr	r3, [r7, #12]
 801207c:	3301      	adds	r3, #1
 801207e:	60fb      	str	r3, [r7, #12]
 8012080:	68fb      	ldr	r3, [r7, #12]
 8012082:	2b03      	cmp	r3, #3
 8012084:	ddf1      	ble.n	801206a <nk_input_begin+0x2a>

    in->keyboard.text_len = 0;
 8012086:	68bb      	ldr	r3, [r7, #8]
 8012088:	2200      	movs	r2, #0
 801208a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    in->mouse.scroll_delta = nk_vec2(0,0);
 801208e:	68bc      	ldr	r4, [r7, #8]
 8012090:	eddf 0a1e 	vldr	s1, [pc, #120]	; 801210c <nk_input_begin+0xcc>
 8012094:	ed9f 0a1d 	vldr	s0, [pc, #116]	; 801210c <nk_input_begin+0xcc>
 8012098:	f001 fc0e 	bl	80138b8 <nk_vec2>
 801209c:	eeb0 7a40 	vmov.f32	s14, s0
 80120a0:	eef0 7a60 	vmov.f32	s15, s1
 80120a4:	ed84 7a57 	vstr	s14, [r4, #348]	; 0x15c
 80120a8:	edc4 7a58 	vstr	s15, [r4, #352]	; 0x160
    in->mouse.prev.x = in->mouse.pos.x;
 80120ac:	68bb      	ldr	r3, [r7, #8]
 80120ae:	f8d3 2144 	ldr.w	r2, [r3, #324]	; 0x144
 80120b2:	68bb      	ldr	r3, [r7, #8]
 80120b4:	f8c3 214c 	str.w	r2, [r3, #332]	; 0x14c
    in->mouse.prev.y = in->mouse.pos.y;
 80120b8:	68bb      	ldr	r3, [r7, #8]
 80120ba:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
 80120be:	68bb      	ldr	r3, [r7, #8]
 80120c0:	f8c3 2150 	str.w	r2, [r3, #336]	; 0x150
    in->mouse.delta.x = 0;
 80120c4:	68bb      	ldr	r3, [r7, #8]
 80120c6:	f04f 0200 	mov.w	r2, #0
 80120ca:	f8c3 2154 	str.w	r2, [r3, #340]	; 0x154
    in->mouse.delta.y = 0;
 80120ce:	68bb      	ldr	r3, [r7, #8]
 80120d0:	f04f 0200 	mov.w	r2, #0
 80120d4:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
    for (i = 0; i < NK_KEY_MAX; i++)
 80120d8:	2300      	movs	r3, #0
 80120da:	60fb      	str	r3, [r7, #12]
 80120dc:	e008      	b.n	80120f0 <nk_input_begin+0xb0>
        in->keyboard.keys[i].clicked = 0;
 80120de:	68ba      	ldr	r2, [r7, #8]
 80120e0:	68fb      	ldr	r3, [r7, #12]
 80120e2:	00db      	lsls	r3, r3, #3
 80120e4:	4413      	add	r3, r2
 80120e6:	2200      	movs	r2, #0
 80120e8:	605a      	str	r2, [r3, #4]
    for (i = 0; i < NK_KEY_MAX; i++)
 80120ea:	68fb      	ldr	r3, [r7, #12]
 80120ec:	3301      	adds	r3, #1
 80120ee:	60fb      	str	r3, [r7, #12]
 80120f0:	68fb      	ldr	r3, [r7, #12]
 80120f2:	2b1d      	cmp	r3, #29
 80120f4:	ddf3      	ble.n	80120de <nk_input_begin+0x9e>
 80120f6:	e000      	b.n	80120fa <nk_input_begin+0xba>
    if (!ctx) return;
 80120f8:	bf00      	nop
}
 80120fa:	3714      	adds	r7, #20
 80120fc:	46bd      	mov	sp, r7
 80120fe:	bd90      	pop	{r4, r7, pc}
 8012100:	08021748 	.word	0x08021748
 8012104:	08023468 	.word	0x08023468
 8012108:	0802174c 	.word	0x0802174c
 801210c:	00000000 	.word	0x00000000

08012110 <nk_input_end>:
NK_API void
nk_input_end(struct nk_context *ctx)
{
 8012110:	b580      	push	{r7, lr}
 8012112:	b084      	sub	sp, #16
 8012114:	af00      	add	r7, sp, #0
 8012116:	6078      	str	r0, [r7, #4]
    struct nk_input *in;
    NK_ASSERT(ctx);
 8012118:	687b      	ldr	r3, [r7, #4]
 801211a:	2b00      	cmp	r3, #0
 801211c:	d105      	bne.n	801212a <nk_input_end+0x1a>
 801211e:	4b15      	ldr	r3, [pc, #84]	; (8012174 <nk_input_end+0x64>)
 8012120:	4a15      	ldr	r2, [pc, #84]	; (8012178 <nk_input_end+0x68>)
 8012122:	2121      	movs	r1, #33	; 0x21
 8012124:	4815      	ldr	r0, [pc, #84]	; (801217c <nk_input_end+0x6c>)
 8012126:	f00b fc77 	bl	801da18 <__assert_func>
    if (!ctx) return;
 801212a:	687b      	ldr	r3, [r7, #4]
 801212c:	2b00      	cmp	r3, #0
 801212e:	d01c      	beq.n	801216a <nk_input_end+0x5a>
    in = &ctx->input;
 8012130:	687b      	ldr	r3, [r7, #4]
 8012132:	60fb      	str	r3, [r7, #12]
    if (in->mouse.grab)
 8012134:	68fb      	ldr	r3, [r7, #12]
 8012136:	f893 3164 	ldrb.w	r3, [r3, #356]	; 0x164
 801213a:	2b00      	cmp	r3, #0
 801213c:	d003      	beq.n	8012146 <nk_input_end+0x36>
        in->mouse.grab = 0;
 801213e:	68fb      	ldr	r3, [r7, #12]
 8012140:	2200      	movs	r2, #0
 8012142:	f883 2164 	strb.w	r2, [r3, #356]	; 0x164
    if (in->mouse.ungrab) {
 8012146:	68fb      	ldr	r3, [r7, #12]
 8012148:	f893 3166 	ldrb.w	r3, [r3, #358]	; 0x166
 801214c:	2b00      	cmp	r3, #0
 801214e:	d00d      	beq.n	801216c <nk_input_end+0x5c>
        in->mouse.grabbed = 0;
 8012150:	68fb      	ldr	r3, [r7, #12]
 8012152:	2200      	movs	r2, #0
 8012154:	f883 2165 	strb.w	r2, [r3, #357]	; 0x165
        in->mouse.ungrab = 0;
 8012158:	68fb      	ldr	r3, [r7, #12]
 801215a:	2200      	movs	r2, #0
 801215c:	f883 2166 	strb.w	r2, [r3, #358]	; 0x166
        in->mouse.grab = 0;
 8012160:	68fb      	ldr	r3, [r7, #12]
 8012162:	2200      	movs	r2, #0
 8012164:	f883 2164 	strb.w	r2, [r3, #356]	; 0x164
 8012168:	e000      	b.n	801216c <nk_input_end+0x5c>
    if (!ctx) return;
 801216a:	bf00      	nop
    }
}
 801216c:	3710      	adds	r7, #16
 801216e:	46bd      	mov	sp, r7
 8012170:	bd80      	pop	{r7, pc}
 8012172:	bf00      	nop
 8012174:	08021748 	.word	0x08021748
 8012178:	08023478 	.word	0x08023478
 801217c:	0802174c 	.word	0x0802174c

08012180 <nk_input_motion>:
NK_API void
nk_input_motion(struct nk_context *ctx, int x, int y)
{
 8012180:	b580      	push	{r7, lr}
 8012182:	b086      	sub	sp, #24
 8012184:	af00      	add	r7, sp, #0
 8012186:	60f8      	str	r0, [r7, #12]
 8012188:	60b9      	str	r1, [r7, #8]
 801218a:	607a      	str	r2, [r7, #4]
    struct nk_input *in;
    NK_ASSERT(ctx);
 801218c:	68fb      	ldr	r3, [r7, #12]
 801218e:	2b00      	cmp	r3, #0
 8012190:	d105      	bne.n	801219e <nk_input_motion+0x1e>
 8012192:	4b1b      	ldr	r3, [pc, #108]	; (8012200 <nk_input_motion+0x80>)
 8012194:	4a1b      	ldr	r2, [pc, #108]	; (8012204 <nk_input_motion+0x84>)
 8012196:	2130      	movs	r1, #48	; 0x30
 8012198:	481b      	ldr	r0, [pc, #108]	; (8012208 <nk_input_motion+0x88>)
 801219a:	f00b fc3d 	bl	801da18 <__assert_func>
    if (!ctx) return;
 801219e:	68fb      	ldr	r3, [r7, #12]
 80121a0:	2b00      	cmp	r3, #0
 80121a2:	d028      	beq.n	80121f6 <nk_input_motion+0x76>
    in = &ctx->input;
 80121a4:	68fb      	ldr	r3, [r7, #12]
 80121a6:	617b      	str	r3, [r7, #20]
    in->mouse.pos.x = (float)x;
 80121a8:	68bb      	ldr	r3, [r7, #8]
 80121aa:	ee07 3a90 	vmov	s15, r3
 80121ae:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80121b2:	697b      	ldr	r3, [r7, #20]
 80121b4:	edc3 7a51 	vstr	s15, [r3, #324]	; 0x144
    in->mouse.pos.y = (float)y;
 80121b8:	687b      	ldr	r3, [r7, #4]
 80121ba:	ee07 3a90 	vmov	s15, r3
 80121be:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80121c2:	697b      	ldr	r3, [r7, #20]
 80121c4:	edc3 7a52 	vstr	s15, [r3, #328]	; 0x148
    in->mouse.delta.x = in->mouse.pos.x - in->mouse.prev.x;
 80121c8:	697b      	ldr	r3, [r7, #20]
 80121ca:	ed93 7a51 	vldr	s14, [r3, #324]	; 0x144
 80121ce:	697b      	ldr	r3, [r7, #20]
 80121d0:	edd3 7a53 	vldr	s15, [r3, #332]	; 0x14c
 80121d4:	ee77 7a67 	vsub.f32	s15, s14, s15
 80121d8:	697b      	ldr	r3, [r7, #20]
 80121da:	edc3 7a55 	vstr	s15, [r3, #340]	; 0x154
    in->mouse.delta.y = in->mouse.pos.y - in->mouse.prev.y;
 80121de:	697b      	ldr	r3, [r7, #20]
 80121e0:	ed93 7a52 	vldr	s14, [r3, #328]	; 0x148
 80121e4:	697b      	ldr	r3, [r7, #20]
 80121e6:	edd3 7a54 	vldr	s15, [r3, #336]	; 0x150
 80121ea:	ee77 7a67 	vsub.f32	s15, s14, s15
 80121ee:	697b      	ldr	r3, [r7, #20]
 80121f0:	edc3 7a56 	vstr	s15, [r3, #344]	; 0x158
 80121f4:	e000      	b.n	80121f8 <nk_input_motion+0x78>
    if (!ctx) return;
 80121f6:	bf00      	nop
}
 80121f8:	3718      	adds	r7, #24
 80121fa:	46bd      	mov	sp, r7
 80121fc:	bd80      	pop	{r7, pc}
 80121fe:	bf00      	nop
 8012200:	08021748 	.word	0x08021748
 8012204:	08023488 	.word	0x08023488
 8012208:	0802174c 	.word	0x0802174c

0801220c <nk_input_button>:
#endif
    in->keyboard.keys[key].down = down;
}
NK_API void
nk_input_button(struct nk_context *ctx, enum nk_buttons id, int x, int y, nk_bool down)
{
 801220c:	b580      	push	{r7, lr}
 801220e:	b086      	sub	sp, #24
 8012210:	af00      	add	r7, sp, #0
 8012212:	60f8      	str	r0, [r7, #12]
 8012214:	607a      	str	r2, [r7, #4]
 8012216:	603b      	str	r3, [r7, #0]
 8012218:	460b      	mov	r3, r1
 801221a:	72fb      	strb	r3, [r7, #11]
    struct nk_mouse_button *btn;
    struct nk_input *in;
    NK_ASSERT(ctx);
 801221c:	68fb      	ldr	r3, [r7, #12]
 801221e:	2b00      	cmp	r3, #0
 8012220:	d105      	bne.n	801222e <nk_input_button+0x22>
 8012222:	4b1d      	ldr	r3, [pc, #116]	; (8012298 <nk_input_button+0x8c>)
 8012224:	4a1d      	ldr	r2, [pc, #116]	; (801229c <nk_input_button+0x90>)
 8012226:	214c      	movs	r1, #76	; 0x4c
 8012228:	481d      	ldr	r0, [pc, #116]	; (80122a0 <nk_input_button+0x94>)
 801222a:	f00b fbf5 	bl	801da18 <__assert_func>
    if (!ctx) return;
 801222e:	68fb      	ldr	r3, [r7, #12]
 8012230:	2b00      	cmp	r3, #0
 8012232:	d02b      	beq.n	801228c <nk_input_button+0x80>
    in = &ctx->input;
 8012234:	68fb      	ldr	r3, [r7, #12]
 8012236:	617b      	str	r3, [r7, #20]
    if (in->mouse.buttons[id].down == down) return;
 8012238:	7afb      	ldrb	r3, [r7, #11]
 801223a:	697a      	ldr	r2, [r7, #20]
 801223c:	3310      	adds	r3, #16
 801223e:	011b      	lsls	r3, r3, #4
 8012240:	4413      	add	r3, r2
 8012242:	3304      	adds	r3, #4
 8012244:	681b      	ldr	r3, [r3, #0]
 8012246:	6a3a      	ldr	r2, [r7, #32]
 8012248:	429a      	cmp	r2, r3
 801224a:	d021      	beq.n	8012290 <nk_input_button+0x84>

    btn = &in->mouse.buttons[id];
 801224c:	7afb      	ldrb	r3, [r7, #11]
 801224e:	3310      	adds	r3, #16
 8012250:	011b      	lsls	r3, r3, #4
 8012252:	697a      	ldr	r2, [r7, #20]
 8012254:	4413      	add	r3, r2
 8012256:	3304      	adds	r3, #4
 8012258:	613b      	str	r3, [r7, #16]
    btn->clicked_pos.x = (float)x;
 801225a:	687b      	ldr	r3, [r7, #4]
 801225c:	ee07 3a90 	vmov	s15, r3
 8012260:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8012264:	693b      	ldr	r3, [r7, #16]
 8012266:	edc3 7a02 	vstr	s15, [r3, #8]
    btn->clicked_pos.y = (float)y;
 801226a:	683b      	ldr	r3, [r7, #0]
 801226c:	ee07 3a90 	vmov	s15, r3
 8012270:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8012274:	693b      	ldr	r3, [r7, #16]
 8012276:	edc3 7a03 	vstr	s15, [r3, #12]
    btn->down = down;
 801227a:	693b      	ldr	r3, [r7, #16]
 801227c:	6a3a      	ldr	r2, [r7, #32]
 801227e:	601a      	str	r2, [r3, #0]
    btn->clicked++;
 8012280:	693b      	ldr	r3, [r7, #16]
 8012282:	685b      	ldr	r3, [r3, #4]
 8012284:	1c5a      	adds	r2, r3, #1
 8012286:	693b      	ldr	r3, [r7, #16]
 8012288:	605a      	str	r2, [r3, #4]
 801228a:	e002      	b.n	8012292 <nk_input_button+0x86>
    if (!ctx) return;
 801228c:	bf00      	nop
 801228e:	e000      	b.n	8012292 <nk_input_button+0x86>
    if (in->mouse.buttons[id].down == down) return;
 8012290:	bf00      	nop
    {
        in->mouse.down_pos.x = btn->clicked_pos.x;
        in->mouse.down_pos.y = btn->clicked_pos.y;
    }
#endif
}
 8012292:	3718      	adds	r7, #24
 8012294:	46bd      	mov	sp, r7
 8012296:	bd80      	pop	{r7, pc}
 8012298:	08021748 	.word	0x08021748
 801229c:	08023498 	.word	0x08023498
 80122a0:	0802174c 	.word	0x0802174c

080122a4 <nk_input_has_mouse_click_in_rect>:
    return (btn->clicked && btn->down == nk_false) ? nk_true : nk_false;
}
NK_API nk_bool
nk_input_has_mouse_click_in_rect(const struct nk_input *i, enum nk_buttons id,
    struct nk_rect b)
{
 80122a4:	b480      	push	{r7}
 80122a6:	b089      	sub	sp, #36	; 0x24
 80122a8:	af00      	add	r7, sp, #0
 80122aa:	6178      	str	r0, [r7, #20]
 80122ac:	460b      	mov	r3, r1
 80122ae:	eeb0 6a40 	vmov.f32	s12, s0
 80122b2:	eef0 6a60 	vmov.f32	s13, s1
 80122b6:	eeb0 7a41 	vmov.f32	s14, s2
 80122ba:	eef0 7a61 	vmov.f32	s15, s3
 80122be:	74fb      	strb	r3, [r7, #19]
 80122c0:	ed87 6a00 	vstr	s12, [r7]
 80122c4:	edc7 6a01 	vstr	s13, [r7, #4]
 80122c8:	ed87 7a02 	vstr	s14, [r7, #8]
 80122cc:	edc7 7a03 	vstr	s15, [r7, #12]
    const struct nk_mouse_button *btn;
    if (!i) return nk_false;
 80122d0:	697b      	ldr	r3, [r7, #20]
 80122d2:	2b00      	cmp	r3, #0
 80122d4:	d101      	bne.n	80122da <nk_input_has_mouse_click_in_rect+0x36>
 80122d6:	2300      	movs	r3, #0
 80122d8:	e059      	b.n	801238e <nk_input_has_mouse_click_in_rect+0xea>
    btn = &i->mouse.buttons[id];
 80122da:	7cfb      	ldrb	r3, [r7, #19]
 80122dc:	3310      	adds	r3, #16
 80122de:	011b      	lsls	r3, r3, #4
 80122e0:	697a      	ldr	r2, [r7, #20]
 80122e2:	4413      	add	r3, r2
 80122e4:	3304      	adds	r3, #4
 80122e6:	61fb      	str	r3, [r7, #28]
    if (!NK_INBOX(btn->clicked_pos.x,btn->clicked_pos.y,b.x,b.y,b.w,b.h))
 80122e8:	ed97 7a00 	vldr	s14, [r7]
 80122ec:	69fb      	ldr	r3, [r7, #28]
 80122ee:	edd3 7a02 	vldr	s15, [r3, #8]
 80122f2:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80122f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80122fa:	bf94      	ite	ls
 80122fc:	2301      	movls	r3, #1
 80122fe:	2300      	movhi	r3, #0
 8012300:	b2db      	uxtb	r3, r3
 8012302:	f083 0301 	eor.w	r3, r3, #1
 8012306:	b2db      	uxtb	r3, r3
 8012308:	2b00      	cmp	r3, #0
 801230a:	d13d      	bne.n	8012388 <nk_input_has_mouse_click_in_rect+0xe4>
 801230c:	69fb      	ldr	r3, [r7, #28]
 801230e:	ed93 7a02 	vldr	s14, [r3, #8]
 8012312:	edd7 6a00 	vldr	s13, [r7]
 8012316:	edd7 7a02 	vldr	s15, [r7, #8]
 801231a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801231e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8012322:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012326:	bf4c      	ite	mi
 8012328:	2301      	movmi	r3, #1
 801232a:	2300      	movpl	r3, #0
 801232c:	b2db      	uxtb	r3, r3
 801232e:	f083 0301 	eor.w	r3, r3, #1
 8012332:	b2db      	uxtb	r3, r3
 8012334:	2b00      	cmp	r3, #0
 8012336:	d127      	bne.n	8012388 <nk_input_has_mouse_click_in_rect+0xe4>
 8012338:	ed97 7a01 	vldr	s14, [r7, #4]
 801233c:	69fb      	ldr	r3, [r7, #28]
 801233e:	edd3 7a03 	vldr	s15, [r3, #12]
 8012342:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8012346:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801234a:	bf94      	ite	ls
 801234c:	2301      	movls	r3, #1
 801234e:	2300      	movhi	r3, #0
 8012350:	b2db      	uxtb	r3, r3
 8012352:	f083 0301 	eor.w	r3, r3, #1
 8012356:	b2db      	uxtb	r3, r3
 8012358:	2b00      	cmp	r3, #0
 801235a:	d115      	bne.n	8012388 <nk_input_has_mouse_click_in_rect+0xe4>
 801235c:	69fb      	ldr	r3, [r7, #28]
 801235e:	ed93 7a03 	vldr	s14, [r3, #12]
 8012362:	edd7 6a01 	vldr	s13, [r7, #4]
 8012366:	edd7 7a03 	vldr	s15, [r7, #12]
 801236a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801236e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8012372:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012376:	bf4c      	ite	mi
 8012378:	2301      	movmi	r3, #1
 801237a:	2300      	movpl	r3, #0
 801237c:	b2db      	uxtb	r3, r3
 801237e:	f083 0301 	eor.w	r3, r3, #1
 8012382:	b2db      	uxtb	r3, r3
 8012384:	2b00      	cmp	r3, #0
 8012386:	d001      	beq.n	801238c <nk_input_has_mouse_click_in_rect+0xe8>
        return nk_false;
 8012388:	2300      	movs	r3, #0
 801238a:	e000      	b.n	801238e <nk_input_has_mouse_click_in_rect+0xea>
    return nk_true;
 801238c:	2301      	movs	r3, #1
}
 801238e:	4618      	mov	r0, r3
 8012390:	3724      	adds	r7, #36	; 0x24
 8012392:	46bd      	mov	sp, r7
 8012394:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012398:	4770      	bx	lr

0801239a <nk_input_has_mouse_click_in_button_rect>:
NK_API nk_bool
nk_input_has_mouse_click_in_button_rect(const struct nk_input *i, enum nk_buttons id,
    struct nk_rect b)
{
 801239a:	b480      	push	{r7}
 801239c:	b089      	sub	sp, #36	; 0x24
 801239e:	af00      	add	r7, sp, #0
 80123a0:	6178      	str	r0, [r7, #20]
 80123a2:	460b      	mov	r3, r1
 80123a4:	eeb0 6a40 	vmov.f32	s12, s0
 80123a8:	eef0 6a60 	vmov.f32	s13, s1
 80123ac:	eeb0 7a41 	vmov.f32	s14, s2
 80123b0:	eef0 7a61 	vmov.f32	s15, s3
 80123b4:	74fb      	strb	r3, [r7, #19]
 80123b6:	ed87 6a00 	vstr	s12, [r7]
 80123ba:	edc7 6a01 	vstr	s13, [r7, #4]
 80123be:	ed87 7a02 	vstr	s14, [r7, #8]
 80123c2:	edc7 7a03 	vstr	s15, [r7, #12]
    const struct nk_mouse_button *btn;
    if (!i) return nk_false;
 80123c6:	697b      	ldr	r3, [r7, #20]
 80123c8:	2b00      	cmp	r3, #0
 80123ca:	d101      	bne.n	80123d0 <nk_input_has_mouse_click_in_button_rect+0x36>
 80123cc:	2300      	movs	r3, #0
 80123ce:	e059      	b.n	8012484 <nk_input_has_mouse_click_in_button_rect+0xea>
    btn = &i->mouse.buttons[id];
 80123d0:	7cfb      	ldrb	r3, [r7, #19]
 80123d2:	3310      	adds	r3, #16
 80123d4:	011b      	lsls	r3, r3, #4
 80123d6:	697a      	ldr	r2, [r7, #20]
 80123d8:	4413      	add	r3, r2
 80123da:	3304      	adds	r3, #4
 80123dc:	61fb      	str	r3, [r7, #28]
#ifdef NK_BUTTON_TRIGGER_ON_RELEASE
    if (!NK_INBOX(btn->clicked_pos.x,btn->clicked_pos.y,b.x,b.y,b.w,b.h)
        || !NK_INBOX(i->mouse.down_pos.x,i->mouse.down_pos.y,b.x,b.y,b.w,b.h))
#else
    if (!NK_INBOX(btn->clicked_pos.x,btn->clicked_pos.y,b.x,b.y,b.w,b.h))
 80123de:	ed97 7a00 	vldr	s14, [r7]
 80123e2:	69fb      	ldr	r3, [r7, #28]
 80123e4:	edd3 7a02 	vldr	s15, [r3, #8]
 80123e8:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80123ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80123f0:	bf94      	ite	ls
 80123f2:	2301      	movls	r3, #1
 80123f4:	2300      	movhi	r3, #0
 80123f6:	b2db      	uxtb	r3, r3
 80123f8:	f083 0301 	eor.w	r3, r3, #1
 80123fc:	b2db      	uxtb	r3, r3
 80123fe:	2b00      	cmp	r3, #0
 8012400:	d13d      	bne.n	801247e <nk_input_has_mouse_click_in_button_rect+0xe4>
 8012402:	69fb      	ldr	r3, [r7, #28]
 8012404:	ed93 7a02 	vldr	s14, [r3, #8]
 8012408:	edd7 6a00 	vldr	s13, [r7]
 801240c:	edd7 7a02 	vldr	s15, [r7, #8]
 8012410:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8012414:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8012418:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801241c:	bf4c      	ite	mi
 801241e:	2301      	movmi	r3, #1
 8012420:	2300      	movpl	r3, #0
 8012422:	b2db      	uxtb	r3, r3
 8012424:	f083 0301 	eor.w	r3, r3, #1
 8012428:	b2db      	uxtb	r3, r3
 801242a:	2b00      	cmp	r3, #0
 801242c:	d127      	bne.n	801247e <nk_input_has_mouse_click_in_button_rect+0xe4>
 801242e:	ed97 7a01 	vldr	s14, [r7, #4]
 8012432:	69fb      	ldr	r3, [r7, #28]
 8012434:	edd3 7a03 	vldr	s15, [r3, #12]
 8012438:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801243c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012440:	bf94      	ite	ls
 8012442:	2301      	movls	r3, #1
 8012444:	2300      	movhi	r3, #0
 8012446:	b2db      	uxtb	r3, r3
 8012448:	f083 0301 	eor.w	r3, r3, #1
 801244c:	b2db      	uxtb	r3, r3
 801244e:	2b00      	cmp	r3, #0
 8012450:	d115      	bne.n	801247e <nk_input_has_mouse_click_in_button_rect+0xe4>
 8012452:	69fb      	ldr	r3, [r7, #28]
 8012454:	ed93 7a03 	vldr	s14, [r3, #12]
 8012458:	edd7 6a01 	vldr	s13, [r7, #4]
 801245c:	edd7 7a03 	vldr	s15, [r7, #12]
 8012460:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8012464:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8012468:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801246c:	bf4c      	ite	mi
 801246e:	2301      	movmi	r3, #1
 8012470:	2300      	movpl	r3, #0
 8012472:	b2db      	uxtb	r3, r3
 8012474:	f083 0301 	eor.w	r3, r3, #1
 8012478:	b2db      	uxtb	r3, r3
 801247a:	2b00      	cmp	r3, #0
 801247c:	d001      	beq.n	8012482 <nk_input_has_mouse_click_in_button_rect+0xe8>
#endif
        return nk_false;
 801247e:	2300      	movs	r3, #0
 8012480:	e000      	b.n	8012484 <nk_input_has_mouse_click_in_button_rect+0xea>
    return nk_true;
 8012482:	2301      	movs	r3, #1
}
 8012484:	4618      	mov	r0, r3
 8012486:	3724      	adds	r7, #36	; 0x24
 8012488:	46bd      	mov	sp, r7
 801248a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801248e:	4770      	bx	lr

08012490 <nk_input_has_mouse_click_down_in_rect>:
NK_API nk_bool
nk_input_has_mouse_click_down_in_rect(const struct nk_input *i, enum nk_buttons id,
    struct nk_rect b, nk_bool down)
{
 8012490:	b580      	push	{r7, lr}
 8012492:	b08a      	sub	sp, #40	; 0x28
 8012494:	af00      	add	r7, sp, #0
 8012496:	61f8      	str	r0, [r7, #28]
 8012498:	460b      	mov	r3, r1
 801249a:	eeb0 6a40 	vmov.f32	s12, s0
 801249e:	eef0 6a60 	vmov.f32	s13, s1
 80124a2:	eeb0 7a41 	vmov.f32	s14, s2
 80124a6:	eef0 7a61 	vmov.f32	s15, s3
 80124aa:	607a      	str	r2, [r7, #4]
 80124ac:	76fb      	strb	r3, [r7, #27]
 80124ae:	ed87 6a02 	vstr	s12, [r7, #8]
 80124b2:	edc7 6a03 	vstr	s13, [r7, #12]
 80124b6:	ed87 7a04 	vstr	s14, [r7, #16]
 80124ba:	edc7 7a05 	vstr	s15, [r7, #20]
    const struct nk_mouse_button *btn;
    if (!i) return nk_false;
 80124be:	69fb      	ldr	r3, [r7, #28]
 80124c0:	2b00      	cmp	r3, #0
 80124c2:	d101      	bne.n	80124c8 <nk_input_has_mouse_click_down_in_rect+0x38>
 80124c4:	2300      	movs	r3, #0
 80124c6:	e026      	b.n	8012516 <nk_input_has_mouse_click_down_in_rect+0x86>
    btn = &i->mouse.buttons[id];
 80124c8:	7efb      	ldrb	r3, [r7, #27]
 80124ca:	3310      	adds	r3, #16
 80124cc:	011b      	lsls	r3, r3, #4
 80124ce:	69fa      	ldr	r2, [r7, #28]
 80124d0:	4413      	add	r3, r2
 80124d2:	3304      	adds	r3, #4
 80124d4:	627b      	str	r3, [r7, #36]	; 0x24
    return nk_input_has_mouse_click_in_rect(i, id, b) && (btn->down == down);
 80124d6:	ed97 6a02 	vldr	s12, [r7, #8]
 80124da:	edd7 6a03 	vldr	s13, [r7, #12]
 80124de:	ed97 7a04 	vldr	s14, [r7, #16]
 80124e2:	edd7 7a05 	vldr	s15, [r7, #20]
 80124e6:	7efb      	ldrb	r3, [r7, #27]
 80124e8:	eeb0 0a46 	vmov.f32	s0, s12
 80124ec:	eef0 0a66 	vmov.f32	s1, s13
 80124f0:	eeb0 1a47 	vmov.f32	s2, s14
 80124f4:	eef0 1a67 	vmov.f32	s3, s15
 80124f8:	4619      	mov	r1, r3
 80124fa:	69f8      	ldr	r0, [r7, #28]
 80124fc:	f7ff fed2 	bl	80122a4 <nk_input_has_mouse_click_in_rect>
 8012500:	4603      	mov	r3, r0
 8012502:	2b00      	cmp	r3, #0
 8012504:	d006      	beq.n	8012514 <nk_input_has_mouse_click_down_in_rect+0x84>
 8012506:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012508:	681b      	ldr	r3, [r3, #0]
 801250a:	687a      	ldr	r2, [r7, #4]
 801250c:	429a      	cmp	r2, r3
 801250e:	d101      	bne.n	8012514 <nk_input_has_mouse_click_down_in_rect+0x84>
 8012510:	2301      	movs	r3, #1
 8012512:	e000      	b.n	8012516 <nk_input_has_mouse_click_down_in_rect+0x86>
 8012514:	2300      	movs	r3, #0
}
 8012516:	4618      	mov	r0, r3
 8012518:	3728      	adds	r7, #40	; 0x28
 801251a:	46bd      	mov	sp, r7
 801251c:	bd80      	pop	{r7, pc}

0801251e <nk_input_is_mouse_hovering_rect>:
        down = down || nk_input_is_mouse_click_in_rect(in, (enum nk_buttons)i, b);
    return down;
}
NK_API nk_bool
nk_input_is_mouse_hovering_rect(const struct nk_input *i, struct nk_rect rect)
{
 801251e:	b480      	push	{r7}
 8012520:	b087      	sub	sp, #28
 8012522:	af00      	add	r7, sp, #0
 8012524:	6178      	str	r0, [r7, #20]
 8012526:	eeb0 6a40 	vmov.f32	s12, s0
 801252a:	eef0 6a60 	vmov.f32	s13, s1
 801252e:	eeb0 7a41 	vmov.f32	s14, s2
 8012532:	eef0 7a61 	vmov.f32	s15, s3
 8012536:	ed87 6a01 	vstr	s12, [r7, #4]
 801253a:	edc7 6a02 	vstr	s13, [r7, #8]
 801253e:	ed87 7a03 	vstr	s14, [r7, #12]
 8012542:	edc7 7a04 	vstr	s15, [r7, #16]
    if (!i) return nk_false;
 8012546:	697b      	ldr	r3, [r7, #20]
 8012548:	2b00      	cmp	r3, #0
 801254a:	d101      	bne.n	8012550 <nk_input_is_mouse_hovering_rect+0x32>
 801254c:	2300      	movs	r3, #0
 801254e:	e032      	b.n	80125b6 <nk_input_is_mouse_hovering_rect+0x98>
    return NK_INBOX(i->mouse.pos.x, i->mouse.pos.y, rect.x, rect.y, rect.w, rect.h);
 8012550:	ed97 7a01 	vldr	s14, [r7, #4]
 8012554:	697b      	ldr	r3, [r7, #20]
 8012556:	edd3 7a51 	vldr	s15, [r3, #324]	; 0x144
 801255a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801255e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012562:	d827      	bhi.n	80125b4 <nk_input_is_mouse_hovering_rect+0x96>
 8012564:	697b      	ldr	r3, [r7, #20]
 8012566:	ed93 7a51 	vldr	s14, [r3, #324]	; 0x144
 801256a:	edd7 6a01 	vldr	s13, [r7, #4]
 801256e:	edd7 7a03 	vldr	s15, [r7, #12]
 8012572:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8012576:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801257a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801257e:	d519      	bpl.n	80125b4 <nk_input_is_mouse_hovering_rect+0x96>
 8012580:	ed97 7a02 	vldr	s14, [r7, #8]
 8012584:	697b      	ldr	r3, [r7, #20]
 8012586:	edd3 7a52 	vldr	s15, [r3, #328]	; 0x148
 801258a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801258e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012592:	d80f      	bhi.n	80125b4 <nk_input_is_mouse_hovering_rect+0x96>
 8012594:	697b      	ldr	r3, [r7, #20]
 8012596:	ed93 7a52 	vldr	s14, [r3, #328]	; 0x148
 801259a:	edd7 6a02 	vldr	s13, [r7, #8]
 801259e:	edd7 7a04 	vldr	s15, [r7, #16]
 80125a2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 80125a6:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80125aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80125ae:	d501      	bpl.n	80125b4 <nk_input_is_mouse_hovering_rect+0x96>
 80125b0:	2301      	movs	r3, #1
 80125b2:	e000      	b.n	80125b6 <nk_input_is_mouse_hovering_rect+0x98>
 80125b4:	2300      	movs	r3, #0
}
 80125b6:	4618      	mov	r0, r3
 80125b8:	371c      	adds	r7, #28
 80125ba:	46bd      	mov	sp, r7
 80125bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80125c0:	4770      	bx	lr

080125c2 <nk_input_is_mouse_prev_hovering_rect>:
NK_API nk_bool
nk_input_is_mouse_prev_hovering_rect(const struct nk_input *i, struct nk_rect rect)
{
 80125c2:	b480      	push	{r7}
 80125c4:	b087      	sub	sp, #28
 80125c6:	af00      	add	r7, sp, #0
 80125c8:	6178      	str	r0, [r7, #20]
 80125ca:	eeb0 6a40 	vmov.f32	s12, s0
 80125ce:	eef0 6a60 	vmov.f32	s13, s1
 80125d2:	eeb0 7a41 	vmov.f32	s14, s2
 80125d6:	eef0 7a61 	vmov.f32	s15, s3
 80125da:	ed87 6a01 	vstr	s12, [r7, #4]
 80125de:	edc7 6a02 	vstr	s13, [r7, #8]
 80125e2:	ed87 7a03 	vstr	s14, [r7, #12]
 80125e6:	edc7 7a04 	vstr	s15, [r7, #16]
    if (!i) return nk_false;
 80125ea:	697b      	ldr	r3, [r7, #20]
 80125ec:	2b00      	cmp	r3, #0
 80125ee:	d101      	bne.n	80125f4 <nk_input_is_mouse_prev_hovering_rect+0x32>
 80125f0:	2300      	movs	r3, #0
 80125f2:	e032      	b.n	801265a <nk_input_is_mouse_prev_hovering_rect+0x98>
    return NK_INBOX(i->mouse.prev.x, i->mouse.prev.y, rect.x, rect.y, rect.w, rect.h);
 80125f4:	ed97 7a01 	vldr	s14, [r7, #4]
 80125f8:	697b      	ldr	r3, [r7, #20]
 80125fa:	edd3 7a53 	vldr	s15, [r3, #332]	; 0x14c
 80125fe:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8012602:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012606:	d827      	bhi.n	8012658 <nk_input_is_mouse_prev_hovering_rect+0x96>
 8012608:	697b      	ldr	r3, [r7, #20]
 801260a:	ed93 7a53 	vldr	s14, [r3, #332]	; 0x14c
 801260e:	edd7 6a01 	vldr	s13, [r7, #4]
 8012612:	edd7 7a03 	vldr	s15, [r7, #12]
 8012616:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801261a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801261e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012622:	d519      	bpl.n	8012658 <nk_input_is_mouse_prev_hovering_rect+0x96>
 8012624:	ed97 7a02 	vldr	s14, [r7, #8]
 8012628:	697b      	ldr	r3, [r7, #20]
 801262a:	edd3 7a54 	vldr	s15, [r3, #336]	; 0x150
 801262e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8012632:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012636:	d80f      	bhi.n	8012658 <nk_input_is_mouse_prev_hovering_rect+0x96>
 8012638:	697b      	ldr	r3, [r7, #20]
 801263a:	ed93 7a54 	vldr	s14, [r3, #336]	; 0x150
 801263e:	edd7 6a02 	vldr	s13, [r7, #8]
 8012642:	edd7 7a04 	vldr	s15, [r7, #16]
 8012646:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801264a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801264e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012652:	d501      	bpl.n	8012658 <nk_input_is_mouse_prev_hovering_rect+0x96>
 8012654:	2301      	movs	r3, #1
 8012656:	e000      	b.n	801265a <nk_input_is_mouse_prev_hovering_rect+0x98>
 8012658:	2300      	movs	r3, #0
}
 801265a:	4618      	mov	r0, r3
 801265c:	371c      	adds	r7, #28
 801265e:	46bd      	mov	sp, r7
 8012660:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012664:	4770      	bx	lr

08012666 <nk_input_is_mouse_down>:
    if (!nk_input_is_mouse_hovering_rect(i, rect)) return nk_false;
    return nk_input_is_mouse_click_in_rect(i, id, rect);
}
NK_API nk_bool
nk_input_is_mouse_down(const struct nk_input *i, enum nk_buttons id)
{
 8012666:	b480      	push	{r7}
 8012668:	b083      	sub	sp, #12
 801266a:	af00      	add	r7, sp, #0
 801266c:	6078      	str	r0, [r7, #4]
 801266e:	460b      	mov	r3, r1
 8012670:	70fb      	strb	r3, [r7, #3]
    if (!i) return nk_false;
 8012672:	687b      	ldr	r3, [r7, #4]
 8012674:	2b00      	cmp	r3, #0
 8012676:	d101      	bne.n	801267c <nk_input_is_mouse_down+0x16>
 8012678:	2300      	movs	r3, #0
 801267a:	e006      	b.n	801268a <nk_input_is_mouse_down+0x24>
    return i->mouse.buttons[id].down;
 801267c:	78fb      	ldrb	r3, [r7, #3]
 801267e:	687a      	ldr	r2, [r7, #4]
 8012680:	3310      	adds	r3, #16
 8012682:	011b      	lsls	r3, r3, #4
 8012684:	4413      	add	r3, r2
 8012686:	3304      	adds	r3, #4
 8012688:	681b      	ldr	r3, [r3, #0]
}
 801268a:	4618      	mov	r0, r3
 801268c:	370c      	adds	r7, #12
 801268e:	46bd      	mov	sp, r7
 8012690:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012694:	4770      	bx	lr

08012696 <nk_input_is_mouse_pressed>:
NK_API nk_bool
nk_input_is_mouse_pressed(const struct nk_input *i, enum nk_buttons id)
{
 8012696:	b480      	push	{r7}
 8012698:	b085      	sub	sp, #20
 801269a:	af00      	add	r7, sp, #0
 801269c:	6078      	str	r0, [r7, #4]
 801269e:	460b      	mov	r3, r1
 80126a0:	70fb      	strb	r3, [r7, #3]
    const struct nk_mouse_button *b;
    if (!i) return nk_false;
 80126a2:	687b      	ldr	r3, [r7, #4]
 80126a4:	2b00      	cmp	r3, #0
 80126a6:	d101      	bne.n	80126ac <nk_input_is_mouse_pressed+0x16>
 80126a8:	2300      	movs	r3, #0
 80126aa:	e011      	b.n	80126d0 <nk_input_is_mouse_pressed+0x3a>
    b = &i->mouse.buttons[id];
 80126ac:	78fb      	ldrb	r3, [r7, #3]
 80126ae:	3310      	adds	r3, #16
 80126b0:	011b      	lsls	r3, r3, #4
 80126b2:	687a      	ldr	r2, [r7, #4]
 80126b4:	4413      	add	r3, r2
 80126b6:	3304      	adds	r3, #4
 80126b8:	60fb      	str	r3, [r7, #12]
    if (b->down && b->clicked)
 80126ba:	68fb      	ldr	r3, [r7, #12]
 80126bc:	681b      	ldr	r3, [r3, #0]
 80126be:	2b00      	cmp	r3, #0
 80126c0:	d005      	beq.n	80126ce <nk_input_is_mouse_pressed+0x38>
 80126c2:	68fb      	ldr	r3, [r7, #12]
 80126c4:	685b      	ldr	r3, [r3, #4]
 80126c6:	2b00      	cmp	r3, #0
 80126c8:	d001      	beq.n	80126ce <nk_input_is_mouse_pressed+0x38>
        return nk_true;
 80126ca:	2301      	movs	r3, #1
 80126cc:	e000      	b.n	80126d0 <nk_input_is_mouse_pressed+0x3a>
    return nk_false;
 80126ce:	2300      	movs	r3, #0
}
 80126d0:	4618      	mov	r0, r3
 80126d2:	3714      	adds	r7, #20
 80126d4:	46bd      	mov	sp, r7
 80126d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80126da:	4770      	bx	lr

080126dc <nk_input_is_key_pressed>:
    if (!i) return nk_false;
    return (!i->mouse.buttons[id].down && i->mouse.buttons[id].clicked);
}
NK_API nk_bool
nk_input_is_key_pressed(const struct nk_input *i, enum nk_keys key)
{
 80126dc:	b480      	push	{r7}
 80126de:	b085      	sub	sp, #20
 80126e0:	af00      	add	r7, sp, #0
 80126e2:	6078      	str	r0, [r7, #4]
 80126e4:	460b      	mov	r3, r1
 80126e6:	70fb      	strb	r3, [r7, #3]
    const struct nk_key *k;
    if (!i) return nk_false;
 80126e8:	687b      	ldr	r3, [r7, #4]
 80126ea:	2b00      	cmp	r3, #0
 80126ec:	d101      	bne.n	80126f2 <nk_input_is_key_pressed+0x16>
 80126ee:	2300      	movs	r3, #0
 80126f0:	e017      	b.n	8012722 <nk_input_is_key_pressed+0x46>
    k = &i->keyboard.keys[key];
 80126f2:	78fb      	ldrb	r3, [r7, #3]
 80126f4:	00db      	lsls	r3, r3, #3
 80126f6:	687a      	ldr	r2, [r7, #4]
 80126f8:	4413      	add	r3, r2
 80126fa:	60fb      	str	r3, [r7, #12]
    if ((k->down && k->clicked) || (!k->down && k->clicked >= 2))
 80126fc:	68fb      	ldr	r3, [r7, #12]
 80126fe:	681b      	ldr	r3, [r3, #0]
 8012700:	2b00      	cmp	r3, #0
 8012702:	d003      	beq.n	801270c <nk_input_is_key_pressed+0x30>
 8012704:	68fb      	ldr	r3, [r7, #12]
 8012706:	685b      	ldr	r3, [r3, #4]
 8012708:	2b00      	cmp	r3, #0
 801270a:	d107      	bne.n	801271c <nk_input_is_key_pressed+0x40>
 801270c:	68fb      	ldr	r3, [r7, #12]
 801270e:	681b      	ldr	r3, [r3, #0]
 8012710:	2b00      	cmp	r3, #0
 8012712:	d105      	bne.n	8012720 <nk_input_is_key_pressed+0x44>
 8012714:	68fb      	ldr	r3, [r7, #12]
 8012716:	685b      	ldr	r3, [r3, #4]
 8012718:	2b01      	cmp	r3, #1
 801271a:	d901      	bls.n	8012720 <nk_input_is_key_pressed+0x44>
        return nk_true;
 801271c:	2301      	movs	r3, #1
 801271e:	e000      	b.n	8012722 <nk_input_is_key_pressed+0x46>
    return nk_false;
 8012720:	2300      	movs	r3, #0
}
 8012722:	4618      	mov	r0, r3
 8012724:	3714      	adds	r7, #20
 8012726:	46bd      	mov	sp, r7
 8012728:	f85d 7b04 	ldr.w	r7, [sp], #4
 801272c:	4770      	bx	lr
	...

08012730 <nk_layout_set_min_row_height>:
 *                          LAYOUT
 *
 * ===============================================================*/
NK_API void
nk_layout_set_min_row_height(struct nk_context *ctx, float height)
{
 8012730:	b580      	push	{r7, lr}
 8012732:	b084      	sub	sp, #16
 8012734:	af00      	add	r7, sp, #0
 8012736:	6078      	str	r0, [r7, #4]
 8012738:	ed87 0a00 	vstr	s0, [r7]
    struct nk_window *win;
    struct nk_panel *layout;

    NK_ASSERT(ctx);
 801273c:	687b      	ldr	r3, [r7, #4]
 801273e:	2b00      	cmp	r3, #0
 8012740:	d105      	bne.n	801274e <nk_layout_set_min_row_height+0x1e>
 8012742:	4b23      	ldr	r3, [pc, #140]	; (80127d0 <nk_layout_set_min_row_height+0xa0>)
 8012744:	4a23      	ldr	r2, [pc, #140]	; (80127d4 <nk_layout_set_min_row_height+0xa4>)
 8012746:	210f      	movs	r1, #15
 8012748:	4823      	ldr	r0, [pc, #140]	; (80127d8 <nk_layout_set_min_row_height+0xa8>)
 801274a:	f00b f965 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 801274e:	687b      	ldr	r3, [r7, #4]
 8012750:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012754:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012758:	2b00      	cmp	r3, #0
 801275a:	d105      	bne.n	8012768 <nk_layout_set_min_row_height+0x38>
 801275c:	4b1f      	ldr	r3, [pc, #124]	; (80127dc <nk_layout_set_min_row_height+0xac>)
 801275e:	4a1d      	ldr	r2, [pc, #116]	; (80127d4 <nk_layout_set_min_row_height+0xa4>)
 8012760:	2110      	movs	r1, #16
 8012762:	481d      	ldr	r0, [pc, #116]	; (80127d8 <nk_layout_set_min_row_height+0xa8>)
 8012764:	f00b f958 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 8012768:	687b      	ldr	r3, [r7, #4]
 801276a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801276e:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012772:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8012776:	2b00      	cmp	r3, #0
 8012778:	d105      	bne.n	8012786 <nk_layout_set_min_row_height+0x56>
 801277a:	4b19      	ldr	r3, [pc, #100]	; (80127e0 <nk_layout_set_min_row_height+0xb0>)
 801277c:	4a15      	ldr	r2, [pc, #84]	; (80127d4 <nk_layout_set_min_row_height+0xa4>)
 801277e:	2111      	movs	r1, #17
 8012780:	4815      	ldr	r0, [pc, #84]	; (80127d8 <nk_layout_set_min_row_height+0xa8>)
 8012782:	f00b f949 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout)
 8012786:	687b      	ldr	r3, [r7, #4]
 8012788:	2b00      	cmp	r3, #0
 801278a:	d01d      	beq.n	80127c8 <nk_layout_set_min_row_height+0x98>
 801278c:	687b      	ldr	r3, [r7, #4]
 801278e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012792:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012796:	2b00      	cmp	r3, #0
 8012798:	d016      	beq.n	80127c8 <nk_layout_set_min_row_height+0x98>
 801279a:	687b      	ldr	r3, [r7, #4]
 801279c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80127a0:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 80127a4:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80127a8:	2b00      	cmp	r3, #0
 80127aa:	d00d      	beq.n	80127c8 <nk_layout_set_min_row_height+0x98>
        return;

    win = ctx->current;
 80127ac:	687b      	ldr	r3, [r7, #4]
 80127ae:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80127b2:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 80127b6:	60fb      	str	r3, [r7, #12]
    layout = win->layout;
 80127b8:	68fb      	ldr	r3, [r7, #12]
 80127ba:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80127be:	60bb      	str	r3, [r7, #8]
    layout->row.min_height = height;
 80127c0:	68bb      	ldr	r3, [r7, #8]
 80127c2:	683a      	ldr	r2, [r7, #0]
 80127c4:	671a      	str	r2, [r3, #112]	; 0x70
 80127c6:	e000      	b.n	80127ca <nk_layout_set_min_row_height+0x9a>
        return;
 80127c8:	bf00      	nop
}
 80127ca:	3710      	adds	r7, #16
 80127cc:	46bd      	mov	sp, r7
 80127ce:	bd80      	pop	{r7, pc}
 80127d0:	08021768 	.word	0x08021768
 80127d4:	080234a8 	.word	0x080234a8
 80127d8:	0802176c 	.word	0x0802176c
 80127dc:	08021788 	.word	0x08021788
 80127e0:	08021798 	.word	0x08021798

080127e4 <nk_layout_reset_min_row_height>:
NK_API void
nk_layout_reset_min_row_height(struct nk_context *ctx)
{
 80127e4:	b580      	push	{r7, lr}
 80127e6:	b084      	sub	sp, #16
 80127e8:	af00      	add	r7, sp, #0
 80127ea:	6078      	str	r0, [r7, #4]
    struct nk_window *win;
    struct nk_panel *layout;

    NK_ASSERT(ctx);
 80127ec:	687b      	ldr	r3, [r7, #4]
 80127ee:	2b00      	cmp	r3, #0
 80127f0:	d105      	bne.n	80127fe <nk_layout_reset_min_row_height+0x1a>
 80127f2:	4b34      	ldr	r3, [pc, #208]	; (80128c4 <nk_layout_reset_min_row_height+0xe0>)
 80127f4:	4a34      	ldr	r2, [pc, #208]	; (80128c8 <nk_layout_reset_min_row_height+0xe4>)
 80127f6:	211f      	movs	r1, #31
 80127f8:	4834      	ldr	r0, [pc, #208]	; (80128cc <nk_layout_reset_min_row_height+0xe8>)
 80127fa:	f00b f90d 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 80127fe:	687b      	ldr	r3, [r7, #4]
 8012800:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012804:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012808:	2b00      	cmp	r3, #0
 801280a:	d105      	bne.n	8012818 <nk_layout_reset_min_row_height+0x34>
 801280c:	4b30      	ldr	r3, [pc, #192]	; (80128d0 <nk_layout_reset_min_row_height+0xec>)
 801280e:	4a2e      	ldr	r2, [pc, #184]	; (80128c8 <nk_layout_reset_min_row_height+0xe4>)
 8012810:	2120      	movs	r1, #32
 8012812:	482e      	ldr	r0, [pc, #184]	; (80128cc <nk_layout_reset_min_row_height+0xe8>)
 8012814:	f00b f900 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 8012818:	687b      	ldr	r3, [r7, #4]
 801281a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801281e:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012822:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8012826:	2b00      	cmp	r3, #0
 8012828:	d105      	bne.n	8012836 <nk_layout_reset_min_row_height+0x52>
 801282a:	4b2a      	ldr	r3, [pc, #168]	; (80128d4 <nk_layout_reset_min_row_height+0xf0>)
 801282c:	4a26      	ldr	r2, [pc, #152]	; (80128c8 <nk_layout_reset_min_row_height+0xe4>)
 801282e:	2121      	movs	r1, #33	; 0x21
 8012830:	4826      	ldr	r0, [pc, #152]	; (80128cc <nk_layout_reset_min_row_height+0xe8>)
 8012832:	f00b f8f1 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout)
 8012836:	687b      	ldr	r3, [r7, #4]
 8012838:	2b00      	cmp	r3, #0
 801283a:	d03e      	beq.n	80128ba <nk_layout_reset_min_row_height+0xd6>
 801283c:	687b      	ldr	r3, [r7, #4]
 801283e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012842:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012846:	2b00      	cmp	r3, #0
 8012848:	d037      	beq.n	80128ba <nk_layout_reset_min_row_height+0xd6>
 801284a:	687b      	ldr	r3, [r7, #4]
 801284c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012850:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012854:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8012858:	2b00      	cmp	r3, #0
 801285a:	d02e      	beq.n	80128ba <nk_layout_reset_min_row_height+0xd6>
        return;

    win = ctx->current;
 801285c:	687b      	ldr	r3, [r7, #4]
 801285e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012862:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012866:	60fb      	str	r3, [r7, #12]
    layout = win->layout;
 8012868:	68fb      	ldr	r3, [r7, #12]
 801286a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801286e:	60bb      	str	r3, [r7, #8]
    layout->row.min_height = ctx->style.font->height;
 8012870:	687b      	ldr	r3, [r7, #4]
 8012872:	f8d3 3168 	ldr.w	r3, [r3, #360]	; 0x168
 8012876:	685a      	ldr	r2, [r3, #4]
 8012878:	68bb      	ldr	r3, [r7, #8]
 801287a:	671a      	str	r2, [r3, #112]	; 0x70
    layout->row.min_height += ctx->style.text.padding.y*2;
 801287c:	68bb      	ldr	r3, [r7, #8]
 801287e:	ed93 7a1c 	vldr	s14, [r3, #112]	; 0x70
 8012882:	687b      	ldr	r3, [r7, #4]
 8012884:	edd3 7a67 	vldr	s15, [r3, #412]	; 0x19c
 8012888:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801288c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8012890:	68bb      	ldr	r3, [r7, #8]
 8012892:	edc3 7a1c 	vstr	s15, [r3, #112]	; 0x70
    layout->row.min_height += ctx->style.window.min_row_height_padding*2;
 8012896:	68bb      	ldr	r3, [r7, #8]
 8012898:	ed93 7a1c 	vldr	s14, [r3, #112]	; 0x70
 801289c:	687b      	ldr	r3, [r7, #4]
 801289e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80128a2:	f603 2334 	addw	r3, r3, #2612	; 0xa34
 80128a6:	edd3 7a00 	vldr	s15, [r3]
 80128aa:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80128ae:	ee77 7a27 	vadd.f32	s15, s14, s15
 80128b2:	68bb      	ldr	r3, [r7, #8]
 80128b4:	edc3 7a1c 	vstr	s15, [r3, #112]	; 0x70
 80128b8:	e000      	b.n	80128bc <nk_layout_reset_min_row_height+0xd8>
        return;
 80128ba:	bf00      	nop
}
 80128bc:	3710      	adds	r7, #16
 80128be:	46bd      	mov	sp, r7
 80128c0:	bd80      	pop	{r7, pc}
 80128c2:	bf00      	nop
 80128c4:	08021768 	.word	0x08021768
 80128c8:	080234c8 	.word	0x080234c8
 80128cc:	0802176c 	.word	0x0802176c
 80128d0:	08021788 	.word	0x08021788
 80128d4:	08021798 	.word	0x08021798

080128d8 <nk_layout_row_calculate_usable_space>:
NK_LIB float
nk_layout_row_calculate_usable_space(const struct nk_style *style, enum nk_panel_type type,
    float total_space, int columns)
{
 80128d8:	b480      	push	{r7}
 80128da:	b089      	sub	sp, #36	; 0x24
 80128dc:	af00      	add	r7, sp, #0
 80128de:	60f8      	str	r0, [r7, #12]
 80128e0:	460b      	mov	r3, r1
 80128e2:	ed87 0a01 	vstr	s0, [r7, #4]
 80128e6:	603a      	str	r2, [r7, #0]
 80128e8:	72fb      	strb	r3, [r7, #11]

    struct nk_vec2 spacing;

    NK_UNUSED(type);

    spacing = style->window.spacing;
 80128ea:	68fb      	ldr	r3, [r7, #12]
 80128ec:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80128f0:	461a      	mov	r2, r3
 80128f2:	f107 0310 	add.w	r3, r7, #16
 80128f6:	f602 02d4 	addw	r2, r2, #2260	; 0x8d4
 80128fa:	e892 0003 	ldmia.w	r2, {r0, r1}
 80128fe:	e883 0003 	stmia.w	r3, {r0, r1}

    /* calculate the usable panel space */
    panel_spacing = (float)NK_MAX(columns - 1, 0) * spacing.x;
 8012902:	683b      	ldr	r3, [r7, #0]
 8012904:	2b00      	cmp	r3, #0
 8012906:	dd06      	ble.n	8012916 <nk_layout_row_calculate_usable_space+0x3e>
 8012908:	683b      	ldr	r3, [r7, #0]
 801290a:	3b01      	subs	r3, #1
 801290c:	ee07 3a90 	vmov	s15, r3
 8012910:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8012914:	e001      	b.n	801291a <nk_layout_row_calculate_usable_space+0x42>
 8012916:	eddf 7a0d 	vldr	s15, [pc, #52]	; 801294c <nk_layout_row_calculate_usable_space+0x74>
 801291a:	ed97 7a04 	vldr	s14, [r7, #16]
 801291e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8012922:	edc7 7a07 	vstr	s15, [r7, #28]
    panel_space  = total_space - panel_spacing;
 8012926:	ed97 7a01 	vldr	s14, [r7, #4]
 801292a:	edd7 7a07 	vldr	s15, [r7, #28]
 801292e:	ee77 7a67 	vsub.f32	s15, s14, s15
 8012932:	edc7 7a06 	vstr	s15, [r7, #24]
    return panel_space;
 8012936:	69bb      	ldr	r3, [r7, #24]
 8012938:	ee07 3a90 	vmov	s15, r3
}
 801293c:	eeb0 0a67 	vmov.f32	s0, s15
 8012940:	3724      	adds	r7, #36	; 0x24
 8012942:	46bd      	mov	sp, r7
 8012944:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012948:	4770      	bx	lr
 801294a:	bf00      	nop
 801294c:	00000000 	.word	0x00000000

08012950 <nk_panel_layout>:
NK_LIB void
nk_panel_layout(const struct nk_context *ctx, struct nk_window *win,
    float height, int cols)
{
 8012950:	b580      	push	{r7, lr}
 8012952:	b08e      	sub	sp, #56	; 0x38
 8012954:	af00      	add	r7, sp, #0
 8012956:	60f8      	str	r0, [r7, #12]
 8012958:	60b9      	str	r1, [r7, #8]
 801295a:	ed87 0a01 	vstr	s0, [r7, #4]
 801295e:	603a      	str	r2, [r7, #0]
    struct nk_command_buffer *out;

    struct nk_vec2 item_spacing;
    struct nk_color color;

    NK_ASSERT(ctx);
 8012960:	68fb      	ldr	r3, [r7, #12]
 8012962:	2b00      	cmp	r3, #0
 8012964:	d105      	bne.n	8012972 <nk_panel_layout+0x22>
 8012966:	4b78      	ldr	r3, [pc, #480]	; (8012b48 <nk_panel_layout+0x1f8>)
 8012968:	4a78      	ldr	r2, [pc, #480]	; (8012b4c <nk_panel_layout+0x1fc>)
 801296a:	2148      	movs	r1, #72	; 0x48
 801296c:	4878      	ldr	r0, [pc, #480]	; (8012b50 <nk_panel_layout+0x200>)
 801296e:	f00b f853 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 8012972:	68fb      	ldr	r3, [r7, #12]
 8012974:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012978:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801297c:	2b00      	cmp	r3, #0
 801297e:	d105      	bne.n	801298c <nk_panel_layout+0x3c>
 8012980:	4b74      	ldr	r3, [pc, #464]	; (8012b54 <nk_panel_layout+0x204>)
 8012982:	4a72      	ldr	r2, [pc, #456]	; (8012b4c <nk_panel_layout+0x1fc>)
 8012984:	2149      	movs	r1, #73	; 0x49
 8012986:	4872      	ldr	r0, [pc, #456]	; (8012b50 <nk_panel_layout+0x200>)
 8012988:	f00b f846 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 801298c:	68fb      	ldr	r3, [r7, #12]
 801298e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012992:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012996:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801299a:	2b00      	cmp	r3, #0
 801299c:	d105      	bne.n	80129aa <nk_panel_layout+0x5a>
 801299e:	4b6e      	ldr	r3, [pc, #440]	; (8012b58 <nk_panel_layout+0x208>)
 80129a0:	4a6a      	ldr	r2, [pc, #424]	; (8012b4c <nk_panel_layout+0x1fc>)
 80129a2:	214a      	movs	r1, #74	; 0x4a
 80129a4:	486a      	ldr	r0, [pc, #424]	; (8012b50 <nk_panel_layout+0x200>)
 80129a6:	f00b f837 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout)
 80129aa:	68fb      	ldr	r3, [r7, #12]
 80129ac:	2b00      	cmp	r3, #0
 80129ae:	f000 80c6 	beq.w	8012b3e <nk_panel_layout+0x1ee>
 80129b2:	68fb      	ldr	r3, [r7, #12]
 80129b4:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80129b8:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 80129bc:	2b00      	cmp	r3, #0
 80129be:	f000 80be 	beq.w	8012b3e <nk_panel_layout+0x1ee>
 80129c2:	68fb      	ldr	r3, [r7, #12]
 80129c4:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80129c8:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 80129cc:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80129d0:	2b00      	cmp	r3, #0
 80129d2:	f000 80b4 	beq.w	8012b3e <nk_panel_layout+0x1ee>
        return;

    /* prefetch some configuration data */
    layout = win->layout;
 80129d6:	68bb      	ldr	r3, [r7, #8]
 80129d8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80129dc:	637b      	str	r3, [r7, #52]	; 0x34
    style = &ctx->style;
 80129de:	68fb      	ldr	r3, [r7, #12]
 80129e0:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 80129e4:	633b      	str	r3, [r7, #48]	; 0x30
    out = &win->buffer;
 80129e6:	68bb      	ldr	r3, [r7, #8]
 80129e8:	3364      	adds	r3, #100	; 0x64
 80129ea:	62fb      	str	r3, [r7, #44]	; 0x2c
    color = style->window.background;
 80129ec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80129ee:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80129f2:	f8d3 3874 	ldr.w	r3, [r3, #2164]	; 0x874
 80129f6:	623b      	str	r3, [r7, #32]
    item_spacing = style->window.spacing;
 80129f8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80129fa:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80129fe:	461a      	mov	r2, r3
 8012a00:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8012a04:	f602 02d4 	addw	r2, r2, #2260	; 0x8d4
 8012a08:	e892 0003 	ldmia.w	r2, {r0, r1}
 8012a0c:	e883 0003 	stmia.w	r3, {r0, r1}
    /*  if one of these triggers you forgot to add an `if` condition around either
        a window, group, popup, combobox or contextual menu `begin` and `end` block.
        Example:
            if (nk_begin(...) {...} nk_end(...); or
            if (nk_group_begin(...) { nk_group_end(...);} */
    NK_ASSERT(!(layout->flags & NK_WINDOW_MINIMIZED));
 8012a10:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012a12:	685b      	ldr	r3, [r3, #4]
 8012a14:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8012a18:	2b00      	cmp	r3, #0
 8012a1a:	d005      	beq.n	8012a28 <nk_panel_layout+0xd8>
 8012a1c:	4b4f      	ldr	r3, [pc, #316]	; (8012b5c <nk_panel_layout+0x20c>)
 8012a1e:	4a4b      	ldr	r2, [pc, #300]	; (8012b4c <nk_panel_layout+0x1fc>)
 8012a20:	215a      	movs	r1, #90	; 0x5a
 8012a22:	484b      	ldr	r0, [pc, #300]	; (8012b50 <nk_panel_layout+0x200>)
 8012a24:	f00a fff8 	bl	801da18 <__assert_func>
    NK_ASSERT(!(layout->flags & NK_WINDOW_HIDDEN));
 8012a28:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012a2a:	685b      	ldr	r3, [r3, #4]
 8012a2c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8012a30:	2b00      	cmp	r3, #0
 8012a32:	d005      	beq.n	8012a40 <nk_panel_layout+0xf0>
 8012a34:	4b4a      	ldr	r3, [pc, #296]	; (8012b60 <nk_panel_layout+0x210>)
 8012a36:	4a45      	ldr	r2, [pc, #276]	; (8012b4c <nk_panel_layout+0x1fc>)
 8012a38:	215b      	movs	r1, #91	; 0x5b
 8012a3a:	4845      	ldr	r0, [pc, #276]	; (8012b50 <nk_panel_layout+0x200>)
 8012a3c:	f00a ffec 	bl	801da18 <__assert_func>
    NK_ASSERT(!(layout->flags & NK_WINDOW_CLOSED));
 8012a40:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012a42:	685b      	ldr	r3, [r3, #4]
 8012a44:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8012a48:	2b00      	cmp	r3, #0
 8012a4a:	d005      	beq.n	8012a58 <nk_panel_layout+0x108>
 8012a4c:	4b45      	ldr	r3, [pc, #276]	; (8012b64 <nk_panel_layout+0x214>)
 8012a4e:	4a3f      	ldr	r2, [pc, #252]	; (8012b4c <nk_panel_layout+0x1fc>)
 8012a50:	215c      	movs	r1, #92	; 0x5c
 8012a52:	483f      	ldr	r0, [pc, #252]	; (8012b50 <nk_panel_layout+0x200>)
 8012a54:	f00a ffe0 	bl	801da18 <__assert_func>

    /* update the current row and set the current row layout */
    layout->row.index = 0;
 8012a58:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012a5a:	2200      	movs	r2, #0
 8012a5c:	669a      	str	r2, [r3, #104]	; 0x68
    layout->at_y += layout->row.height;
 8012a5e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012a60:	ed93 7a09 	vldr	s14, [r3, #36]	; 0x24
 8012a64:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012a66:	edd3 7a1b 	vldr	s15, [r3, #108]	; 0x6c
 8012a6a:	ee77 7a27 	vadd.f32	s15, s14, s15
 8012a6e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012a70:	edc3 7a09 	vstr	s15, [r3, #36]	; 0x24
    layout->row.columns = cols;
 8012a74:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012a76:	683a      	ldr	r2, [r7, #0]
 8012a78:	675a      	str	r2, [r3, #116]	; 0x74
    if (height == 0.0f)
 8012a7a:	edd7 7a01 	vldr	s15, [r7, #4]
 8012a7e:	eef5 7a40 	vcmp.f32	s15, #0.0
 8012a82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012a86:	d117      	bne.n	8012ab8 <nk_panel_layout+0x168>
        layout->row.height = NK_MAX(height, layout->row.min_height) + item_spacing.y;
 8012a88:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012a8a:	edd3 7a1c 	vldr	s15, [r3, #112]	; 0x70
 8012a8e:	ed97 7a01 	vldr	s14, [r7, #4]
 8012a92:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8012a96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012a9a:	d503      	bpl.n	8012aa4 <nk_panel_layout+0x154>
 8012a9c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012a9e:	edd3 7a1c 	vldr	s15, [r3, #112]	; 0x70
 8012aa2:	e001      	b.n	8012aa8 <nk_panel_layout+0x158>
 8012aa4:	edd7 7a01 	vldr	s15, [r7, #4]
 8012aa8:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
 8012aac:	ee77 7a87 	vadd.f32	s15, s15, s14
 8012ab0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012ab2:	edc3 7a1b 	vstr	s15, [r3, #108]	; 0x6c
 8012ab6:	e008      	b.n	8012aca <nk_panel_layout+0x17a>
    else layout->row.height = height + item_spacing.y;
 8012ab8:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
 8012abc:	edd7 7a01 	vldr	s15, [r7, #4]
 8012ac0:	ee77 7a27 	vadd.f32	s15, s14, s15
 8012ac4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012ac6:	edc3 7a1b 	vstr	s15, [r3, #108]	; 0x6c

    layout->row.item_offset = 0;
 8012aca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012acc:	f04f 0200 	mov.w	r2, #0
 8012ad0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    if (layout->flags & NK_WINDOW_DYNAMIC) {
 8012ad4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012ad6:	685b      	ldr	r3, [r3, #4]
 8012ad8:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8012adc:	2b00      	cmp	r3, #0
 8012ade:	d02f      	beq.n	8012b40 <nk_panel_layout+0x1f0>
        /* draw background for dynamic panels */
        struct nk_rect background;
        background.x = win->bounds.x;
 8012ae0:	68bb      	ldr	r3, [r7, #8]
 8012ae2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8012ae4:	613b      	str	r3, [r7, #16]
        background.w = win->bounds.w;
 8012ae6:	68bb      	ldr	r3, [r7, #8]
 8012ae8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8012aea:	61bb      	str	r3, [r7, #24]
        background.y = layout->at_y - 1.0f;
 8012aec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012aee:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
 8012af2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8012af6:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8012afa:	edc7 7a05 	vstr	s15, [r7, #20]
        background.h = layout->row.height + 1.0f;
 8012afe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012b00:	edd3 7a1b 	vldr	s15, [r3, #108]	; 0x6c
 8012b04:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8012b08:	ee77 7a87 	vadd.f32	s15, s15, s14
 8012b0c:	edc7 7a07 	vstr	s15, [r7, #28]
        nk_fill_rect(out, background, 0, color);
 8012b10:	ed97 6a04 	vldr	s12, [r7, #16]
 8012b14:	edd7 6a05 	vldr	s13, [r7, #20]
 8012b18:	ed97 7a06 	vldr	s14, [r7, #24]
 8012b1c:	edd7 7a07 	vldr	s15, [r7, #28]
 8012b20:	6a39      	ldr	r1, [r7, #32]
 8012b22:	ed9f 2a11 	vldr	s4, [pc, #68]	; 8012b68 <nk_panel_layout+0x218>
 8012b26:	eeb0 0a46 	vmov.f32	s0, s12
 8012b2a:	eef0 0a66 	vmov.f32	s1, s13
 8012b2e:	eeb0 1a47 	vmov.f32	s2, s14
 8012b32:	eef0 1a67 	vmov.f32	s3, s15
 8012b36:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8012b38:	f7fe f8b0 	bl	8010c9c <nk_fill_rect>
 8012b3c:	e000      	b.n	8012b40 <nk_panel_layout+0x1f0>
        return;
 8012b3e:	bf00      	nop
    }
}
 8012b40:	3738      	adds	r7, #56	; 0x38
 8012b42:	46bd      	mov	sp, r7
 8012b44:	bd80      	pop	{r7, pc}
 8012b46:	bf00      	nop
 8012b48:	08021768 	.word	0x08021768
 8012b4c:	080234e8 	.word	0x080234e8
 8012b50:	0802176c 	.word	0x0802176c
 8012b54:	08021788 	.word	0x08021788
 8012b58:	08021798 	.word	0x08021798
 8012b5c:	080217b0 	.word	0x080217b0
 8012b60:	080217d8 	.word	0x080217d8
 8012b64:	080217fc 	.word	0x080217fc
 8012b68:	00000000 	.word	0x00000000

08012b6c <nk_row_layout>:
NK_LIB void
nk_row_layout(struct nk_context *ctx, enum nk_layout_format fmt,
    float height, int cols, int width)
{
 8012b6c:	b580      	push	{r7, lr}
 8012b6e:	b088      	sub	sp, #32
 8012b70:	af00      	add	r7, sp, #0
 8012b72:	6178      	str	r0, [r7, #20]
 8012b74:	ed87 0a03 	vstr	s0, [r7, #12]
 8012b78:	60ba      	str	r2, [r7, #8]
 8012b7a:	607b      	str	r3, [r7, #4]
 8012b7c:	460b      	mov	r3, r1
 8012b7e:	74fb      	strb	r3, [r7, #19]
    /* update the current row and set the current row layout */
    struct nk_window *win;
    NK_ASSERT(ctx);
 8012b80:	697b      	ldr	r3, [r7, #20]
 8012b82:	2b00      	cmp	r3, #0
 8012b84:	d105      	bne.n	8012b92 <nk_row_layout+0x26>
 8012b86:	4b3a      	ldr	r3, [pc, #232]	; (8012c70 <nk_row_layout+0x104>)
 8012b88:	4a3a      	ldr	r2, [pc, #232]	; (8012c74 <nk_row_layout+0x108>)
 8012b8a:	2177      	movs	r1, #119	; 0x77
 8012b8c:	483a      	ldr	r0, [pc, #232]	; (8012c78 <nk_row_layout+0x10c>)
 8012b8e:	f00a ff43 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 8012b92:	697b      	ldr	r3, [r7, #20]
 8012b94:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012b98:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012b9c:	2b00      	cmp	r3, #0
 8012b9e:	d105      	bne.n	8012bac <nk_row_layout+0x40>
 8012ba0:	4b36      	ldr	r3, [pc, #216]	; (8012c7c <nk_row_layout+0x110>)
 8012ba2:	4a34      	ldr	r2, [pc, #208]	; (8012c74 <nk_row_layout+0x108>)
 8012ba4:	2178      	movs	r1, #120	; 0x78
 8012ba6:	4834      	ldr	r0, [pc, #208]	; (8012c78 <nk_row_layout+0x10c>)
 8012ba8:	f00a ff36 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 8012bac:	697b      	ldr	r3, [r7, #20]
 8012bae:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012bb2:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012bb6:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8012bba:	2b00      	cmp	r3, #0
 8012bbc:	d105      	bne.n	8012bca <nk_row_layout+0x5e>
 8012bbe:	4b30      	ldr	r3, [pc, #192]	; (8012c80 <nk_row_layout+0x114>)
 8012bc0:	4a2c      	ldr	r2, [pc, #176]	; (8012c74 <nk_row_layout+0x108>)
 8012bc2:	2179      	movs	r1, #121	; 0x79
 8012bc4:	482c      	ldr	r0, [pc, #176]	; (8012c78 <nk_row_layout+0x10c>)
 8012bc6:	f00a ff27 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout)
 8012bca:	697b      	ldr	r3, [r7, #20]
 8012bcc:	2b00      	cmp	r3, #0
 8012bce:	d04a      	beq.n	8012c66 <nk_row_layout+0xfa>
 8012bd0:	697b      	ldr	r3, [r7, #20]
 8012bd2:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012bd6:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012bda:	2b00      	cmp	r3, #0
 8012bdc:	d043      	beq.n	8012c66 <nk_row_layout+0xfa>
 8012bde:	697b      	ldr	r3, [r7, #20]
 8012be0:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012be4:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012be8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8012bec:	2b00      	cmp	r3, #0
 8012bee:	d03a      	beq.n	8012c66 <nk_row_layout+0xfa>
        return;

    win = ctx->current;
 8012bf0:	697b      	ldr	r3, [r7, #20]
 8012bf2:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012bf6:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012bfa:	61fb      	str	r3, [r7, #28]
    nk_panel_layout(ctx, win, height, cols);
 8012bfc:	68ba      	ldr	r2, [r7, #8]
 8012bfe:	ed97 0a03 	vldr	s0, [r7, #12]
 8012c02:	69f9      	ldr	r1, [r7, #28]
 8012c04:	6978      	ldr	r0, [r7, #20]
 8012c06:	f7ff fea3 	bl	8012950 <nk_panel_layout>
    if (fmt == NK_DYNAMIC)
 8012c0a:	7cfb      	ldrb	r3, [r7, #19]
 8012c0c:	2b00      	cmp	r3, #0
 8012c0e:	d106      	bne.n	8012c1e <nk_row_layout+0xb2>
        win->layout->row.type = NK_LAYOUT_DYNAMIC_FIXED;
 8012c10:	69fb      	ldr	r3, [r7, #28]
 8012c12:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8012c16:	2200      	movs	r2, #0
 8012c18:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
 8012c1c:	e005      	b.n	8012c2a <nk_row_layout+0xbe>
    else win->layout->row.type = NK_LAYOUT_STATIC_FIXED;
 8012c1e:	69fb      	ldr	r3, [r7, #28]
 8012c20:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8012c24:	2204      	movs	r2, #4
 8012c26:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64

    win->layout->row.ratio = 0;
 8012c2a:	69fb      	ldr	r3, [r7, #28]
 8012c2c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8012c30:	2200      	movs	r2, #0
 8012c32:	679a      	str	r2, [r3, #120]	; 0x78
    win->layout->row.filled = 0;
 8012c34:	69fb      	ldr	r3, [r7, #28]
 8012c36:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8012c3a:	f04f 0200 	mov.w	r2, #0
 8012c3e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    win->layout->row.item_offset = 0;
 8012c42:	69fb      	ldr	r3, [r7, #28]
 8012c44:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8012c48:	f04f 0200 	mov.w	r2, #0
 8012c4c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    win->layout->row.item_width = (float)width;
 8012c50:	69fb      	ldr	r3, [r7, #28]
 8012c52:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8012c56:	687a      	ldr	r2, [r7, #4]
 8012c58:	ee07 2a90 	vmov	s15, r2
 8012c5c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8012c60:	edc3 7a1f 	vstr	s15, [r3, #124]	; 0x7c
 8012c64:	e000      	b.n	8012c68 <nk_row_layout+0xfc>
        return;
 8012c66:	bf00      	nop
}
 8012c68:	3720      	adds	r7, #32
 8012c6a:	46bd      	mov	sp, r7
 8012c6c:	bd80      	pop	{r7, pc}
 8012c6e:	bf00      	nop
 8012c70:	08021768 	.word	0x08021768
 8012c74:	080234f8 	.word	0x080234f8
 8012c78:	0802176c 	.word	0x0802176c
 8012c7c:	08021788 	.word	0x08021788
 8012c80:	08021798 	.word	0x08021798

08012c84 <nk_layout_row_dynamic>:
    win = ctx->current;
    return NK_CLAMP(0.0f, pixel_width/win->bounds.x, 1.0f);
}
NK_API void
nk_layout_row_dynamic(struct nk_context *ctx, float height, int cols)
{
 8012c84:	b580      	push	{r7, lr}
 8012c86:	b084      	sub	sp, #16
 8012c88:	af00      	add	r7, sp, #0
 8012c8a:	60f8      	str	r0, [r7, #12]
 8012c8c:	ed87 0a02 	vstr	s0, [r7, #8]
 8012c90:	6079      	str	r1, [r7, #4]
    nk_row_layout(ctx, NK_DYNAMIC, height, cols, 0);
 8012c92:	2300      	movs	r3, #0
 8012c94:	687a      	ldr	r2, [r7, #4]
 8012c96:	ed97 0a02 	vldr	s0, [r7, #8]
 8012c9a:	2100      	movs	r1, #0
 8012c9c:	68f8      	ldr	r0, [r7, #12]
 8012c9e:	f7ff ff65 	bl	8012b6c <nk_row_layout>
}
 8012ca2:	bf00      	nop
 8012ca4:	3710      	adds	r7, #16
 8012ca6:	46bd      	mov	sp, r7
 8012ca8:	bd80      	pop	{r7, pc}
	...

08012cac <nk_layout_row>:
    layout->row.item_offset = 0;
}
NK_API void
nk_layout_row(struct nk_context *ctx, enum nk_layout_format fmt,
    float height, int cols, const float *ratio)
{
 8012cac:	b580      	push	{r7, lr}
 8012cae:	b08c      	sub	sp, #48	; 0x30
 8012cb0:	af00      	add	r7, sp, #0
 8012cb2:	6178      	str	r0, [r7, #20]
 8012cb4:	ed87 0a03 	vstr	s0, [r7, #12]
 8012cb8:	60ba      	str	r2, [r7, #8]
 8012cba:	607b      	str	r3, [r7, #4]
 8012cbc:	460b      	mov	r3, r1
 8012cbe:	74fb      	strb	r3, [r7, #19]
    int i;
    int n_undef = 0;
 8012cc0:	2300      	movs	r3, #0
 8012cc2:	62bb      	str	r3, [r7, #40]	; 0x28
    struct nk_window *win;
    struct nk_panel *layout;

    NK_ASSERT(ctx);
 8012cc4:	697b      	ldr	r3, [r7, #20]
 8012cc6:	2b00      	cmp	r3, #0
 8012cc8:	d105      	bne.n	8012cd6 <nk_layout_row+0x2a>
 8012cca:	4b73      	ldr	r3, [pc, #460]	; (8012e98 <nk_layout_row+0x1ec>)
 8012ccc:	4a73      	ldr	r2, [pc, #460]	; (8012e9c <nk_layout_row+0x1f0>)
 8012cce:	21ed      	movs	r1, #237	; 0xed
 8012cd0:	4873      	ldr	r0, [pc, #460]	; (8012ea0 <nk_layout_row+0x1f4>)
 8012cd2:	f00a fea1 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 8012cd6:	697b      	ldr	r3, [r7, #20]
 8012cd8:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012cdc:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012ce0:	2b00      	cmp	r3, #0
 8012ce2:	d105      	bne.n	8012cf0 <nk_layout_row+0x44>
 8012ce4:	4b6f      	ldr	r3, [pc, #444]	; (8012ea4 <nk_layout_row+0x1f8>)
 8012ce6:	4a6d      	ldr	r2, [pc, #436]	; (8012e9c <nk_layout_row+0x1f0>)
 8012ce8:	21ee      	movs	r1, #238	; 0xee
 8012cea:	486d      	ldr	r0, [pc, #436]	; (8012ea0 <nk_layout_row+0x1f4>)
 8012cec:	f00a fe94 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 8012cf0:	697b      	ldr	r3, [r7, #20]
 8012cf2:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012cf6:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012cfa:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8012cfe:	2b00      	cmp	r3, #0
 8012d00:	d105      	bne.n	8012d0e <nk_layout_row+0x62>
 8012d02:	4b69      	ldr	r3, [pc, #420]	; (8012ea8 <nk_layout_row+0x1fc>)
 8012d04:	4a65      	ldr	r2, [pc, #404]	; (8012e9c <nk_layout_row+0x1f0>)
 8012d06:	21ef      	movs	r1, #239	; 0xef
 8012d08:	4865      	ldr	r0, [pc, #404]	; (8012ea0 <nk_layout_row+0x1f4>)
 8012d0a:	f00a fe85 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout)
 8012d0e:	697b      	ldr	r3, [r7, #20]
 8012d10:	2b00      	cmp	r3, #0
 8012d12:	f000 80bd 	beq.w	8012e90 <nk_layout_row+0x1e4>
 8012d16:	697b      	ldr	r3, [r7, #20]
 8012d18:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012d1c:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012d20:	2b00      	cmp	r3, #0
 8012d22:	f000 80b5 	beq.w	8012e90 <nk_layout_row+0x1e4>
 8012d26:	697b      	ldr	r3, [r7, #20]
 8012d28:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012d2c:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012d30:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8012d34:	2b00      	cmp	r3, #0
 8012d36:	f000 80ab 	beq.w	8012e90 <nk_layout_row+0x1e4>
        return;

    win = ctx->current;
 8012d3a:	697b      	ldr	r3, [r7, #20]
 8012d3c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012d40:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012d44:	623b      	str	r3, [r7, #32]
    layout = win->layout;
 8012d46:	6a3b      	ldr	r3, [r7, #32]
 8012d48:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8012d4c:	61fb      	str	r3, [r7, #28]
    nk_panel_layout(ctx, win, height, cols);
 8012d4e:	68ba      	ldr	r2, [r7, #8]
 8012d50:	ed97 0a03 	vldr	s0, [r7, #12]
 8012d54:	6a39      	ldr	r1, [r7, #32]
 8012d56:	6978      	ldr	r0, [r7, #20]
 8012d58:	f7ff fdfa 	bl	8012950 <nk_panel_layout>
    if (fmt == NK_DYNAMIC) {
 8012d5c:	7cfb      	ldrb	r3, [r7, #19]
 8012d5e:	2b00      	cmp	r3, #0
 8012d60:	d17b      	bne.n	8012e5a <nk_layout_row+0x1ae>
        /* calculate width of undefined widget ratios */
        float r = 0;
 8012d62:	f04f 0300 	mov.w	r3, #0
 8012d66:	627b      	str	r3, [r7, #36]	; 0x24
        layout->row.ratio = ratio;
 8012d68:	69fb      	ldr	r3, [r7, #28]
 8012d6a:	687a      	ldr	r2, [r7, #4]
 8012d6c:	679a      	str	r2, [r3, #120]	; 0x78
        for (i = 0; i < cols; ++i) {
 8012d6e:	2300      	movs	r3, #0
 8012d70:	62fb      	str	r3, [r7, #44]	; 0x2c
 8012d72:	e01d      	b.n	8012db0 <nk_layout_row+0x104>
            if (ratio[i] < 0.0f)
 8012d74:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012d76:	009b      	lsls	r3, r3, #2
 8012d78:	687a      	ldr	r2, [r7, #4]
 8012d7a:	4413      	add	r3, r2
 8012d7c:	edd3 7a00 	vldr	s15, [r3]
 8012d80:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8012d84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012d88:	d503      	bpl.n	8012d92 <nk_layout_row+0xe6>
                n_undef++;
 8012d8a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012d8c:	3301      	adds	r3, #1
 8012d8e:	62bb      	str	r3, [r7, #40]	; 0x28
 8012d90:	e00b      	b.n	8012daa <nk_layout_row+0xfe>
            else r += ratio[i];
 8012d92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012d94:	009b      	lsls	r3, r3, #2
 8012d96:	687a      	ldr	r2, [r7, #4]
 8012d98:	4413      	add	r3, r2
 8012d9a:	edd3 7a00 	vldr	s15, [r3]
 8012d9e:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 8012da2:	ee77 7a27 	vadd.f32	s15, s14, s15
 8012da6:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
        for (i = 0; i < cols; ++i) {
 8012daa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012dac:	3301      	adds	r3, #1
 8012dae:	62fb      	str	r3, [r7, #44]	; 0x2c
 8012db0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8012db2:	68bb      	ldr	r3, [r7, #8]
 8012db4:	429a      	cmp	r2, r3
 8012db6:	dbdd      	blt.n	8012d74 <nk_layout_row+0xc8>
        }
        r = NK_SATURATE(1.0f - r);
 8012db8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8012dbc:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8012dc0:	ee77 7a67 	vsub.f32	s15, s14, s15
 8012dc4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8012dc8:	eef4 7ac7 	vcmpe.f32	s15, s14
 8012dcc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012dd0:	dc0a      	bgt.n	8012de8 <nk_layout_row+0x13c>
 8012dd2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8012dd6:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8012dda:	ee77 7a67 	vsub.f32	s15, s14, s15
 8012dde:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8012de2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012de6:	dd16      	ble.n	8012e16 <nk_layout_row+0x16a>
 8012de8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8012dec:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8012df0:	ee77 7a67 	vsub.f32	s15, s14, s15
 8012df4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8012df8:	eef4 7ac7 	vcmpe.f32	s15, s14
 8012dfc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012e00:	dd02      	ble.n	8012e08 <nk_layout_row+0x15c>
 8012e02:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8012e06:	e008      	b.n	8012e1a <nk_layout_row+0x16e>
 8012e08:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8012e0c:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8012e10:	ee77 7a67 	vsub.f32	s15, s14, s15
 8012e14:	e001      	b.n	8012e1a <nk_layout_row+0x16e>
 8012e16:	eddf 7a25 	vldr	s15, [pc, #148]	; 8012eac <nk_layout_row+0x200>
 8012e1a:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
        layout->row.type = NK_LAYOUT_DYNAMIC;
 8012e1e:	69fb      	ldr	r3, [r7, #28]
 8012e20:	2203      	movs	r2, #3
 8012e22:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
        layout->row.item_width = (r > 0 && n_undef > 0) ? (r / (float)n_undef):0;
 8012e26:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8012e2a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8012e2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012e32:	dd0c      	ble.n	8012e4e <nk_layout_row+0x1a2>
 8012e34:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012e36:	2b00      	cmp	r3, #0
 8012e38:	dd09      	ble.n	8012e4e <nk_layout_row+0x1a2>
 8012e3a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012e3c:	ee07 3a90 	vmov	s15, r3
 8012e40:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8012e44:	edd7 6a09 	vldr	s13, [r7, #36]	; 0x24
 8012e48:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8012e4c:	e001      	b.n	8012e52 <nk_layout_row+0x1a6>
 8012e4e:	eddf 7a17 	vldr	s15, [pc, #92]	; 8012eac <nk_layout_row+0x200>
 8012e52:	69fb      	ldr	r3, [r7, #28]
 8012e54:	edc3 7a1f 	vstr	s15, [r3, #124]	; 0x7c
 8012e58:	e00f      	b.n	8012e7a <nk_layout_row+0x1ce>
    } else {
        layout->row.ratio = ratio;
 8012e5a:	69fb      	ldr	r3, [r7, #28]
 8012e5c:	687a      	ldr	r2, [r7, #4]
 8012e5e:	679a      	str	r2, [r3, #120]	; 0x78
        layout->row.type = NK_LAYOUT_STATIC;
 8012e60:	69fb      	ldr	r3, [r7, #28]
 8012e62:	2207      	movs	r2, #7
 8012e64:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
        layout->row.item_width = 0;
 8012e68:	69fb      	ldr	r3, [r7, #28]
 8012e6a:	f04f 0200 	mov.w	r2, #0
 8012e6e:	67da      	str	r2, [r3, #124]	; 0x7c
        layout->row.item_offset = 0;
 8012e70:	69fb      	ldr	r3, [r7, #28]
 8012e72:	f04f 0200 	mov.w	r2, #0
 8012e76:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    }
    layout->row.item_offset = 0;
 8012e7a:	69fb      	ldr	r3, [r7, #28]
 8012e7c:	f04f 0200 	mov.w	r2, #0
 8012e80:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    layout->row.filled = 0;
 8012e84:	69fb      	ldr	r3, [r7, #28]
 8012e86:	f04f 0200 	mov.w	r2, #0
 8012e8a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 8012e8e:	e000      	b.n	8012e92 <nk_layout_row+0x1e6>
        return;
 8012e90:	bf00      	nop
}
 8012e92:	3730      	adds	r7, #48	; 0x30
 8012e94:	46bd      	mov	sp, r7
 8012e96:	bd80      	pop	{r7, pc}
 8012e98:	08021768 	.word	0x08021768
 8012e9c:	08023508 	.word	0x08023508
 8012ea0:	0802176c 	.word	0x0802176c
 8012ea4:	08021788 	.word	0x08021788
 8012ea8:	08021798 	.word	0x08021798
 8012eac:	00000000 	.word	0x00000000

08012eb0 <nk_panel_alloc_row>:
    ret.y += -layout->at_y + (float)*layout->offset_y;
    return ret;
}
NK_LIB void
nk_panel_alloc_row(const struct nk_context *ctx, struct nk_window *win)
{
 8012eb0:	b580      	push	{r7, lr}
 8012eb2:	b086      	sub	sp, #24
 8012eb4:	af00      	add	r7, sp, #0
 8012eb6:	6078      	str	r0, [r7, #4]
 8012eb8:	6039      	str	r1, [r7, #0]
    struct nk_panel *layout = win->layout;
 8012eba:	683b      	ldr	r3, [r7, #0]
 8012ebc:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8012ec0:	617b      	str	r3, [r7, #20]
    struct nk_vec2 spacing = ctx->style.window.spacing;
 8012ec2:	687b      	ldr	r3, [r7, #4]
 8012ec4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8012ec8:	461a      	mov	r2, r3
 8012eca:	f107 0308 	add.w	r3, r7, #8
 8012ece:	f602 223c 	addw	r2, r2, #2620	; 0xa3c
 8012ed2:	e892 0003 	ldmia.w	r2, {r0, r1}
 8012ed6:	e883 0003 	stmia.w	r3, {r0, r1}
    const float row_height = layout->row.height - spacing.y;
 8012eda:	697b      	ldr	r3, [r7, #20]
 8012edc:	ed93 7a1b 	vldr	s14, [r3, #108]	; 0x6c
 8012ee0:	edd7 7a03 	vldr	s15, [r7, #12]
 8012ee4:	ee77 7a67 	vsub.f32	s15, s14, s15
 8012ee8:	edc7 7a04 	vstr	s15, [r7, #16]
    nk_panel_layout(ctx, win, row_height, layout->row.columns);
 8012eec:	697b      	ldr	r3, [r7, #20]
 8012eee:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8012ef0:	461a      	mov	r2, r3
 8012ef2:	ed97 0a04 	vldr	s0, [r7, #16]
 8012ef6:	6839      	ldr	r1, [r7, #0]
 8012ef8:	6878      	ldr	r0, [r7, #4]
 8012efa:	f7ff fd29 	bl	8012950 <nk_panel_layout>
}
 8012efe:	bf00      	nop
 8012f00:	3718      	adds	r7, #24
 8012f02:	46bd      	mov	sp, r7
 8012f04:	bd80      	pop	{r7, pc}
	...

08012f08 <nk_layout_widget_space>:
NK_LIB void
nk_layout_widget_space(struct nk_rect *bounds, const struct nk_context *ctx,
    struct nk_window *win, int modify)
{
 8012f08:	b580      	push	{r7, lr}
 8012f0a:	b092      	sub	sp, #72	; 0x48
 8012f0c:	af00      	add	r7, sp, #0
 8012f0e:	60f8      	str	r0, [r7, #12]
 8012f10:	60b9      	str	r1, [r7, #8]
 8012f12:	607a      	str	r2, [r7, #4]
 8012f14:	603b      	str	r3, [r7, #0]
    struct nk_panel *layout;
    const struct nk_style *style;

    struct nk_vec2 spacing;

    float item_offset = 0;
 8012f16:	f04f 0300 	mov.w	r3, #0
 8012f1a:	647b      	str	r3, [r7, #68]	; 0x44
    float item_width = 0;
 8012f1c:	f04f 0300 	mov.w	r3, #0
 8012f20:	643b      	str	r3, [r7, #64]	; 0x40
    float item_spacing = 0;
 8012f22:	f04f 0300 	mov.w	r3, #0
 8012f26:	63fb      	str	r3, [r7, #60]	; 0x3c
    float panel_space = 0;
 8012f28:	f04f 0300 	mov.w	r3, #0
 8012f2c:	63bb      	str	r3, [r7, #56]	; 0x38

    NK_ASSERT(ctx);
 8012f2e:	68bb      	ldr	r3, [r7, #8]
 8012f30:	2b00      	cmp	r3, #0
 8012f32:	d106      	bne.n	8012f42 <nk_layout_widget_space+0x3a>
 8012f34:	4bc4      	ldr	r3, [pc, #784]	; (8013248 <nk_layout_widget_space+0x340>)
 8012f36:	4ac5      	ldr	r2, [pc, #788]	; (801324c <nk_layout_widget_space+0x344>)
 8012f38:	f240 214d 	movw	r1, #589	; 0x24d
 8012f3c:	48c4      	ldr	r0, [pc, #784]	; (8013250 <nk_layout_widget_space+0x348>)
 8012f3e:	f00a fd6b 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 8012f42:	68bb      	ldr	r3, [r7, #8]
 8012f44:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012f48:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012f4c:	2b00      	cmp	r3, #0
 8012f4e:	d106      	bne.n	8012f5e <nk_layout_widget_space+0x56>
 8012f50:	4bc0      	ldr	r3, [pc, #768]	; (8013254 <nk_layout_widget_space+0x34c>)
 8012f52:	4abe      	ldr	r2, [pc, #760]	; (801324c <nk_layout_widget_space+0x344>)
 8012f54:	f240 214e 	movw	r1, #590	; 0x24e
 8012f58:	48bd      	ldr	r0, [pc, #756]	; (8013250 <nk_layout_widget_space+0x348>)
 8012f5a:	f00a fd5d 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 8012f5e:	68bb      	ldr	r3, [r7, #8]
 8012f60:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012f64:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012f68:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8012f6c:	2b00      	cmp	r3, #0
 8012f6e:	d106      	bne.n	8012f7e <nk_layout_widget_space+0x76>
 8012f70:	4bb9      	ldr	r3, [pc, #740]	; (8013258 <nk_layout_widget_space+0x350>)
 8012f72:	4ab6      	ldr	r2, [pc, #728]	; (801324c <nk_layout_widget_space+0x344>)
 8012f74:	f240 214f 	movw	r1, #591	; 0x24f
 8012f78:	48b5      	ldr	r0, [pc, #724]	; (8013250 <nk_layout_widget_space+0x348>)
 8012f7a:	f00a fd4d 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout)
 8012f7e:	68bb      	ldr	r3, [r7, #8]
 8012f80:	2b00      	cmp	r3, #0
 8012f82:	f000 8340 	beq.w	8013606 <nk_layout_widget_space+0x6fe>
 8012f86:	68bb      	ldr	r3, [r7, #8]
 8012f88:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012f8c:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012f90:	2b00      	cmp	r3, #0
 8012f92:	f000 8338 	beq.w	8013606 <nk_layout_widget_space+0x6fe>
 8012f96:	68bb      	ldr	r3, [r7, #8]
 8012f98:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012f9c:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012fa0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8012fa4:	2b00      	cmp	r3, #0
 8012fa6:	f000 832e 	beq.w	8013606 <nk_layout_widget_space+0x6fe>
        return;

    win = ctx->current;
 8012faa:	68bb      	ldr	r3, [r7, #8]
 8012fac:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8012fb0:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8012fb4:	607b      	str	r3, [r7, #4]
    layout = win->layout;
 8012fb6:	687b      	ldr	r3, [r7, #4]
 8012fb8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8012fbc:	637b      	str	r3, [r7, #52]	; 0x34
    style = &ctx->style;
 8012fbe:	68bb      	ldr	r3, [r7, #8]
 8012fc0:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 8012fc4:	633b      	str	r3, [r7, #48]	; 0x30
    NK_ASSERT(bounds);
 8012fc6:	68fb      	ldr	r3, [r7, #12]
 8012fc8:	2b00      	cmp	r3, #0
 8012fca:	d106      	bne.n	8012fda <nk_layout_widget_space+0xd2>
 8012fcc:	4ba3      	ldr	r3, [pc, #652]	; (801325c <nk_layout_widget_space+0x354>)
 8012fce:	4a9f      	ldr	r2, [pc, #636]	; (801324c <nk_layout_widget_space+0x344>)
 8012fd0:	f240 2156 	movw	r1, #598	; 0x256
 8012fd4:	489e      	ldr	r0, [pc, #632]	; (8013250 <nk_layout_widget_space+0x348>)
 8012fd6:	f00a fd1f 	bl	801da18 <__assert_func>

    spacing = style->window.spacing;
 8012fda:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012fdc:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8012fe0:	461a      	mov	r2, r3
 8012fe2:	f107 0314 	add.w	r3, r7, #20
 8012fe6:	f602 02d4 	addw	r2, r2, #2260	; 0x8d4
 8012fea:	e892 0003 	ldmia.w	r2, {r0, r1}
 8012fee:	e883 0003 	stmia.w	r3, {r0, r1}
    panel_space = nk_layout_row_calculate_usable_space(&ctx->style, layout->type,
 8012ff2:	68bb      	ldr	r3, [r7, #8]
 8012ff4:	f503 70b4 	add.w	r0, r3, #360	; 0x168
 8012ff8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012ffa:	7819      	ldrb	r1, [r3, #0]
 8012ffc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012ffe:	edd3 7a04 	vldr	s15, [r3, #16]
 8013002:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013004:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8013006:	461a      	mov	r2, r3
 8013008:	eeb0 0a67 	vmov.f32	s0, s15
 801300c:	f7ff fc64 	bl	80128d8 <nk_layout_row_calculate_usable_space>
 8013010:	ed87 0a0e 	vstr	s0, [r7, #56]	; 0x38
                                            layout->bounds.w, layout->row.columns);

    #define NK_FRAC(x) (x - (float)(int)x) /* will be used to remove fookin gaps */
    /* calculate the width of one item inside the current layout space */
    switch (layout->row.type) {
 8013014:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013016:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 801301a:	2b08      	cmp	r3, #8
 801301c:	f200 828b 	bhi.w	8013536 <nk_layout_widget_space+0x62e>
 8013020:	a201      	add	r2, pc, #4	; (adr r2, 8013028 <nk_layout_widget_space+0x120>)
 8013022:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8013026:	bf00      	nop
 8013028:	0801304d 	.word	0x0801304d
 801302c:	080130cf 	.word	0x080130cf
 8013030:	08013151 	.word	0x08013151
 8013034:	08013233 	.word	0x08013233
 8013038:	08013317 	.word	0x08013317
 801303c:	0801334f 	.word	0x0801334f
 8013040:	08013393 	.word	0x08013393
 8013044:	0801344d 	.word	0x0801344d
 8013048:	08013499 	.word	0x08013499
    case NK_LAYOUT_DYNAMIC_FIXED: {
        /* scaling fixed size widgets item width */
        float w = NK_MAX(1.0f,panel_space) / (float)layout->row.columns;
 801304c:	edd7 7a0e 	vldr	s15, [r7, #56]	; 0x38
 8013050:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8013054:	eef4 7ac7 	vcmpe.f32	s15, s14
 8013058:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801305c:	dd02      	ble.n	8013064 <nk_layout_widget_space+0x15c>
 801305e:	edd7 7a0e 	vldr	s15, [r7, #56]	; 0x38
 8013062:	e001      	b.n	8013068 <nk_layout_widget_space+0x160>
 8013064:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8013068:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801306a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801306c:	ee07 3a10 	vmov	s14, r3
 8013070:	eef8 6ac7 	vcvt.f32.s32	s13, s14
 8013074:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8013078:	ed87 7a07 	vstr	s14, [r7, #28]
        item_offset = (float)layout->row.index * w;
 801307c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801307e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8013080:	ee07 3a90 	vmov	s15, r3
 8013084:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013088:	ed97 7a07 	vldr	s14, [r7, #28]
 801308c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8013090:	edc7 7a11 	vstr	s15, [r7, #68]	; 0x44
        item_width = w + NK_FRAC(item_offset);
 8013094:	edd7 7a11 	vldr	s15, [r7, #68]	; 0x44
 8013098:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801309c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80130a0:	ed97 7a11 	vldr	s14, [r7, #68]	; 0x44
 80130a4:	ee77 7a67 	vsub.f32	s15, s14, s15
 80130a8:	ed97 7a07 	vldr	s14, [r7, #28]
 80130ac:	ee77 7a27 	vadd.f32	s15, s14, s15
 80130b0:	edc7 7a10 	vstr	s15, [r7, #64]	; 0x40
        item_spacing = (float)layout->row.index * spacing.x;
 80130b4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80130b6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80130b8:	ee07 3a90 	vmov	s15, r3
 80130bc:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 80130c0:	edd7 7a05 	vldr	s15, [r7, #20]
 80130c4:	ee67 7a27 	vmul.f32	s15, s14, s15
 80130c8:	edc7 7a0f 	vstr	s15, [r7, #60]	; 0x3c
    } break;
 80130cc:	e243      	b.n	8013556 <nk_layout_widget_space+0x64e>
    case NK_LAYOUT_DYNAMIC_ROW: {
        /* scaling single ratio widget width */
        float w = layout->row.item_width * panel_space;
 80130ce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80130d0:	edd3 7a1f 	vldr	s15, [r3, #124]	; 0x7c
 80130d4:	ed97 7a0e 	vldr	s14, [r7, #56]	; 0x38
 80130d8:	ee67 7a27 	vmul.f32	s15, s14, s15
 80130dc:	edc7 7a08 	vstr	s15, [r7, #32]
        item_offset = layout->row.item_offset;
 80130e0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80130e2:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80130e6:	647b      	str	r3, [r7, #68]	; 0x44
        item_width = w + NK_FRAC(item_offset);
 80130e8:	edd7 7a11 	vldr	s15, [r7, #68]	; 0x44
 80130ec:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80130f0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80130f4:	ed97 7a11 	vldr	s14, [r7, #68]	; 0x44
 80130f8:	ee77 7a67 	vsub.f32	s15, s14, s15
 80130fc:	ed97 7a08 	vldr	s14, [r7, #32]
 8013100:	ee77 7a27 	vadd.f32	s15, s14, s15
 8013104:	edc7 7a10 	vstr	s15, [r7, #64]	; 0x40
        item_spacing = 0;
 8013108:	f04f 0300 	mov.w	r3, #0
 801310c:	63fb      	str	r3, [r7, #60]	; 0x3c

        if (modify) {
 801310e:	683b      	ldr	r3, [r7, #0]
 8013110:	2b00      	cmp	r3, #0
 8013112:	f000 8217 	beq.w	8013544 <nk_layout_widget_space+0x63c>
            layout->row.item_offset += w + spacing.x;
 8013116:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013118:	ed93 7a21 	vldr	s14, [r3, #132]	; 0x84
 801311c:	edd7 6a05 	vldr	s13, [r7, #20]
 8013120:	edd7 7a08 	vldr	s15, [r7, #32]
 8013124:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8013128:	ee77 7a27 	vadd.f32	s15, s14, s15
 801312c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801312e:	edc3 7a21 	vstr	s15, [r3, #132]	; 0x84
            layout->row.filled += layout->row.item_width;
 8013132:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013134:	ed93 7a22 	vldr	s14, [r3, #136]	; 0x88
 8013138:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801313a:	edd3 7a1f 	vldr	s15, [r3, #124]	; 0x7c
 801313e:	ee77 7a27 	vadd.f32	s15, s14, s15
 8013142:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013144:	edc3 7a22 	vstr	s15, [r3, #136]	; 0x88
            layout->row.index = 0;
 8013148:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801314a:	2200      	movs	r2, #0
 801314c:	669a      	str	r2, [r3, #104]	; 0x68
        }
    } break;
 801314e:	e1f9      	b.n	8013544 <nk_layout_widget_space+0x63c>
    case NK_LAYOUT_DYNAMIC_FREE: {
        /* panel width depended free widget placing */
        bounds->x = layout->at_x + (layout->bounds.w * layout->row.item.x);
 8013150:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013152:	ed93 7a08 	vldr	s14, [r3, #32]
 8013156:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013158:	edd3 6a04 	vldr	s13, [r3, #16]
 801315c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801315e:	edd3 7a23 	vldr	s15, [r3, #140]	; 0x8c
 8013162:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8013166:	ee77 7a27 	vadd.f32	s15, s14, s15
 801316a:	68fb      	ldr	r3, [r7, #12]
 801316c:	edc3 7a00 	vstr	s15, [r3]
        bounds->x -= (float)*layout->offset_x;
 8013170:	68fb      	ldr	r3, [r7, #12]
 8013172:	ed93 7a00 	vldr	s14, [r3]
 8013176:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013178:	699b      	ldr	r3, [r3, #24]
 801317a:	681b      	ldr	r3, [r3, #0]
 801317c:	ee07 3a90 	vmov	s15, r3
 8013180:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013184:	ee77 7a67 	vsub.f32	s15, s14, s15
 8013188:	68fb      	ldr	r3, [r7, #12]
 801318a:	edc3 7a00 	vstr	s15, [r3]
        bounds->y = layout->at_y + (layout->row.height * layout->row.item.y);
 801318e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013190:	ed93 7a09 	vldr	s14, [r3, #36]	; 0x24
 8013194:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013196:	edd3 6a1b 	vldr	s13, [r3, #108]	; 0x6c
 801319a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801319c:	edd3 7a24 	vldr	s15, [r3, #144]	; 0x90
 80131a0:	ee66 7aa7 	vmul.f32	s15, s13, s15
 80131a4:	ee77 7a27 	vadd.f32	s15, s14, s15
 80131a8:	68fb      	ldr	r3, [r7, #12]
 80131aa:	edc3 7a01 	vstr	s15, [r3, #4]
        bounds->y -= (float)*layout->offset_y;
 80131ae:	68fb      	ldr	r3, [r7, #12]
 80131b0:	ed93 7a01 	vldr	s14, [r3, #4]
 80131b4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80131b6:	69db      	ldr	r3, [r3, #28]
 80131b8:	681b      	ldr	r3, [r3, #0]
 80131ba:	ee07 3a90 	vmov	s15, r3
 80131be:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80131c2:	ee77 7a67 	vsub.f32	s15, s14, s15
 80131c6:	68fb      	ldr	r3, [r7, #12]
 80131c8:	edc3 7a01 	vstr	s15, [r3, #4]
        bounds->w = layout->bounds.w  * layout->row.item.w + NK_FRAC(bounds->x);
 80131cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80131ce:	ed93 7a04 	vldr	s14, [r3, #16]
 80131d2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80131d4:	edd3 7a25 	vldr	s15, [r3, #148]	; 0x94
 80131d8:	ee27 7a27 	vmul.f32	s14, s14, s15
 80131dc:	68fb      	ldr	r3, [r7, #12]
 80131de:	edd3 6a00 	vldr	s13, [r3]
 80131e2:	68fb      	ldr	r3, [r7, #12]
 80131e4:	edd3 7a00 	vldr	s15, [r3]
 80131e8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80131ec:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80131f0:	ee76 7ae7 	vsub.f32	s15, s13, s15
 80131f4:	ee77 7a27 	vadd.f32	s15, s14, s15
 80131f8:	68fb      	ldr	r3, [r7, #12]
 80131fa:	edc3 7a02 	vstr	s15, [r3, #8]
        bounds->h = layout->row.height * layout->row.item.h + NK_FRAC(bounds->y);
 80131fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013200:	ed93 7a1b 	vldr	s14, [r3, #108]	; 0x6c
 8013204:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013206:	edd3 7a26 	vldr	s15, [r3, #152]	; 0x98
 801320a:	ee27 7a27 	vmul.f32	s14, s14, s15
 801320e:	68fb      	ldr	r3, [r7, #12]
 8013210:	edd3 6a01 	vldr	s13, [r3, #4]
 8013214:	68fb      	ldr	r3, [r7, #12]
 8013216:	edd3 7a01 	vldr	s15, [r3, #4]
 801321a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801321e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013222:	ee76 7ae7 	vsub.f32	s15, s13, s15
 8013226:	ee77 7a27 	vadd.f32	s15, s14, s15
 801322a:	68fb      	ldr	r3, [r7, #12]
 801322c:	edc3 7a03 	vstr	s15, [r3, #12]
        return;
 8013230:	e1ea      	b.n	8013608 <nk_layout_widget_space+0x700>
    }
    case NK_LAYOUT_DYNAMIC: {
        /* scaling arrays of panel width ratios for every widget */
        float ratio, w;
        NK_ASSERT(layout->row.ratio);
 8013232:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013234:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8013236:	2b00      	cmp	r3, #0
 8013238:	d114      	bne.n	8013264 <nk_layout_widget_space+0x35c>
 801323a:	4b09      	ldr	r3, [pc, #36]	; (8013260 <nk_layout_widget_space+0x358>)
 801323c:	4a03      	ldr	r2, [pc, #12]	; (801324c <nk_layout_widget_space+0x344>)
 801323e:	f44f 7120 	mov.w	r1, #640	; 0x280
 8013242:	4803      	ldr	r0, [pc, #12]	; (8013250 <nk_layout_widget_space+0x348>)
 8013244:	f00a fbe8 	bl	801da18 <__assert_func>
 8013248:	08021768 	.word	0x08021768
 801324c:	08023518 	.word	0x08023518
 8013250:	0802176c 	.word	0x0802176c
 8013254:	08021788 	.word	0x08021788
 8013258:	08021798 	.word	0x08021798
 801325c:	080218c8 	.word	0x080218c8
 8013260:	080218d0 	.word	0x080218d0
        ratio = (layout->row.ratio[layout->row.index] < 0) ?
 8013264:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013266:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8013268:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801326a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801326c:	009b      	lsls	r3, r3, #2
 801326e:	4413      	add	r3, r2
 8013270:	edd3 7a00 	vldr	s15, [r3]
            layout->row.item_width : layout->row.ratio[layout->row.index];
 8013274:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8013278:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801327c:	d502      	bpl.n	8013284 <nk_layout_widget_space+0x37c>
 801327e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013280:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8013282:	e006      	b.n	8013292 <nk_layout_widget_space+0x38a>
 8013284:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013286:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8013288:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801328a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801328c:	009b      	lsls	r3, r3, #2
 801328e:	4413      	add	r3, r2
 8013290:	681b      	ldr	r3, [r3, #0]
        ratio = (layout->row.ratio[layout->row.index] < 0) ?
 8013292:	62bb      	str	r3, [r7, #40]	; 0x28

        w = (ratio * panel_space);
 8013294:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
 8013298:	edd7 7a0e 	vldr	s15, [r7, #56]	; 0x38
 801329c:	ee67 7a27 	vmul.f32	s15, s14, s15
 80132a0:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
        item_spacing = (float)layout->row.index * spacing.x;
 80132a4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80132a6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80132a8:	ee07 3a90 	vmov	s15, r3
 80132ac:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 80132b0:	edd7 7a05 	vldr	s15, [r7, #20]
 80132b4:	ee67 7a27 	vmul.f32	s15, s14, s15
 80132b8:	edc7 7a0f 	vstr	s15, [r7, #60]	; 0x3c
        item_offset = layout->row.item_offset;
 80132bc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80132be:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80132c2:	647b      	str	r3, [r7, #68]	; 0x44
        item_width = w + NK_FRAC(item_offset);
 80132c4:	edd7 7a11 	vldr	s15, [r7, #68]	; 0x44
 80132c8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80132cc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80132d0:	ed97 7a11 	vldr	s14, [r7, #68]	; 0x44
 80132d4:	ee77 7a67 	vsub.f32	s15, s14, s15
 80132d8:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 80132dc:	ee77 7a27 	vadd.f32	s15, s14, s15
 80132e0:	edc7 7a10 	vstr	s15, [r7, #64]	; 0x40

        if (modify) {
 80132e4:	683b      	ldr	r3, [r7, #0]
 80132e6:	2b00      	cmp	r3, #0
 80132e8:	f000 812e 	beq.w	8013548 <nk_layout_widget_space+0x640>
            layout->row.item_offset += w;
 80132ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80132ee:	ed93 7a21 	vldr	s14, [r3, #132]	; 0x84
 80132f2:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 80132f6:	ee77 7a27 	vadd.f32	s15, s14, s15
 80132fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80132fc:	edc3 7a21 	vstr	s15, [r3, #132]	; 0x84
            layout->row.filled += ratio;
 8013300:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013302:	ed93 7a22 	vldr	s14, [r3, #136]	; 0x88
 8013306:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
 801330a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801330e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013310:	edc3 7a22 	vstr	s15, [r3, #136]	; 0x88
        }
    } break;
 8013314:	e118      	b.n	8013548 <nk_layout_widget_space+0x640>
    case NK_LAYOUT_STATIC_FIXED: {
        /* non-scaling fixed widgets item width */
        item_width = layout->row.item_width;
 8013316:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013318:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 801331a:	643b      	str	r3, [r7, #64]	; 0x40
        item_offset = (float)layout->row.index * item_width;
 801331c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801331e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8013320:	ee07 3a90 	vmov	s15, r3
 8013324:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013328:	ed97 7a10 	vldr	s14, [r7, #64]	; 0x40
 801332c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8013330:	edc7 7a11 	vstr	s15, [r7, #68]	; 0x44
        item_spacing = (float)layout->row.index * spacing.x;
 8013334:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013336:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8013338:	ee07 3a90 	vmov	s15, r3
 801333c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8013340:	edd7 7a05 	vldr	s15, [r7, #20]
 8013344:	ee67 7a27 	vmul.f32	s15, s14, s15
 8013348:	edc7 7a0f 	vstr	s15, [r7, #60]	; 0x3c
    } break;
 801334c:	e103      	b.n	8013556 <nk_layout_widget_space+0x64e>
    case NK_LAYOUT_STATIC_ROW: {
        /* scaling single ratio widget width */
        item_width = layout->row.item_width;
 801334e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013350:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8013352:	643b      	str	r3, [r7, #64]	; 0x40
        item_offset = layout->row.item_offset;
 8013354:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013356:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 801335a:	647b      	str	r3, [r7, #68]	; 0x44
        item_spacing = (float)layout->row.index * spacing.x;
 801335c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801335e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8013360:	ee07 3a90 	vmov	s15, r3
 8013364:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8013368:	edd7 7a05 	vldr	s15, [r7, #20]
 801336c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8013370:	edc7 7a0f 	vstr	s15, [r7, #60]	; 0x3c
        if (modify) layout->row.item_offset += item_width;
 8013374:	683b      	ldr	r3, [r7, #0]
 8013376:	2b00      	cmp	r3, #0
 8013378:	f000 80e8 	beq.w	801354c <nk_layout_widget_space+0x644>
 801337c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801337e:	ed93 7a21 	vldr	s14, [r3, #132]	; 0x84
 8013382:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
 8013386:	ee77 7a27 	vadd.f32	s15, s14, s15
 801338a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801338c:	edc3 7a21 	vstr	s15, [r3, #132]	; 0x84
    } break;
 8013390:	e0dc      	b.n	801354c <nk_layout_widget_space+0x644>
    case NK_LAYOUT_STATIC_FREE: {
        /* free widget placing */
        bounds->x = layout->at_x + layout->row.item.x;
 8013392:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013394:	ed93 7a08 	vldr	s14, [r3, #32]
 8013398:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801339a:	edd3 7a23 	vldr	s15, [r3, #140]	; 0x8c
 801339e:	ee77 7a27 	vadd.f32	s15, s14, s15
 80133a2:	68fb      	ldr	r3, [r7, #12]
 80133a4:	edc3 7a00 	vstr	s15, [r3]
        bounds->w = layout->row.item.w;
 80133a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80133aa:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 80133ae:	68fb      	ldr	r3, [r7, #12]
 80133b0:	609a      	str	r2, [r3, #8]
        if (((bounds->x + bounds->w) > layout->max_x) && modify)
 80133b2:	68fb      	ldr	r3, [r7, #12]
 80133b4:	ed93 7a00 	vldr	s14, [r3]
 80133b8:	68fb      	ldr	r3, [r7, #12]
 80133ba:	edd3 7a02 	vldr	s15, [r3, #8]
 80133be:	ee37 7a27 	vadd.f32	s14, s14, s15
 80133c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80133c4:	edd3 7a0a 	vldr	s15, [r3, #40]	; 0x28
 80133c8:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80133cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80133d0:	dd0d      	ble.n	80133ee <nk_layout_widget_space+0x4e6>
 80133d2:	683b      	ldr	r3, [r7, #0]
 80133d4:	2b00      	cmp	r3, #0
 80133d6:	d00a      	beq.n	80133ee <nk_layout_widget_space+0x4e6>
            layout->max_x = (bounds->x + bounds->w);
 80133d8:	68fb      	ldr	r3, [r7, #12]
 80133da:	ed93 7a00 	vldr	s14, [r3]
 80133de:	68fb      	ldr	r3, [r7, #12]
 80133e0:	edd3 7a02 	vldr	s15, [r3, #8]
 80133e4:	ee77 7a27 	vadd.f32	s15, s14, s15
 80133e8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80133ea:	edc3 7a0a 	vstr	s15, [r3, #40]	; 0x28
        bounds->x -= (float)*layout->offset_x;
 80133ee:	68fb      	ldr	r3, [r7, #12]
 80133f0:	ed93 7a00 	vldr	s14, [r3]
 80133f4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80133f6:	699b      	ldr	r3, [r3, #24]
 80133f8:	681b      	ldr	r3, [r3, #0]
 80133fa:	ee07 3a90 	vmov	s15, r3
 80133fe:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013402:	ee77 7a67 	vsub.f32	s15, s14, s15
 8013406:	68fb      	ldr	r3, [r7, #12]
 8013408:	edc3 7a00 	vstr	s15, [r3]
        bounds->y = layout->at_y + layout->row.item.y;
 801340c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801340e:	ed93 7a09 	vldr	s14, [r3, #36]	; 0x24
 8013412:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013414:	edd3 7a24 	vldr	s15, [r3, #144]	; 0x90
 8013418:	ee77 7a27 	vadd.f32	s15, s14, s15
 801341c:	68fb      	ldr	r3, [r7, #12]
 801341e:	edc3 7a01 	vstr	s15, [r3, #4]
        bounds->y -= (float)*layout->offset_y;
 8013422:	68fb      	ldr	r3, [r7, #12]
 8013424:	ed93 7a01 	vldr	s14, [r3, #4]
 8013428:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801342a:	69db      	ldr	r3, [r3, #28]
 801342c:	681b      	ldr	r3, [r3, #0]
 801342e:	ee07 3a90 	vmov	s15, r3
 8013432:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013436:	ee77 7a67 	vsub.f32	s15, s14, s15
 801343a:	68fb      	ldr	r3, [r7, #12]
 801343c:	edc3 7a01 	vstr	s15, [r3, #4]
        bounds->h = layout->row.item.h;
 8013440:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013442:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 8013446:	68fb      	ldr	r3, [r7, #12]
 8013448:	60da      	str	r2, [r3, #12]
        return;
 801344a:	e0dd      	b.n	8013608 <nk_layout_widget_space+0x700>
    }
    case NK_LAYOUT_STATIC: {
        /* non-scaling array of panel pixel width for every widget */
        item_spacing = (float)layout->row.index * spacing.x;
 801344c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801344e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8013450:	ee07 3a90 	vmov	s15, r3
 8013454:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8013458:	edd7 7a05 	vldr	s15, [r7, #20]
 801345c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8013460:	edc7 7a0f 	vstr	s15, [r7, #60]	; 0x3c
        item_width = layout->row.ratio[layout->row.index];
 8013464:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013466:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8013468:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801346a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801346c:	009b      	lsls	r3, r3, #2
 801346e:	4413      	add	r3, r2
 8013470:	681b      	ldr	r3, [r3, #0]
 8013472:	643b      	str	r3, [r7, #64]	; 0x40
        item_offset = layout->row.item_offset;
 8013474:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013476:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 801347a:	647b      	str	r3, [r7, #68]	; 0x44
        if (modify) layout->row.item_offset += item_width;
 801347c:	683b      	ldr	r3, [r7, #0]
 801347e:	2b00      	cmp	r3, #0
 8013480:	d066      	beq.n	8013550 <nk_layout_widget_space+0x648>
 8013482:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013484:	ed93 7a21 	vldr	s14, [r3, #132]	; 0x84
 8013488:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
 801348c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8013490:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013492:	edc3 7a21 	vstr	s15, [r3, #132]	; 0x84
    } break;
 8013496:	e05b      	b.n	8013550 <nk_layout_widget_space+0x648>
    case NK_LAYOUT_TEMPLATE: {
        /* stretchy row layout with combined dynamic/static widget width*/
        float w;
        NK_ASSERT(layout->row.index < layout->row.columns);
 8013498:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801349a:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 801349c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801349e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80134a0:	429a      	cmp	r2, r3
 80134a2:	db06      	blt.n	80134b2 <nk_layout_widget_space+0x5aa>
 80134a4:	4b5a      	ldr	r3, [pc, #360]	; (8013610 <nk_layout_widget_space+0x708>)
 80134a6:	4a5b      	ldr	r2, [pc, #364]	; (8013614 <nk_layout_widget_space+0x70c>)
 80134a8:	f240 21b1 	movw	r1, #689	; 0x2b1
 80134ac:	485a      	ldr	r0, [pc, #360]	; (8013618 <nk_layout_widget_space+0x710>)
 80134ae:	f00a fab3 	bl	801da18 <__assert_func>
        NK_ASSERT(layout->row.index < NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS);
 80134b2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80134b4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80134b6:	2b0f      	cmp	r3, #15
 80134b8:	dd06      	ble.n	80134c8 <nk_layout_widget_space+0x5c0>
 80134ba:	4b58      	ldr	r3, [pc, #352]	; (801361c <nk_layout_widget_space+0x714>)
 80134bc:	4a55      	ldr	r2, [pc, #340]	; (8013614 <nk_layout_widget_space+0x70c>)
 80134be:	f240 21b2 	movw	r1, #690	; 0x2b2
 80134c2:	4855      	ldr	r0, [pc, #340]	; (8013618 <nk_layout_widget_space+0x710>)
 80134c4:	f00a faa8 	bl	801da18 <__assert_func>
        w = layout->row.templates[layout->row.index];
 80134c8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80134ca:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80134cc:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80134ce:	3326      	adds	r3, #38	; 0x26
 80134d0:	009b      	lsls	r3, r3, #2
 80134d2:	4413      	add	r3, r2
 80134d4:	3308      	adds	r3, #8
 80134d6:	681b      	ldr	r3, [r3, #0]
 80134d8:	62fb      	str	r3, [r7, #44]	; 0x2c
        item_offset = layout->row.item_offset;
 80134da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80134dc:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80134e0:	647b      	str	r3, [r7, #68]	; 0x44
        item_width = w + NK_FRAC(item_offset);
 80134e2:	edd7 7a11 	vldr	s15, [r7, #68]	; 0x44
 80134e6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80134ea:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80134ee:	ed97 7a11 	vldr	s14, [r7, #68]	; 0x44
 80134f2:	ee77 7a67 	vsub.f32	s15, s14, s15
 80134f6:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
 80134fa:	ee77 7a27 	vadd.f32	s15, s14, s15
 80134fe:	edc7 7a10 	vstr	s15, [r7, #64]	; 0x40
        item_spacing = (float)layout->row.index * spacing.x;
 8013502:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013504:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8013506:	ee07 3a90 	vmov	s15, r3
 801350a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801350e:	edd7 7a05 	vldr	s15, [r7, #20]
 8013512:	ee67 7a27 	vmul.f32	s15, s14, s15
 8013516:	edc7 7a0f 	vstr	s15, [r7, #60]	; 0x3c
        if (modify) layout->row.item_offset += w;
 801351a:	683b      	ldr	r3, [r7, #0]
 801351c:	2b00      	cmp	r3, #0
 801351e:	d019      	beq.n	8013554 <nk_layout_widget_space+0x64c>
 8013520:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013522:	ed93 7a21 	vldr	s14, [r3, #132]	; 0x84
 8013526:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
 801352a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801352e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013530:	edc3 7a21 	vstr	s15, [r3, #132]	; 0x84
    } break;
 8013534:	e00e      	b.n	8013554 <nk_layout_widget_space+0x64c>
    #undef NK_FRAC
    default: NK_ASSERT(0); break;
 8013536:	4b3a      	ldr	r3, [pc, #232]	; (8013620 <nk_layout_widget_space+0x718>)
 8013538:	4a36      	ldr	r2, [pc, #216]	; (8013614 <nk_layout_widget_space+0x70c>)
 801353a:	f240 21ba 	movw	r1, #698	; 0x2ba
 801353e:	4836      	ldr	r0, [pc, #216]	; (8013618 <nk_layout_widget_space+0x710>)
 8013540:	f00a fa6a 	bl	801da18 <__assert_func>
    } break;
 8013544:	bf00      	nop
 8013546:	e006      	b.n	8013556 <nk_layout_widget_space+0x64e>
    } break;
 8013548:	bf00      	nop
 801354a:	e004      	b.n	8013556 <nk_layout_widget_space+0x64e>
    } break;
 801354c:	bf00      	nop
 801354e:	e002      	b.n	8013556 <nk_layout_widget_space+0x64e>
    } break;
 8013550:	bf00      	nop
 8013552:	e000      	b.n	8013556 <nk_layout_widget_space+0x64e>
    } break;
 8013554:	bf00      	nop
    };

    /* set the bounds of the newly allocated widget */
    bounds->w = item_width;
 8013556:	68fb      	ldr	r3, [r7, #12]
 8013558:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801355a:	609a      	str	r2, [r3, #8]
    bounds->h = layout->row.height - spacing.y;
 801355c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801355e:	ed93 7a1b 	vldr	s14, [r3, #108]	; 0x6c
 8013562:	edd7 7a06 	vldr	s15, [r7, #24]
 8013566:	ee77 7a67 	vsub.f32	s15, s14, s15
 801356a:	68fb      	ldr	r3, [r7, #12]
 801356c:	edc3 7a03 	vstr	s15, [r3, #12]
    bounds->y = layout->at_y - (float)*layout->offset_y;
 8013570:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013572:	ed93 7a09 	vldr	s14, [r3, #36]	; 0x24
 8013576:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013578:	69db      	ldr	r3, [r3, #28]
 801357a:	681b      	ldr	r3, [r3, #0]
 801357c:	ee07 3a90 	vmov	s15, r3
 8013580:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013584:	ee77 7a67 	vsub.f32	s15, s14, s15
 8013588:	68fb      	ldr	r3, [r7, #12]
 801358a:	edc3 7a01 	vstr	s15, [r3, #4]
    bounds->x = layout->at_x + item_offset + item_spacing;
 801358e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013590:	ed93 7a08 	vldr	s14, [r3, #32]
 8013594:	edd7 7a11 	vldr	s15, [r7, #68]	; 0x44
 8013598:	ee37 7a27 	vadd.f32	s14, s14, s15
 801359c:	edd7 7a0f 	vldr	s15, [r7, #60]	; 0x3c
 80135a0:	ee77 7a27 	vadd.f32	s15, s14, s15
 80135a4:	68fb      	ldr	r3, [r7, #12]
 80135a6:	edc3 7a00 	vstr	s15, [r3]
    if (((bounds->x + bounds->w) > layout->max_x) && modify)
 80135aa:	68fb      	ldr	r3, [r7, #12]
 80135ac:	ed93 7a00 	vldr	s14, [r3]
 80135b0:	68fb      	ldr	r3, [r7, #12]
 80135b2:	edd3 7a02 	vldr	s15, [r3, #8]
 80135b6:	ee37 7a27 	vadd.f32	s14, s14, s15
 80135ba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80135bc:	edd3 7a0a 	vldr	s15, [r3, #40]	; 0x28
 80135c0:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80135c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80135c8:	dd0d      	ble.n	80135e6 <nk_layout_widget_space+0x6de>
 80135ca:	683b      	ldr	r3, [r7, #0]
 80135cc:	2b00      	cmp	r3, #0
 80135ce:	d00a      	beq.n	80135e6 <nk_layout_widget_space+0x6de>
        layout->max_x = bounds->x + bounds->w;
 80135d0:	68fb      	ldr	r3, [r7, #12]
 80135d2:	ed93 7a00 	vldr	s14, [r3]
 80135d6:	68fb      	ldr	r3, [r7, #12]
 80135d8:	edd3 7a02 	vldr	s15, [r3, #8]
 80135dc:	ee77 7a27 	vadd.f32	s15, s14, s15
 80135e0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80135e2:	edc3 7a0a 	vstr	s15, [r3, #40]	; 0x28
    bounds->x -= (float)*layout->offset_x;
 80135e6:	68fb      	ldr	r3, [r7, #12]
 80135e8:	ed93 7a00 	vldr	s14, [r3]
 80135ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80135ee:	699b      	ldr	r3, [r3, #24]
 80135f0:	681b      	ldr	r3, [r3, #0]
 80135f2:	ee07 3a90 	vmov	s15, r3
 80135f6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80135fa:	ee77 7a67 	vsub.f32	s15, s14, s15
 80135fe:	68fb      	ldr	r3, [r7, #12]
 8013600:	edc3 7a00 	vstr	s15, [r3]
 8013604:	e000      	b.n	8013608 <nk_layout_widget_space+0x700>
        return;
 8013606:	bf00      	nop
}
 8013608:	3748      	adds	r7, #72	; 0x48
 801360a:	46bd      	mov	sp, r7
 801360c:	bd80      	pop	{r7, pc}
 801360e:	bf00      	nop
 8013610:	080218e4 	.word	0x080218e4
 8013614:	08023518 	.word	0x08023518
 8013618:	0802176c 	.word	0x0802176c
 801361c:	0802190c 	.word	0x0802190c
 8013620:	08021924 	.word	0x08021924

08013624 <nk_panel_alloc_space>:
NK_LIB void
nk_panel_alloc_space(struct nk_rect *bounds, const struct nk_context *ctx)
{
 8013624:	b580      	push	{r7, lr}
 8013626:	b084      	sub	sp, #16
 8013628:	af00      	add	r7, sp, #0
 801362a:	6078      	str	r0, [r7, #4]
 801362c:	6039      	str	r1, [r7, #0]
    struct nk_window *win;
    struct nk_panel *layout;

    NK_ASSERT(ctx);
 801362e:	683b      	ldr	r3, [r7, #0]
 8013630:	2b00      	cmp	r3, #0
 8013632:	d106      	bne.n	8013642 <nk_panel_alloc_space+0x1e>
 8013634:	4b2d      	ldr	r3, [pc, #180]	; (80136ec <nk_panel_alloc_space+0xc8>)
 8013636:	4a2e      	ldr	r2, [pc, #184]	; (80136f0 <nk_panel_alloc_space+0xcc>)
 8013638:	f44f 7133 	mov.w	r1, #716	; 0x2cc
 801363c:	482d      	ldr	r0, [pc, #180]	; (80136f4 <nk_panel_alloc_space+0xd0>)
 801363e:	f00a f9eb 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 8013642:	683b      	ldr	r3, [r7, #0]
 8013644:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8013648:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801364c:	2b00      	cmp	r3, #0
 801364e:	d106      	bne.n	801365e <nk_panel_alloc_space+0x3a>
 8013650:	4b29      	ldr	r3, [pc, #164]	; (80136f8 <nk_panel_alloc_space+0xd4>)
 8013652:	4a27      	ldr	r2, [pc, #156]	; (80136f0 <nk_panel_alloc_space+0xcc>)
 8013654:	f240 21cd 	movw	r1, #717	; 0x2cd
 8013658:	4826      	ldr	r0, [pc, #152]	; (80136f4 <nk_panel_alloc_space+0xd0>)
 801365a:	f00a f9dd 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 801365e:	683b      	ldr	r3, [r7, #0]
 8013660:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8013664:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8013668:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801366c:	2b00      	cmp	r3, #0
 801366e:	d106      	bne.n	801367e <nk_panel_alloc_space+0x5a>
 8013670:	4b22      	ldr	r3, [pc, #136]	; (80136fc <nk_panel_alloc_space+0xd8>)
 8013672:	4a1f      	ldr	r2, [pc, #124]	; (80136f0 <nk_panel_alloc_space+0xcc>)
 8013674:	f240 21ce 	movw	r1, #718	; 0x2ce
 8013678:	481e      	ldr	r0, [pc, #120]	; (80136f4 <nk_panel_alloc_space+0xd0>)
 801367a:	f00a f9cd 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout)
 801367e:	683b      	ldr	r3, [r7, #0]
 8013680:	2b00      	cmp	r3, #0
 8013682:	d02f      	beq.n	80136e4 <nk_panel_alloc_space+0xc0>
 8013684:	683b      	ldr	r3, [r7, #0]
 8013686:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801368a:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801368e:	2b00      	cmp	r3, #0
 8013690:	d028      	beq.n	80136e4 <nk_panel_alloc_space+0xc0>
 8013692:	683b      	ldr	r3, [r7, #0]
 8013694:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8013698:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801369c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80136a0:	2b00      	cmp	r3, #0
 80136a2:	d01f      	beq.n	80136e4 <nk_panel_alloc_space+0xc0>
        return;

    /* check if the end of the row has been hit and begin new row if so */
    win = ctx->current;
 80136a4:	683b      	ldr	r3, [r7, #0]
 80136a6:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80136aa:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 80136ae:	60fb      	str	r3, [r7, #12]
    layout = win->layout;
 80136b0:	68fb      	ldr	r3, [r7, #12]
 80136b2:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80136b6:	60bb      	str	r3, [r7, #8]
    if (layout->row.index >= layout->row.columns)
 80136b8:	68bb      	ldr	r3, [r7, #8]
 80136ba:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 80136bc:	68bb      	ldr	r3, [r7, #8]
 80136be:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80136c0:	429a      	cmp	r2, r3
 80136c2:	db03      	blt.n	80136cc <nk_panel_alloc_space+0xa8>
        nk_panel_alloc_row(ctx, win);
 80136c4:	68f9      	ldr	r1, [r7, #12]
 80136c6:	6838      	ldr	r0, [r7, #0]
 80136c8:	f7ff fbf2 	bl	8012eb0 <nk_panel_alloc_row>

    /* calculate widget position and size */
    nk_layout_widget_space(bounds, ctx, win, nk_true);
 80136cc:	2301      	movs	r3, #1
 80136ce:	68fa      	ldr	r2, [r7, #12]
 80136d0:	6839      	ldr	r1, [r7, #0]
 80136d2:	6878      	ldr	r0, [r7, #4]
 80136d4:	f7ff fc18 	bl	8012f08 <nk_layout_widget_space>
    layout->row.index++;
 80136d8:	68bb      	ldr	r3, [r7, #8]
 80136da:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80136dc:	1c5a      	adds	r2, r3, #1
 80136de:	68bb      	ldr	r3, [r7, #8]
 80136e0:	669a      	str	r2, [r3, #104]	; 0x68
 80136e2:	e000      	b.n	80136e6 <nk_panel_alloc_space+0xc2>
        return;
 80136e4:	bf00      	nop
}
 80136e6:	3710      	adds	r7, #16
 80136e8:	46bd      	mov	sp, r7
 80136ea:	bd80      	pop	{r7, pc}
 80136ec:	08021768 	.word	0x08021768
 80136f0:	08023530 	.word	0x08023530
 80136f4:	0802176c 	.word	0x0802176c
 80136f8:	08021788 	.word	0x08021788
 80136fc:	08021798 	.word	0x08021798

08013700 <nk_round_up_pow2>:
    return a0 + x*(a1 + x*(a2 + x*(a3 + x*(a4 + x*(a5 + x*(a6 + x*(a7 + x*a8)))))));
}
#endif
NK_LIB nk_uint
nk_round_up_pow2(nk_uint v)
{
 8013700:	b480      	push	{r7}
 8013702:	b083      	sub	sp, #12
 8013704:	af00      	add	r7, sp, #0
 8013706:	6078      	str	r0, [r7, #4]
    v--;
 8013708:	687b      	ldr	r3, [r7, #4]
 801370a:	3b01      	subs	r3, #1
 801370c:	607b      	str	r3, [r7, #4]
    v |= v >> 1;
 801370e:	687b      	ldr	r3, [r7, #4]
 8013710:	085b      	lsrs	r3, r3, #1
 8013712:	687a      	ldr	r2, [r7, #4]
 8013714:	4313      	orrs	r3, r2
 8013716:	607b      	str	r3, [r7, #4]
    v |= v >> 2;
 8013718:	687b      	ldr	r3, [r7, #4]
 801371a:	089b      	lsrs	r3, r3, #2
 801371c:	687a      	ldr	r2, [r7, #4]
 801371e:	4313      	orrs	r3, r2
 8013720:	607b      	str	r3, [r7, #4]
    v |= v >> 4;
 8013722:	687b      	ldr	r3, [r7, #4]
 8013724:	091b      	lsrs	r3, r3, #4
 8013726:	687a      	ldr	r2, [r7, #4]
 8013728:	4313      	orrs	r3, r2
 801372a:	607b      	str	r3, [r7, #4]
    v |= v >> 8;
 801372c:	687b      	ldr	r3, [r7, #4]
 801372e:	0a1b      	lsrs	r3, r3, #8
 8013730:	687a      	ldr	r2, [r7, #4]
 8013732:	4313      	orrs	r3, r2
 8013734:	607b      	str	r3, [r7, #4]
    v |= v >> 16;
 8013736:	687b      	ldr	r3, [r7, #4]
 8013738:	0c1b      	lsrs	r3, r3, #16
 801373a:	687a      	ldr	r2, [r7, #4]
 801373c:	4313      	orrs	r3, r2
 801373e:	607b      	str	r3, [r7, #4]
    v++;
 8013740:	687b      	ldr	r3, [r7, #4]
 8013742:	3301      	adds	r3, #1
 8013744:	607b      	str	r3, [r7, #4]
    return v;
 8013746:	687b      	ldr	r3, [r7, #4]
}
 8013748:	4618      	mov	r0, r3
 801374a:	370c      	adds	r7, #12
 801374c:	46bd      	mov	sp, r7
 801374e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013752:	4770      	bx	lr

08013754 <nk_rect>:
{
    return nk_null_rect;
}
NK_API struct nk_rect
nk_rect(float x, float y, float w, float h)
{
 8013754:	b490      	push	{r4, r7}
 8013756:	b090      	sub	sp, #64	; 0x40
 8013758:	af00      	add	r7, sp, #0
 801375a:	ed87 0a07 	vstr	s0, [r7, #28]
 801375e:	edc7 0a06 	vstr	s1, [r7, #24]
 8013762:	ed87 1a05 	vstr	s2, [r7, #20]
 8013766:	edc7 1a04 	vstr	s3, [r7, #16]
    struct nk_rect r;
    r.x = x; r.y = y;
 801376a:	69fb      	ldr	r3, [r7, #28]
 801376c:	623b      	str	r3, [r7, #32]
 801376e:	69bb      	ldr	r3, [r7, #24]
 8013770:	627b      	str	r3, [r7, #36]	; 0x24
    r.w = w; r.h = h;
 8013772:	697b      	ldr	r3, [r7, #20]
 8013774:	62bb      	str	r3, [r7, #40]	; 0x28
 8013776:	693b      	ldr	r3, [r7, #16]
 8013778:	62fb      	str	r3, [r7, #44]	; 0x2c
    return r;
 801377a:	f107 0430 	add.w	r4, r7, #48	; 0x30
 801377e:	f107 0320 	add.w	r3, r7, #32
 8013782:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8013784:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 8013788:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801378a:	6b79      	ldr	r1, [r7, #52]	; 0x34
 801378c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801378e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013790:	ee06 0a10 	vmov	s12, r0
 8013794:	ee06 1a90 	vmov	s13, r1
 8013798:	ee07 2a10 	vmov	s14, r2
 801379c:	ee07 3a90 	vmov	s15, r3
}
 80137a0:	eeb0 0a46 	vmov.f32	s0, s12
 80137a4:	eef0 0a66 	vmov.f32	s1, s13
 80137a8:	eeb0 1a47 	vmov.f32	s2, s14
 80137ac:	eef0 1a67 	vmov.f32	s3, s15
 80137b0:	3740      	adds	r7, #64	; 0x40
 80137b2:	46bd      	mov	sp, r7
 80137b4:	bc90      	pop	{r4, r7}
 80137b6:	4770      	bx	lr

080137b8 <nk_shrink_rect>:
    ret.x = r.w; ret.y = r.h;
    return ret;
}
NK_LIB struct nk_rect
nk_shrink_rect(struct nk_rect r, float amount)
{
 80137b8:	b490      	push	{r4, r7}
 80137ba:	b092      	sub	sp, #72	; 0x48
 80137bc:	af00      	add	r7, sp, #0
 80137be:	eeb0 6a40 	vmov.f32	s12, s0
 80137c2:	eef0 6a60 	vmov.f32	s13, s1
 80137c6:	eeb0 7a41 	vmov.f32	s14, s2
 80137ca:	eef0 7a61 	vmov.f32	s15, s3
 80137ce:	ed87 2a05 	vstr	s4, [r7, #20]
 80137d2:	ed87 6a06 	vstr	s12, [r7, #24]
 80137d6:	edc7 6a07 	vstr	s13, [r7, #28]
 80137da:	ed87 7a08 	vstr	s14, [r7, #32]
 80137de:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
    struct nk_rect res;
    r.w = NK_MAX(r.w, 2 * amount);
 80137e2:	ed97 7a08 	vldr	s14, [r7, #32]
 80137e6:	edd7 7a05 	vldr	s15, [r7, #20]
 80137ea:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80137ee:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80137f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80137f6:	d504      	bpl.n	8013802 <nk_shrink_rect+0x4a>
 80137f8:	edd7 7a05 	vldr	s15, [r7, #20]
 80137fc:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8013800:	e001      	b.n	8013806 <nk_shrink_rect+0x4e>
 8013802:	edd7 7a08 	vldr	s15, [r7, #32]
 8013806:	edc7 7a08 	vstr	s15, [r7, #32]
    r.h = NK_MAX(r.h, 2 * amount);
 801380a:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 801380e:	edd7 7a05 	vldr	s15, [r7, #20]
 8013812:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8013816:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801381a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801381e:	d504      	bpl.n	801382a <nk_shrink_rect+0x72>
 8013820:	edd7 7a05 	vldr	s15, [r7, #20]
 8013824:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8013828:	e001      	b.n	801382e <nk_shrink_rect+0x76>
 801382a:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 801382e:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
    res.x = r.x + amount;
 8013832:	ed97 7a06 	vldr	s14, [r7, #24]
 8013836:	edd7 7a05 	vldr	s15, [r7, #20]
 801383a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801383e:	edc7 7a0a 	vstr	s15, [r7, #40]	; 0x28
    res.y = r.y + amount;
 8013842:	ed97 7a07 	vldr	s14, [r7, #28]
 8013846:	edd7 7a05 	vldr	s15, [r7, #20]
 801384a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801384e:	edc7 7a0b 	vstr	s15, [r7, #44]	; 0x2c
    res.w = r.w - 2 * amount;
 8013852:	ed97 7a08 	vldr	s14, [r7, #32]
 8013856:	edd7 7a05 	vldr	s15, [r7, #20]
 801385a:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801385e:	ee77 7a67 	vsub.f32	s15, s14, s15
 8013862:	edc7 7a0c 	vstr	s15, [r7, #48]	; 0x30
    res.h = r.h - 2 * amount;
 8013866:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 801386a:	edd7 7a05 	vldr	s15, [r7, #20]
 801386e:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8013872:	ee77 7a67 	vsub.f32	s15, s14, s15
 8013876:	edc7 7a0d 	vstr	s15, [r7, #52]	; 0x34
    return res;
 801387a:	f107 0438 	add.w	r4, r7, #56	; 0x38
 801387e:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8013882:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8013884:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 8013888:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 801388a:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801388c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801388e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8013890:	ee06 0a10 	vmov	s12, r0
 8013894:	ee06 1a90 	vmov	s13, r1
 8013898:	ee07 2a10 	vmov	s14, r2
 801389c:	ee07 3a90 	vmov	s15, r3
}
 80138a0:	eeb0 0a46 	vmov.f32	s0, s12
 80138a4:	eef0 0a66 	vmov.f32	s1, s13
 80138a8:	eeb0 1a47 	vmov.f32	s2, s14
 80138ac:	eef0 1a67 	vmov.f32	s3, s15
 80138b0:	3748      	adds	r7, #72	; 0x48
 80138b2:	46bd      	mov	sp, r7
 80138b4:	bc90      	pop	{r4, r7}
 80138b6:	4770      	bx	lr

080138b8 <nk_vec2>:
    r.h -= 2 * pad.y;
    return r;
}
NK_API struct nk_vec2
nk_vec2(float x, float y)
{
 80138b8:	b480      	push	{r7}
 80138ba:	b089      	sub	sp, #36	; 0x24
 80138bc:	af00      	add	r7, sp, #0
 80138be:	ed87 0a03 	vstr	s0, [r7, #12]
 80138c2:	edc7 0a02 	vstr	s1, [r7, #8]
    struct nk_vec2 ret;
    ret.x = x; ret.y = y;
 80138c6:	68fb      	ldr	r3, [r7, #12]
 80138c8:	613b      	str	r3, [r7, #16]
 80138ca:	68bb      	ldr	r3, [r7, #8]
 80138cc:	617b      	str	r3, [r7, #20]
    return ret;
 80138ce:	f107 0318 	add.w	r3, r7, #24
 80138d2:	f107 0210 	add.w	r2, r7, #16
 80138d6:	e892 0003 	ldmia.w	r2, {r0, r1}
 80138da:	e883 0003 	stmia.w	r3, {r0, r1}
 80138de:	69ba      	ldr	r2, [r7, #24]
 80138e0:	69fb      	ldr	r3, [r7, #28]
 80138e2:	ee07 2a10 	vmov	s14, r2
 80138e6:	ee07 3a90 	vmov	s15, r3
}
 80138ea:	eeb0 0a47 	vmov.f32	s0, s14
 80138ee:	eef0 0a67 	vmov.f32	s1, s15
 80138f2:	3724      	adds	r7, #36	; 0x24
 80138f4:	46bd      	mov	sp, r7
 80138f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80138fa:	4770      	bx	lr

080138fc <nk_unify>:
    return nk_vec2i(v[0], v[1]);
}
NK_LIB void
nk_unify(struct nk_rect *clip, const struct nk_rect *a, float x0, float y0,
    float x1, float y1)
{
 80138fc:	b580      	push	{r7, lr}
 80138fe:	b086      	sub	sp, #24
 8013900:	af00      	add	r7, sp, #0
 8013902:	6178      	str	r0, [r7, #20]
 8013904:	6139      	str	r1, [r7, #16]
 8013906:	ed87 0a03 	vstr	s0, [r7, #12]
 801390a:	edc7 0a02 	vstr	s1, [r7, #8]
 801390e:	ed87 1a01 	vstr	s2, [r7, #4]
 8013912:	edc7 1a00 	vstr	s3, [r7]
    NK_ASSERT(a);
 8013916:	693b      	ldr	r3, [r7, #16]
 8013918:	2b00      	cmp	r3, #0
 801391a:	d106      	bne.n	801392a <nk_unify+0x2e>
 801391c:	4b4b      	ldr	r3, [pc, #300]	; (8013a4c <nk_unify+0x150>)
 801391e:	4a4c      	ldr	r2, [pc, #304]	; (8013a50 <nk_unify+0x154>)
 8013920:	f240 1101 	movw	r1, #257	; 0x101
 8013924:	484b      	ldr	r0, [pc, #300]	; (8013a54 <nk_unify+0x158>)
 8013926:	f00a f877 	bl	801da18 <__assert_func>
    NK_ASSERT(clip);
 801392a:	697b      	ldr	r3, [r7, #20]
 801392c:	2b00      	cmp	r3, #0
 801392e:	d106      	bne.n	801393e <nk_unify+0x42>
 8013930:	4b49      	ldr	r3, [pc, #292]	; (8013a58 <nk_unify+0x15c>)
 8013932:	4a47      	ldr	r2, [pc, #284]	; (8013a50 <nk_unify+0x154>)
 8013934:	f44f 7181 	mov.w	r1, #258	; 0x102
 8013938:	4846      	ldr	r0, [pc, #280]	; (8013a54 <nk_unify+0x158>)
 801393a:	f00a f86d 	bl	801da18 <__assert_func>
    clip->x = NK_MAX(a->x, x0);
 801393e:	693b      	ldr	r3, [r7, #16]
 8013940:	edd3 7a00 	vldr	s15, [r3]
 8013944:	ed97 7a03 	vldr	s14, [r7, #12]
 8013948:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801394c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013950:	dd01      	ble.n	8013956 <nk_unify+0x5a>
 8013952:	68fb      	ldr	r3, [r7, #12]
 8013954:	e001      	b.n	801395a <nk_unify+0x5e>
 8013956:	693b      	ldr	r3, [r7, #16]
 8013958:	681b      	ldr	r3, [r3, #0]
 801395a:	697a      	ldr	r2, [r7, #20]
 801395c:	6013      	str	r3, [r2, #0]
    clip->y = NK_MAX(a->y, y0);
 801395e:	693b      	ldr	r3, [r7, #16]
 8013960:	edd3 7a01 	vldr	s15, [r3, #4]
 8013964:	ed97 7a02 	vldr	s14, [r7, #8]
 8013968:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801396c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013970:	dd01      	ble.n	8013976 <nk_unify+0x7a>
 8013972:	68bb      	ldr	r3, [r7, #8]
 8013974:	e001      	b.n	801397a <nk_unify+0x7e>
 8013976:	693b      	ldr	r3, [r7, #16]
 8013978:	685b      	ldr	r3, [r3, #4]
 801397a:	697a      	ldr	r2, [r7, #20]
 801397c:	6053      	str	r3, [r2, #4]
    clip->w = NK_MIN(a->x + a->w, x1) - clip->x;
 801397e:	693b      	ldr	r3, [r7, #16]
 8013980:	ed93 7a00 	vldr	s14, [r3]
 8013984:	693b      	ldr	r3, [r7, #16]
 8013986:	edd3 7a02 	vldr	s15, [r3, #8]
 801398a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801398e:	ed97 7a01 	vldr	s14, [r7, #4]
 8013992:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8013996:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801399a:	dd08      	ble.n	80139ae <nk_unify+0xb2>
 801399c:	693b      	ldr	r3, [r7, #16]
 801399e:	ed93 7a00 	vldr	s14, [r3]
 80139a2:	693b      	ldr	r3, [r7, #16]
 80139a4:	edd3 7a02 	vldr	s15, [r3, #8]
 80139a8:	ee77 7a27 	vadd.f32	s15, s14, s15
 80139ac:	e001      	b.n	80139b2 <nk_unify+0xb6>
 80139ae:	edd7 7a01 	vldr	s15, [r7, #4]
 80139b2:	697b      	ldr	r3, [r7, #20]
 80139b4:	ed93 7a00 	vldr	s14, [r3]
 80139b8:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80139bc:	697b      	ldr	r3, [r7, #20]
 80139be:	edc3 7a02 	vstr	s15, [r3, #8]
    clip->h = NK_MIN(a->y + a->h, y1) - clip->y;
 80139c2:	693b      	ldr	r3, [r7, #16]
 80139c4:	ed93 7a01 	vldr	s14, [r3, #4]
 80139c8:	693b      	ldr	r3, [r7, #16]
 80139ca:	edd3 7a03 	vldr	s15, [r3, #12]
 80139ce:	ee77 7a27 	vadd.f32	s15, s14, s15
 80139d2:	ed97 7a00 	vldr	s14, [r7]
 80139d6:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80139da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80139de:	dd08      	ble.n	80139f2 <nk_unify+0xf6>
 80139e0:	693b      	ldr	r3, [r7, #16]
 80139e2:	ed93 7a01 	vldr	s14, [r3, #4]
 80139e6:	693b      	ldr	r3, [r7, #16]
 80139e8:	edd3 7a03 	vldr	s15, [r3, #12]
 80139ec:	ee77 7a27 	vadd.f32	s15, s14, s15
 80139f0:	e001      	b.n	80139f6 <nk_unify+0xfa>
 80139f2:	edd7 7a00 	vldr	s15, [r7]
 80139f6:	697b      	ldr	r3, [r7, #20]
 80139f8:	ed93 7a01 	vldr	s14, [r3, #4]
 80139fc:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8013a00:	697b      	ldr	r3, [r7, #20]
 8013a02:	edc3 7a03 	vstr	s15, [r3, #12]
    clip->w = NK_MAX(0, clip->w);
 8013a06:	697b      	ldr	r3, [r7, #20]
 8013a08:	edd3 7a02 	vldr	s15, [r3, #8]
 8013a0c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8013a10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013a14:	dd02      	ble.n	8013a1c <nk_unify+0x120>
 8013a16:	697b      	ldr	r3, [r7, #20]
 8013a18:	689b      	ldr	r3, [r3, #8]
 8013a1a:	e001      	b.n	8013a20 <nk_unify+0x124>
 8013a1c:	f04f 0300 	mov.w	r3, #0
 8013a20:	697a      	ldr	r2, [r7, #20]
 8013a22:	6093      	str	r3, [r2, #8]
    clip->h = NK_MAX(0, clip->h);
 8013a24:	697b      	ldr	r3, [r7, #20]
 8013a26:	edd3 7a03 	vldr	s15, [r3, #12]
 8013a2a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8013a2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013a32:	dd02      	ble.n	8013a3a <nk_unify+0x13e>
 8013a34:	697b      	ldr	r3, [r7, #20]
 8013a36:	68db      	ldr	r3, [r3, #12]
 8013a38:	e001      	b.n	8013a3e <nk_unify+0x142>
 8013a3a:	f04f 0300 	mov.w	r3, #0
 8013a3e:	697a      	ldr	r2, [r7, #20]
 8013a40:	60d3      	str	r3, [r2, #12]
}
 8013a42:	bf00      	nop
 8013a44:	3718      	adds	r7, #24
 8013a46:	46bd      	mov	sp, r7
 8013a48:	bd80      	pop	{r7, pc}
 8013a4a:	bf00      	nop
 8013a4c:	08021928 	.word	0x08021928
 8013a50:	08023548 	.word	0x08023548
 8013a54:	0802192c 	.word	0x0802192c
 8013a58:	08021948 	.word	0x08021948

08013a5c <nk_triangle_from_direction>:

NK_API void
nk_triangle_from_direction(struct nk_vec2 *result, struct nk_rect r,
    float pad_x, float pad_y, enum nk_heading direction)
{
 8013a5c:	b590      	push	{r4, r7, lr}
 8013a5e:	b08b      	sub	sp, #44	; 0x2c
 8013a60:	af00      	add	r7, sp, #0
 8013a62:	61f8      	str	r0, [r7, #28]
 8013a64:	eeb0 6a40 	vmov.f32	s12, s0
 8013a68:	eef0 6a60 	vmov.f32	s13, s1
 8013a6c:	eeb0 7a41 	vmov.f32	s14, s2
 8013a70:	eef0 7a61 	vmov.f32	s15, s3
 8013a74:	ed87 2a02 	vstr	s4, [r7, #8]
 8013a78:	edc7 2a01 	vstr	s5, [r7, #4]
 8013a7c:	460b      	mov	r3, r1
 8013a7e:	ed87 6a03 	vstr	s12, [r7, #12]
 8013a82:	edc7 6a04 	vstr	s13, [r7, #16]
 8013a86:	ed87 7a05 	vstr	s14, [r7, #20]
 8013a8a:	edc7 7a06 	vstr	s15, [r7, #24]
 8013a8e:	70fb      	strb	r3, [r7, #3]
    float w_half, h_half;
    NK_ASSERT(result);
 8013a90:	69fb      	ldr	r3, [r7, #28]
 8013a92:	2b00      	cmp	r3, #0
 8013a94:	d106      	bne.n	8013aa4 <nk_triangle_from_direction+0x48>
 8013a96:	4bcf      	ldr	r3, [pc, #828]	; (8013dd4 <nk_triangle_from_direction+0x378>)
 8013a98:	4acf      	ldr	r2, [pc, #828]	; (8013dd8 <nk_triangle_from_direction+0x37c>)
 8013a9a:	f44f 7188 	mov.w	r1, #272	; 0x110
 8013a9e:	48cf      	ldr	r0, [pc, #828]	; (8013ddc <nk_triangle_from_direction+0x380>)
 8013aa0:	f009 ffba 	bl	801da18 <__assert_func>

    r.w = NK_MAX(2 * pad_x, r.w);
 8013aa4:	edd7 7a02 	vldr	s15, [r7, #8]
 8013aa8:	ee37 7aa7 	vadd.f32	s14, s15, s15
 8013aac:	edd7 7a05 	vldr	s15, [r7, #20]
 8013ab0:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8013ab4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013ab8:	d502      	bpl.n	8013ac0 <nk_triangle_from_direction+0x64>
 8013aba:	edd7 7a05 	vldr	s15, [r7, #20]
 8013abe:	e003      	b.n	8013ac8 <nk_triangle_from_direction+0x6c>
 8013ac0:	edd7 7a02 	vldr	s15, [r7, #8]
 8013ac4:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8013ac8:	edc7 7a05 	vstr	s15, [r7, #20]
    r.h = NK_MAX(2 * pad_y, r.h);
 8013acc:	edd7 7a01 	vldr	s15, [r7, #4]
 8013ad0:	ee37 7aa7 	vadd.f32	s14, s15, s15
 8013ad4:	edd7 7a06 	vldr	s15, [r7, #24]
 8013ad8:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8013adc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013ae0:	d502      	bpl.n	8013ae8 <nk_triangle_from_direction+0x8c>
 8013ae2:	edd7 7a06 	vldr	s15, [r7, #24]
 8013ae6:	e003      	b.n	8013af0 <nk_triangle_from_direction+0x94>
 8013ae8:	edd7 7a01 	vldr	s15, [r7, #4]
 8013aec:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8013af0:	edc7 7a06 	vstr	s15, [r7, #24]
    r.w = r.w - 2 * pad_x;
 8013af4:	ed97 7a05 	vldr	s14, [r7, #20]
 8013af8:	edd7 7a02 	vldr	s15, [r7, #8]
 8013afc:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8013b00:	ee77 7a67 	vsub.f32	s15, s14, s15
 8013b04:	edc7 7a05 	vstr	s15, [r7, #20]
    r.h = r.h - 2 * pad_y;
 8013b08:	ed97 7a06 	vldr	s14, [r7, #24]
 8013b0c:	edd7 7a01 	vldr	s15, [r7, #4]
 8013b10:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8013b14:	ee77 7a67 	vsub.f32	s15, s14, s15
 8013b18:	edc7 7a06 	vstr	s15, [r7, #24]

    r.x = r.x + pad_x;
 8013b1c:	ed97 7a03 	vldr	s14, [r7, #12]
 8013b20:	edd7 7a02 	vldr	s15, [r7, #8]
 8013b24:	ee77 7a27 	vadd.f32	s15, s14, s15
 8013b28:	edc7 7a03 	vstr	s15, [r7, #12]
    r.y = r.y + pad_y;
 8013b2c:	ed97 7a04 	vldr	s14, [r7, #16]
 8013b30:	edd7 7a01 	vldr	s15, [r7, #4]
 8013b34:	ee77 7a27 	vadd.f32	s15, s14, s15
 8013b38:	edc7 7a04 	vstr	s15, [r7, #16]

    w_half = r.w / 2.0f;
 8013b3c:	ed97 7a05 	vldr	s14, [r7, #20]
 8013b40:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
 8013b44:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8013b48:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
    h_half = r.h / 2.0f;
 8013b4c:	ed97 7a06 	vldr	s14, [r7, #24]
 8013b50:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
 8013b54:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8013b58:	edc7 7a08 	vstr	s15, [r7, #32]

    if (direction == NK_UP) {
 8013b5c:	78fb      	ldrb	r3, [r7, #3]
 8013b5e:	2b00      	cmp	r3, #0
 8013b60:	d14d      	bne.n	8013bfe <nk_triangle_from_direction+0x1a2>
        result[0] = nk_vec2(r.x + w_half, r.y);
 8013b62:	ed97 7a03 	vldr	s14, [r7, #12]
 8013b66:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8013b6a:	ee77 7a27 	vadd.f32	s15, s14, s15
 8013b6e:	ed97 7a04 	vldr	s14, [r7, #16]
 8013b72:	eef0 0a47 	vmov.f32	s1, s14
 8013b76:	eeb0 0a67 	vmov.f32	s0, s15
 8013b7a:	f7ff fe9d 	bl	80138b8 <nk_vec2>
 8013b7e:	eeb0 7a40 	vmov.f32	s14, s0
 8013b82:	eef0 7a60 	vmov.f32	s15, s1
 8013b86:	69fb      	ldr	r3, [r7, #28]
 8013b88:	ed83 7a00 	vstr	s14, [r3]
 8013b8c:	edc3 7a01 	vstr	s15, [r3, #4]
        result[1] = nk_vec2(r.x + r.w, r.y + r.h);
 8013b90:	ed97 7a03 	vldr	s14, [r7, #12]
 8013b94:	edd7 7a05 	vldr	s15, [r7, #20]
 8013b98:	ee77 6a27 	vadd.f32	s13, s14, s15
 8013b9c:	ed97 7a04 	vldr	s14, [r7, #16]
 8013ba0:	edd7 7a06 	vldr	s15, [r7, #24]
 8013ba4:	ee77 7a27 	vadd.f32	s15, s14, s15
 8013ba8:	69fb      	ldr	r3, [r7, #28]
 8013baa:	f103 0408 	add.w	r4, r3, #8
 8013bae:	eef0 0a67 	vmov.f32	s1, s15
 8013bb2:	eeb0 0a66 	vmov.f32	s0, s13
 8013bb6:	f7ff fe7f 	bl	80138b8 <nk_vec2>
 8013bba:	eeb0 7a40 	vmov.f32	s14, s0
 8013bbe:	eef0 7a60 	vmov.f32	s15, s1
 8013bc2:	ed84 7a00 	vstr	s14, [r4]
 8013bc6:	edc4 7a01 	vstr	s15, [r4, #4]
        result[2] = nk_vec2(r.x, r.y + r.h);
 8013bca:	edd7 6a03 	vldr	s13, [r7, #12]
 8013bce:	ed97 7a04 	vldr	s14, [r7, #16]
 8013bd2:	edd7 7a06 	vldr	s15, [r7, #24]
 8013bd6:	ee77 7a27 	vadd.f32	s15, s14, s15
 8013bda:	69fb      	ldr	r3, [r7, #28]
 8013bdc:	f103 0410 	add.w	r4, r3, #16
 8013be0:	eef0 0a67 	vmov.f32	s1, s15
 8013be4:	eeb0 0a66 	vmov.f32	s0, s13
 8013be8:	f7ff fe66 	bl	80138b8 <nk_vec2>
 8013bec:	eeb0 7a40 	vmov.f32	s14, s0
 8013bf0:	eef0 7a60 	vmov.f32	s15, s1
 8013bf4:	ed84 7a00 	vstr	s14, [r4]
 8013bf8:	edc4 7a01 	vstr	s15, [r4, #4]
    } else {
        result[0] = nk_vec2(r.x, r.y + h_half);
        result[1] = nk_vec2(r.x + r.w, r.y);
        result[2] = nk_vec2(r.x + r.w, r.y + r.h);
    }
}
 8013bfc:	e0e6      	b.n	8013dcc <nk_triangle_from_direction+0x370>
    } else if (direction == NK_RIGHT) {
 8013bfe:	78fb      	ldrb	r3, [r7, #3]
 8013c00:	2b01      	cmp	r3, #1
 8013c02:	d149      	bne.n	8013c98 <nk_triangle_from_direction+0x23c>
        result[0] = nk_vec2(r.x, r.y);
 8013c04:	edd7 7a03 	vldr	s15, [r7, #12]
 8013c08:	ed97 7a04 	vldr	s14, [r7, #16]
 8013c0c:	eef0 0a47 	vmov.f32	s1, s14
 8013c10:	eeb0 0a67 	vmov.f32	s0, s15
 8013c14:	f7ff fe50 	bl	80138b8 <nk_vec2>
 8013c18:	eeb0 7a40 	vmov.f32	s14, s0
 8013c1c:	eef0 7a60 	vmov.f32	s15, s1
 8013c20:	69fb      	ldr	r3, [r7, #28]
 8013c22:	ed83 7a00 	vstr	s14, [r3]
 8013c26:	edc3 7a01 	vstr	s15, [r3, #4]
        result[1] = nk_vec2(r.x + r.w, r.y + h_half);
 8013c2a:	ed97 7a03 	vldr	s14, [r7, #12]
 8013c2e:	edd7 7a05 	vldr	s15, [r7, #20]
 8013c32:	ee77 6a27 	vadd.f32	s13, s14, s15
 8013c36:	ed97 7a04 	vldr	s14, [r7, #16]
 8013c3a:	edd7 7a08 	vldr	s15, [r7, #32]
 8013c3e:	ee77 7a27 	vadd.f32	s15, s14, s15
 8013c42:	69fb      	ldr	r3, [r7, #28]
 8013c44:	f103 0408 	add.w	r4, r3, #8
 8013c48:	eef0 0a67 	vmov.f32	s1, s15
 8013c4c:	eeb0 0a66 	vmov.f32	s0, s13
 8013c50:	f7ff fe32 	bl	80138b8 <nk_vec2>
 8013c54:	eeb0 7a40 	vmov.f32	s14, s0
 8013c58:	eef0 7a60 	vmov.f32	s15, s1
 8013c5c:	ed84 7a00 	vstr	s14, [r4]
 8013c60:	edc4 7a01 	vstr	s15, [r4, #4]
        result[2] = nk_vec2(r.x, r.y + r.h);
 8013c64:	edd7 6a03 	vldr	s13, [r7, #12]
 8013c68:	ed97 7a04 	vldr	s14, [r7, #16]
 8013c6c:	edd7 7a06 	vldr	s15, [r7, #24]
 8013c70:	ee77 7a27 	vadd.f32	s15, s14, s15
 8013c74:	69fb      	ldr	r3, [r7, #28]
 8013c76:	f103 0410 	add.w	r4, r3, #16
 8013c7a:	eef0 0a67 	vmov.f32	s1, s15
 8013c7e:	eeb0 0a66 	vmov.f32	s0, s13
 8013c82:	f7ff fe19 	bl	80138b8 <nk_vec2>
 8013c86:	eeb0 7a40 	vmov.f32	s14, s0
 8013c8a:	eef0 7a60 	vmov.f32	s15, s1
 8013c8e:	ed84 7a00 	vstr	s14, [r4]
 8013c92:	edc4 7a01 	vstr	s15, [r4, #4]
}
 8013c96:	e099      	b.n	8013dcc <nk_triangle_from_direction+0x370>
    } else if (direction == NK_DOWN) {
 8013c98:	78fb      	ldrb	r3, [r7, #3]
 8013c9a:	2b02      	cmp	r3, #2
 8013c9c:	d149      	bne.n	8013d32 <nk_triangle_from_direction+0x2d6>
        result[0] = nk_vec2(r.x, r.y);
 8013c9e:	edd7 7a03 	vldr	s15, [r7, #12]
 8013ca2:	ed97 7a04 	vldr	s14, [r7, #16]
 8013ca6:	eef0 0a47 	vmov.f32	s1, s14
 8013caa:	eeb0 0a67 	vmov.f32	s0, s15
 8013cae:	f7ff fe03 	bl	80138b8 <nk_vec2>
 8013cb2:	eeb0 7a40 	vmov.f32	s14, s0
 8013cb6:	eef0 7a60 	vmov.f32	s15, s1
 8013cba:	69fb      	ldr	r3, [r7, #28]
 8013cbc:	ed83 7a00 	vstr	s14, [r3]
 8013cc0:	edc3 7a01 	vstr	s15, [r3, #4]
        result[1] = nk_vec2(r.x + r.w, r.y);
 8013cc4:	ed97 7a03 	vldr	s14, [r7, #12]
 8013cc8:	edd7 7a05 	vldr	s15, [r7, #20]
 8013ccc:	ee77 7a27 	vadd.f32	s15, s14, s15
 8013cd0:	ed97 7a04 	vldr	s14, [r7, #16]
 8013cd4:	69fb      	ldr	r3, [r7, #28]
 8013cd6:	f103 0408 	add.w	r4, r3, #8
 8013cda:	eef0 0a47 	vmov.f32	s1, s14
 8013cde:	eeb0 0a67 	vmov.f32	s0, s15
 8013ce2:	f7ff fde9 	bl	80138b8 <nk_vec2>
 8013ce6:	eeb0 7a40 	vmov.f32	s14, s0
 8013cea:	eef0 7a60 	vmov.f32	s15, s1
 8013cee:	ed84 7a00 	vstr	s14, [r4]
 8013cf2:	edc4 7a01 	vstr	s15, [r4, #4]
        result[2] = nk_vec2(r.x + w_half, r.y + r.h);
 8013cf6:	ed97 7a03 	vldr	s14, [r7, #12]
 8013cfa:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8013cfe:	ee77 6a27 	vadd.f32	s13, s14, s15
 8013d02:	ed97 7a04 	vldr	s14, [r7, #16]
 8013d06:	edd7 7a06 	vldr	s15, [r7, #24]
 8013d0a:	ee77 7a27 	vadd.f32	s15, s14, s15
 8013d0e:	69fb      	ldr	r3, [r7, #28]
 8013d10:	f103 0410 	add.w	r4, r3, #16
 8013d14:	eef0 0a67 	vmov.f32	s1, s15
 8013d18:	eeb0 0a66 	vmov.f32	s0, s13
 8013d1c:	f7ff fdcc 	bl	80138b8 <nk_vec2>
 8013d20:	eeb0 7a40 	vmov.f32	s14, s0
 8013d24:	eef0 7a60 	vmov.f32	s15, s1
 8013d28:	ed84 7a00 	vstr	s14, [r4]
 8013d2c:	edc4 7a01 	vstr	s15, [r4, #4]
}
 8013d30:	e04c      	b.n	8013dcc <nk_triangle_from_direction+0x370>
        result[0] = nk_vec2(r.x, r.y + h_half);
 8013d32:	edd7 6a03 	vldr	s13, [r7, #12]
 8013d36:	ed97 7a04 	vldr	s14, [r7, #16]
 8013d3a:	edd7 7a08 	vldr	s15, [r7, #32]
 8013d3e:	ee77 7a27 	vadd.f32	s15, s14, s15
 8013d42:	eef0 0a67 	vmov.f32	s1, s15
 8013d46:	eeb0 0a66 	vmov.f32	s0, s13
 8013d4a:	f7ff fdb5 	bl	80138b8 <nk_vec2>
 8013d4e:	eeb0 7a40 	vmov.f32	s14, s0
 8013d52:	eef0 7a60 	vmov.f32	s15, s1
 8013d56:	69fb      	ldr	r3, [r7, #28]
 8013d58:	ed83 7a00 	vstr	s14, [r3]
 8013d5c:	edc3 7a01 	vstr	s15, [r3, #4]
        result[1] = nk_vec2(r.x + r.w, r.y);
 8013d60:	ed97 7a03 	vldr	s14, [r7, #12]
 8013d64:	edd7 7a05 	vldr	s15, [r7, #20]
 8013d68:	ee77 7a27 	vadd.f32	s15, s14, s15
 8013d6c:	ed97 7a04 	vldr	s14, [r7, #16]
 8013d70:	69fb      	ldr	r3, [r7, #28]
 8013d72:	f103 0408 	add.w	r4, r3, #8
 8013d76:	eef0 0a47 	vmov.f32	s1, s14
 8013d7a:	eeb0 0a67 	vmov.f32	s0, s15
 8013d7e:	f7ff fd9b 	bl	80138b8 <nk_vec2>
 8013d82:	eeb0 7a40 	vmov.f32	s14, s0
 8013d86:	eef0 7a60 	vmov.f32	s15, s1
 8013d8a:	ed84 7a00 	vstr	s14, [r4]
 8013d8e:	edc4 7a01 	vstr	s15, [r4, #4]
        result[2] = nk_vec2(r.x + r.w, r.y + r.h);
 8013d92:	ed97 7a03 	vldr	s14, [r7, #12]
 8013d96:	edd7 7a05 	vldr	s15, [r7, #20]
 8013d9a:	ee77 6a27 	vadd.f32	s13, s14, s15
 8013d9e:	ed97 7a04 	vldr	s14, [r7, #16]
 8013da2:	edd7 7a06 	vldr	s15, [r7, #24]
 8013da6:	ee77 7a27 	vadd.f32	s15, s14, s15
 8013daa:	69fb      	ldr	r3, [r7, #28]
 8013dac:	f103 0410 	add.w	r4, r3, #16
 8013db0:	eef0 0a67 	vmov.f32	s1, s15
 8013db4:	eeb0 0a66 	vmov.f32	s0, s13
 8013db8:	f7ff fd7e 	bl	80138b8 <nk_vec2>
 8013dbc:	eeb0 7a40 	vmov.f32	s14, s0
 8013dc0:	eef0 7a60 	vmov.f32	s15, s1
 8013dc4:	ed84 7a00 	vstr	s14, [r4]
 8013dc8:	edc4 7a01 	vstr	s15, [r4, #4]
}
 8013dcc:	bf00      	nop
 8013dce:	372c      	adds	r7, #44	; 0x2c
 8013dd0:	46bd      	mov	sp, r7
 8013dd2:	bd90      	pop	{r4, r7, pc}
 8013dd4:	08021950 	.word	0x08021950
 8013dd8:	08023554 	.word	0x08023554
 8013ddc:	0802192c 	.word	0x0802192c

08013de0 <nk_create_page_element>:
 *                          PAGE ELEMENT
 *
 * ===============================================================*/
NK_LIB struct nk_page_element*
nk_create_page_element(struct nk_context *ctx)
{
 8013de0:	b580      	push	{r7, lr}
 8013de2:	b084      	sub	sp, #16
 8013de4:	af00      	add	r7, sp, #0
 8013de6:	6078      	str	r0, [r7, #4]
    struct nk_page_element *elem;
    if (ctx->freelist) {
 8013de8:	687b      	ldr	r3, [r7, #4]
 8013dea:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8013dee:	f8d3 365c 	ldr.w	r3, [r3, #1628]	; 0x65c
 8013df2:	2b00      	cmp	r3, #0
 8013df4:	d00e      	beq.n	8013e14 <nk_create_page_element+0x34>
        /* unlink page element from free list */
        elem = ctx->freelist;
 8013df6:	687b      	ldr	r3, [r7, #4]
 8013df8:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8013dfc:	f8d3 365c 	ldr.w	r3, [r3, #1628]	; 0x65c
 8013e00:	60fb      	str	r3, [r7, #12]
        ctx->freelist = elem->next;
 8013e02:	68fb      	ldr	r3, [r7, #12]
 8013e04:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8013e08:	687a      	ldr	r2, [r7, #4]
 8013e0a:	f502 5240 	add.w	r2, r2, #12288	; 0x3000
 8013e0e:	f8c2 365c 	str.w	r3, [r2, #1628]	; 0x65c
 8013e12:	e036      	b.n	8013e82 <nk_create_page_element+0xa2>
    } else if (ctx->use_pool) {
 8013e14:	687b      	ldr	r3, [r7, #4]
 8013e16:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8013e1a:	f8d3 3620 	ldr.w	r3, [r3, #1568]	; 0x620
 8013e1e:	2b00      	cmp	r3, #0
 8013e20:	d015      	beq.n	8013e4e <nk_create_page_element+0x6e>
        /* allocate page element from memory pool */
        elem = nk_pool_alloc(&ctx->pool);
 8013e22:	687b      	ldr	r3, [r7, #4]
 8013e24:	f503 5358 	add.w	r3, r3, #13824	; 0x3600
 8013e28:	3324      	adds	r3, #36	; 0x24
 8013e2a:	4618      	mov	r0, r3
 8013e2c:	f002 fa88 	bl	8016340 <nk_pool_alloc>
 8013e30:	60f8      	str	r0, [r7, #12]
        NK_ASSERT(elem);
 8013e32:	68fb      	ldr	r3, [r7, #12]
 8013e34:	2b00      	cmp	r3, #0
 8013e36:	d105      	bne.n	8013e44 <nk_create_page_element+0x64>
 8013e38:	4b1b      	ldr	r3, [pc, #108]	; (8013ea8 <nk_create_page_element+0xc8>)
 8013e3a:	4a1c      	ldr	r2, [pc, #112]	; (8013eac <nk_create_page_element+0xcc>)
 8013e3c:	2114      	movs	r1, #20
 8013e3e:	481c      	ldr	r0, [pc, #112]	; (8013eb0 <nk_create_page_element+0xd0>)
 8013e40:	f009 fdea 	bl	801da18 <__assert_func>
        if (!elem) return 0;
 8013e44:	68fb      	ldr	r3, [r7, #12]
 8013e46:	2b00      	cmp	r3, #0
 8013e48:	d11b      	bne.n	8013e82 <nk_create_page_element+0xa2>
 8013e4a:	2300      	movs	r3, #0
 8013e4c:	e027      	b.n	8013e9e <nk_create_page_element+0xbe>
    } else {
        /* allocate new page element from back of fixed size memory buffer */
        NK_STORAGE const nk_size size = sizeof(struct nk_page_element);
        NK_STORAGE const nk_size align = NK_ALIGNOF(struct nk_page_element);
        elem = (struct nk_page_element*)nk_buffer_alloc(&ctx->memory, NK_BUFFER_BACK, size, align);
 8013e4e:	687b      	ldr	r3, [r7, #4]
 8013e50:	f503 50d4 	add.w	r0, r3, #6784	; 0x1a80
 8013e54:	300c      	adds	r0, #12
 8013e56:	4b17      	ldr	r3, [pc, #92]	; (8013eb4 <nk_create_page_element+0xd4>)
 8013e58:	681a      	ldr	r2, [r3, #0]
 8013e5a:	4b17      	ldr	r3, [pc, #92]	; (8013eb8 <nk_create_page_element+0xd8>)
 8013e5c:	681b      	ldr	r3, [r3, #0]
 8013e5e:	2101      	movs	r1, #1
 8013e60:	f7f9 fecc 	bl	800dbfc <nk_buffer_alloc>
 8013e64:	60f8      	str	r0, [r7, #12]
        NK_ASSERT(elem);
 8013e66:	68fb      	ldr	r3, [r7, #12]
 8013e68:	2b00      	cmp	r3, #0
 8013e6a:	d105      	bne.n	8013e78 <nk_create_page_element+0x98>
 8013e6c:	4b0e      	ldr	r3, [pc, #56]	; (8013ea8 <nk_create_page_element+0xc8>)
 8013e6e:	4a0f      	ldr	r2, [pc, #60]	; (8013eac <nk_create_page_element+0xcc>)
 8013e70:	211b      	movs	r1, #27
 8013e72:	480f      	ldr	r0, [pc, #60]	; (8013eb0 <nk_create_page_element+0xd0>)
 8013e74:	f009 fdd0 	bl	801da18 <__assert_func>
        if (!elem) return 0;
 8013e78:	68fb      	ldr	r3, [r7, #12]
 8013e7a:	2b00      	cmp	r3, #0
 8013e7c:	d101      	bne.n	8013e82 <nk_create_page_element+0xa2>
 8013e7e:	2300      	movs	r3, #0
 8013e80:	e00d      	b.n	8013e9e <nk_create_page_element+0xbe>
    }
    nk_zero_struct(*elem);
 8013e82:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 8013e86:	68f8      	ldr	r0, [r7, #12]
 8013e88:	f008 f8ce 	bl	801c028 <nk_zero>
    elem->next = 0;
 8013e8c:	68fb      	ldr	r3, [r7, #12]
 8013e8e:	2200      	movs	r2, #0
 8013e90:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
    elem->prev = 0;
 8013e94:	68fb      	ldr	r3, [r7, #12]
 8013e96:	2200      	movs	r2, #0
 8013e98:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
    return elem;
 8013e9c:	68fb      	ldr	r3, [r7, #12]
}
 8013e9e:	4618      	mov	r0, r3
 8013ea0:	3710      	adds	r7, #16
 8013ea2:	46bd      	mov	sp, r7
 8013ea4:	bd80      	pop	{r7, pc}
 8013ea6:	bf00      	nop
 8013ea8:	08021958 	.word	0x08021958
 8013eac:	08023570 	.word	0x08023570
 8013eb0:	08021960 	.word	0x08021960
 8013eb4:	08023588 	.word	0x08023588
 8013eb8:	0802358c 	.word	0x0802358c

08013ebc <nk_link_page_element_into_freelist>:
NK_LIB void
nk_link_page_element_into_freelist(struct nk_context *ctx,
    struct nk_page_element *elem)
{
 8013ebc:	b480      	push	{r7}
 8013ebe:	b083      	sub	sp, #12
 8013ec0:	af00      	add	r7, sp, #0
 8013ec2:	6078      	str	r0, [r7, #4]
 8013ec4:	6039      	str	r1, [r7, #0]
    /* link table into freelist */
    if (!ctx->freelist) {
 8013ec6:	687b      	ldr	r3, [r7, #4]
 8013ec8:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8013ecc:	f8d3 365c 	ldr.w	r3, [r3, #1628]	; 0x65c
 8013ed0:	2b00      	cmp	r3, #0
 8013ed2:	d107      	bne.n	8013ee4 <nk_link_page_element_into_freelist+0x28>
        ctx->freelist = elem;
 8013ed4:	687b      	ldr	r3, [r7, #4]
 8013ed6:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8013eda:	461a      	mov	r2, r3
 8013edc:	683b      	ldr	r3, [r7, #0]
 8013ede:	f8c2 365c 	str.w	r3, [r2, #1628]	; 0x65c
    } else {
        elem->next = ctx->freelist;
        ctx->freelist = elem;
    }
}
 8013ee2:	e00e      	b.n	8013f02 <nk_link_page_element_into_freelist+0x46>
        elem->next = ctx->freelist;
 8013ee4:	687b      	ldr	r3, [r7, #4]
 8013ee6:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8013eea:	f8d3 265c 	ldr.w	r2, [r3, #1628]	; 0x65c
 8013eee:	683b      	ldr	r3, [r7, #0]
 8013ef0:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
        ctx->freelist = elem;
 8013ef4:	687b      	ldr	r3, [r7, #4]
 8013ef6:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8013efa:	461a      	mov	r2, r3
 8013efc:	683b      	ldr	r3, [r7, #0]
 8013efe:	f8c2 365c 	str.w	r3, [r2, #1628]	; 0x65c
}
 8013f02:	bf00      	nop
 8013f04:	370c      	adds	r7, #12
 8013f06:	46bd      	mov	sp, r7
 8013f08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013f0c:	4770      	bx	lr

08013f0e <nk_free_page_element>:
NK_LIB void
nk_free_page_element(struct nk_context *ctx, struct nk_page_element *elem)
{
 8013f0e:	b580      	push	{r7, lr}
 8013f10:	b084      	sub	sp, #16
 8013f12:	af00      	add	r7, sp, #0
 8013f14:	6078      	str	r0, [r7, #4]
 8013f16:	6039      	str	r1, [r7, #0]
    /* we have a pool so just add to free list */
    if (ctx->use_pool) {
 8013f18:	687b      	ldr	r3, [r7, #4]
 8013f1a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8013f1e:	f8d3 3620 	ldr.w	r3, [r3, #1568]	; 0x620
 8013f22:	2b00      	cmp	r3, #0
 8013f24:	d004      	beq.n	8013f30 <nk_free_page_element+0x22>
        nk_link_page_element_into_freelist(ctx, elem);
 8013f26:	6839      	ldr	r1, [r7, #0]
 8013f28:	6878      	ldr	r0, [r7, #4]
 8013f2a:	f7ff ffc7 	bl	8013ebc <nk_link_page_element_into_freelist>
        return;
 8013f2e:	e024      	b.n	8013f7a <nk_free_page_element+0x6c>
    }
    /* if possible remove last element from back of fixed memory buffer */
    {void *elem_end = (void*)(elem + 1);
 8013f30:	683b      	ldr	r3, [r7, #0]
 8013f32:	f503 73d8 	add.w	r3, r3, #432	; 0x1b0
 8013f36:	60fb      	str	r3, [r7, #12]
    void *buffer_end = (nk_byte*)ctx->memory.memory.ptr + ctx->memory.size;
 8013f38:	687b      	ldr	r3, [r7, #4]
 8013f3a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8013f3e:	f8d3 2aac 	ldr.w	r2, [r3, #2732]	; 0xaac
 8013f42:	687b      	ldr	r3, [r7, #4]
 8013f44:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8013f48:	f8d3 3ac4 	ldr.w	r3, [r3, #2756]	; 0xac4
 8013f4c:	4413      	add	r3, r2
 8013f4e:	60bb      	str	r3, [r7, #8]
    if (elem_end == buffer_end)
 8013f50:	68fa      	ldr	r2, [r7, #12]
 8013f52:	68bb      	ldr	r3, [r7, #8]
 8013f54:	429a      	cmp	r2, r3
 8013f56:	d10c      	bne.n	8013f72 <nk_free_page_element+0x64>
        ctx->memory.size -= sizeof(struct nk_page_element);
 8013f58:	687b      	ldr	r3, [r7, #4]
 8013f5a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8013f5e:	f8d3 3ac4 	ldr.w	r3, [r3, #2756]	; 0xac4
 8013f62:	f5a3 73d8 	sub.w	r3, r3, #432	; 0x1b0
 8013f66:	687a      	ldr	r2, [r7, #4]
 8013f68:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8013f6c:	f8c2 3ac4 	str.w	r3, [r2, #2756]	; 0xac4
 8013f70:	e003      	b.n	8013f7a <nk_free_page_element+0x6c>
    else nk_link_page_element_into_freelist(ctx, elem);}
 8013f72:	6839      	ldr	r1, [r7, #0]
 8013f74:	6878      	ldr	r0, [r7, #4]
 8013f76:	f7ff ffa1 	bl	8013ebc <nk_link_page_element_into_freelist>
}
 8013f7a:	3710      	adds	r7, #16
 8013f7c:	46bd      	mov	sp, r7
 8013f7e:	bd80      	pop	{r7, pc}

08013f80 <nk_create_panel>:
 *                              PANEL
 *
 * ===============================================================*/
NK_LIB void*
nk_create_panel(struct nk_context *ctx)
{
 8013f80:	b580      	push	{r7, lr}
 8013f82:	b084      	sub	sp, #16
 8013f84:	af00      	add	r7, sp, #0
 8013f86:	6078      	str	r0, [r7, #4]
    struct nk_page_element *elem;
    elem = nk_create_page_element(ctx);
 8013f88:	6878      	ldr	r0, [r7, #4]
 8013f8a:	f7ff ff29 	bl	8013de0 <nk_create_page_element>
 8013f8e:	60f8      	str	r0, [r7, #12]
    if (!elem) return 0;
 8013f90:	68fb      	ldr	r3, [r7, #12]
 8013f92:	2b00      	cmp	r3, #0
 8013f94:	d101      	bne.n	8013f9a <nk_create_panel+0x1a>
 8013f96:	2300      	movs	r3, #0
 8013f98:	e005      	b.n	8013fa6 <nk_create_panel+0x26>
    nk_zero_struct(*elem);
 8013f9a:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 8013f9e:	68f8      	ldr	r0, [r7, #12]
 8013fa0:	f008 f842 	bl	801c028 <nk_zero>
    return &elem->data.pan;
 8013fa4:	68fb      	ldr	r3, [r7, #12]
}
 8013fa6:	4618      	mov	r0, r3
 8013fa8:	3710      	adds	r7, #16
 8013faa:	46bd      	mov	sp, r7
 8013fac:	bd80      	pop	{r7, pc}

08013fae <nk_free_panel>:
NK_LIB void
nk_free_panel(struct nk_context *ctx, struct nk_panel *pan)
{
 8013fae:	b580      	push	{r7, lr}
 8013fb0:	b084      	sub	sp, #16
 8013fb2:	af00      	add	r7, sp, #0
 8013fb4:	6078      	str	r0, [r7, #4]
 8013fb6:	6039      	str	r1, [r7, #0]
    union nk_page_data *pd = NK_CONTAINER_OF(pan, union nk_page_data, pan);
 8013fb8:	683b      	ldr	r3, [r7, #0]
 8013fba:	60fb      	str	r3, [r7, #12]
    struct nk_page_element *pe = NK_CONTAINER_OF(pd, struct nk_page_element, data);
 8013fbc:	68fb      	ldr	r3, [r7, #12]
 8013fbe:	60bb      	str	r3, [r7, #8]
    nk_free_page_element(ctx, pe);
 8013fc0:	68b9      	ldr	r1, [r7, #8]
 8013fc2:	6878      	ldr	r0, [r7, #4]
 8013fc4:	f7ff ffa3 	bl	8013f0e <nk_free_page_element>
}
 8013fc8:	bf00      	nop
 8013fca:	3710      	adds	r7, #16
 8013fcc:	46bd      	mov	sp, r7
 8013fce:	bd80      	pop	{r7, pc}

08013fd0 <nk_panel_has_header>:
NK_LIB nk_bool
nk_panel_has_header(nk_flags flags, const char *title)
{
 8013fd0:	b480      	push	{r7}
 8013fd2:	b085      	sub	sp, #20
 8013fd4:	af00      	add	r7, sp, #0
 8013fd6:	6078      	str	r0, [r7, #4]
 8013fd8:	6039      	str	r1, [r7, #0]
    nk_bool active = 0;
 8013fda:	2300      	movs	r3, #0
 8013fdc:	60fb      	str	r3, [r7, #12]
    active = (flags & (NK_WINDOW_CLOSABLE|NK_WINDOW_MINIMIZABLE));
 8013fde:	687b      	ldr	r3, [r7, #4]
 8013fe0:	f003 0318 	and.w	r3, r3, #24
 8013fe4:	60fb      	str	r3, [r7, #12]
    active = active || (flags & NK_WINDOW_TITLE);
 8013fe6:	68fb      	ldr	r3, [r7, #12]
 8013fe8:	2b00      	cmp	r3, #0
 8013fea:	d104      	bne.n	8013ff6 <nk_panel_has_header+0x26>
 8013fec:	687b      	ldr	r3, [r7, #4]
 8013fee:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013ff2:	2b00      	cmp	r3, #0
 8013ff4:	d001      	beq.n	8013ffa <nk_panel_has_header+0x2a>
 8013ff6:	2301      	movs	r3, #1
 8013ff8:	e000      	b.n	8013ffc <nk_panel_has_header+0x2c>
 8013ffa:	2300      	movs	r3, #0
 8013ffc:	60fb      	str	r3, [r7, #12]
    active = active && !(flags & NK_WINDOW_HIDDEN) && title;
 8013ffe:	68fb      	ldr	r3, [r7, #12]
 8014000:	2b00      	cmp	r3, #0
 8014002:	d009      	beq.n	8014018 <nk_panel_has_header+0x48>
 8014004:	687b      	ldr	r3, [r7, #4]
 8014006:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801400a:	2b00      	cmp	r3, #0
 801400c:	d104      	bne.n	8014018 <nk_panel_has_header+0x48>
 801400e:	683b      	ldr	r3, [r7, #0]
 8014010:	2b00      	cmp	r3, #0
 8014012:	d001      	beq.n	8014018 <nk_panel_has_header+0x48>
 8014014:	2301      	movs	r3, #1
 8014016:	e000      	b.n	801401a <nk_panel_has_header+0x4a>
 8014018:	2300      	movs	r3, #0
 801401a:	60fb      	str	r3, [r7, #12]
    return active;
 801401c:	68fb      	ldr	r3, [r7, #12]
}
 801401e:	4618      	mov	r0, r3
 8014020:	3714      	adds	r7, #20
 8014022:	46bd      	mov	sp, r7
 8014024:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014028:	4770      	bx	lr
	...

0801402c <nk_panel_get_padding>:
NK_LIB struct nk_vec2
nk_panel_get_padding(const struct nk_style *style, enum nk_panel_type type)
{
 801402c:	b480      	push	{r7}
 801402e:	b087      	sub	sp, #28
 8014030:	af00      	add	r7, sp, #0
 8014032:	60f8      	str	r0, [r7, #12]
 8014034:	460b      	mov	r3, r1
 8014036:	72fb      	strb	r3, [r7, #11]
    switch (type) {
 8014038:	7afb      	ldrb	r3, [r7, #11]
 801403a:	2b80      	cmp	r3, #128	; 0x80
 801403c:	f000 809a 	beq.w	8014174 <nk_panel_get_padding+0x148>
 8014040:	2b80      	cmp	r3, #128	; 0x80
 8014042:	dc49      	bgt.n	80140d8 <nk_panel_get_padding+0xac>
 8014044:	2b20      	cmp	r3, #32
 8014046:	dc45      	bgt.n	80140d4 <nk_panel_get_padding+0xa8>
 8014048:	2b02      	cmp	r3, #2
 801404a:	db45      	blt.n	80140d8 <nk_panel_get_padding+0xac>
 801404c:	3b02      	subs	r3, #2
 801404e:	2b1e      	cmp	r3, #30
 8014050:	d842      	bhi.n	80140d8 <nk_panel_get_padding+0xac>
 8014052:	a201      	add	r2, pc, #4	; (adr r2, 8014058 <nk_panel_get_padding+0x2c>)
 8014054:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8014058:	080140f3 	.word	0x080140f3
 801405c:	080140d9 	.word	0x080140d9
 8014060:	0801410d 	.word	0x0801410d
 8014064:	080140d9 	.word	0x080140d9
 8014068:	080140d9 	.word	0x080140d9
 801406c:	080140d9 	.word	0x080140d9
 8014070:	080140d9 	.word	0x080140d9
 8014074:	080140d9 	.word	0x080140d9
 8014078:	080140d9 	.word	0x080140d9
 801407c:	080140d9 	.word	0x080140d9
 8014080:	080140d9 	.word	0x080140d9
 8014084:	080140d9 	.word	0x080140d9
 8014088:	080140d9 	.word	0x080140d9
 801408c:	080140d9 	.word	0x080140d9
 8014090:	08014127 	.word	0x08014127
 8014094:	080140d9 	.word	0x080140d9
 8014098:	080140d9 	.word	0x080140d9
 801409c:	080140d9 	.word	0x080140d9
 80140a0:	080140d9 	.word	0x080140d9
 80140a4:	080140d9 	.word	0x080140d9
 80140a8:	080140d9 	.word	0x080140d9
 80140ac:	080140d9 	.word	0x080140d9
 80140b0:	080140d9 	.word	0x080140d9
 80140b4:	080140d9 	.word	0x080140d9
 80140b8:	080140d9 	.word	0x080140d9
 80140bc:	080140d9 	.word	0x080140d9
 80140c0:	080140d9 	.word	0x080140d9
 80140c4:	080140d9 	.word	0x080140d9
 80140c8:	080140d9 	.word	0x080140d9
 80140cc:	080140d9 	.word	0x080140d9
 80140d0:	08014141 	.word	0x08014141
 80140d4:	2b40      	cmp	r3, #64	; 0x40
 80140d6:	d040      	beq.n	801415a <nk_panel_get_padding+0x12e>
    default:
    case NK_PANEL_WINDOW: return style->window.padding;
 80140d8:	68fb      	ldr	r3, [r7, #12]
 80140da:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80140de:	461a      	mov	r2, r3
 80140e0:	f107 0310 	add.w	r3, r7, #16
 80140e4:	f602 02ec 	addw	r2, r2, #2284	; 0x8ec
 80140e8:	e892 0003 	ldmia.w	r2, {r0, r1}
 80140ec:	e883 0003 	stmia.w	r3, {r0, r1}
 80140f0:	e04c      	b.n	801418c <nk_panel_get_padding+0x160>
    case NK_PANEL_GROUP: return style->window.group_padding;
 80140f2:	68fb      	ldr	r3, [r7, #12]
 80140f4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80140f8:	461a      	mov	r2, r3
 80140fa:	f107 0310 	add.w	r3, r7, #16
 80140fe:	f602 02f4 	addw	r2, r2, #2292	; 0x8f4
 8014102:	e892 0003 	ldmia.w	r2, {r0, r1}
 8014106:	e883 0003 	stmia.w	r3, {r0, r1}
 801410a:	e03f      	b.n	801418c <nk_panel_get_padding+0x160>
    case NK_PANEL_POPUP: return style->window.popup_padding;
 801410c:	68fb      	ldr	r3, [r7, #12]
 801410e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014112:	461a      	mov	r2, r3
 8014114:	f107 0310 	add.w	r3, r7, #16
 8014118:	f602 02fc 	addw	r2, r2, #2300	; 0x8fc
 801411c:	e892 0003 	ldmia.w	r2, {r0, r1}
 8014120:	e883 0003 	stmia.w	r3, {r0, r1}
 8014124:	e032      	b.n	801418c <nk_panel_get_padding+0x160>
    case NK_PANEL_CONTEXTUAL: return style->window.contextual_padding;
 8014126:	68fb      	ldr	r3, [r7, #12]
 8014128:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801412c:	461a      	mov	r2, r3
 801412e:	f107 0310 	add.w	r3, r7, #16
 8014132:	f602 120c 	addw	r2, r2, #2316	; 0x90c
 8014136:	e892 0003 	ldmia.w	r2, {r0, r1}
 801413a:	e883 0003 	stmia.w	r3, {r0, r1}
 801413e:	e025      	b.n	801418c <nk_panel_get_padding+0x160>
    case NK_PANEL_COMBO: return style->window.combo_padding;
 8014140:	68fb      	ldr	r3, [r7, #12]
 8014142:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014146:	461a      	mov	r2, r3
 8014148:	f107 0310 	add.w	r3, r7, #16
 801414c:	f602 1204 	addw	r2, r2, #2308	; 0x904
 8014150:	e892 0003 	ldmia.w	r2, {r0, r1}
 8014154:	e883 0003 	stmia.w	r3, {r0, r1}
 8014158:	e018      	b.n	801418c <nk_panel_get_padding+0x160>
    case NK_PANEL_MENU: return style->window.menu_padding;
 801415a:	68fb      	ldr	r3, [r7, #12]
 801415c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014160:	461a      	mov	r2, r3
 8014162:	f107 0310 	add.w	r3, r7, #16
 8014166:	f602 1214 	addw	r2, r2, #2324	; 0x914
 801416a:	e892 0003 	ldmia.w	r2, {r0, r1}
 801416e:	e883 0003 	stmia.w	r3, {r0, r1}
 8014172:	e00b      	b.n	801418c <nk_panel_get_padding+0x160>
    case NK_PANEL_TOOLTIP: return style->window.menu_padding;}
 8014174:	68fb      	ldr	r3, [r7, #12]
 8014176:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801417a:	461a      	mov	r2, r3
 801417c:	f107 0310 	add.w	r3, r7, #16
 8014180:	f602 1214 	addw	r2, r2, #2324	; 0x914
 8014184:	e892 0003 	ldmia.w	r2, {r0, r1}
 8014188:	e883 0003 	stmia.w	r3, {r0, r1}
}
 801418c:	693a      	ldr	r2, [r7, #16]
 801418e:	697b      	ldr	r3, [r7, #20]
 8014190:	ee07 2a10 	vmov	s14, r2
 8014194:	ee07 3a90 	vmov	s15, r3
 8014198:	eeb0 0a47 	vmov.f32	s0, s14
 801419c:	eef0 0a67 	vmov.f32	s1, s15
 80141a0:	371c      	adds	r7, #28
 80141a2:	46bd      	mov	sp, r7
 80141a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80141a8:	4770      	bx	lr
 80141aa:	bf00      	nop

080141ac <nk_panel_get_border>:
NK_LIB float
nk_panel_get_border(const struct nk_style *style, nk_flags flags,
    enum nk_panel_type type)
{
 80141ac:	b480      	push	{r7}
 80141ae:	b085      	sub	sp, #20
 80141b0:	af00      	add	r7, sp, #0
 80141b2:	60f8      	str	r0, [r7, #12]
 80141b4:	60b9      	str	r1, [r7, #8]
 80141b6:	4613      	mov	r3, r2
 80141b8:	71fb      	strb	r3, [r7, #7]
    if (flags & NK_WINDOW_BORDER) {
 80141ba:	68bb      	ldr	r3, [r7, #8]
 80141bc:	f003 0301 	and.w	r3, r3, #1
 80141c0:	2b00      	cmp	r3, #0
 80141c2:	f000 8080 	beq.w	80142c6 <nk_panel_get_border+0x11a>
        switch (type) {
 80141c6:	79fb      	ldrb	r3, [r7, #7]
 80141c8:	2b80      	cmp	r3, #128	; 0x80
 80141ca:	d075      	beq.n	80142b8 <nk_panel_get_border+0x10c>
 80141cc:	2b80      	cmp	r3, #128	; 0x80
 80141ce:	dc49      	bgt.n	8014264 <nk_panel_get_border+0xb8>
 80141d0:	2b20      	cmp	r3, #32
 80141d2:	dc45      	bgt.n	8014260 <nk_panel_get_border+0xb4>
 80141d4:	2b02      	cmp	r3, #2
 80141d6:	db45      	blt.n	8014264 <nk_panel_get_border+0xb8>
 80141d8:	3b02      	subs	r3, #2
 80141da:	2b1e      	cmp	r3, #30
 80141dc:	d842      	bhi.n	8014264 <nk_panel_get_border+0xb8>
 80141de:	a201      	add	r2, pc, #4	; (adr r2, 80141e4 <nk_panel_get_border+0x38>)
 80141e0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80141e4:	08014273 	.word	0x08014273
 80141e8:	08014265 	.word	0x08014265
 80141ec:	08014281 	.word	0x08014281
 80141f0:	08014265 	.word	0x08014265
 80141f4:	08014265 	.word	0x08014265
 80141f8:	08014265 	.word	0x08014265
 80141fc:	08014265 	.word	0x08014265
 8014200:	08014265 	.word	0x08014265
 8014204:	08014265 	.word	0x08014265
 8014208:	08014265 	.word	0x08014265
 801420c:	08014265 	.word	0x08014265
 8014210:	08014265 	.word	0x08014265
 8014214:	08014265 	.word	0x08014265
 8014218:	08014265 	.word	0x08014265
 801421c:	0801428f 	.word	0x0801428f
 8014220:	08014265 	.word	0x08014265
 8014224:	08014265 	.word	0x08014265
 8014228:	08014265 	.word	0x08014265
 801422c:	08014265 	.word	0x08014265
 8014230:	08014265 	.word	0x08014265
 8014234:	08014265 	.word	0x08014265
 8014238:	08014265 	.word	0x08014265
 801423c:	08014265 	.word	0x08014265
 8014240:	08014265 	.word	0x08014265
 8014244:	08014265 	.word	0x08014265
 8014248:	08014265 	.word	0x08014265
 801424c:	08014265 	.word	0x08014265
 8014250:	08014265 	.word	0x08014265
 8014254:	08014265 	.word	0x08014265
 8014258:	08014265 	.word	0x08014265
 801425c:	0801429d 	.word	0x0801429d
 8014260:	2b40      	cmp	r3, #64	; 0x40
 8014262:	d022      	beq.n	80142aa <nk_panel_get_border+0xfe>
        default:
        case NK_PANEL_WINDOW: return style->window.border;
 8014264:	68fb      	ldr	r3, [r7, #12]
 8014266:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801426a:	f503 630b 	add.w	r3, r3, #2224	; 0x8b0
 801426e:	681b      	ldr	r3, [r3, #0]
 8014270:	e02b      	b.n	80142ca <nk_panel_get_border+0x11e>
        case NK_PANEL_GROUP: return style->window.group_border;
 8014272:	68fb      	ldr	r3, [r7, #12]
 8014274:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014278:	f503 630c 	add.w	r3, r3, #2240	; 0x8c0
 801427c:	681b      	ldr	r3, [r3, #0]
 801427e:	e024      	b.n	80142ca <nk_panel_get_border+0x11e>
        case NK_PANEL_POPUP: return style->window.popup_border;
 8014280:	68fb      	ldr	r3, [r7, #12]
 8014282:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014286:	f603 03c8 	addw	r3, r3, #2248	; 0x8c8
 801428a:	681b      	ldr	r3, [r3, #0]
 801428c:	e01d      	b.n	80142ca <nk_panel_get_border+0x11e>
        case NK_PANEL_CONTEXTUAL: return style->window.contextual_border;
 801428e:	68fb      	ldr	r3, [r7, #12]
 8014290:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014294:	f603 03b8 	addw	r3, r3, #2232	; 0x8b8
 8014298:	681b      	ldr	r3, [r3, #0]
 801429a:	e016      	b.n	80142ca <nk_panel_get_border+0x11e>
        case NK_PANEL_COMBO: return style->window.combo_border;
 801429c:	68fb      	ldr	r3, [r7, #12]
 801429e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80142a2:	f603 03b4 	addw	r3, r3, #2228	; 0x8b4
 80142a6:	681b      	ldr	r3, [r3, #0]
 80142a8:	e00f      	b.n	80142ca <nk_panel_get_border+0x11e>
        case NK_PANEL_MENU: return style->window.menu_border;
 80142aa:	68fb      	ldr	r3, [r7, #12]
 80142ac:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80142b0:	f603 03bc 	addw	r3, r3, #2236	; 0x8bc
 80142b4:	681b      	ldr	r3, [r3, #0]
 80142b6:	e008      	b.n	80142ca <nk_panel_get_border+0x11e>
        case NK_PANEL_TOOLTIP: return style->window.menu_border;
 80142b8:	68fb      	ldr	r3, [r7, #12]
 80142ba:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80142be:	f603 03bc 	addw	r3, r3, #2236	; 0x8bc
 80142c2:	681b      	ldr	r3, [r3, #0]
 80142c4:	e001      	b.n	80142ca <nk_panel_get_border+0x11e>
    }} else return 0;
 80142c6:	f04f 0300 	mov.w	r3, #0
}
 80142ca:	ee07 3a90 	vmov	s15, r3
 80142ce:	eeb0 0a67 	vmov.f32	s0, s15
 80142d2:	3714      	adds	r7, #20
 80142d4:	46bd      	mov	sp, r7
 80142d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80142da:	4770      	bx	lr

080142dc <nk_panel_get_border_color>:
NK_LIB struct nk_color
nk_panel_get_border_color(const struct nk_style *style, enum nk_panel_type type)
{
 80142dc:	b480      	push	{r7}
 80142de:	b085      	sub	sp, #20
 80142e0:	af00      	add	r7, sp, #0
 80142e2:	6078      	str	r0, [r7, #4]
 80142e4:	460b      	mov	r3, r1
 80142e6:	70fb      	strb	r3, [r7, #3]
    switch (type) {
 80142e8:	78fb      	ldrb	r3, [r7, #3]
 80142ea:	2b80      	cmp	r3, #128	; 0x80
 80142ec:	d076      	beq.n	80143dc <nk_panel_get_border_color+0x100>
 80142ee:	2b80      	cmp	r3, #128	; 0x80
 80142f0:	dc4a      	bgt.n	8014388 <nk_panel_get_border_color+0xac>
 80142f2:	2b20      	cmp	r3, #32
 80142f4:	dc46      	bgt.n	8014384 <nk_panel_get_border_color+0xa8>
 80142f6:	2b02      	cmp	r3, #2
 80142f8:	db46      	blt.n	8014388 <nk_panel_get_border_color+0xac>
 80142fa:	3b02      	subs	r3, #2
 80142fc:	2b1e      	cmp	r3, #30
 80142fe:	d843      	bhi.n	8014388 <nk_panel_get_border_color+0xac>
 8014300:	a201      	add	r2, pc, #4	; (adr r2, 8014308 <nk_panel_get_border_color+0x2c>)
 8014302:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8014306:	bf00      	nop
 8014308:	08014397 	.word	0x08014397
 801430c:	08014389 	.word	0x08014389
 8014310:	080143a5 	.word	0x080143a5
 8014314:	08014389 	.word	0x08014389
 8014318:	08014389 	.word	0x08014389
 801431c:	08014389 	.word	0x08014389
 8014320:	08014389 	.word	0x08014389
 8014324:	08014389 	.word	0x08014389
 8014328:	08014389 	.word	0x08014389
 801432c:	08014389 	.word	0x08014389
 8014330:	08014389 	.word	0x08014389
 8014334:	08014389 	.word	0x08014389
 8014338:	08014389 	.word	0x08014389
 801433c:	08014389 	.word	0x08014389
 8014340:	080143b3 	.word	0x080143b3
 8014344:	08014389 	.word	0x08014389
 8014348:	08014389 	.word	0x08014389
 801434c:	08014389 	.word	0x08014389
 8014350:	08014389 	.word	0x08014389
 8014354:	08014389 	.word	0x08014389
 8014358:	08014389 	.word	0x08014389
 801435c:	08014389 	.word	0x08014389
 8014360:	08014389 	.word	0x08014389
 8014364:	08014389 	.word	0x08014389
 8014368:	08014389 	.word	0x08014389
 801436c:	08014389 	.word	0x08014389
 8014370:	08014389 	.word	0x08014389
 8014374:	08014389 	.word	0x08014389
 8014378:	08014389 	.word	0x08014389
 801437c:	08014389 	.word	0x08014389
 8014380:	080143c1 	.word	0x080143c1
 8014384:	2b40      	cmp	r3, #64	; 0x40
 8014386:	d022      	beq.n	80143ce <nk_panel_get_border_color+0xf2>
    default:
    case NK_PANEL_WINDOW: return style->window.border_color;
 8014388:	687b      	ldr	r3, [r7, #4]
 801438a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801438e:	f8d3 3878 	ldr.w	r3, [r3, #2168]	; 0x878
 8014392:	60fb      	str	r3, [r7, #12]
 8014394:	e028      	b.n	80143e8 <nk_panel_get_border_color+0x10c>
    case NK_PANEL_GROUP: return style->window.group_border_color;
 8014396:	687b      	ldr	r3, [r7, #4]
 8014398:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801439c:	f8d3 388c 	ldr.w	r3, [r3, #2188]	; 0x88c
 80143a0:	60fb      	str	r3, [r7, #12]
 80143a2:	e021      	b.n	80143e8 <nk_panel_get_border_color+0x10c>
    case NK_PANEL_POPUP: return style->window.popup_border_color;
 80143a4:	687b      	ldr	r3, [r7, #4]
 80143a6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80143aa:	f8d3 387c 	ldr.w	r3, [r3, #2172]	; 0x87c
 80143ae:	60fb      	str	r3, [r7, #12]
 80143b0:	e01a      	b.n	80143e8 <nk_panel_get_border_color+0x10c>
    case NK_PANEL_CONTEXTUAL: return style->window.contextual_border_color;
 80143b2:	687b      	ldr	r3, [r7, #4]
 80143b4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80143b8:	f8d3 3884 	ldr.w	r3, [r3, #2180]	; 0x884
 80143bc:	60fb      	str	r3, [r7, #12]
 80143be:	e013      	b.n	80143e8 <nk_panel_get_border_color+0x10c>
    case NK_PANEL_COMBO: return style->window.combo_border_color;
 80143c0:	687b      	ldr	r3, [r7, #4]
 80143c2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80143c6:	f8d3 3880 	ldr.w	r3, [r3, #2176]	; 0x880
 80143ca:	60fb      	str	r3, [r7, #12]
 80143cc:	e00c      	b.n	80143e8 <nk_panel_get_border_color+0x10c>
    case NK_PANEL_MENU: return style->window.menu_border_color;
 80143ce:	687b      	ldr	r3, [r7, #4]
 80143d0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80143d4:	f8d3 3888 	ldr.w	r3, [r3, #2184]	; 0x888
 80143d8:	60fb      	str	r3, [r7, #12]
 80143da:	e005      	b.n	80143e8 <nk_panel_get_border_color+0x10c>
    case NK_PANEL_TOOLTIP: return style->window.menu_border_color;}
 80143dc:	687b      	ldr	r3, [r7, #4]
 80143de:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80143e2:	f8d3 3888 	ldr.w	r3, [r3, #2184]	; 0x888
 80143e6:	60fb      	str	r3, [r7, #12]
}
 80143e8:	2300      	movs	r3, #0
 80143ea:	7b3a      	ldrb	r2, [r7, #12]
 80143ec:	f362 0307 	bfi	r3, r2, #0, #8
 80143f0:	7b7a      	ldrb	r2, [r7, #13]
 80143f2:	f362 230f 	bfi	r3, r2, #8, #8
 80143f6:	7bba      	ldrb	r2, [r7, #14]
 80143f8:	f362 4317 	bfi	r3, r2, #16, #8
 80143fc:	7bfa      	ldrb	r2, [r7, #15]
 80143fe:	f362 631f 	bfi	r3, r2, #24, #8
 8014402:	4618      	mov	r0, r3
 8014404:	3714      	adds	r7, #20
 8014406:	46bd      	mov	sp, r7
 8014408:	f85d 7b04 	ldr.w	r7, [sp], #4
 801440c:	4770      	bx	lr
 801440e:	bf00      	nop

08014410 <nk_panel_is_sub>:
NK_LIB nk_bool
nk_panel_is_sub(enum nk_panel_type type)
{
 8014410:	b480      	push	{r7}
 8014412:	b083      	sub	sp, #12
 8014414:	af00      	add	r7, sp, #0
 8014416:	4603      	mov	r3, r0
 8014418:	71fb      	strb	r3, [r7, #7]
    return (type & NK_PANEL_SET_SUB)?1:0;
 801441a:	79fb      	ldrb	r3, [r7, #7]
 801441c:	f003 03f6 	and.w	r3, r3, #246	; 0xf6
 8014420:	2b00      	cmp	r3, #0
 8014422:	bf14      	ite	ne
 8014424:	2301      	movne	r3, #1
 8014426:	2300      	moveq	r3, #0
 8014428:	b2db      	uxtb	r3, r3
}
 801442a:	4618      	mov	r0, r3
 801442c:	370c      	adds	r7, #12
 801442e:	46bd      	mov	sp, r7
 8014430:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014434:	4770      	bx	lr

08014436 <nk_panel_is_nonblock>:
NK_LIB nk_bool
nk_panel_is_nonblock(enum nk_panel_type type)
{
 8014436:	b480      	push	{r7}
 8014438:	b083      	sub	sp, #12
 801443a:	af00      	add	r7, sp, #0
 801443c:	4603      	mov	r3, r0
 801443e:	71fb      	strb	r3, [r7, #7]
    return (type & NK_PANEL_SET_NONBLOCK)?1:0;
 8014440:	79fb      	ldrb	r3, [r7, #7]
 8014442:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8014446:	2b00      	cmp	r3, #0
 8014448:	bf14      	ite	ne
 801444a:	2301      	movne	r3, #1
 801444c:	2300      	moveq	r3, #0
 801444e:	b2db      	uxtb	r3, r3
}
 8014450:	4618      	mov	r0, r3
 8014452:	370c      	adds	r7, #12
 8014454:	46bd      	mov	sp, r7
 8014456:	f85d 7b04 	ldr.w	r7, [sp], #4
 801445a:	4770      	bx	lr

0801445c <nk_panel_begin>:
NK_LIB nk_bool
nk_panel_begin(struct nk_context *ctx, const char *title, enum nk_panel_type panel_type)
{
 801445c:	b590      	push	{r4, r7, lr}
 801445e:	b0b7      	sub	sp, #220	; 0xdc
 8014460:	af04      	add	r7, sp, #16
 8014462:	60f8      	str	r0, [r7, #12]
 8014464:	60b9      	str	r1, [r7, #8]
 8014466:	4613      	mov	r3, r2
 8014468:	71fb      	strb	r3, [r7, #7]
    const struct nk_user_font *font;

    struct nk_vec2 scrollbar_size;
    struct nk_vec2 panel_padding;

    NK_ASSERT(ctx);
 801446a:	68fb      	ldr	r3, [r7, #12]
 801446c:	2b00      	cmp	r3, #0
 801446e:	d105      	bne.n	801447c <nk_panel_begin+0x20>
 8014470:	4b7e      	ldr	r3, [pc, #504]	; (801466c <nk_panel_begin+0x210>)
 8014472:	4a7f      	ldr	r2, [pc, #508]	; (8014670 <nk_panel_begin+0x214>)
 8014474:	2163      	movs	r1, #99	; 0x63
 8014476:	487f      	ldr	r0, [pc, #508]	; (8014674 <nk_panel_begin+0x218>)
 8014478:	f009 face 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 801447c:	68fb      	ldr	r3, [r7, #12]
 801447e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8014482:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8014486:	2b00      	cmp	r3, #0
 8014488:	d105      	bne.n	8014496 <nk_panel_begin+0x3a>
 801448a:	4b7b      	ldr	r3, [pc, #492]	; (8014678 <nk_panel_begin+0x21c>)
 801448c:	4a78      	ldr	r2, [pc, #480]	; (8014670 <nk_panel_begin+0x214>)
 801448e:	2164      	movs	r1, #100	; 0x64
 8014490:	4878      	ldr	r0, [pc, #480]	; (8014674 <nk_panel_begin+0x218>)
 8014492:	f009 fac1 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 8014496:	68fb      	ldr	r3, [r7, #12]
 8014498:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801449c:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 80144a0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80144a4:	2b00      	cmp	r3, #0
 80144a6:	d105      	bne.n	80144b4 <nk_panel_begin+0x58>
 80144a8:	4b74      	ldr	r3, [pc, #464]	; (801467c <nk_panel_begin+0x220>)
 80144aa:	4a71      	ldr	r2, [pc, #452]	; (8014670 <nk_panel_begin+0x214>)
 80144ac:	2165      	movs	r1, #101	; 0x65
 80144ae:	4871      	ldr	r0, [pc, #452]	; (8014674 <nk_panel_begin+0x218>)
 80144b0:	f009 fab2 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout) return 0;
 80144b4:	68fb      	ldr	r3, [r7, #12]
 80144b6:	2b00      	cmp	r3, #0
 80144b8:	d00f      	beq.n	80144da <nk_panel_begin+0x7e>
 80144ba:	68fb      	ldr	r3, [r7, #12]
 80144bc:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80144c0:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 80144c4:	2b00      	cmp	r3, #0
 80144c6:	d008      	beq.n	80144da <nk_panel_begin+0x7e>
 80144c8:	68fb      	ldr	r3, [r7, #12]
 80144ca:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80144ce:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 80144d2:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80144d6:	2b00      	cmp	r3, #0
 80144d8:	d102      	bne.n	80144e0 <nk_panel_begin+0x84>
 80144da:	2300      	movs	r3, #0
 80144dc:	f000 bef7 	b.w	80152ce <nk_panel_begin+0xe72>
    nk_zero(ctx->current->layout, sizeof(*ctx->current->layout));
 80144e0:	68fb      	ldr	r3, [r7, #12]
 80144e2:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80144e6:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 80144ea:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80144ee:	f44f 71ce 	mov.w	r1, #412	; 0x19c
 80144f2:	4618      	mov	r0, r3
 80144f4:	f007 fd98 	bl	801c028 <nk_zero>
    if ((ctx->current->flags & NK_WINDOW_HIDDEN) || (ctx->current->flags & NK_WINDOW_CLOSED)) {
 80144f8:	68fb      	ldr	r3, [r7, #12]
 80144fa:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80144fe:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8014502:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8014504:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8014508:	2b00      	cmp	r3, #0
 801450a:	d109      	bne.n	8014520 <nk_panel_begin+0xc4>
 801450c:	68fb      	ldr	r3, [r7, #12]
 801450e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8014512:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8014516:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8014518:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 801451c:	2b00      	cmp	r3, #0
 801451e:	d017      	beq.n	8014550 <nk_panel_begin+0xf4>
        nk_zero(ctx->current->layout, sizeof(struct nk_panel));
 8014520:	68fb      	ldr	r3, [r7, #12]
 8014522:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8014526:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801452a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801452e:	f44f 71ce 	mov.w	r1, #412	; 0x19c
 8014532:	4618      	mov	r0, r3
 8014534:	f007 fd78 	bl	801c028 <nk_zero>
        ctx->current->layout->type = panel_type;
 8014538:	68fb      	ldr	r3, [r7, #12]
 801453a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801453e:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8014542:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8014546:	79fa      	ldrb	r2, [r7, #7]
 8014548:	701a      	strb	r2, [r3, #0]
        return 0;
 801454a:	2300      	movs	r3, #0
 801454c:	f000 bebf 	b.w	80152ce <nk_panel_begin+0xe72>
    }
    /* pull state into local stack */
    style = &ctx->style;
 8014550:	68fb      	ldr	r3, [r7, #12]
 8014552:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 8014556:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
    font = style->font;
 801455a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 801455e:	681b      	ldr	r3, [r3, #0]
 8014560:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    win = ctx->current;
 8014564:	68fb      	ldr	r3, [r7, #12]
 8014566:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801456a:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801456e:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    layout = win->layout;
 8014572:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8014576:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801457a:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
    out = &win->buffer;
 801457e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8014582:	3364      	adds	r3, #100	; 0x64
 8014584:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
    in = (win->flags & NK_WINDOW_NO_INPUT) ? 0: &ctx->input;
 8014588:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801458c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801458e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8014592:	2b00      	cmp	r3, #0
 8014594:	d101      	bne.n	801459a <nk_panel_begin+0x13e>
 8014596:	68fb      	ldr	r3, [r7, #12]
 8014598:	e000      	b.n	801459c <nk_panel_begin+0x140>
 801459a:	2300      	movs	r3, #0
 801459c:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
#ifdef NK_INCLUDE_COMMAND_USERDATA
    win->buffer.userdata = ctx->userdata;
#endif
    /* pull style configuration into local stack */
    scrollbar_size = style->window.scrollbar_size;
 80145a0:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 80145a4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80145a8:	461a      	mov	r2, r3
 80145aa:	f107 0390 	add.w	r3, r7, #144	; 0x90
 80145ae:	f602 02dc 	addw	r2, r2, #2268	; 0x8dc
 80145b2:	e892 0003 	ldmia.w	r2, {r0, r1}
 80145b6:	e883 0003 	stmia.w	r3, {r0, r1}
    panel_padding = nk_panel_get_padding(style, panel_type);
 80145ba:	79fb      	ldrb	r3, [r7, #7]
 80145bc:	4619      	mov	r1, r3
 80145be:	f8d7 00c0 	ldr.w	r0, [r7, #192]	; 0xc0
 80145c2:	f7ff fd33 	bl	801402c <nk_panel_get_padding>
 80145c6:	eeb0 7a40 	vmov.f32	s14, s0
 80145ca:	eef0 7a60 	vmov.f32	s15, s1
 80145ce:	ed87 7a22 	vstr	s14, [r7, #136]	; 0x88
 80145d2:	edc7 7a23 	vstr	s15, [r7, #140]	; 0x8c

    /* window movement */
    if ((win->flags & NK_WINDOW_MOVABLE) && !(win->flags & NK_WINDOW_ROM)) {
 80145d6:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80145da:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80145dc:	f003 0302 	and.w	r3, r3, #2
 80145e0:	2b00      	cmp	r3, #0
 80145e2:	f000 80bf 	beq.w	8014764 <nk_panel_begin+0x308>
 80145e6:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80145ea:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80145ec:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80145f0:	2b00      	cmp	r3, #0
 80145f2:	f040 80b7 	bne.w	8014764 <nk_panel_begin+0x308>
        unsigned int left_mouse_clicked;
        int left_mouse_click_in_cursor;

        /* calculate draggable window space */
        struct nk_rect header;
        header.x = win->bounds.x;
 80145f6:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80145fa:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80145fc:	67bb      	str	r3, [r7, #120]	; 0x78
        header.y = win->bounds.y;
 80145fe:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8014602:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8014604:	67fb      	str	r3, [r7, #124]	; 0x7c
        header.w = win->bounds.w;
 8014606:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801460a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801460c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
        if (nk_panel_has_header(win->flags, title)) {
 8014610:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8014614:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8014616:	68b9      	ldr	r1, [r7, #8]
 8014618:	4618      	mov	r0, r3
 801461a:	f7ff fcd9 	bl	8013fd0 <nk_panel_has_header>
 801461e:	4603      	mov	r3, r0
 8014620:	2b00      	cmp	r3, #0
 8014622:	d02d      	beq.n	8014680 <nk_panel_begin+0x224>
            header.h = font->height + 2.0f * style->window.header.padding.y;
 8014624:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8014628:	ed93 7a01 	vldr	s14, [r3, #4]
 801462c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014630:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014634:	f603 0344 	addw	r3, r3, #2116	; 0x844
 8014638:	edd3 7a00 	vldr	s15, [r3]
 801463c:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8014640:	ee77 7a27 	vadd.f32	s15, s14, s15
 8014644:	edc7 7a21 	vstr	s15, [r7, #132]	; 0x84
            header.h += 2.0f * style->window.header.label_padding.y;
 8014648:	ed97 7a21 	vldr	s14, [r7, #132]	; 0x84
 801464c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014650:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014654:	f603 034c 	addw	r3, r3, #2124	; 0x84c
 8014658:	edd3 7a00 	vldr	s15, [r3]
 801465c:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8014660:	ee77 7a27 	vadd.f32	s15, s14, s15
 8014664:	edc7 7a21 	vstr	s15, [r7, #132]	; 0x84
 8014668:	e00e      	b.n	8014688 <nk_panel_begin+0x22c>
 801466a:	bf00      	nop
 801466c:	08021984 	.word	0x08021984
 8014670:	080235a4 	.word	0x080235a4
 8014674:	08021988 	.word	0x08021988
 8014678:	080219a4 	.word	0x080219a4
 801467c:	080219b4 	.word	0x080219b4
        } else header.h = panel_padding.y;
 8014680:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8014684:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84

        /* window movement by dragging */
        left_mouse_down = in->mouse.buttons[NK_BUTTON_LEFT].down;
 8014688:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801468c:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8014690:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
        left_mouse_clicked = in->mouse.buttons[NK_BUTTON_LEFT].clicked;
 8014694:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8014698:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 801469c:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
        left_mouse_click_in_cursor = nk_input_has_mouse_click_down_in_rect(in,
 80146a0:	ed97 6a1e 	vldr	s12, [r7, #120]	; 0x78
 80146a4:	edd7 6a1f 	vldr	s13, [r7, #124]	; 0x7c
 80146a8:	ed97 7a20 	vldr	s14, [r7, #128]	; 0x80
 80146ac:	edd7 7a21 	vldr	s15, [r7, #132]	; 0x84
 80146b0:	2201      	movs	r2, #1
 80146b2:	eeb0 0a46 	vmov.f32	s0, s12
 80146b6:	eef0 0a66 	vmov.f32	s1, s13
 80146ba:	eeb0 1a47 	vmov.f32	s2, s14
 80146be:	eef0 1a67 	vmov.f32	s3, s15
 80146c2:	2100      	movs	r1, #0
 80146c4:	f8d7 00ac 	ldr.w	r0, [r7, #172]	; 0xac
 80146c8:	f7fd fee2 	bl	8012490 <nk_input_has_mouse_click_down_in_rect>
 80146cc:	f8c7 00a0 	str.w	r0, [r7, #160]	; 0xa0
            NK_BUTTON_LEFT, header, nk_true);
        if (left_mouse_down && left_mouse_click_in_cursor && !left_mouse_clicked) {
 80146d0:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80146d4:	2b00      	cmp	r3, #0
 80146d6:	d045      	beq.n	8014764 <nk_panel_begin+0x308>
 80146d8:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80146dc:	2b00      	cmp	r3, #0
 80146de:	d041      	beq.n	8014764 <nk_panel_begin+0x308>
 80146e0:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80146e4:	2b00      	cmp	r3, #0
 80146e6:	d13d      	bne.n	8014764 <nk_panel_begin+0x308>
            win->bounds.x = win->bounds.x + in->mouse.delta.x;
 80146e8:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80146ec:	ed93 7a13 	vldr	s14, [r3, #76]	; 0x4c
 80146f0:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80146f4:	edd3 7a55 	vldr	s15, [r3, #340]	; 0x154
 80146f8:	ee77 7a27 	vadd.f32	s15, s14, s15
 80146fc:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8014700:	edc3 7a13 	vstr	s15, [r3, #76]	; 0x4c
            win->bounds.y = win->bounds.y + in->mouse.delta.y;
 8014704:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8014708:	ed93 7a14 	vldr	s14, [r3, #80]	; 0x50
 801470c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8014710:	edd3 7a56 	vldr	s15, [r3, #344]	; 0x158
 8014714:	ee77 7a27 	vadd.f32	s15, s14, s15
 8014718:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801471c:	edc3 7a14 	vstr	s15, [r3, #80]	; 0x50
            in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x += in->mouse.delta.x;
 8014720:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8014724:	ed93 7a43 	vldr	s14, [r3, #268]	; 0x10c
 8014728:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801472c:	edd3 7a55 	vldr	s15, [r3, #340]	; 0x154
 8014730:	ee77 7a27 	vadd.f32	s15, s14, s15
 8014734:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8014738:	edc3 7a43 	vstr	s15, [r3, #268]	; 0x10c
            in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.y += in->mouse.delta.y;
 801473c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8014740:	ed93 7a44 	vldr	s14, [r3, #272]	; 0x110
 8014744:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8014748:	edd3 7a56 	vldr	s15, [r3, #344]	; 0x158
 801474c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8014750:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8014754:	edc3 7a44 	vstr	s15, [r3, #272]	; 0x110
            ctx->style.cursor_active = ctx->style.cursors[NK_CURSOR_MOVE];
 8014758:	68fb      	ldr	r3, [r7, #12]
 801475a:	f8d3 2174 	ldr.w	r2, [r3, #372]	; 0x174
 801475e:	68fb      	ldr	r3, [r7, #12]
 8014760:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
        }
    }

    /* setup panel */
    layout->type = panel_type;
 8014764:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014768:	79fa      	ldrb	r2, [r7, #7]
 801476a:	701a      	strb	r2, [r3, #0]
    layout->flags = win->flags;
 801476c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8014770:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8014772:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014776:	605a      	str	r2, [r3, #4]
    layout->bounds = win->bounds;
 8014778:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 801477c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8014780:	f102 0408 	add.w	r4, r2, #8
 8014784:	334c      	adds	r3, #76	; 0x4c
 8014786:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8014788:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    layout->bounds.x += panel_padding.x;
 801478c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014790:	ed93 7a02 	vldr	s14, [r3, #8]
 8014794:	edd7 7a22 	vldr	s15, [r7, #136]	; 0x88
 8014798:	ee77 7a27 	vadd.f32	s15, s14, s15
 801479c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80147a0:	edc3 7a02 	vstr	s15, [r3, #8]
    layout->bounds.w -= 2*panel_padding.x;
 80147a4:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80147a8:	ed93 7a04 	vldr	s14, [r3, #16]
 80147ac:	edd7 7a22 	vldr	s15, [r7, #136]	; 0x88
 80147b0:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80147b4:	ee77 7a67 	vsub.f32	s15, s14, s15
 80147b8:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80147bc:	edc3 7a04 	vstr	s15, [r3, #16]
    if (win->flags & NK_WINDOW_BORDER) {
 80147c0:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80147c4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80147c6:	f003 0301 	and.w	r3, r3, #1
 80147ca:	2b00      	cmp	r3, #0
 80147cc:	d03b      	beq.n	8014846 <nk_panel_begin+0x3ea>
        layout->border = nk_panel_get_border(style, win->flags, panel_type);
 80147ce:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80147d2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80147d4:	79fa      	ldrb	r2, [r7, #7]
 80147d6:	4619      	mov	r1, r3
 80147d8:	f8d7 00c0 	ldr.w	r0, [r7, #192]	; 0xc0
 80147dc:	f7ff fce6 	bl	80141ac <nk_panel_get_border>
 80147e0:	eef0 7a40 	vmov.f32	s15, s0
 80147e4:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80147e8:	edc3 7a0d 	vstr	s15, [r3, #52]	; 0x34
        layout->bounds = nk_shrink_rect(layout->bounds, layout->border);
 80147ec:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80147f0:	edd3 5a0d 	vldr	s11, [r3, #52]	; 0x34
 80147f4:	f8d7 40b4 	ldr.w	r4, [r7, #180]	; 0xb4
 80147f8:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80147fc:	ed93 6a02 	vldr	s12, [r3, #8]
 8014800:	edd3 6a03 	vldr	s13, [r3, #12]
 8014804:	ed93 7a04 	vldr	s14, [r3, #16]
 8014808:	edd3 7a05 	vldr	s15, [r3, #20]
 801480c:	eeb0 2a65 	vmov.f32	s4, s11
 8014810:	eeb0 0a46 	vmov.f32	s0, s12
 8014814:	eef0 0a66 	vmov.f32	s1, s13
 8014818:	eeb0 1a47 	vmov.f32	s2, s14
 801481c:	eef0 1a67 	vmov.f32	s3, s15
 8014820:	f7fe ffca 	bl	80137b8 <nk_shrink_rect>
 8014824:	eeb0 6a40 	vmov.f32	s12, s0
 8014828:	eef0 6a60 	vmov.f32	s13, s1
 801482c:	eeb0 7a41 	vmov.f32	s14, s2
 8014830:	eef0 7a61 	vmov.f32	s15, s3
 8014834:	ed84 6a02 	vstr	s12, [r4, #8]
 8014838:	edc4 6a03 	vstr	s13, [r4, #12]
 801483c:	ed84 7a04 	vstr	s14, [r4, #16]
 8014840:	edc4 7a05 	vstr	s15, [r4, #20]
 8014844:	e004      	b.n	8014850 <nk_panel_begin+0x3f4>
    } else layout->border = 0;
 8014846:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801484a:	f04f 0200 	mov.w	r2, #0
 801484e:	635a      	str	r2, [r3, #52]	; 0x34
    layout->at_y = layout->bounds.y;
 8014850:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014854:	68da      	ldr	r2, [r3, #12]
 8014856:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801485a:	625a      	str	r2, [r3, #36]	; 0x24
    layout->at_x = layout->bounds.x;
 801485c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014860:	689a      	ldr	r2, [r3, #8]
 8014862:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014866:	621a      	str	r2, [r3, #32]
    layout->max_x = 0;
 8014868:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801486c:	f04f 0200 	mov.w	r2, #0
 8014870:	629a      	str	r2, [r3, #40]	; 0x28
    layout->header_height = 0;
 8014872:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014876:	f04f 0200 	mov.w	r2, #0
 801487a:	631a      	str	r2, [r3, #48]	; 0x30
    layout->footer_height = 0;
 801487c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014880:	f04f 0200 	mov.w	r2, #0
 8014884:	62da      	str	r2, [r3, #44]	; 0x2c
    nk_layout_reset_min_row_height(ctx);
 8014886:	68f8      	ldr	r0, [r7, #12]
 8014888:	f7fd ffac 	bl	80127e4 <nk_layout_reset_min_row_height>
    layout->row.index = 0;
 801488c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014890:	2200      	movs	r2, #0
 8014892:	669a      	str	r2, [r3, #104]	; 0x68
    layout->row.columns = 0;
 8014894:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014898:	2200      	movs	r2, #0
 801489a:	675a      	str	r2, [r3, #116]	; 0x74
    layout->row.ratio = 0;
 801489c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80148a0:	2200      	movs	r2, #0
 80148a2:	679a      	str	r2, [r3, #120]	; 0x78
    layout->row.item_width = 0;
 80148a4:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80148a8:	f04f 0200 	mov.w	r2, #0
 80148ac:	67da      	str	r2, [r3, #124]	; 0x7c
    layout->row.tree_depth = 0;
 80148ae:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80148b2:	2200      	movs	r2, #0
 80148b4:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
    layout->row.height = panel_padding.y;
 80148b8:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 80148bc:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80148c0:	66da      	str	r2, [r3, #108]	; 0x6c
    layout->has_scrolling = nk_true;
 80148c2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80148c6:	2201      	movs	r2, #1
 80148c8:	639a      	str	r2, [r3, #56]	; 0x38
    if (!(win->flags & NK_WINDOW_NO_SCROLLBAR))
 80148ca:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80148ce:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80148d0:	f003 0320 	and.w	r3, r3, #32
 80148d4:	2b00      	cmp	r3, #0
 80148d6:	d10b      	bne.n	80148f0 <nk_panel_begin+0x494>
        layout->bounds.w -= scrollbar_size.x;
 80148d8:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80148dc:	ed93 7a04 	vldr	s14, [r3, #16]
 80148e0:	edd7 7a24 	vldr	s15, [r7, #144]	; 0x90
 80148e4:	ee77 7a67 	vsub.f32	s15, s14, s15
 80148e8:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80148ec:	edc3 7a04 	vstr	s15, [r3, #16]
    if (!nk_panel_is_nonblock(panel_type)) {
 80148f0:	79fb      	ldrb	r3, [r7, #7]
 80148f2:	4618      	mov	r0, r3
 80148f4:	f7ff fd9f 	bl	8014436 <nk_panel_is_nonblock>
 80148f8:	4603      	mov	r3, r0
 80148fa:	2b00      	cmp	r3, #0
 80148fc:	d125      	bne.n	801494a <nk_panel_begin+0x4ee>
        layout->footer_height = 0;
 80148fe:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014902:	f04f 0200 	mov.w	r2, #0
 8014906:	62da      	str	r2, [r3, #44]	; 0x2c
        if (!(win->flags & NK_WINDOW_NO_SCROLLBAR) || win->flags & NK_WINDOW_SCALABLE)
 8014908:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801490c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801490e:	f003 0320 	and.w	r3, r3, #32
 8014912:	2b00      	cmp	r3, #0
 8014914:	d006      	beq.n	8014924 <nk_panel_begin+0x4c8>
 8014916:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801491a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801491c:	f003 0304 	and.w	r3, r3, #4
 8014920:	2b00      	cmp	r3, #0
 8014922:	d004      	beq.n	801492e <nk_panel_begin+0x4d2>
            layout->footer_height = scrollbar_size.y;
 8014924:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8014928:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801492c:	62da      	str	r2, [r3, #44]	; 0x2c
        layout->bounds.h -= layout->footer_height;
 801492e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014932:	ed93 7a05 	vldr	s14, [r3, #20]
 8014936:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801493a:	edd3 7a0b 	vldr	s15, [r3, #44]	; 0x2c
 801493e:	ee77 7a67 	vsub.f32	s15, s14, s15
 8014942:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014946:	edc3 7a05 	vstr	s15, [r3, #20]
    }

    /* panel header */
    if (nk_panel_has_header(win->flags, title))
 801494a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801494e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8014950:	68b9      	ldr	r1, [r7, #8]
 8014952:	4618      	mov	r0, r3
 8014954:	f7ff fb3c 	bl	8013fd0 <nk_panel_has_header>
 8014958:	4603      	mov	r3, r0
 801495a:	2b00      	cmp	r3, #0
 801495c:	f000 83bc 	beq.w	80150d8 <nk_panel_begin+0xc7c>
    {
        struct nk_text text;
        struct nk_rect header;
        const struct nk_style_item *background = 0;
 8014960:	2300      	movs	r3, #0
 8014962:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

        /* calculate header bounds */
        header.x = win->bounds.x;
 8014966:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801496a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801496c:	65bb      	str	r3, [r7, #88]	; 0x58
        header.y = win->bounds.y;
 801496e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8014972:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8014974:	65fb      	str	r3, [r7, #92]	; 0x5c
        header.w = win->bounds.w;
 8014976:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801497a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801497c:	663b      	str	r3, [r7, #96]	; 0x60
        header.h = font->height + 2.0f * style->window.header.padding.y;
 801497e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8014982:	ed93 7a01 	vldr	s14, [r3, #4]
 8014986:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 801498a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801498e:	f603 0344 	addw	r3, r3, #2116	; 0x844
 8014992:	edd3 7a00 	vldr	s15, [r3]
 8014996:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801499a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801499e:	edc7 7a19 	vstr	s15, [r7, #100]	; 0x64
        header.h += (2.0f * style->window.header.label_padding.y);
 80149a2:	ed97 7a19 	vldr	s14, [r7, #100]	; 0x64
 80149a6:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 80149aa:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80149ae:	f603 034c 	addw	r3, r3, #2124	; 0x84c
 80149b2:	edd3 7a00 	vldr	s15, [r3]
 80149b6:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80149ba:	ee77 7a27 	vadd.f32	s15, s14, s15
 80149be:	edc7 7a19 	vstr	s15, [r7, #100]	; 0x64

        /* shrink panel by header */
        layout->header_height = header.h;
 80149c2:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 80149c4:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80149c8:	631a      	str	r2, [r3, #48]	; 0x30
        layout->bounds.y += header.h;
 80149ca:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80149ce:	ed93 7a03 	vldr	s14, [r3, #12]
 80149d2:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
 80149d6:	ee77 7a27 	vadd.f32	s15, s14, s15
 80149da:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80149de:	edc3 7a03 	vstr	s15, [r3, #12]
        layout->bounds.h -= header.h;
 80149e2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80149e6:	ed93 7a05 	vldr	s14, [r3, #20]
 80149ea:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
 80149ee:	ee77 7a67 	vsub.f32	s15, s14, s15
 80149f2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80149f6:	edc3 7a05 	vstr	s15, [r3, #20]
        layout->at_y += header.h;
 80149fa:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80149fe:	ed93 7a09 	vldr	s14, [r3, #36]	; 0x24
 8014a02:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
 8014a06:	ee77 7a27 	vadd.f32	s15, s14, s15
 8014a0a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014a0e:	edc3 7a09 	vstr	s15, [r3, #36]	; 0x24

        /* select correct header background and text color */
        if (ctx->active == win) {
 8014a12:	68fb      	ldr	r3, [r7, #12]
 8014a14:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8014a18:	f8d3 3654 	ldr.w	r3, [r3, #1620]	; 0x654
 8014a1c:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8014a20:	429a      	cmp	r2, r3
 8014a22:	d112      	bne.n	8014a4a <nk_panel_begin+0x5ee>
            background = &style->window.header.active;
 8014a24:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014a28:	f503 53b7 	add.w	r3, r3, #5856	; 0x16e0
 8014a2c:	3304      	adds	r3, #4
 8014a2e:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
            text.text = style->window.header.label_active;
 8014a32:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014a36:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014a3a:	461a      	mov	r2, r3
 8014a3c:	f107 0374 	add.w	r3, r7, #116	; 0x74
 8014a40:	f602 023b 	addw	r2, r2, #2107	; 0x83b
 8014a44:	6810      	ldr	r0, [r2, #0]
 8014a46:	6018      	str	r0, [r3, #0]
 8014a48:	e03b      	b.n	8014ac2 <nk_panel_begin+0x666>
        } else if (nk_input_is_mouse_hovering_rect(&ctx->input, header)) {
 8014a4a:	68fb      	ldr	r3, [r7, #12]
 8014a4c:	ed97 6a16 	vldr	s12, [r7, #88]	; 0x58
 8014a50:	edd7 6a17 	vldr	s13, [r7, #92]	; 0x5c
 8014a54:	ed97 7a18 	vldr	s14, [r7, #96]	; 0x60
 8014a58:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
 8014a5c:	eeb0 0a46 	vmov.f32	s0, s12
 8014a60:	eef0 0a66 	vmov.f32	s1, s13
 8014a64:	eeb0 1a47 	vmov.f32	s2, s14
 8014a68:	eef0 1a67 	vmov.f32	s3, s15
 8014a6c:	4618      	mov	r0, r3
 8014a6e:	f7fd fd56 	bl	801251e <nk_input_is_mouse_hovering_rect>
 8014a72:	4603      	mov	r3, r0
 8014a74:	2b00      	cmp	r3, #0
 8014a76:	d012      	beq.n	8014a9e <nk_panel_begin+0x642>
            background = &style->window.header.hover;
 8014a78:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014a7c:	f503 53b6 	add.w	r3, r3, #5824	; 0x16c0
 8014a80:	3308      	adds	r3, #8
 8014a82:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
            text.text = style->window.header.label_hover;
 8014a86:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014a8a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014a8e:	461a      	mov	r2, r3
 8014a90:	f107 0374 	add.w	r3, r7, #116	; 0x74
 8014a94:	f602 0237 	addw	r2, r2, #2103	; 0x837
 8014a98:	6810      	ldr	r0, [r2, #0]
 8014a9a:	6018      	str	r0, [r3, #0]
 8014a9c:	e011      	b.n	8014ac2 <nk_panel_begin+0x666>
        } else {
            background = &style->window.header.normal;
 8014a9e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014aa2:	f503 53b5 	add.w	r3, r3, #5792	; 0x16a0
 8014aa6:	330c      	adds	r3, #12
 8014aa8:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
            text.text = style->window.header.label_normal;
 8014aac:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014ab0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014ab4:	461a      	mov	r2, r3
 8014ab6:	f107 0374 	add.w	r3, r7, #116	; 0x74
 8014aba:	f602 0233 	addw	r2, r2, #2099	; 0x833
 8014abe:	6810      	ldr	r0, [r2, #0]
 8014ac0:	6018      	str	r0, [r3, #0]
        }

        /* draw header background */
        header.h += 1.0f;
 8014ac2:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
 8014ac6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8014aca:	ee77 7a87 	vadd.f32	s15, s15, s14
 8014ace:	edc7 7a19 	vstr	s15, [r7, #100]	; 0x64

        switch(background->type) {
 8014ad2:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8014ad6:	781b      	ldrb	r3, [r3, #0]
 8014ad8:	2b02      	cmp	r3, #2
 8014ada:	d02a      	beq.n	8014b32 <nk_panel_begin+0x6d6>
 8014adc:	2b02      	cmp	r3, #2
 8014ade:	dc6b      	bgt.n	8014bb8 <nk_panel_begin+0x75c>
 8014ae0:	2b00      	cmp	r3, #0
 8014ae2:	d04b      	beq.n	8014b7c <nk_panel_begin+0x720>
 8014ae4:	2b01      	cmp	r3, #1
 8014ae6:	d167      	bne.n	8014bb8 <nk_panel_begin+0x75c>
            case NK_STYLE_ITEM_IMAGE:
                text.background = nk_rgba(0,0,0,0);
 8014ae8:	2300      	movs	r3, #0
 8014aea:	2200      	movs	r2, #0
 8014aec:	2100      	movs	r1, #0
 8014aee:	2000      	movs	r0, #0
 8014af0:	f7fa f9c6 	bl	800ee80 <nk_rgba>
 8014af4:	4603      	mov	r3, r0
 8014af6:	673b      	str	r3, [r7, #112]	; 0x70
                nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
 8014af8:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8014afc:	f103 0064 	add.w	r0, r3, #100	; 0x64
 8014b00:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8014b04:	3304      	adds	r3, #4
 8014b06:	4ad9      	ldr	r2, [pc, #868]	; (8014e6c <nk_panel_begin+0xa10>)
 8014b08:	ed97 6a16 	vldr	s12, [r7, #88]	; 0x58
 8014b0c:	edd7 6a17 	vldr	s13, [r7, #92]	; 0x5c
 8014b10:	ed97 7a18 	vldr	s14, [r7, #96]	; 0x60
 8014b14:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
 8014b18:	6812      	ldr	r2, [r2, #0]
 8014b1a:	4619      	mov	r1, r3
 8014b1c:	eeb0 0a46 	vmov.f32	s0, s12
 8014b20:	eef0 0a66 	vmov.f32	s1, s13
 8014b24:	eeb0 1a47 	vmov.f32	s2, s14
 8014b28:	eef0 1a67 	vmov.f32	s3, s15
 8014b2c:	f7fc fc10 	bl	8011350 <nk_draw_image>
                break;
 8014b30:	e042      	b.n	8014bb8 <nk_panel_begin+0x75c>
            case NK_STYLE_ITEM_NINE_SLICE:
                text.background = nk_rgba(0, 0, 0, 0);
 8014b32:	2300      	movs	r3, #0
 8014b34:	2200      	movs	r2, #0
 8014b36:	2100      	movs	r1, #0
 8014b38:	2000      	movs	r0, #0
 8014b3a:	f7fa f9a1 	bl	800ee80 <nk_rgba>
 8014b3e:	4603      	mov	r3, r0
 8014b40:	673b      	str	r3, [r7, #112]	; 0x70
                nk_draw_nine_slice(&win->buffer, header, &background->data.slice, nk_white);
 8014b42:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8014b46:	f103 0064 	add.w	r0, r3, #100	; 0x64
 8014b4a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8014b4e:	3304      	adds	r3, #4
 8014b50:	4ac6      	ldr	r2, [pc, #792]	; (8014e6c <nk_panel_begin+0xa10>)
 8014b52:	ed97 6a16 	vldr	s12, [r7, #88]	; 0x58
 8014b56:	edd7 6a17 	vldr	s13, [r7, #92]	; 0x5c
 8014b5a:	ed97 7a18 	vldr	s14, [r7, #96]	; 0x60
 8014b5e:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
 8014b62:	6812      	ldr	r2, [r2, #0]
 8014b64:	4619      	mov	r1, r3
 8014b66:	eeb0 0a46 	vmov.f32	s0, s12
 8014b6a:	eef0 0a66 	vmov.f32	s1, s13
 8014b6e:	eeb0 1a47 	vmov.f32	s2, s14
 8014b72:	eef0 1a67 	vmov.f32	s3, s15
 8014b76:	f7fc fcdd 	bl	8011534 <nk_draw_nine_slice>
                break;
 8014b7a:	e01d      	b.n	8014bb8 <nk_panel_begin+0x75c>
            case NK_STYLE_ITEM_COLOR:
                text.background = background->data.color;
 8014b7c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8014b80:	685b      	ldr	r3, [r3, #4]
 8014b82:	673b      	str	r3, [r7, #112]	; 0x70
                nk_fill_rect(out, header, 0, background->data.color);
 8014b84:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8014b88:	ed97 6a16 	vldr	s12, [r7, #88]	; 0x58
 8014b8c:	edd7 6a17 	vldr	s13, [r7, #92]	; 0x5c
 8014b90:	ed97 7a18 	vldr	s14, [r7, #96]	; 0x60
 8014b94:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
 8014b98:	6859      	ldr	r1, [r3, #4]
 8014b9a:	ed9f 2ab5 	vldr	s4, [pc, #724]	; 8014e70 <nk_panel_begin+0xa14>
 8014b9e:	eeb0 0a46 	vmov.f32	s0, s12
 8014ba2:	eef0 0a66 	vmov.f32	s1, s13
 8014ba6:	eeb0 1a47 	vmov.f32	s2, s14
 8014baa:	eef0 1a67 	vmov.f32	s3, s15
 8014bae:	f8d7 00b0 	ldr.w	r0, [r7, #176]	; 0xb0
 8014bb2:	f7fc f873 	bl	8010c9c <nk_fill_rect>
                break;
 8014bb6:	bf00      	nop
        }

        /* window close button */
        {struct nk_rect button;
        button.y = header.y + style->window.header.padding.y;
 8014bb8:	ed97 7a17 	vldr	s14, [r7, #92]	; 0x5c
 8014bbc:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014bc0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014bc4:	f603 0344 	addw	r3, r3, #2116	; 0x844
 8014bc8:	edd3 7a00 	vldr	s15, [r3]
 8014bcc:	ee77 7a27 	vadd.f32	s15, s14, s15
 8014bd0:	edc7 7a13 	vstr	s15, [r7, #76]	; 0x4c
        button.h = header.h - 2 * style->window.header.padding.y;
 8014bd4:	ed97 7a19 	vldr	s14, [r7, #100]	; 0x64
 8014bd8:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014bdc:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014be0:	f603 0344 	addw	r3, r3, #2116	; 0x844
 8014be4:	edd3 7a00 	vldr	s15, [r3]
 8014be8:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8014bec:	ee77 7a67 	vsub.f32	s15, s14, s15
 8014bf0:	edc7 7a15 	vstr	s15, [r7, #84]	; 0x54
        button.w = button.h;
 8014bf4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8014bf6:	653b      	str	r3, [r7, #80]	; 0x50
        if (win->flags & NK_WINDOW_CLOSABLE) {
 8014bf8:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8014bfc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8014bfe:	f003 0308 	and.w	r3, r3, #8
 8014c02:	2b00      	cmp	r3, #0
 8014c04:	f000 80ad 	beq.w	8014d62 <nk_panel_begin+0x906>
            nk_flags ws = 0;
 8014c08:	2300      	movs	r3, #0
 8014c0a:	647b      	str	r3, [r7, #68]	; 0x44
            if (style->window.header.align == NK_HEADER_RIGHT) {
 8014c0c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014c10:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014c14:	f893 383f 	ldrb.w	r3, [r3, #2111]	; 0x83f
 8014c18:	2b01      	cmp	r3, #1
 8014c1a:	d132      	bne.n	8014c82 <nk_panel_begin+0x826>
                button.x = (header.w + header.x) - (button.w + style->window.header.padding.x);
 8014c1c:	ed97 7a18 	vldr	s14, [r7, #96]	; 0x60
 8014c20:	edd7 7a16 	vldr	s15, [r7, #88]	; 0x58
 8014c24:	ee37 7a27 	vadd.f32	s14, s14, s15
 8014c28:	edd7 6a14 	vldr	s13, [r7, #80]	; 0x50
 8014c2c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014c30:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014c34:	f503 6304 	add.w	r3, r3, #2112	; 0x840
 8014c38:	edd3 7a00 	vldr	s15, [r3]
 8014c3c:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8014c40:	ee77 7a67 	vsub.f32	s15, s14, s15
 8014c44:	edc7 7a12 	vstr	s15, [r7, #72]	; 0x48
                header.w -= button.w + style->window.header.spacing.x + style->window.header.padding.x;
 8014c48:	ed97 7a18 	vldr	s14, [r7, #96]	; 0x60
 8014c4c:	edd7 6a14 	vldr	s13, [r7, #80]	; 0x50
 8014c50:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014c54:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014c58:	f503 6305 	add.w	r3, r3, #2128	; 0x850
 8014c5c:	edd3 7a00 	vldr	s15, [r3]
 8014c60:	ee76 6aa7 	vadd.f32	s13, s13, s15
 8014c64:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014c68:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014c6c:	f503 6304 	add.w	r3, r3, #2112	; 0x840
 8014c70:	edd3 7a00 	vldr	s15, [r3]
 8014c74:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8014c78:	ee77 7a67 	vsub.f32	s15, s14, s15
 8014c7c:	edc7 7a18 	vstr	s15, [r7, #96]	; 0x60
 8014c80:	e029      	b.n	8014cd6 <nk_panel_begin+0x87a>
            } else {
                button.x = header.x + style->window.header.padding.x;
 8014c82:	ed97 7a16 	vldr	s14, [r7, #88]	; 0x58
 8014c86:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014c8a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014c8e:	f503 6304 	add.w	r3, r3, #2112	; 0x840
 8014c92:	edd3 7a00 	vldr	s15, [r3]
 8014c96:	ee77 7a27 	vadd.f32	s15, s14, s15
 8014c9a:	edc7 7a12 	vstr	s15, [r7, #72]	; 0x48
                header.x += button.w + style->window.header.spacing.x + style->window.header.padding.x;
 8014c9e:	ed97 7a16 	vldr	s14, [r7, #88]	; 0x58
 8014ca2:	edd7 6a14 	vldr	s13, [r7, #80]	; 0x50
 8014ca6:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014caa:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014cae:	f503 6305 	add.w	r3, r3, #2128	; 0x850
 8014cb2:	edd3 7a00 	vldr	s15, [r3]
 8014cb6:	ee76 6aa7 	vadd.f32	s13, s13, s15
 8014cba:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014cbe:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014cc2:	f503 6304 	add.w	r3, r3, #2112	; 0x840
 8014cc6:	edd3 7a00 	vldr	s15, [r3]
 8014cca:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8014cce:	ee77 7a27 	vadd.f32	s15, s14, s15
 8014cd2:	edc7 7a16 	vstr	s15, [r7, #88]	; 0x58
            }

            if (nk_do_button_symbol(&ws, &win->buffer, button,
 8014cd6:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8014cda:	f103 0164 	add.w	r1, r3, #100	; 0x64
                style->window.header.close_symbol, NK_BUTTON_DEFAULT,
 8014cde:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014ce2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014ce6:	f893 4830 	ldrb.w	r4, [r3, #2096]	; 0x830
            if (nk_do_button_symbol(&ws, &win->buffer, button,
 8014cea:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014cee:	f503 53b8 	add.w	r3, r3, #5888	; 0x1700
                &style->window.header.close_button, in, style->font) && !(win->flags & NK_WINDOW_ROM))
 8014cf2:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 8014cf6:	6812      	ldr	r2, [r2, #0]
            if (nk_do_button_symbol(&ws, &win->buffer, button,
 8014cf8:	ed97 6a12 	vldr	s12, [r7, #72]	; 0x48
 8014cfc:	edd7 6a13 	vldr	s13, [r7, #76]	; 0x4c
 8014d00:	ed97 7a14 	vldr	s14, [r7, #80]	; 0x50
 8014d04:	edd7 7a15 	vldr	s15, [r7, #84]	; 0x54
 8014d08:	f107 0044 	add.w	r0, r7, #68	; 0x44
 8014d0c:	9202      	str	r2, [sp, #8]
 8014d0e:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 8014d12:	9201      	str	r2, [sp, #4]
 8014d14:	9300      	str	r3, [sp, #0]
 8014d16:	2300      	movs	r3, #0
 8014d18:	4622      	mov	r2, r4
 8014d1a:	eeb0 0a46 	vmov.f32	s0, s12
 8014d1e:	eef0 0a66 	vmov.f32	s1, s13
 8014d22:	eeb0 1a47 	vmov.f32	s2, s14
 8014d26:	eef0 1a67 	vmov.f32	s3, s15
 8014d2a:	f7f9 fe23 	bl	800e974 <nk_do_button_symbol>
 8014d2e:	4603      	mov	r3, r0
 8014d30:	2b00      	cmp	r3, #0
 8014d32:	d016      	beq.n	8014d62 <nk_panel_begin+0x906>
                &style->window.header.close_button, in, style->font) && !(win->flags & NK_WINDOW_ROM))
 8014d34:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8014d38:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8014d3a:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8014d3e:	2b00      	cmp	r3, #0
 8014d40:	d10f      	bne.n	8014d62 <nk_panel_begin+0x906>
            {
                layout->flags |= NK_WINDOW_HIDDEN;
 8014d42:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014d46:	685b      	ldr	r3, [r3, #4]
 8014d48:	f443 5200 	orr.w	r2, r3, #8192	; 0x2000
 8014d4c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014d50:	605a      	str	r2, [r3, #4]
                layout->flags &= (nk_flags)~NK_WINDOW_MINIMIZED;
 8014d52:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014d56:	685b      	ldr	r3, [r3, #4]
 8014d58:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
 8014d5c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014d60:	605a      	str	r2, [r3, #4]
            }
        }

        /* window minimize button */
        if (win->flags & NK_WINDOW_MINIMIZABLE) {
 8014d62:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8014d66:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8014d68:	f003 0310 	and.w	r3, r3, #16
 8014d6c:	2b00      	cmp	r3, #0
 8014d6e:	f000 80c9 	beq.w	8014f04 <nk_panel_begin+0xaa8>
            nk_flags ws = 0;
 8014d72:	2300      	movs	r3, #0
 8014d74:	643b      	str	r3, [r7, #64]	; 0x40
            if (style->window.header.align == NK_HEADER_RIGHT) {
 8014d76:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014d7a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014d7e:	f893 383f 	ldrb.w	r3, [r3, #2111]	; 0x83f
 8014d82:	2b01      	cmp	r3, #1
 8014d84:	d141      	bne.n	8014e0a <nk_panel_begin+0x9ae>
                button.x = (header.w + header.x) - button.w;
 8014d86:	ed97 7a18 	vldr	s14, [r7, #96]	; 0x60
 8014d8a:	edd7 7a16 	vldr	s15, [r7, #88]	; 0x58
 8014d8e:	ee37 7a27 	vadd.f32	s14, s14, s15
 8014d92:	edd7 7a14 	vldr	s15, [r7, #80]	; 0x50
 8014d96:	ee77 7a67 	vsub.f32	s15, s14, s15
 8014d9a:	edc7 7a12 	vstr	s15, [r7, #72]	; 0x48
                if (!(win->flags & NK_WINDOW_CLOSABLE)) {
 8014d9e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8014da2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8014da4:	f003 0308 	and.w	r3, r3, #8
 8014da8:	2b00      	cmp	r3, #0
 8014daa:	d11b      	bne.n	8014de4 <nk_panel_begin+0x988>
                    button.x -= style->window.header.padding.x;
 8014dac:	ed97 7a12 	vldr	s14, [r7, #72]	; 0x48
 8014db0:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014db4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014db8:	f503 6304 	add.w	r3, r3, #2112	; 0x840
 8014dbc:	edd3 7a00 	vldr	s15, [r3]
 8014dc0:	ee77 7a67 	vsub.f32	s15, s14, s15
 8014dc4:	edc7 7a12 	vstr	s15, [r7, #72]	; 0x48
                    header.w -= style->window.header.padding.x;
 8014dc8:	ed97 7a18 	vldr	s14, [r7, #96]	; 0x60
 8014dcc:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014dd0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014dd4:	f503 6304 	add.w	r3, r3, #2112	; 0x840
 8014dd8:	edd3 7a00 	vldr	s15, [r3]
 8014ddc:	ee77 7a67 	vsub.f32	s15, s14, s15
 8014de0:	edc7 7a18 	vstr	s15, [r7, #96]	; 0x60
                }
                header.w -= button.w + style->window.header.spacing.x;
 8014de4:	ed97 7a18 	vldr	s14, [r7, #96]	; 0x60
 8014de8:	edd7 6a14 	vldr	s13, [r7, #80]	; 0x50
 8014dec:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014df0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014df4:	f503 6305 	add.w	r3, r3, #2128	; 0x850
 8014df8:	edd3 7a00 	vldr	s15, [r3]
 8014dfc:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8014e00:	ee77 7a67 	vsub.f32	s15, s14, s15
 8014e04:	edc7 7a18 	vstr	s15, [r7, #96]	; 0x60
 8014e08:	e01d      	b.n	8014e46 <nk_panel_begin+0x9ea>
            } else {
                button.x = header.x;
 8014e0a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014e0c:	64bb      	str	r3, [r7, #72]	; 0x48
                header.x += button.w + style->window.header.spacing.x + style->window.header.padding.x;
 8014e0e:	ed97 7a16 	vldr	s14, [r7, #88]	; 0x58
 8014e12:	edd7 6a14 	vldr	s13, [r7, #80]	; 0x50
 8014e16:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014e1a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014e1e:	f503 6305 	add.w	r3, r3, #2128	; 0x850
 8014e22:	edd3 7a00 	vldr	s15, [r3]
 8014e26:	ee76 6aa7 	vadd.f32	s13, s13, s15
 8014e2a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014e2e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014e32:	f503 6304 	add.w	r3, r3, #2112	; 0x840
 8014e36:	edd3 7a00 	vldr	s15, [r3]
 8014e3a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8014e3e:	ee77 7a27 	vadd.f32	s15, s14, s15
 8014e42:	edc7 7a16 	vstr	s15, [r7, #88]	; 0x58
            }
            if (nk_do_button_symbol(&ws, &win->buffer, button, (layout->flags & NK_WINDOW_MINIMIZED)?
 8014e46:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8014e4a:	f103 0464 	add.w	r4, r3, #100	; 0x64
 8014e4e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014e52:	685b      	ldr	r3, [r3, #4]
 8014e54:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8014e58:	2b00      	cmp	r3, #0
 8014e5a:	d00b      	beq.n	8014e74 <nk_panel_begin+0xa18>
 8014e5c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014e60:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014e64:	f893 2832 	ldrb.w	r2, [r3, #2098]	; 0x832
 8014e68:	e00a      	b.n	8014e80 <nk_panel_begin+0xa24>
 8014e6a:	bf00      	nop
 8014e6c:	080235a0 	.word	0x080235a0
 8014e70:	00000000 	.word	0x00000000
 8014e74:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014e78:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014e7c:	f893 2831 	ldrb.w	r2, [r3, #2097]	; 0x831
 8014e80:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014e84:	f503 53bc 	add.w	r3, r3, #6016	; 0x1780
 8014e88:	3318      	adds	r3, #24
                style->window.header.maximize_symbol: style->window.header.minimize_symbol,
                NK_BUTTON_DEFAULT, &style->window.header.minimize_button, in, style->font) && !(win->flags & NK_WINDOW_ROM))
 8014e8a:	f8d7 10c0 	ldr.w	r1, [r7, #192]	; 0xc0
 8014e8e:	6809      	ldr	r1, [r1, #0]
            if (nk_do_button_symbol(&ws, &win->buffer, button, (layout->flags & NK_WINDOW_MINIMIZED)?
 8014e90:	ed97 6a12 	vldr	s12, [r7, #72]	; 0x48
 8014e94:	edd7 6a13 	vldr	s13, [r7, #76]	; 0x4c
 8014e98:	ed97 7a14 	vldr	s14, [r7, #80]	; 0x50
 8014e9c:	edd7 7a15 	vldr	s15, [r7, #84]	; 0x54
 8014ea0:	f107 0040 	add.w	r0, r7, #64	; 0x40
 8014ea4:	9102      	str	r1, [sp, #8]
 8014ea6:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 8014eaa:	9101      	str	r1, [sp, #4]
 8014eac:	9300      	str	r3, [sp, #0]
 8014eae:	2300      	movs	r3, #0
 8014eb0:	eeb0 0a46 	vmov.f32	s0, s12
 8014eb4:	eef0 0a66 	vmov.f32	s1, s13
 8014eb8:	eeb0 1a47 	vmov.f32	s2, s14
 8014ebc:	eef0 1a67 	vmov.f32	s3, s15
 8014ec0:	4621      	mov	r1, r4
 8014ec2:	f7f9 fd57 	bl	800e974 <nk_do_button_symbol>
 8014ec6:	4603      	mov	r3, r0
 8014ec8:	2b00      	cmp	r3, #0
 8014eca:	d01b      	beq.n	8014f04 <nk_panel_begin+0xaa8>
                NK_BUTTON_DEFAULT, &style->window.header.minimize_button, in, style->font) && !(win->flags & NK_WINDOW_ROM))
 8014ecc:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8014ed0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8014ed2:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8014ed6:	2b00      	cmp	r3, #0
 8014ed8:	d114      	bne.n	8014f04 <nk_panel_begin+0xaa8>
                layout->flags = (layout->flags & NK_WINDOW_MINIMIZED) ?
 8014eda:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014ede:	685b      	ldr	r3, [r3, #4]
 8014ee0:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
                    layout->flags & (nk_flags)~NK_WINDOW_MINIMIZED:
 8014ee4:	2b00      	cmp	r3, #0
 8014ee6:	d005      	beq.n	8014ef4 <nk_panel_begin+0xa98>
 8014ee8:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014eec:	685b      	ldr	r3, [r3, #4]
 8014eee:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8014ef2:	e004      	b.n	8014efe <nk_panel_begin+0xaa2>
                    layout->flags | NK_WINDOW_MINIMIZED;
 8014ef4:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014ef8:	685b      	ldr	r3, [r3, #4]
                    layout->flags & (nk_flags)~NK_WINDOW_MINIMIZED:
 8014efa:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
                layout->flags = (layout->flags & NK_WINDOW_MINIMIZED) ?
 8014efe:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8014f02:	6053      	str	r3, [r2, #4]
        }}

        {/* window header title */
        int text_len = nk_strlen(title);
 8014f04:	68b8      	ldr	r0, [r7, #8]
 8014f06:	f007 f8ad 	bl	801c064 <nk_strlen>
 8014f0a:	f8c7 009c 	str.w	r0, [r7, #156]	; 0x9c
        struct nk_rect label = {0,0,0,0};
 8014f0e:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8014f12:	2200      	movs	r2, #0
 8014f14:	601a      	str	r2, [r3, #0]
 8014f16:	605a      	str	r2, [r3, #4]
 8014f18:	609a      	str	r2, [r3, #8]
 8014f1a:	60da      	str	r2, [r3, #12]
        float t = font->width(font->userdata, font->height, title, text_len);
 8014f1c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8014f20:	689b      	ldr	r3, [r3, #8]
 8014f22:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8014f26:	edd2 7a01 	vldr	s15, [r2, #4]
 8014f2a:	f8d7 00bc 	ldr.w	r0, [r7, #188]	; 0xbc
 8014f2e:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8014f32:	68b9      	ldr	r1, [r7, #8]
 8014f34:	eeb0 0a67 	vmov.f32	s0, s15
 8014f38:	6800      	ldr	r0, [r0, #0]
 8014f3a:	4798      	blx	r3
 8014f3c:	ed87 0a26 	vstr	s0, [r7, #152]	; 0x98
        text.padding = nk_vec2(0,0);
 8014f40:	ed5f 0a35 	vldr	s1, [pc, #-212]	; 8014e70 <nk_panel_begin+0xa14>
 8014f44:	ed1f 0a36 	vldr	s0, [pc, #-216]	; 8014e70 <nk_panel_begin+0xa14>
 8014f48:	f7fe fcb6 	bl	80138b8 <nk_vec2>
 8014f4c:	eeb0 7a40 	vmov.f32	s14, s0
 8014f50:	eef0 7a60 	vmov.f32	s15, s1
 8014f54:	ed87 7a1a 	vstr	s14, [r7, #104]	; 0x68
 8014f58:	edc7 7a1b 	vstr	s15, [r7, #108]	; 0x6c

        label.x = header.x + style->window.header.padding.x;
 8014f5c:	ed97 7a16 	vldr	s14, [r7, #88]	; 0x58
 8014f60:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014f64:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014f68:	f503 6304 	add.w	r3, r3, #2112	; 0x840
 8014f6c:	edd3 7a00 	vldr	s15, [r3]
 8014f70:	ee77 7a27 	vadd.f32	s15, s14, s15
 8014f74:	edc7 7a0c 	vstr	s15, [r7, #48]	; 0x30
        label.x += style->window.header.label_padding.x;
 8014f78:	ed97 7a0c 	vldr	s14, [r7, #48]	; 0x30
 8014f7c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014f80:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014f84:	f603 0348 	addw	r3, r3, #2120	; 0x848
 8014f88:	edd3 7a00 	vldr	s15, [r3]
 8014f8c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8014f90:	edc7 7a0c 	vstr	s15, [r7, #48]	; 0x30
        label.y = header.y + style->window.header.label_padding.y;
 8014f94:	ed97 7a17 	vldr	s14, [r7, #92]	; 0x5c
 8014f98:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014f9c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014fa0:	f603 034c 	addw	r3, r3, #2124	; 0x84c
 8014fa4:	edd3 7a00 	vldr	s15, [r3]
 8014fa8:	ee77 7a27 	vadd.f32	s15, s14, s15
 8014fac:	edc7 7a0d 	vstr	s15, [r7, #52]	; 0x34
        label.h = font->height + 2 * style->window.header.label_padding.y;
 8014fb0:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8014fb4:	ed93 7a01 	vldr	s14, [r3, #4]
 8014fb8:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014fbc:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014fc0:	f603 034c 	addw	r3, r3, #2124	; 0x84c
 8014fc4:	edd3 7a00 	vldr	s15, [r3]
 8014fc8:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8014fcc:	ee77 7a27 	vadd.f32	s15, s14, s15
 8014fd0:	edc7 7a0f 	vstr	s15, [r7, #60]	; 0x3c
        label.w = t + 2 * style->window.header.spacing.x;
 8014fd4:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8014fd8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014fdc:	f503 6305 	add.w	r3, r3, #2128	; 0x850
 8014fe0:	edd3 7a00 	vldr	s15, [r3]
 8014fe4:	ee37 7aa7 	vadd.f32	s14, s15, s15
 8014fe8:	edd7 7a26 	vldr	s15, [r7, #152]	; 0x98
 8014fec:	ee77 7a27 	vadd.f32	s15, s14, s15
 8014ff0:	edc7 7a0e 	vstr	s15, [r7, #56]	; 0x38
        label.w = NK_CLAMP(0, label.w, header.x + header.w - label.x);
 8014ff4:	ed97 7a0e 	vldr	s14, [r7, #56]	; 0x38
 8014ff8:	edd7 6a16 	vldr	s13, [r7, #88]	; 0x58
 8014ffc:	edd7 7a18 	vldr	s15, [r7, #96]	; 0x60
 8015000:	ee76 6aa7 	vadd.f32	s13, s13, s15
 8015004:	edd7 7a0c 	vldr	s15, [r7, #48]	; 0x30
 8015008:	ee76 7ae7 	vsub.f32	s15, s13, s15
 801500c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8015010:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015014:	d50a      	bpl.n	801502c <nk_panel_begin+0xbd0>
 8015016:	edd7 7a0e 	vldr	s15, [r7, #56]	; 0x38
 801501a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801501e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015022:	bf4c      	ite	mi
 8015024:	2301      	movmi	r3, #1
 8015026:	2300      	movpl	r3, #0
 8015028:	b2db      	uxtb	r3, r3
 801502a:	e011      	b.n	8015050 <nk_panel_begin+0xbf4>
 801502c:	ed97 7a16 	vldr	s14, [r7, #88]	; 0x58
 8015030:	edd7 7a18 	vldr	s15, [r7, #96]	; 0x60
 8015034:	ee37 7a27 	vadd.f32	s14, s14, s15
 8015038:	edd7 7a0c 	vldr	s15, [r7, #48]	; 0x30
 801503c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8015040:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8015044:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015048:	bf4c      	ite	mi
 801504a:	2301      	movmi	r3, #1
 801504c:	2300      	movpl	r3, #0
 801504e:	b2db      	uxtb	r3, r3
 8015050:	2b00      	cmp	r3, #0
 8015052:	d002      	beq.n	801505a <nk_panel_begin+0xbfe>
 8015054:	ed5f 7a7a 	vldr	s15, [pc, #-488]	; 8014e70 <nk_panel_begin+0xa14>
 8015058:	e01d      	b.n	8015096 <nk_panel_begin+0xc3a>
 801505a:	ed97 7a0e 	vldr	s14, [r7, #56]	; 0x38
 801505e:	edd7 6a16 	vldr	s13, [r7, #88]	; 0x58
 8015062:	edd7 7a18 	vldr	s15, [r7, #96]	; 0x60
 8015066:	ee76 6aa7 	vadd.f32	s13, s13, s15
 801506a:	edd7 7a0c 	vldr	s15, [r7, #48]	; 0x30
 801506e:	ee76 7ae7 	vsub.f32	s15, s13, s15
 8015072:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8015076:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801507a:	d502      	bpl.n	8015082 <nk_panel_begin+0xc26>
 801507c:	edd7 7a0e 	vldr	s15, [r7, #56]	; 0x38
 8015080:	e009      	b.n	8015096 <nk_panel_begin+0xc3a>
 8015082:	ed97 7a16 	vldr	s14, [r7, #88]	; 0x58
 8015086:	edd7 7a18 	vldr	s15, [r7, #96]	; 0x60
 801508a:	ee37 7a27 	vadd.f32	s14, s14, s15
 801508e:	edd7 7a0c 	vldr	s15, [r7, #48]	; 0x30
 8015092:	ee77 7a67 	vsub.f32	s15, s14, s15
 8015096:	edc7 7a0e 	vstr	s15, [r7, #56]	; 0x38
        nk_widget_text(out, label, (const char*)title, text_len, &text, NK_TEXT_LEFT, font);}
 801509a:	f107 0268 	add.w	r2, r7, #104	; 0x68
 801509e:	ed97 6a0c 	vldr	s12, [r7, #48]	; 0x30
 80150a2:	edd7 6a0d 	vldr	s13, [r7, #52]	; 0x34
 80150a6:	ed97 7a0e 	vldr	s14, [r7, #56]	; 0x38
 80150aa:	edd7 7a0f 	vldr	s15, [r7, #60]	; 0x3c
 80150ae:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80150b2:	9301      	str	r3, [sp, #4]
 80150b4:	2311      	movs	r3, #17
 80150b6:	9300      	str	r3, [sp, #0]
 80150b8:	4613      	mov	r3, r2
 80150ba:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 80150be:	68b9      	ldr	r1, [r7, #8]
 80150c0:	eeb0 0a46 	vmov.f32	s0, s12
 80150c4:	eef0 0a66 	vmov.f32	s1, s13
 80150c8:	eeb0 1a47 	vmov.f32	s2, s14
 80150cc:	eef0 1a67 	vmov.f32	s3, s15
 80150d0:	f8d7 00b0 	ldr.w	r0, [r7, #176]	; 0xb0
 80150d4:	f005 fdee 	bl	801acb4 <nk_widget_text>
    }

    /* draw window background */
    if (!(layout->flags & NK_WINDOW_MINIMIZED) && !(layout->flags & NK_WINDOW_DYNAMIC)) {
 80150d8:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80150dc:	685b      	ldr	r3, [r3, #4]
 80150de:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80150e2:	2b00      	cmp	r3, #0
 80150e4:	f040 808d 	bne.w	8015202 <nk_panel_begin+0xda6>
 80150e8:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80150ec:	685b      	ldr	r3, [r3, #4]
 80150ee:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80150f2:	2b00      	cmp	r3, #0
 80150f4:	f040 8085 	bne.w	8015202 <nk_panel_begin+0xda6>
        struct nk_rect body;
        body.x = win->bounds.x;
 80150f8:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80150fc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80150fe:	623b      	str	r3, [r7, #32]
        body.w = win->bounds.w;
 8015100:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8015104:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8015106:	62bb      	str	r3, [r7, #40]	; 0x28
        body.y = (win->bounds.y + layout->header_height);
 8015108:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801510c:	ed93 7a14 	vldr	s14, [r3, #80]	; 0x50
 8015110:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8015114:	edd3 7a0c 	vldr	s15, [r3, #48]	; 0x30
 8015118:	ee77 7a27 	vadd.f32	s15, s14, s15
 801511c:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
        body.h = (win->bounds.h - layout->header_height);
 8015120:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8015124:	ed93 7a16 	vldr	s14, [r3, #88]	; 0x58
 8015128:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801512c:	edd3 7a0c 	vldr	s15, [r3, #48]	; 0x30
 8015130:	ee77 7a67 	vsub.f32	s15, s14, s15
 8015134:	edc7 7a0b 	vstr	s15, [r7, #44]	; 0x2c

        switch(style->window.fixed_background.type) {
 8015138:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 801513c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8015140:	f893 3858 	ldrb.w	r3, [r3, #2136]	; 0x858
 8015144:	2b02      	cmp	r3, #2
 8015146:	d022      	beq.n	801518e <nk_panel_begin+0xd32>
 8015148:	2b02      	cmp	r3, #2
 801514a:	dc5a      	bgt.n	8015202 <nk_panel_begin+0xda6>
 801514c:	2b00      	cmp	r3, #0
 801514e:	d03b      	beq.n	80151c8 <nk_panel_begin+0xd6c>
 8015150:	2b01      	cmp	r3, #1
 8015152:	d156      	bne.n	8015202 <nk_panel_begin+0xda6>
            case NK_STYLE_ITEM_IMAGE:
                nk_draw_image(out, body, &style->window.fixed_background.data.image, nk_white);
 8015154:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8015158:	f503 53c2 	add.w	r3, r3, #6208	; 0x1840
 801515c:	331c      	adds	r3, #28
 801515e:	4a5e      	ldr	r2, [pc, #376]	; (80152d8 <nk_panel_begin+0xe7c>)
 8015160:	ed97 6a08 	vldr	s12, [r7, #32]
 8015164:	edd7 6a09 	vldr	s13, [r7, #36]	; 0x24
 8015168:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
 801516c:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
 8015170:	6812      	ldr	r2, [r2, #0]
 8015172:	4619      	mov	r1, r3
 8015174:	eeb0 0a46 	vmov.f32	s0, s12
 8015178:	eef0 0a66 	vmov.f32	s1, s13
 801517c:	eeb0 1a47 	vmov.f32	s2, s14
 8015180:	eef0 1a67 	vmov.f32	s3, s15
 8015184:	f8d7 00b0 	ldr.w	r0, [r7, #176]	; 0xb0
 8015188:	f7fc f8e2 	bl	8011350 <nk_draw_image>
                break;
 801518c:	e039      	b.n	8015202 <nk_panel_begin+0xda6>
            case NK_STYLE_ITEM_NINE_SLICE:
                nk_draw_nine_slice(out, body, &style->window.fixed_background.data.slice, nk_white);
 801518e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8015192:	f503 53c2 	add.w	r3, r3, #6208	; 0x1840
 8015196:	331c      	adds	r3, #28
 8015198:	4a4f      	ldr	r2, [pc, #316]	; (80152d8 <nk_panel_begin+0xe7c>)
 801519a:	ed97 6a08 	vldr	s12, [r7, #32]
 801519e:	edd7 6a09 	vldr	s13, [r7, #36]	; 0x24
 80151a2:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
 80151a6:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
 80151aa:	6812      	ldr	r2, [r2, #0]
 80151ac:	4619      	mov	r1, r3
 80151ae:	eeb0 0a46 	vmov.f32	s0, s12
 80151b2:	eef0 0a66 	vmov.f32	s1, s13
 80151b6:	eeb0 1a47 	vmov.f32	s2, s14
 80151ba:	eef0 1a67 	vmov.f32	s3, s15
 80151be:	f8d7 00b0 	ldr.w	r0, [r7, #176]	; 0xb0
 80151c2:	f7fc f9b7 	bl	8011534 <nk_draw_nine_slice>
                break;
 80151c6:	e01c      	b.n	8015202 <nk_panel_begin+0xda6>
            case NK_STYLE_ITEM_COLOR:
                nk_fill_rect(out, body, 0, style->window.fixed_background.data.color);
 80151c8:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 80151cc:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80151d0:	ed97 6a08 	vldr	s12, [r7, #32]
 80151d4:	edd7 6a09 	vldr	s13, [r7, #36]	; 0x24
 80151d8:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
 80151dc:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
 80151e0:	f8d3 185c 	ldr.w	r1, [r3, #2140]	; 0x85c
 80151e4:	ed9f 2a3d 	vldr	s4, [pc, #244]	; 80152dc <nk_panel_begin+0xe80>
 80151e8:	eeb0 0a46 	vmov.f32	s0, s12
 80151ec:	eef0 0a66 	vmov.f32	s1, s13
 80151f0:	eeb0 1a47 	vmov.f32	s2, s14
 80151f4:	eef0 1a67 	vmov.f32	s3, s15
 80151f8:	f8d7 00b0 	ldr.w	r0, [r7, #176]	; 0xb0
 80151fc:	f7fb fd4e 	bl	8010c9c <nk_fill_rect>
                break;
 8015200:	bf00      	nop
        }
    }

    /* set clipping rectangle */
    {struct nk_rect clip;
    layout->clip = layout->bounds;
 8015202:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8015206:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801520a:	f102 043c 	add.w	r4, r2, #60	; 0x3c
 801520e:	3308      	adds	r3, #8
 8015210:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8015212:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    nk_unify(&clip, &win->buffer.clip, layout->clip.x, layout->clip.y,
 8015216:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801521a:	f103 0268 	add.w	r2, r3, #104	; 0x68
 801521e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8015222:	edd3 6a0f 	vldr	s13, [r3, #60]	; 0x3c
 8015226:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801522a:	ed93 6a10 	vldr	s12, [r3, #64]	; 0x40
        layout->clip.x + layout->clip.w, layout->clip.y + layout->clip.h);
 801522e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8015232:	ed93 7a0f 	vldr	s14, [r3, #60]	; 0x3c
 8015236:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801523a:	edd3 7a11 	vldr	s15, [r3, #68]	; 0x44
    nk_unify(&clip, &win->buffer.clip, layout->clip.x, layout->clip.y,
 801523e:	ee77 5a27 	vadd.f32	s11, s14, s15
        layout->clip.x + layout->clip.w, layout->clip.y + layout->clip.h);
 8015242:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8015246:	ed93 7a10 	vldr	s14, [r3, #64]	; 0x40
 801524a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801524e:	edd3 7a12 	vldr	s15, [r3, #72]	; 0x48
    nk_unify(&clip, &win->buffer.clip, layout->clip.x, layout->clip.y,
 8015252:	ee77 7a27 	vadd.f32	s15, s14, s15
 8015256:	f107 0310 	add.w	r3, r7, #16
 801525a:	eef0 1a67 	vmov.f32	s3, s15
 801525e:	eeb0 1a65 	vmov.f32	s2, s11
 8015262:	eef0 0a46 	vmov.f32	s1, s12
 8015266:	eeb0 0a66 	vmov.f32	s0, s13
 801526a:	4611      	mov	r1, r2
 801526c:	4618      	mov	r0, r3
 801526e:	f7fe fb45 	bl	80138fc <nk_unify>
    nk_push_scissor(out, clip);
 8015272:	ed97 6a04 	vldr	s12, [r7, #16]
 8015276:	edd7 6a05 	vldr	s13, [r7, #20]
 801527a:	ed97 7a06 	vldr	s14, [r7, #24]
 801527e:	edd7 7a07 	vldr	s15, [r7, #28]
 8015282:	eeb0 0a46 	vmov.f32	s0, s12
 8015286:	eef0 0a66 	vmov.f32	s1, s13
 801528a:	eeb0 1a47 	vmov.f32	s2, s14
 801528e:	eef0 1a67 	vmov.f32	s3, s15
 8015292:	f8d7 00b0 	ldr.w	r0, [r7, #176]	; 0xb0
 8015296:	f7fb fb81 	bl	801099c <nk_push_scissor>
    layout->clip = clip;}
 801529a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801529e:	f103 043c 	add.w	r4, r3, #60	; 0x3c
 80152a2:	f107 0310 	add.w	r3, r7, #16
 80152a6:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80152a8:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    return !(layout->flags & NK_WINDOW_HIDDEN) && !(layout->flags & NK_WINDOW_MINIMIZED);
 80152ac:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80152b0:	685b      	ldr	r3, [r3, #4]
 80152b2:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 80152b6:	2b00      	cmp	r3, #0
 80152b8:	d108      	bne.n	80152cc <nk_panel_begin+0xe70>
 80152ba:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80152be:	685b      	ldr	r3, [r3, #4]
 80152c0:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80152c4:	2b00      	cmp	r3, #0
 80152c6:	d101      	bne.n	80152cc <nk_panel_begin+0xe70>
 80152c8:	2301      	movs	r3, #1
 80152ca:	e000      	b.n	80152ce <nk_panel_begin+0xe72>
 80152cc:	2300      	movs	r3, #0
}
 80152ce:	4618      	mov	r0, r3
 80152d0:	37cc      	adds	r7, #204	; 0xcc
 80152d2:	46bd      	mov	sp, r7
 80152d4:	bd90      	pop	{r4, r7, pc}
 80152d6:	bf00      	nop
 80152d8:	080235a0 	.word	0x080235a0
 80152dc:	00000000 	.word	0x00000000

080152e0 <nk_panel_end>:
NK_LIB void
nk_panel_end(struct nk_context *ctx)
{
 80152e0:	b590      	push	{r4, r7, lr}
 80152e2:	b0b3      	sub	sp, #204	; 0xcc
 80152e4:	af02      	add	r7, sp, #8
 80152e6:	6078      	str	r0, [r7, #4]
    struct nk_command_buffer *out;

    struct nk_vec2 scrollbar_size;
    struct nk_vec2 panel_padding;

    NK_ASSERT(ctx);
 80152e8:	687b      	ldr	r3, [r7, #4]
 80152ea:	2b00      	cmp	r3, #0
 80152ec:	d106      	bne.n	80152fc <nk_panel_end+0x1c>
 80152ee:	4b31      	ldr	r3, [pc, #196]	; (80153b4 <nk_panel_end+0xd4>)
 80152f0:	4a31      	ldr	r2, [pc, #196]	; (80153b8 <nk_panel_end+0xd8>)
 80152f2:	f44f 71a9 	mov.w	r1, #338	; 0x152
 80152f6:	4831      	ldr	r0, [pc, #196]	; (80153bc <nk_panel_end+0xdc>)
 80152f8:	f008 fb8e 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 80152fc:	687b      	ldr	r3, [r7, #4]
 80152fe:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8015302:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8015306:	2b00      	cmp	r3, #0
 8015308:	d106      	bne.n	8015318 <nk_panel_end+0x38>
 801530a:	4b2d      	ldr	r3, [pc, #180]	; (80153c0 <nk_panel_end+0xe0>)
 801530c:	4a2a      	ldr	r2, [pc, #168]	; (80153b8 <nk_panel_end+0xd8>)
 801530e:	f240 1153 	movw	r1, #339	; 0x153
 8015312:	482a      	ldr	r0, [pc, #168]	; (80153bc <nk_panel_end+0xdc>)
 8015314:	f008 fb80 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 8015318:	687b      	ldr	r3, [r7, #4]
 801531a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801531e:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8015322:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8015326:	2b00      	cmp	r3, #0
 8015328:	d106      	bne.n	8015338 <nk_panel_end+0x58>
 801532a:	4b26      	ldr	r3, [pc, #152]	; (80153c4 <nk_panel_end+0xe4>)
 801532c:	4a22      	ldr	r2, [pc, #136]	; (80153b8 <nk_panel_end+0xd8>)
 801532e:	f44f 71aa 	mov.w	r1, #340	; 0x154
 8015332:	4822      	ldr	r0, [pc, #136]	; (80153bc <nk_panel_end+0xdc>)
 8015334:	f008 fb70 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout)
 8015338:	687b      	ldr	r3, [r7, #4]
 801533a:	2b00      	cmp	r3, #0
 801533c:	f000 8792 	beq.w	8016264 <nk_panel_end+0xf84>
 8015340:	687b      	ldr	r3, [r7, #4]
 8015342:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8015346:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801534a:	2b00      	cmp	r3, #0
 801534c:	f000 878a 	beq.w	8016264 <nk_panel_end+0xf84>
 8015350:	687b      	ldr	r3, [r7, #4]
 8015352:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8015356:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801535a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801535e:	2b00      	cmp	r3, #0
 8015360:	f000 8780 	beq.w	8016264 <nk_panel_end+0xf84>
        return;

    window = ctx->current;
 8015364:	687b      	ldr	r3, [r7, #4]
 8015366:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801536a:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801536e:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    layout = window->layout;
 8015372:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8015376:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801537a:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    style = &ctx->style;
 801537e:	687b      	ldr	r3, [r7, #4]
 8015380:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 8015384:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    out = &window->buffer;
 8015388:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801538c:	3364      	adds	r3, #100	; 0x64
 801538e:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
    in = (layout->flags & NK_WINDOW_ROM || layout->flags & NK_WINDOW_NO_INPUT) ? 0 :&ctx->input;
 8015392:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015396:	685b      	ldr	r3, [r3, #4]
 8015398:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 801539c:	2b00      	cmp	r3, #0
 801539e:	d113      	bne.n	80153c8 <nk_panel_end+0xe8>
 80153a0:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80153a4:	685b      	ldr	r3, [r3, #4]
 80153a6:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80153aa:	2b00      	cmp	r3, #0
 80153ac:	d10c      	bne.n	80153c8 <nk_panel_end+0xe8>
 80153ae:	687b      	ldr	r3, [r7, #4]
 80153b0:	e00b      	b.n	80153ca <nk_panel_end+0xea>
 80153b2:	bf00      	nop
 80153b4:	08021984 	.word	0x08021984
 80153b8:	080235b4 	.word	0x080235b4
 80153bc:	08021988 	.word	0x08021988
 80153c0:	080219a4 	.word	0x080219a4
 80153c4:	080219b4 	.word	0x080219b4
 80153c8:	2300      	movs	r3, #0
 80153ca:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
    if (!nk_panel_is_sub(layout->type))
 80153ce:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80153d2:	781b      	ldrb	r3, [r3, #0]
 80153d4:	4618      	mov	r0, r3
 80153d6:	f7ff f81b 	bl	8014410 <nk_panel_is_sub>
 80153da:	4603      	mov	r3, r0
 80153dc:	2b00      	cmp	r3, #0
 80153de:	d114      	bne.n	801540a <nk_panel_end+0x12a>
        nk_push_scissor(out, nk_null_rect);
 80153e0:	4bcb      	ldr	r3, [pc, #812]	; (8015710 <nk_panel_end+0x430>)
 80153e2:	ed93 6a00 	vldr	s12, [r3]
 80153e6:	edd3 6a01 	vldr	s13, [r3, #4]
 80153ea:	ed93 7a02 	vldr	s14, [r3, #8]
 80153ee:	edd3 7a03 	vldr	s15, [r3, #12]
 80153f2:	eeb0 0a46 	vmov.f32	s0, s12
 80153f6:	eef0 0a66 	vmov.f32	s1, s13
 80153fa:	eeb0 1a47 	vmov.f32	s2, s14
 80153fe:	eef0 1a67 	vmov.f32	s3, s15
 8015402:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
 8015406:	f7fb fac9 	bl	801099c <nk_push_scissor>

    /* cache configuration data */
    scrollbar_size = style->window.scrollbar_size;
 801540a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 801540e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8015412:	461a      	mov	r2, r3
 8015414:	f107 0368 	add.w	r3, r7, #104	; 0x68
 8015418:	f602 02dc 	addw	r2, r2, #2268	; 0x8dc
 801541c:	e892 0003 	ldmia.w	r2, {r0, r1}
 8015420:	e883 0003 	stmia.w	r3, {r0, r1}
    panel_padding = nk_panel_get_padding(style, layout->type);
 8015424:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015428:	781b      	ldrb	r3, [r3, #0]
 801542a:	4619      	mov	r1, r3
 801542c:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 8015430:	f7fe fdfc 	bl	801402c <nk_panel_get_padding>
 8015434:	eeb0 7a40 	vmov.f32	s14, s0
 8015438:	eef0 7a60 	vmov.f32	s15, s1
 801543c:	ed87 7a18 	vstr	s14, [r7, #96]	; 0x60
 8015440:	edc7 7a19 	vstr	s15, [r7, #100]	; 0x64

    /* update the current cursor Y-position to point over the last added widget */
    layout->at_y += layout->row.height;
 8015444:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015448:	ed93 7a09 	vldr	s14, [r3, #36]	; 0x24
 801544c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015450:	edd3 7a1b 	vldr	s15, [r3, #108]	; 0x6c
 8015454:	ee77 7a27 	vadd.f32	s15, s14, s15
 8015458:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801545c:	edc3 7a09 	vstr	s15, [r3, #36]	; 0x24

    /* dynamic panels */
    if (layout->flags & NK_WINDOW_DYNAMIC && !(layout->flags & NK_WINDOW_MINIMIZED))
 8015460:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015464:	685b      	ldr	r3, [r3, #4]
 8015466:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801546a:	2b00      	cmp	r3, #0
 801546c:	f000 8111 	beq.w	8015692 <nk_panel_end+0x3b2>
 8015470:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015474:	685b      	ldr	r3, [r3, #4]
 8015476:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 801547a:	2b00      	cmp	r3, #0
 801547c:	f040 8109 	bne.w	8015692 <nk_panel_end+0x3b2>
    {
        /* update panel height to fit dynamic growth */
        struct nk_rect empty_space;
        if (layout->at_y < (layout->bounds.y + layout->bounds.h))
 8015480:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015484:	ed93 7a09 	vldr	s14, [r3, #36]	; 0x24
 8015488:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801548c:	edd3 6a03 	vldr	s13, [r3, #12]
 8015490:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015494:	edd3 7a05 	vldr	s15, [r3, #20]
 8015498:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801549c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80154a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80154a4:	d50d      	bpl.n	80154c2 <nk_panel_end+0x1e2>
            layout->bounds.h = layout->at_y - layout->bounds.y;
 80154a6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80154aa:	ed93 7a09 	vldr	s14, [r3, #36]	; 0x24
 80154ae:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80154b2:	edd3 7a03 	vldr	s15, [r3, #12]
 80154b6:	ee77 7a67 	vsub.f32	s15, s14, s15
 80154ba:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80154be:	edc3 7a05 	vstr	s15, [r3, #20]

        /* fill top empty space */
        empty_space.x = window->bounds.x;
 80154c2:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80154c6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80154c8:	653b      	str	r3, [r7, #80]	; 0x50
        empty_space.y = layout->bounds.y;
 80154ca:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80154ce:	68db      	ldr	r3, [r3, #12]
 80154d0:	657b      	str	r3, [r7, #84]	; 0x54
        empty_space.h = panel_padding.y;
 80154d2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80154d4:	65fb      	str	r3, [r7, #92]	; 0x5c
        empty_space.w = window->bounds.w;
 80154d6:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80154da:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80154dc:	65bb      	str	r3, [r7, #88]	; 0x58
        nk_fill_rect(out, empty_space, 0, style->window.background);
 80154de:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80154e2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80154e6:	ed97 6a14 	vldr	s12, [r7, #80]	; 0x50
 80154ea:	edd7 6a15 	vldr	s13, [r7, #84]	; 0x54
 80154ee:	ed97 7a16 	vldr	s14, [r7, #88]	; 0x58
 80154f2:	edd7 7a17 	vldr	s15, [r7, #92]	; 0x5c
 80154f6:	f8d3 1874 	ldr.w	r1, [r3, #2164]	; 0x874
 80154fa:	ed9f 2a86 	vldr	s4, [pc, #536]	; 8015714 <nk_panel_end+0x434>
 80154fe:	eeb0 0a46 	vmov.f32	s0, s12
 8015502:	eef0 0a66 	vmov.f32	s1, s13
 8015506:	eeb0 1a47 	vmov.f32	s2, s14
 801550a:	eef0 1a67 	vmov.f32	s3, s15
 801550e:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
 8015512:	f7fb fbc3 	bl	8010c9c <nk_fill_rect>

        /* fill left empty space */
        empty_space.x = window->bounds.x;
 8015516:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801551a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801551c:	653b      	str	r3, [r7, #80]	; 0x50
        empty_space.y = layout->bounds.y;
 801551e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015522:	68db      	ldr	r3, [r3, #12]
 8015524:	657b      	str	r3, [r7, #84]	; 0x54
        empty_space.w = panel_padding.x + layout->border;
 8015526:	ed97 7a18 	vldr	s14, [r7, #96]	; 0x60
 801552a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801552e:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
 8015532:	ee77 7a27 	vadd.f32	s15, s14, s15
 8015536:	edc7 7a16 	vstr	s15, [r7, #88]	; 0x58
        empty_space.h = layout->bounds.h;
 801553a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801553e:	695b      	ldr	r3, [r3, #20]
 8015540:	65fb      	str	r3, [r7, #92]	; 0x5c
        nk_fill_rect(out, empty_space, 0, style->window.background);
 8015542:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8015546:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801554a:	ed97 6a14 	vldr	s12, [r7, #80]	; 0x50
 801554e:	edd7 6a15 	vldr	s13, [r7, #84]	; 0x54
 8015552:	ed97 7a16 	vldr	s14, [r7, #88]	; 0x58
 8015556:	edd7 7a17 	vldr	s15, [r7, #92]	; 0x5c
 801555a:	f8d3 1874 	ldr.w	r1, [r3, #2164]	; 0x874
 801555e:	ed9f 2a6d 	vldr	s4, [pc, #436]	; 8015714 <nk_panel_end+0x434>
 8015562:	eeb0 0a46 	vmov.f32	s0, s12
 8015566:	eef0 0a66 	vmov.f32	s1, s13
 801556a:	eeb0 1a47 	vmov.f32	s2, s14
 801556e:	eef0 1a67 	vmov.f32	s3, s15
 8015572:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
 8015576:	f7fb fb91 	bl	8010c9c <nk_fill_rect>

        /* fill right empty space */
        empty_space.x = layout->bounds.x + layout->bounds.w;
 801557a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801557e:	ed93 7a02 	vldr	s14, [r3, #8]
 8015582:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015586:	edd3 7a04 	vldr	s15, [r3, #16]
 801558a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801558e:	edc7 7a14 	vstr	s15, [r7, #80]	; 0x50
        empty_space.y = layout->bounds.y;
 8015592:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015596:	68db      	ldr	r3, [r3, #12]
 8015598:	657b      	str	r3, [r7, #84]	; 0x54
        empty_space.w = panel_padding.x + layout->border;
 801559a:	ed97 7a18 	vldr	s14, [r7, #96]	; 0x60
 801559e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80155a2:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
 80155a6:	ee77 7a27 	vadd.f32	s15, s14, s15
 80155aa:	edc7 7a16 	vstr	s15, [r7, #88]	; 0x58
        empty_space.h = layout->bounds.h;
 80155ae:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80155b2:	695b      	ldr	r3, [r3, #20]
 80155b4:	65fb      	str	r3, [r7, #92]	; 0x5c
        if (*layout->offset_y == 0 && !(layout->flags & NK_WINDOW_NO_SCROLLBAR))
 80155b6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80155ba:	69db      	ldr	r3, [r3, #28]
 80155bc:	681b      	ldr	r3, [r3, #0]
 80155be:	2b00      	cmp	r3, #0
 80155c0:	d10e      	bne.n	80155e0 <nk_panel_end+0x300>
 80155c2:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80155c6:	685b      	ldr	r3, [r3, #4]
 80155c8:	f003 0320 	and.w	r3, r3, #32
 80155cc:	2b00      	cmp	r3, #0
 80155ce:	d107      	bne.n	80155e0 <nk_panel_end+0x300>
            empty_space.w += scrollbar_size.x;
 80155d0:	ed97 7a16 	vldr	s14, [r7, #88]	; 0x58
 80155d4:	edd7 7a1a 	vldr	s15, [r7, #104]	; 0x68
 80155d8:	ee77 7a27 	vadd.f32	s15, s14, s15
 80155dc:	edc7 7a16 	vstr	s15, [r7, #88]	; 0x58
        nk_fill_rect(out, empty_space, 0, style->window.background);
 80155e0:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80155e4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80155e8:	ed97 6a14 	vldr	s12, [r7, #80]	; 0x50
 80155ec:	edd7 6a15 	vldr	s13, [r7, #84]	; 0x54
 80155f0:	ed97 7a16 	vldr	s14, [r7, #88]	; 0x58
 80155f4:	edd7 7a17 	vldr	s15, [r7, #92]	; 0x5c
 80155f8:	f8d3 1874 	ldr.w	r1, [r3, #2164]	; 0x874
 80155fc:	ed9f 2a45 	vldr	s4, [pc, #276]	; 8015714 <nk_panel_end+0x434>
 8015600:	eeb0 0a46 	vmov.f32	s0, s12
 8015604:	eef0 0a66 	vmov.f32	s1, s13
 8015608:	eeb0 1a47 	vmov.f32	s2, s14
 801560c:	eef0 1a67 	vmov.f32	s3, s15
 8015610:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
 8015614:	f7fb fb42 	bl	8010c9c <nk_fill_rect>

        /* fill bottom empty space */
        if (layout->footer_height > 0) {
 8015618:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801561c:	edd3 7a0b 	vldr	s15, [r3, #44]	; 0x2c
 8015620:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8015624:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015628:	dd33      	ble.n	8015692 <nk_panel_end+0x3b2>
            empty_space.x = window->bounds.x;
 801562a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801562e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8015630:	653b      	str	r3, [r7, #80]	; 0x50
            empty_space.y = layout->bounds.y + layout->bounds.h;
 8015632:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015636:	ed93 7a03 	vldr	s14, [r3, #12]
 801563a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801563e:	edd3 7a05 	vldr	s15, [r3, #20]
 8015642:	ee77 7a27 	vadd.f32	s15, s14, s15
 8015646:	edc7 7a15 	vstr	s15, [r7, #84]	; 0x54
            empty_space.w = window->bounds.w;
 801564a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801564e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8015650:	65bb      	str	r3, [r7, #88]	; 0x58
            empty_space.h = layout->footer_height;
 8015652:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015656:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8015658:	65fb      	str	r3, [r7, #92]	; 0x5c
            nk_fill_rect(out, empty_space, 0, style->window.background);
 801565a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 801565e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8015662:	ed97 6a14 	vldr	s12, [r7, #80]	; 0x50
 8015666:	edd7 6a15 	vldr	s13, [r7, #84]	; 0x54
 801566a:	ed97 7a16 	vldr	s14, [r7, #88]	; 0x58
 801566e:	edd7 7a17 	vldr	s15, [r7, #92]	; 0x5c
 8015672:	f8d3 1874 	ldr.w	r1, [r3, #2164]	; 0x874
 8015676:	ed9f 2a27 	vldr	s4, [pc, #156]	; 8015714 <nk_panel_end+0x434>
 801567a:	eeb0 0a46 	vmov.f32	s0, s12
 801567e:	eef0 0a66 	vmov.f32	s1, s13
 8015682:	eeb0 1a47 	vmov.f32	s2, s14
 8015686:	eef0 1a67 	vmov.f32	s3, s15
 801568a:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
 801568e:	f7fb fb05 	bl	8010c9c <nk_fill_rect>
        }
    }

    /* scrollbars */
    if (!(layout->flags & NK_WINDOW_NO_SCROLLBAR) &&
 8015692:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015696:	685b      	ldr	r3, [r3, #4]
 8015698:	f003 0320 	and.w	r3, r3, #32
 801569c:	2b00      	cmp	r3, #0
 801569e:	f040 8232 	bne.w	8015b06 <nk_panel_end+0x826>
        !(layout->flags & NK_WINDOW_MINIMIZED) &&
 80156a2:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80156a6:	685b      	ldr	r3, [r3, #4]
 80156a8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
    if (!(layout->flags & NK_WINDOW_NO_SCROLLBAR) &&
 80156ac:	2b00      	cmp	r3, #0
 80156ae:	f040 822a 	bne.w	8015b06 <nk_panel_end+0x826>
        window->scrollbar_hiding_timer < NK_SCROLLBAR_HIDING_TIMEOUT)
 80156b2:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80156b6:	edd3 7a24 	vldr	s15, [r3, #144]	; 0x90
        !(layout->flags & NK_WINDOW_MINIMIZED) &&
 80156ba:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 80156be:	eef4 7ac7 	vcmpe.f32	s15, s14
 80156c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80156c6:	f140 821e 	bpl.w	8015b06 <nk_panel_end+0x826>
        float scroll_offset;
        float scroll_step;
        float scroll_inc;

        /* mouse wheel scrolling */
        if (nk_panel_is_sub(layout->type))
 80156ca:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80156ce:	781b      	ldrb	r3, [r3, #0]
 80156d0:	4618      	mov	r0, r3
 80156d2:	f7fe fe9d 	bl	8014410 <nk_panel_is_sub>
 80156d6:	4603      	mov	r3, r0
 80156d8:	2b00      	cmp	r3, #0
 80156da:	f000 80cb 	beq.w	8015874 <nk_panel_end+0x594>
        {
            /* sub-window mouse wheel scrolling */
            struct nk_window *root_window = window;
 80156de:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80156e2:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
            struct nk_panel *root_panel = window->layout;
 80156e6:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80156ea:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80156ee:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
            while (root_panel->parent)
 80156f2:	e005      	b.n	8015700 <nk_panel_end+0x420>
                root_panel = root_panel->parent;
 80156f4:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80156f8:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 80156fc:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
            while (root_panel->parent)
 8015700:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8015704:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 8015708:	2b00      	cmp	r3, #0
 801570a:	d1f3      	bne.n	80156f4 <nk_panel_end+0x414>
            while (root_window->parent)
 801570c:	e012      	b.n	8015734 <nk_panel_end+0x454>
 801570e:	bf00      	nop
 8015710:	08023590 	.word	0x08023590
 8015714:	00000000 	.word	0x00000000
 8015718:	3dcccccd 	.word	0x3dcccccd
 801571c:	3c23d70a 	.word	0x3c23d70a
 8015720:	3d4ccccd 	.word	0x3d4ccccd
 8015724:	3ba3d70a 	.word	0x3ba3d70a
                root_window = root_window->parent;
 8015728:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801572c:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 8015730:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
            while (root_window->parent)
 8015734:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8015738:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 801573c:	2b00      	cmp	r3, #0
 801573e:	d1f3      	bne.n	8015728 <nk_panel_end+0x448>

            /* only allow scrolling if parent window is active */
            scroll_has_scrolling = 0;
 8015740:	2300      	movs	r3, #0
 8015742:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
            if ((root_window == ctx->active) && layout->has_scrolling) {
 8015746:	687b      	ldr	r3, [r7, #4]
 8015748:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801574c:	f8d3 3654 	ldr.w	r3, [r3, #1620]	; 0x654
 8015750:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8015754:	429a      	cmp	r2, r3
 8015756:	f040 80d2 	bne.w	80158fe <nk_panel_end+0x61e>
 801575a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801575e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8015760:	2b00      	cmp	r3, #0
 8015762:	f000 80cc 	beq.w	80158fe <nk_panel_end+0x61e>
                /* and panel is being hovered and inside clip rect*/
                if (nk_input_is_mouse_hovering_rect(in, layout->bounds) &&
 8015766:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801576a:	ed93 6a02 	vldr	s12, [r3, #8]
 801576e:	edd3 6a03 	vldr	s13, [r3, #12]
 8015772:	ed93 7a04 	vldr	s14, [r3, #16]
 8015776:	edd3 7a05 	vldr	s15, [r3, #20]
 801577a:	eeb0 0a46 	vmov.f32	s0, s12
 801577e:	eef0 0a66 	vmov.f32	s1, s13
 8015782:	eeb0 1a47 	vmov.f32	s2, s14
 8015786:	eef0 1a67 	vmov.f32	s3, s15
 801578a:	f8d7 009c 	ldr.w	r0, [r7, #156]	; 0x9c
 801578e:	f7fc fec6 	bl	801251e <nk_input_is_mouse_hovering_rect>
 8015792:	4603      	mov	r3, r0
 8015794:	2b00      	cmp	r3, #0
 8015796:	f000 80b2 	beq.w	80158fe <nk_panel_end+0x61e>
                    NK_INTERSECT(layout->bounds.x, layout->bounds.y, layout->bounds.w, layout->bounds.h,
 801579a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801579e:	ed93 7a0f 	vldr	s14, [r3, #60]	; 0x3c
 80157a2:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80157a6:	edd3 6a02 	vldr	s13, [r3, #8]
 80157aa:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80157ae:	edd3 7a04 	vldr	s15, [r3, #16]
 80157b2:	ee76 7aa7 	vadd.f32	s15, s13, s15
                if (nk_input_is_mouse_hovering_rect(in, layout->bounds) &&
 80157b6:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80157ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80157be:	f140 809e 	bpl.w	80158fe <nk_panel_end+0x61e>
                    NK_INTERSECT(layout->bounds.x, layout->bounds.y, layout->bounds.w, layout->bounds.h,
 80157c2:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80157c6:	ed93 7a02 	vldr	s14, [r3, #8]
 80157ca:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80157ce:	edd3 6a0f 	vldr	s13, [r3, #60]	; 0x3c
 80157d2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80157d6:	edd3 7a11 	vldr	s15, [r3, #68]	; 0x44
 80157da:	ee76 7aa7 	vadd.f32	s15, s13, s15
 80157de:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80157e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80157e6:	f140 808a 	bpl.w	80158fe <nk_panel_end+0x61e>
 80157ea:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80157ee:	ed93 7a10 	vldr	s14, [r3, #64]	; 0x40
 80157f2:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80157f6:	edd3 6a03 	vldr	s13, [r3, #12]
 80157fa:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80157fe:	edd3 7a05 	vldr	s15, [r3, #20]
 8015802:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8015806:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801580a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801580e:	d576      	bpl.n	80158fe <nk_panel_end+0x61e>
 8015810:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015814:	ed93 7a03 	vldr	s14, [r3, #12]
 8015818:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801581c:	edd3 6a10 	vldr	s13, [r3, #64]	; 0x40
 8015820:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8015824:	edd3 7a12 	vldr	s15, [r3, #72]	; 0x48
 8015828:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801582c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8015830:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015834:	d563      	bpl.n	80158fe <nk_panel_end+0x61e>
                        root_panel->clip.x, root_panel->clip.y, root_panel->clip.w, root_panel->clip.h))
                {
                    /* deactivate all parent scrolling */
                    root_panel = window->layout;
 8015836:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801583a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801583e:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
                    while (root_panel->parent) {
 8015842:	e009      	b.n	8015858 <nk_panel_end+0x578>
                        root_panel->has_scrolling = nk_false;
 8015844:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8015848:	2200      	movs	r2, #0
 801584a:	639a      	str	r2, [r3, #56]	; 0x38
                        root_panel = root_panel->parent;
 801584c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8015850:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 8015854:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
                    while (root_panel->parent) {
 8015858:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801585c:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 8015860:	2b00      	cmp	r3, #0
 8015862:	d1ef      	bne.n	8015844 <nk_panel_end+0x564>
                    }
                    root_panel->has_scrolling = nk_false;
 8015864:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8015868:	2200      	movs	r2, #0
 801586a:	639a      	str	r2, [r3, #56]	; 0x38
                    scroll_has_scrolling = nk_true;
 801586c:	2301      	movs	r3, #1
 801586e:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8015872:	e044      	b.n	80158fe <nk_panel_end+0x61e>
                }
            }
        } else if (!nk_panel_is_sub(layout->type)) {
 8015874:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015878:	781b      	ldrb	r3, [r3, #0]
 801587a:	4618      	mov	r0, r3
 801587c:	f7fe fdc8 	bl	8014410 <nk_panel_is_sub>
 8015880:	4603      	mov	r3, r0
 8015882:	2b00      	cmp	r3, #0
 8015884:	d138      	bne.n	80158f8 <nk_panel_end+0x618>
            /* window mouse wheel scrolling */
            scroll_has_scrolling = (window == ctx->active) && layout->has_scrolling;
 8015886:	687b      	ldr	r3, [r7, #4]
 8015888:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801588c:	f8d3 3654 	ldr.w	r3, [r3, #1620]	; 0x654
 8015890:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 8015894:	429a      	cmp	r2, r3
 8015896:	d106      	bne.n	80158a6 <nk_panel_end+0x5c6>
 8015898:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801589c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801589e:	2b00      	cmp	r3, #0
 80158a0:	d001      	beq.n	80158a6 <nk_panel_end+0x5c6>
 80158a2:	2301      	movs	r3, #1
 80158a4:	e000      	b.n	80158a8 <nk_panel_end+0x5c8>
 80158a6:	2300      	movs	r3, #0
 80158a8:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
            if (in && (in->mouse.scroll_delta.y > 0 || in->mouse.scroll_delta.x > 0) && scroll_has_scrolling)
 80158ac:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80158b0:	2b00      	cmp	r3, #0
 80158b2:	d01b      	beq.n	80158ec <nk_panel_end+0x60c>
 80158b4:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80158b8:	edd3 7a58 	vldr	s15, [r3, #352]	; 0x160
 80158bc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80158c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80158c4:	dc08      	bgt.n	80158d8 <nk_panel_end+0x5f8>
 80158c6:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80158ca:	edd3 7a57 	vldr	s15, [r3, #348]	; 0x15c
 80158ce:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80158d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80158d6:	dd09      	ble.n	80158ec <nk_panel_end+0x60c>
 80158d8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80158dc:	2b00      	cmp	r3, #0
 80158de:	d005      	beq.n	80158ec <nk_panel_end+0x60c>
                window->scrolled = nk_true;
 80158e0:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80158e4:	2201      	movs	r2, #1
 80158e6:	f8c3 216c 	str.w	r2, [r3, #364]	; 0x16c
 80158ea:	e008      	b.n	80158fe <nk_panel_end+0x61e>
            else window->scrolled = nk_false;
 80158ec:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80158f0:	2200      	movs	r2, #0
 80158f2:	f8c3 216c 	str.w	r2, [r3, #364]	; 0x16c
 80158f6:	e002      	b.n	80158fe <nk_panel_end+0x61e>
        } else scroll_has_scrolling = nk_false;
 80158f8:	2300      	movs	r3, #0
 80158fa:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc

        {
            /* vertical scrollbar */
            nk_flags state = 0;
 80158fe:	2300      	movs	r3, #0
 8015900:	63fb      	str	r3, [r7, #60]	; 0x3c
            scroll.x = layout->bounds.x + layout->bounds.w + panel_padding.x;
 8015902:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015906:	ed93 7a02 	vldr	s14, [r3, #8]
 801590a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801590e:	edd3 7a04 	vldr	s15, [r3, #16]
 8015912:	ee37 7a27 	vadd.f32	s14, s14, s15
 8015916:	edd7 7a18 	vldr	s15, [r7, #96]	; 0x60
 801591a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801591e:	edc7 7a10 	vstr	s15, [r7, #64]	; 0x40
            scroll.y = layout->bounds.y;
 8015922:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015926:	68db      	ldr	r3, [r3, #12]
 8015928:	647b      	str	r3, [r7, #68]	; 0x44
            scroll.w = scrollbar_size.x;
 801592a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801592c:	64bb      	str	r3, [r7, #72]	; 0x48
            scroll.h = layout->bounds.h;
 801592e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015932:	695b      	ldr	r3, [r3, #20]
 8015934:	64fb      	str	r3, [r7, #76]	; 0x4c

            scroll_offset = (float)*layout->offset_y;
 8015936:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801593a:	69db      	ldr	r3, [r3, #28]
 801593c:	681b      	ldr	r3, [r3, #0]
 801593e:	ee07 3a90 	vmov	s15, r3
 8015942:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8015946:	edc7 7a26 	vstr	s15, [r7, #152]	; 0x98
            scroll_step = scroll.h * 0.10f;
 801594a:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
 801594e:	ed1f 7a8e 	vldr	s14, [pc, #-568]	; 8015718 <nk_panel_end+0x438>
 8015952:	ee67 7a87 	vmul.f32	s15, s15, s14
 8015956:	edc7 7a25 	vstr	s15, [r7, #148]	; 0x94
            scroll_inc = scroll.h * 0.01f;
 801595a:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
 801595e:	ed1f 7a91 	vldr	s14, [pc, #-580]	; 801571c <nk_panel_end+0x43c>
 8015962:	ee67 7a87 	vmul.f32	s15, s15, s14
 8015966:	edc7 7a24 	vstr	s15, [r7, #144]	; 0x90
            scroll_target = (float)(int)(layout->at_y - scroll.y);
 801596a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801596e:	ed93 7a09 	vldr	s14, [r3, #36]	; 0x24
 8015972:	edd7 7a11 	vldr	s15, [r7, #68]	; 0x44
 8015976:	ee77 7a67 	vsub.f32	s15, s14, s15
 801597a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801597e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8015982:	edc7 7a23 	vstr	s15, [r7, #140]	; 0x8c
            scroll_offset = nk_do_scrollbarv(&state, out, scroll, scroll_has_scrolling,
                scroll_offset, scroll_target, scroll_step, scroll_inc,
                &ctx->style.scrollv, in, style->font);
 8015986:	687b      	ldr	r3, [r7, #4]
 8015988:	f503 5391 	add.w	r3, r3, #4640	; 0x1220
 801598c:	3318      	adds	r3, #24
 801598e:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8015992:	6812      	ldr	r2, [r2, #0]
            scroll_offset = nk_do_scrollbarv(&state, out, scroll, scroll_has_scrolling,
 8015994:	ed97 6a10 	vldr	s12, [r7, #64]	; 0x40
 8015998:	edd7 6a11 	vldr	s13, [r7, #68]	; 0x44
 801599c:	ed97 7a12 	vldr	s14, [r7, #72]	; 0x48
 80159a0:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
 80159a4:	f107 003c 	add.w	r0, r7, #60	; 0x3c
 80159a8:	9201      	str	r2, [sp, #4]
 80159aa:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 80159ae:	9200      	str	r2, [sp, #0]
 80159b0:	edd7 3a24 	vldr	s7, [r7, #144]	; 0x90
 80159b4:	ed97 3a25 	vldr	s6, [r7, #148]	; 0x94
 80159b8:	edd7 2a23 	vldr	s5, [r7, #140]	; 0x8c
 80159bc:	ed97 2a26 	vldr	s4, [r7, #152]	; 0x98
 80159c0:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 80159c4:	eeb0 0a46 	vmov.f32	s0, s12
 80159c8:	eef0 0a66 	vmov.f32	s1, s13
 80159cc:	eeb0 1a47 	vmov.f32	s2, s14
 80159d0:	eef0 1a67 	vmov.f32	s3, s15
 80159d4:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
 80159d8:	f001 fc82 	bl	80172e0 <nk_do_scrollbarv>
 80159dc:	ed87 0a26 	vstr	s0, [r7, #152]	; 0x98
            *layout->offset_y = (nk_uint)scroll_offset;
 80159e0:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80159e4:	69db      	ldr	r3, [r3, #28]
 80159e6:	edd7 7a26 	vldr	s15, [r7, #152]	; 0x98
 80159ea:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80159ee:	ee17 2a90 	vmov	r2, s15
 80159f2:	601a      	str	r2, [r3, #0]
            if (in && scroll_has_scrolling)
 80159f4:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80159f8:	2b00      	cmp	r3, #0
 80159fa:	d009      	beq.n	8015a10 <nk_panel_end+0x730>
 80159fc:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8015a00:	2b00      	cmp	r3, #0
 8015a02:	d005      	beq.n	8015a10 <nk_panel_end+0x730>
                in->mouse.scroll_delta.y = 0;
 8015a04:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8015a08:	f04f 0200 	mov.w	r2, #0
 8015a0c:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
        }
        {
            /* horizontal scrollbar */
            nk_flags state = 0;
 8015a10:	2300      	movs	r3, #0
 8015a12:	63bb      	str	r3, [r7, #56]	; 0x38
            scroll.x = layout->bounds.x;
 8015a14:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015a18:	689b      	ldr	r3, [r3, #8]
 8015a1a:	643b      	str	r3, [r7, #64]	; 0x40
            scroll.y = layout->bounds.y + layout->bounds.h;
 8015a1c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015a20:	ed93 7a03 	vldr	s14, [r3, #12]
 8015a24:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015a28:	edd3 7a05 	vldr	s15, [r3, #20]
 8015a2c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8015a30:	edc7 7a11 	vstr	s15, [r7, #68]	; 0x44
            scroll.w = layout->bounds.w;
 8015a34:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015a38:	691b      	ldr	r3, [r3, #16]
 8015a3a:	64bb      	str	r3, [r7, #72]	; 0x48
            scroll.h = scrollbar_size.y;
 8015a3c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8015a3e:	64fb      	str	r3, [r7, #76]	; 0x4c

            scroll_offset = (float)*layout->offset_x;
 8015a40:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015a44:	699b      	ldr	r3, [r3, #24]
 8015a46:	681b      	ldr	r3, [r3, #0]
 8015a48:	ee07 3a90 	vmov	s15, r3
 8015a4c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8015a50:	edc7 7a26 	vstr	s15, [r7, #152]	; 0x98
            scroll_target = (float)(int)(layout->max_x - scroll.x);
 8015a54:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015a58:	ed93 7a0a 	vldr	s14, [r3, #40]	; 0x28
 8015a5c:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
 8015a60:	ee77 7a67 	vsub.f32	s15, s14, s15
 8015a64:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8015a68:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8015a6c:	edc7 7a23 	vstr	s15, [r7, #140]	; 0x8c
            scroll_step = layout->max_x * 0.05f;
 8015a70:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015a74:	edd3 7a0a 	vldr	s15, [r3, #40]	; 0x28
 8015a78:	ed1f 7ad7 	vldr	s14, [pc, #-860]	; 8015720 <nk_panel_end+0x440>
 8015a7c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8015a80:	edc7 7a25 	vstr	s15, [r7, #148]	; 0x94
            scroll_inc = layout->max_x * 0.005f;
 8015a84:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015a88:	edd3 7a0a 	vldr	s15, [r3, #40]	; 0x28
 8015a8c:	ed1f 7adb 	vldr	s14, [pc, #-876]	; 8015724 <nk_panel_end+0x444>
 8015a90:	ee67 7a87 	vmul.f32	s15, s15, s14
 8015a94:	edc7 7a24 	vstr	s15, [r7, #144]	; 0x90
            scroll_offset = nk_do_scrollbarh(&state, out, scroll, scroll_has_scrolling,
                scroll_offset, scroll_target, scroll_step, scroll_inc,
                &ctx->style.scrollh, in, style->font);
 8015a98:	687b      	ldr	r3, [r7, #4]
 8015a9a:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
 8015a9e:	330c      	adds	r3, #12
 8015aa0:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8015aa4:	6812      	ldr	r2, [r2, #0]
            scroll_offset = nk_do_scrollbarh(&state, out, scroll, scroll_has_scrolling,
 8015aa6:	ed97 6a10 	vldr	s12, [r7, #64]	; 0x40
 8015aaa:	edd7 6a11 	vldr	s13, [r7, #68]	; 0x44
 8015aae:	ed97 7a12 	vldr	s14, [r7, #72]	; 0x48
 8015ab2:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
 8015ab6:	f107 0038 	add.w	r0, r7, #56	; 0x38
 8015aba:	9201      	str	r2, [sp, #4]
 8015abc:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8015ac0:	9200      	str	r2, [sp, #0]
 8015ac2:	edd7 3a24 	vldr	s7, [r7, #144]	; 0x90
 8015ac6:	ed97 3a25 	vldr	s6, [r7, #148]	; 0x94
 8015aca:	edd7 2a23 	vldr	s5, [r7, #140]	; 0x8c
 8015ace:	ed97 2a26 	vldr	s4, [r7, #152]	; 0x98
 8015ad2:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8015ad6:	eeb0 0a46 	vmov.f32	s0, s12
 8015ada:	eef0 0a66 	vmov.f32	s1, s13
 8015ade:	eeb0 1a47 	vmov.f32	s2, s14
 8015ae2:	eef0 1a67 	vmov.f32	s3, s15
 8015ae6:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
 8015aea:	f001 fe97 	bl	801781c <nk_do_scrollbarh>
 8015aee:	ed87 0a26 	vstr	s0, [r7, #152]	; 0x98
            *layout->offset_x = (nk_uint)scroll_offset;
 8015af2:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015af6:	699b      	ldr	r3, [r3, #24]
 8015af8:	edd7 7a26 	vldr	s15, [r7, #152]	; 0x98
 8015afc:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8015b00:	ee17 2a90 	vmov	r2, s15
 8015b04:	601a      	str	r2, [r3, #0]
        }
    }

    /* hide scroll if no user input */
    if (window->flags & NK_WINDOW_SCROLL_AUTO_HIDE) {
 8015b06:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8015b0a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8015b0c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8015b10:	2b00      	cmp	r3, #0
 8015b12:	d051      	beq.n	8015bb8 <nk_panel_end+0x8d8>
        int has_input = ctx->input.mouse.delta.x != 0 || ctx->input.mouse.delta.y != 0 || ctx->input.mouse.scroll_delta.y != 0;
 8015b14:	687b      	ldr	r3, [r7, #4]
 8015b16:	edd3 7a55 	vldr	s15, [r3, #340]	; 0x154
 8015b1a:	eef5 7a40 	vcmp.f32	s15, #0.0
 8015b1e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015b22:	d10f      	bne.n	8015b44 <nk_panel_end+0x864>
 8015b24:	687b      	ldr	r3, [r7, #4]
 8015b26:	edd3 7a56 	vldr	s15, [r3, #344]	; 0x158
 8015b2a:	eef5 7a40 	vcmp.f32	s15, #0.0
 8015b2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015b32:	d107      	bne.n	8015b44 <nk_panel_end+0x864>
 8015b34:	687b      	ldr	r3, [r7, #4]
 8015b36:	edd3 7a58 	vldr	s15, [r3, #352]	; 0x160
 8015b3a:	eef5 7a40 	vcmp.f32	s15, #0.0
 8015b3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015b42:	d001      	beq.n	8015b48 <nk_panel_end+0x868>
 8015b44:	2301      	movs	r3, #1
 8015b46:	e000      	b.n	8015b4a <nk_panel_end+0x86a>
 8015b48:	2300      	movs	r3, #0
 8015b4a:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
        int is_window_hovered = nk_window_is_hovered(ctx);
 8015b4e:	6878      	ldr	r0, [r7, #4]
 8015b50:	f007 fda6 	bl	801d6a0 <nk_window_is_hovered>
 8015b54:	f8c7 0084 	str.w	r0, [r7, #132]	; 0x84
        int any_item_active = (ctx->last_widget_state & NK_WIDGET_STATE_MODIFIED);
 8015b58:	687b      	ldr	r3, [r7, #4]
 8015b5a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8015b5e:	f8d3 3ad4 	ldr.w	r3, [r3, #2772]	; 0xad4
 8015b62:	f003 0302 	and.w	r3, r3, #2
 8015b66:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
        if ((!has_input && is_window_hovered) || (!is_window_hovered && !any_item_active))
 8015b6a:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8015b6e:	2b00      	cmp	r3, #0
 8015b70:	d103      	bne.n	8015b7a <nk_panel_end+0x89a>
 8015b72:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8015b76:	2b00      	cmp	r3, #0
 8015b78:	d107      	bne.n	8015b8a <nk_panel_end+0x8aa>
 8015b7a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8015b7e:	2b00      	cmp	r3, #0
 8015b80:	d113      	bne.n	8015baa <nk_panel_end+0x8ca>
 8015b82:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8015b86:	2b00      	cmp	r3, #0
 8015b88:	d10f      	bne.n	8015baa <nk_panel_end+0x8ca>
            window->scrollbar_hiding_timer += ctx->delta_time_seconds;
 8015b8a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8015b8e:	ed93 7a24 	vldr	s14, [r3, #144]	; 0x90
 8015b92:	687b      	ldr	r3, [r7, #4]
 8015b94:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8015b98:	edd3 7a4e 	vldr	s15, [r3, #312]	; 0x138
 8015b9c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8015ba0:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8015ba4:	edc3 7a24 	vstr	s15, [r3, #144]	; 0x90
 8015ba8:	e00c      	b.n	8015bc4 <nk_panel_end+0x8e4>
        else window->scrollbar_hiding_timer = 0;
 8015baa:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8015bae:	f04f 0200 	mov.w	r2, #0
 8015bb2:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8015bb6:	e005      	b.n	8015bc4 <nk_panel_end+0x8e4>
    } else window->scrollbar_hiding_timer = 0;
 8015bb8:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8015bbc:	f04f 0200 	mov.w	r2, #0
 8015bc0:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

    /* window border */
    if (layout->flags & NK_WINDOW_BORDER)
 8015bc4:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015bc8:	685b      	ldr	r3, [r3, #4]
 8015bca:	f003 0301 	and.w	r3, r3, #1
 8015bce:	2b00      	cmp	r3, #0
 8015bd0:	d078      	beq.n	8015cc4 <nk_panel_end+0x9e4>
    {
        struct nk_color border_color = nk_panel_get_border_color(style, layout->type);
 8015bd2:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015bd6:	781b      	ldrb	r3, [r3, #0]
 8015bd8:	4619      	mov	r1, r3
 8015bda:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 8015bde:	f7fe fb7d 	bl	80142dc <nk_panel_get_border_color>
 8015be2:	4603      	mov	r3, r0
 8015be4:	637b      	str	r3, [r7, #52]	; 0x34
        const float padding_y = (layout->flags & NK_WINDOW_MINIMIZED)
 8015be6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015bea:	685b      	ldr	r3, [r3, #4]
 8015bec:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
            ? (style->window.border + window->bounds.y + layout->header_height)
            : ((layout->flags & NK_WINDOW_DYNAMIC)
 8015bf0:	2b00      	cmp	r3, #0
 8015bf2:	d014      	beq.n	8015c1e <nk_panel_end+0x93e>
            ? (style->window.border + window->bounds.y + layout->header_height)
 8015bf4:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8015bf8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8015bfc:	f503 630b 	add.w	r3, r3, #2224	; 0x8b0
 8015c00:	ed93 7a00 	vldr	s14, [r3]
 8015c04:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8015c08:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 8015c0c:	ee37 7a27 	vadd.f32	s14, s14, s15
 8015c10:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015c14:	edd3 7a0c 	vldr	s15, [r3, #48]	; 0x30
            : ((layout->flags & NK_WINDOW_DYNAMIC)
 8015c18:	ee77 7a27 	vadd.f32	s15, s14, s15
 8015c1c:	e021      	b.n	8015c62 <nk_panel_end+0x982>
 8015c1e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015c22:	685b      	ldr	r3, [r3, #4]
 8015c24:	f403 6300 	and.w	r3, r3, #2048	; 0x800
                ? (layout->bounds.y + layout->bounds.h + layout->footer_height)
                : (window->bounds.y + window->bounds.h));
 8015c28:	2b00      	cmp	r3, #0
 8015c2a:	d010      	beq.n	8015c4e <nk_panel_end+0x96e>
                ? (layout->bounds.y + layout->bounds.h + layout->footer_height)
 8015c2c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015c30:	ed93 7a03 	vldr	s14, [r3, #12]
 8015c34:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015c38:	edd3 7a05 	vldr	s15, [r3, #20]
 8015c3c:	ee37 7a27 	vadd.f32	s14, s14, s15
 8015c40:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015c44:	edd3 7a0b 	vldr	s15, [r3, #44]	; 0x2c
                : (window->bounds.y + window->bounds.h));
 8015c48:	ee77 7a27 	vadd.f32	s15, s14, s15
 8015c4c:	e009      	b.n	8015c62 <nk_panel_end+0x982>
 8015c4e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8015c52:	ed93 7a14 	vldr	s14, [r3, #80]	; 0x50
 8015c56:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8015c5a:	edd3 7a16 	vldr	s15, [r3, #88]	; 0x58
 8015c5e:	ee77 7a27 	vadd.f32	s15, s14, s15
        const float padding_y = (layout->flags & NK_WINDOW_MINIMIZED)
 8015c62:	edc7 7a1f 	vstr	s15, [r7, #124]	; 0x7c
        struct nk_rect b = window->bounds;
 8015c66:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8015c6a:	f107 0424 	add.w	r4, r7, #36	; 0x24
 8015c6e:	334c      	adds	r3, #76	; 0x4c
 8015c70:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8015c72:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        b.h = padding_y - window->bounds.y;
 8015c76:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8015c7a:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 8015c7e:	ed97 7a1f 	vldr	s14, [r7, #124]	; 0x7c
 8015c82:	ee77 7a67 	vsub.f32	s15, s14, s15
 8015c86:	edc7 7a0c 	vstr	s15, [r7, #48]	; 0x30
        nk_stroke_rect(out, b, 0, layout->border, border_color);
 8015c8a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015c8e:	edd3 5a0d 	vldr	s11, [r3, #52]	; 0x34
 8015c92:	ed97 6a09 	vldr	s12, [r7, #36]	; 0x24
 8015c96:	edd7 6a0a 	vldr	s13, [r7, #40]	; 0x28
 8015c9a:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
 8015c9e:	edd7 7a0c 	vldr	s15, [r7, #48]	; 0x30
 8015ca2:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8015ca4:	eef0 2a65 	vmov.f32	s5, s11
 8015ca8:	ed9f 2a5e 	vldr	s4, [pc, #376]	; 8015e24 <nk_panel_end+0xb44>
 8015cac:	eeb0 0a46 	vmov.f32	s0, s12
 8015cb0:	eef0 0a66 	vmov.f32	s1, s13
 8015cb4:	eeb0 1a47 	vmov.f32	s2, s14
 8015cb8:	eef0 1a67 	vmov.f32	s3, s15
 8015cbc:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
 8015cc0:	f7fa fee4 	bl	8010a8c <nk_stroke_rect>
    }

    /* scaler */
    if ((layout->flags & NK_WINDOW_SCALABLE) && in && !(layout->flags & NK_WINDOW_MINIMIZED))
 8015cc4:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015cc8:	685b      	ldr	r3, [r3, #4]
 8015cca:	f003 0304 	and.w	r3, r3, #4
 8015cce:	2b00      	cmp	r3, #0
 8015cd0:	f000 81e1 	beq.w	8016096 <nk_panel_end+0xdb6>
 8015cd4:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8015cd8:	2b00      	cmp	r3, #0
 8015cda:	f000 81dc 	beq.w	8016096 <nk_panel_end+0xdb6>
 8015cde:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015ce2:	685b      	ldr	r3, [r3, #4]
 8015ce4:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8015ce8:	2b00      	cmp	r3, #0
 8015cea:	f040 81d4 	bne.w	8016096 <nk_panel_end+0xdb6>
    {
        /* calculate scaler bounds */
        struct nk_rect scaler;
        scaler.w = scrollbar_size.x;
 8015cee:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8015cf0:	61fb      	str	r3, [r7, #28]
        scaler.h = scrollbar_size.y;
 8015cf2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8015cf4:	623b      	str	r3, [r7, #32]
        scaler.y = layout->bounds.y + layout->bounds.h;
 8015cf6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015cfa:	ed93 7a03 	vldr	s14, [r3, #12]
 8015cfe:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015d02:	edd3 7a05 	vldr	s15, [r3, #20]
 8015d06:	ee77 7a27 	vadd.f32	s15, s14, s15
 8015d0a:	edc7 7a06 	vstr	s15, [r7, #24]
        if (layout->flags & NK_WINDOW_SCALE_LEFT)
 8015d0e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015d12:	685b      	ldr	r3, [r3, #4]
 8015d14:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8015d18:	2b00      	cmp	r3, #0
 8015d1a:	d00e      	beq.n	8015d3a <nk_panel_end+0xa5a>
            scaler.x = layout->bounds.x - panel_padding.x * 0.5f;
 8015d1c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015d20:	ed93 7a02 	vldr	s14, [r3, #8]
 8015d24:	edd7 7a18 	vldr	s15, [r7, #96]	; 0x60
 8015d28:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 8015d2c:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8015d30:	ee77 7a67 	vsub.f32	s15, s14, s15
 8015d34:	edc7 7a05 	vstr	s15, [r7, #20]
 8015d38:	e00f      	b.n	8015d5a <nk_panel_end+0xa7a>
        else scaler.x = layout->bounds.x + layout->bounds.w + panel_padding.x;
 8015d3a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015d3e:	ed93 7a02 	vldr	s14, [r3, #8]
 8015d42:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015d46:	edd3 7a04 	vldr	s15, [r3, #16]
 8015d4a:	ee37 7a27 	vadd.f32	s14, s14, s15
 8015d4e:	edd7 7a18 	vldr	s15, [r7, #96]	; 0x60
 8015d52:	ee77 7a27 	vadd.f32	s15, s14, s15
 8015d56:	edc7 7a05 	vstr	s15, [r7, #20]
        if (layout->flags & NK_WINDOW_NO_SCROLLBAR)
 8015d5a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015d5e:	685b      	ldr	r3, [r3, #4]
 8015d60:	f003 0320 	and.w	r3, r3, #32
 8015d64:	2b00      	cmp	r3, #0
 8015d66:	d007      	beq.n	8015d78 <nk_panel_end+0xa98>
            scaler.x -= scaler.w;
 8015d68:	ed97 7a05 	vldr	s14, [r7, #20]
 8015d6c:	edd7 7a07 	vldr	s15, [r7, #28]
 8015d70:	ee77 7a67 	vsub.f32	s15, s14, s15
 8015d74:	edc7 7a05 	vstr	s15, [r7, #20]

        /* draw scaler */
        {const struct nk_style_item *item = &style->window.scaler;
 8015d78:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8015d7c:	f503 53c4 	add.w	r3, r3, #6272	; 0x1880
 8015d80:	3314      	adds	r3, #20
 8015d82:	67bb      	str	r3, [r7, #120]	; 0x78
        if (item->type == NK_STYLE_ITEM_IMAGE)
 8015d84:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8015d86:	781b      	ldrb	r3, [r3, #0]
 8015d88:	2b01      	cmp	r3, #1
 8015d8a:	d119      	bne.n	8015dc0 <nk_panel_end+0xae0>
            nk_draw_image(out, scaler, &item->data.image, nk_white);
 8015d8c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8015d8e:	3304      	adds	r3, #4
 8015d90:	4a25      	ldr	r2, [pc, #148]	; (8015e28 <nk_panel_end+0xb48>)
 8015d92:	ed97 6a05 	vldr	s12, [r7, #20]
 8015d96:	edd7 6a06 	vldr	s13, [r7, #24]
 8015d9a:	ed97 7a07 	vldr	s14, [r7, #28]
 8015d9e:	edd7 7a08 	vldr	s15, [r7, #32]
 8015da2:	6812      	ldr	r2, [r2, #0]
 8015da4:	4619      	mov	r1, r3
 8015da6:	eeb0 0a46 	vmov.f32	s0, s12
 8015daa:	eef0 0a66 	vmov.f32	s1, s13
 8015dae:	eeb0 1a47 	vmov.f32	s2, s14
 8015db2:	eef0 1a67 	vmov.f32	s3, s15
 8015db6:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
 8015dba:	f7fb fac9 	bl	8011350 <nk_draw_image>
 8015dbe:	e063      	b.n	8015e88 <nk_panel_end+0xba8>
        else {
            if (layout->flags & NK_WINDOW_SCALE_LEFT) {
 8015dc0:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015dc4:	685b      	ldr	r3, [r3, #4]
 8015dc6:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8015dca:	2b00      	cmp	r3, #0
 8015dcc:	d02e      	beq.n	8015e2c <nk_panel_end+0xb4c>
                nk_fill_triangle(out, scaler.x, scaler.y, scaler.x,
 8015dce:	edd7 6a05 	vldr	s13, [r7, #20]
 8015dd2:	ed97 6a06 	vldr	s12, [r7, #24]
 8015dd6:	edd7 5a05 	vldr	s11, [r7, #20]
                    scaler.y + scaler.h, scaler.x + scaler.w,
 8015dda:	ed97 7a06 	vldr	s14, [r7, #24]
 8015dde:	edd7 7a08 	vldr	s15, [r7, #32]
                nk_fill_triangle(out, scaler.x, scaler.y, scaler.x,
 8015de2:	ee37 5a27 	vadd.f32	s10, s14, s15
                    scaler.y + scaler.h, scaler.x + scaler.w,
 8015de6:	ed97 7a05 	vldr	s14, [r7, #20]
 8015dea:	edd7 7a07 	vldr	s15, [r7, #28]
                nk_fill_triangle(out, scaler.x, scaler.y, scaler.x,
 8015dee:	ee77 4a27 	vadd.f32	s9, s14, s15
                    scaler.y + scaler.h, item->data.color);
 8015df2:	ed97 7a06 	vldr	s14, [r7, #24]
 8015df6:	edd7 7a08 	vldr	s15, [r7, #32]
                nk_fill_triangle(out, scaler.x, scaler.y, scaler.x,
 8015dfa:	ee77 7a27 	vadd.f32	s15, s14, s15
 8015dfe:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8015e00:	6859      	ldr	r1, [r3, #4]
 8015e02:	eef0 2a67 	vmov.f32	s5, s15
 8015e06:	eeb0 2a64 	vmov.f32	s4, s9
 8015e0a:	eef0 1a45 	vmov.f32	s3, s10
 8015e0e:	eeb0 1a65 	vmov.f32	s2, s11
 8015e12:	eef0 0a46 	vmov.f32	s1, s12
 8015e16:	eeb0 0a66 	vmov.f32	s0, s13
 8015e1a:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
 8015e1e:	f7fb f91d 	bl	801105c <nk_fill_triangle>
 8015e22:	e031      	b.n	8015e88 <nk_panel_end+0xba8>
 8015e24:	00000000 	.word	0x00000000
 8015e28:	080235a0 	.word	0x080235a0
            } else {
                nk_fill_triangle(out, scaler.x + scaler.w, scaler.y, scaler.x + scaler.w,
 8015e2c:	ed97 7a05 	vldr	s14, [r7, #20]
 8015e30:	edd7 7a07 	vldr	s15, [r7, #28]
 8015e34:	ee77 6a27 	vadd.f32	s13, s14, s15
 8015e38:	ed97 6a06 	vldr	s12, [r7, #24]
 8015e3c:	ed97 7a05 	vldr	s14, [r7, #20]
 8015e40:	edd7 7a07 	vldr	s15, [r7, #28]
 8015e44:	ee77 5a27 	vadd.f32	s11, s14, s15
                    scaler.y + scaler.h, scaler.x, scaler.y + scaler.h, item->data.color);
 8015e48:	ed97 7a06 	vldr	s14, [r7, #24]
 8015e4c:	edd7 7a08 	vldr	s15, [r7, #32]
                nk_fill_triangle(out, scaler.x + scaler.w, scaler.y, scaler.x + scaler.w,
 8015e50:	ee37 5a27 	vadd.f32	s10, s14, s15
 8015e54:	edd7 4a05 	vldr	s9, [r7, #20]
                    scaler.y + scaler.h, scaler.x, scaler.y + scaler.h, item->data.color);
 8015e58:	ed97 7a06 	vldr	s14, [r7, #24]
 8015e5c:	edd7 7a08 	vldr	s15, [r7, #32]
                nk_fill_triangle(out, scaler.x + scaler.w, scaler.y, scaler.x + scaler.w,
 8015e60:	ee77 7a27 	vadd.f32	s15, s14, s15
 8015e64:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8015e66:	6859      	ldr	r1, [r3, #4]
 8015e68:	eef0 2a67 	vmov.f32	s5, s15
 8015e6c:	eeb0 2a64 	vmov.f32	s4, s9
 8015e70:	eef0 1a45 	vmov.f32	s3, s10
 8015e74:	eeb0 1a65 	vmov.f32	s2, s11
 8015e78:	eef0 0a46 	vmov.f32	s1, s12
 8015e7c:	eeb0 0a66 	vmov.f32	s0, s13
 8015e80:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
 8015e84:	f7fb f8ea 	bl	801105c <nk_fill_triangle>
            }
        }}

        /* do window scaling */
        if (!(window->flags & NK_WINDOW_ROM)) {
 8015e88:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8015e8c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8015e8e:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8015e92:	2b00      	cmp	r3, #0
 8015e94:	f040 80ff 	bne.w	8016096 <nk_panel_end+0xdb6>
            struct nk_vec2 window_size = style->window.min_size;
 8015e98:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8015e9c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8015ea0:	461a      	mov	r2, r3
 8015ea2:	f107 030c 	add.w	r3, r7, #12
 8015ea6:	f602 02e4 	addw	r2, r2, #2276	; 0x8e4
 8015eaa:	e892 0003 	ldmia.w	r2, {r0, r1}
 8015eae:	e883 0003 	stmia.w	r3, {r0, r1}
            int left_mouse_down = in->mouse.buttons[NK_BUTTON_LEFT].down;
 8015eb2:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8015eb6:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8015eba:	677b      	str	r3, [r7, #116]	; 0x74
            int left_mouse_click_in_scaler = nk_input_has_mouse_click_down_in_rect(in,
 8015ebc:	ed97 6a05 	vldr	s12, [r7, #20]
 8015ec0:	edd7 6a06 	vldr	s13, [r7, #24]
 8015ec4:	ed97 7a07 	vldr	s14, [r7, #28]
 8015ec8:	edd7 7a08 	vldr	s15, [r7, #32]
 8015ecc:	2201      	movs	r2, #1
 8015ece:	eeb0 0a46 	vmov.f32	s0, s12
 8015ed2:	eef0 0a66 	vmov.f32	s1, s13
 8015ed6:	eeb0 1a47 	vmov.f32	s2, s14
 8015eda:	eef0 1a67 	vmov.f32	s3, s15
 8015ede:	2100      	movs	r1, #0
 8015ee0:	f8d7 009c 	ldr.w	r0, [r7, #156]	; 0x9c
 8015ee4:	f7fc fad4 	bl	8012490 <nk_input_has_mouse_click_down_in_rect>
 8015ee8:	6738      	str	r0, [r7, #112]	; 0x70
                    NK_BUTTON_LEFT, scaler, nk_true);

            if (left_mouse_down && left_mouse_click_in_scaler) {
 8015eea:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015eec:	2b00      	cmp	r3, #0
 8015eee:	f000 80d2 	beq.w	8016096 <nk_panel_end+0xdb6>
 8015ef2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8015ef4:	2b00      	cmp	r3, #0
 8015ef6:	f000 80ce 	beq.w	8016096 <nk_panel_end+0xdb6>
                float delta_x = in->mouse.delta.x;
 8015efa:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8015efe:	f8d3 3154 	ldr.w	r3, [r3, #340]	; 0x154
 8015f02:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
                if (layout->flags & NK_WINDOW_SCALE_LEFT) {
 8015f06:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015f0a:	685b      	ldr	r3, [r3, #4]
 8015f0c:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8015f10:	2b00      	cmp	r3, #0
 8015f12:	d013      	beq.n	8015f3c <nk_panel_end+0xc5c>
                    delta_x = -delta_x;
 8015f14:	edd7 7a2c 	vldr	s15, [r7, #176]	; 0xb0
 8015f18:	eef1 7a67 	vneg.f32	s15, s15
 8015f1c:	edc7 7a2c 	vstr	s15, [r7, #176]	; 0xb0
                    window->bounds.x += in->mouse.delta.x;
 8015f20:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8015f24:	ed93 7a13 	vldr	s14, [r3, #76]	; 0x4c
 8015f28:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8015f2c:	edd3 7a55 	vldr	s15, [r3, #340]	; 0x154
 8015f30:	ee77 7a27 	vadd.f32	s15, s14, s15
 8015f34:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8015f38:	edc3 7a13 	vstr	s15, [r3, #76]	; 0x4c
                }
                /* dragging in x-direction  */
                if (window->bounds.w + delta_x >= window_size.x) {
 8015f3c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8015f40:	ed93 7a15 	vldr	s14, [r3, #84]	; 0x54
 8015f44:	edd7 7a2c 	vldr	s15, [r7, #176]	; 0xb0
 8015f48:	ee37 7a27 	vadd.f32	s14, s14, s15
 8015f4c:	edd7 7a03 	vldr	s15, [r7, #12]
 8015f50:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8015f54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015f58:	db2e      	blt.n	8015fb8 <nk_panel_end+0xcd8>
                    if ((delta_x < 0) || (delta_x > 0 && in->mouse.pos.x >= scaler.x)) {
 8015f5a:	edd7 7a2c 	vldr	s15, [r7, #176]	; 0xb0
 8015f5e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8015f62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015f66:	d411      	bmi.n	8015f8c <nk_panel_end+0xcac>
 8015f68:	edd7 7a2c 	vldr	s15, [r7, #176]	; 0xb0
 8015f6c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8015f70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015f74:	dd20      	ble.n	8015fb8 <nk_panel_end+0xcd8>
 8015f76:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8015f7a:	ed93 7a51 	vldr	s14, [r3, #324]	; 0x144
 8015f7e:	edd7 7a05 	vldr	s15, [r7, #20]
 8015f82:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8015f86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015f8a:	db15      	blt.n	8015fb8 <nk_panel_end+0xcd8>
                        window->bounds.w = window->bounds.w + delta_x;
 8015f8c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8015f90:	ed93 7a15 	vldr	s14, [r3, #84]	; 0x54
 8015f94:	edd7 7a2c 	vldr	s15, [r7, #176]	; 0xb0
 8015f98:	ee77 7a27 	vadd.f32	s15, s14, s15
 8015f9c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8015fa0:	edc3 7a15 	vstr	s15, [r3, #84]	; 0x54
                        scaler.x += in->mouse.delta.x;
 8015fa4:	ed97 7a05 	vldr	s14, [r7, #20]
 8015fa8:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8015fac:	edd3 7a55 	vldr	s15, [r3, #340]	; 0x154
 8015fb0:	ee77 7a27 	vadd.f32	s15, s14, s15
 8015fb4:	edc7 7a05 	vstr	s15, [r7, #20]
                    }
                }
                /* dragging in y-direction (only possible if static window) */
                if (!(layout->flags & NK_WINDOW_DYNAMIC)) {
 8015fb8:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8015fbc:	685b      	ldr	r3, [r3, #4]
 8015fbe:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8015fc2:	2b00      	cmp	r3, #0
 8015fc4:	d145      	bne.n	8016052 <nk_panel_end+0xd72>
                    if (window_size.y < window->bounds.h + in->mouse.delta.y) {
 8015fc6:	ed97 7a04 	vldr	s14, [r7, #16]
 8015fca:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8015fce:	edd3 6a16 	vldr	s13, [r3, #88]	; 0x58
 8015fd2:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8015fd6:	edd3 7a56 	vldr	s15, [r3, #344]	; 0x158
 8015fda:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8015fde:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8015fe2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015fe6:	d534      	bpl.n	8016052 <nk_panel_end+0xd72>
                        if ((in->mouse.delta.y < 0) || (in->mouse.delta.y > 0 && in->mouse.pos.y >= scaler.y)) {
 8015fe8:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8015fec:	edd3 7a56 	vldr	s15, [r3, #344]	; 0x158
 8015ff0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8015ff4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015ff8:	d413      	bmi.n	8016022 <nk_panel_end+0xd42>
 8015ffa:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8015ffe:	edd3 7a56 	vldr	s15, [r3, #344]	; 0x158
 8016002:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016006:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801600a:	dd22      	ble.n	8016052 <nk_panel_end+0xd72>
 801600c:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8016010:	ed93 7a52 	vldr	s14, [r3, #328]	; 0x148
 8016014:	edd7 7a06 	vldr	s15, [r7, #24]
 8016018:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801601c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016020:	db17      	blt.n	8016052 <nk_panel_end+0xd72>
                            window->bounds.h = window->bounds.h + in->mouse.delta.y;
 8016022:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8016026:	ed93 7a16 	vldr	s14, [r3, #88]	; 0x58
 801602a:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 801602e:	edd3 7a56 	vldr	s15, [r3, #344]	; 0x158
 8016032:	ee77 7a27 	vadd.f32	s15, s14, s15
 8016036:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801603a:	edc3 7a16 	vstr	s15, [r3, #88]	; 0x58
                            scaler.y += in->mouse.delta.y;
 801603e:	ed97 7a06 	vldr	s14, [r7, #24]
 8016042:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8016046:	edd3 7a56 	vldr	s15, [r3, #344]	; 0x158
 801604a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801604e:	edc7 7a06 	vstr	s15, [r7, #24]
                        }
                    }
                }
                ctx->style.cursor_active = ctx->style.cursors[NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT];
 8016052:	687b      	ldr	r3, [r7, #4]
 8016054:	f8d3 2184 	ldr.w	r2, [r3, #388]	; 0x184
 8016058:	687b      	ldr	r3, [r7, #4]
 801605a:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
                in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x = scaler.x + scaler.w/2.0f;
 801605e:	ed97 7a05 	vldr	s14, [r7, #20]
 8016062:	edd7 6a07 	vldr	s13, [r7, #28]
 8016066:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 801606a:	eec6 7a86 	vdiv.f32	s15, s13, s12
 801606e:	ee77 7a27 	vadd.f32	s15, s14, s15
 8016072:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8016076:	edc3 7a43 	vstr	s15, [r3, #268]	; 0x10c
                in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.y = scaler.y + scaler.h/2.0f;
 801607a:	ed97 7a06 	vldr	s14, [r7, #24]
 801607e:	edd7 6a08 	vldr	s13, [r7, #32]
 8016082:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 8016086:	eec6 7a86 	vdiv.f32	s15, s13, s12
 801608a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801608e:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8016092:	edc3 7a44 	vstr	s15, [r3, #272]	; 0x110
            }
        }
    }
    if (!nk_panel_is_sub(layout->type)) {
 8016096:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801609a:	781b      	ldrb	r3, [r3, #0]
 801609c:	4618      	mov	r0, r3
 801609e:	f7fe f9b7 	bl	8014410 <nk_panel_is_sub>
 80160a2:	4603      	mov	r3, r0
 80160a4:	2b00      	cmp	r3, #0
 80160a6:	d112      	bne.n	80160ce <nk_panel_end+0xdee>
        /* window is hidden so clear command buffer  */
        if (layout->flags & NK_WINDOW_HIDDEN)
 80160a8:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80160ac:	685b      	ldr	r3, [r3, #4]
 80160ae:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 80160b2:	2b00      	cmp	r3, #0
 80160b4:	d006      	beq.n	80160c4 <nk_panel_end+0xde4>
            nk_command_buffer_reset(&window->buffer);
 80160b6:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80160ba:	3364      	adds	r3, #100	; 0x64
 80160bc:	4618      	mov	r0, r3
 80160be:	f7fa fbd9 	bl	8010874 <nk_command_buffer_reset>
 80160c2:	e004      	b.n	80160ce <nk_panel_end+0xdee>
        /* window is visible and not tab */
        else nk_finish(ctx, window);
 80160c4:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 80160c8:	6878      	ldr	r0, [r7, #4]
 80160ca:	f7f9 ff83 	bl	800ffd4 <nk_finish>
    }

    /* NK_WINDOW_REMOVE_ROM flag was set so remove NK_WINDOW_ROM */
    if (layout->flags & NK_WINDOW_REMOVE_ROM) {
 80160ce:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80160d2:	685b      	ldr	r3, [r3, #4]
 80160d4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80160d8:	2b00      	cmp	r3, #0
 80160da:	d00f      	beq.n	80160fc <nk_panel_end+0xe1c>
        layout->flags &= ~(nk_flags)NK_WINDOW_ROM;
 80160dc:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80160e0:	685b      	ldr	r3, [r3, #4]
 80160e2:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 80160e6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80160ea:	605a      	str	r2, [r3, #4]
        layout->flags &= ~(nk_flags)NK_WINDOW_REMOVE_ROM;
 80160ec:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80160f0:	685b      	ldr	r3, [r3, #4]
 80160f2:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 80160f6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80160fa:	605a      	str	r2, [r3, #4]
    }
    window->flags = layout->flags;
 80160fc:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8016100:	685a      	ldr	r2, [r3, #4]
 8016102:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8016106:	649a      	str	r2, [r3, #72]	; 0x48

    /* property garbage collector */
    if (window->property.active && window->property.old != window->property.seq &&
 8016108:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801610c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8016110:	2b00      	cmp	r3, #0
 8016112:	d01b      	beq.n	801614c <nk_panel_end+0xe6c>
 8016114:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8016118:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
 801611c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8016120:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8016124:	429a      	cmp	r2, r3
 8016126:	d011      	beq.n	801614c <nk_panel_end+0xe6c>
        window->property.active == window->property.prev) {
 8016128:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801612c:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8016130:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8016134:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    if (window->property.active && window->property.old != window->property.seq &&
 8016138:	429a      	cmp	r2, r3
 801613a:	d107      	bne.n	801614c <nk_panel_end+0xe6c>
        nk_zero(&window->property, sizeof(window->property));
 801613c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8016140:	3394      	adds	r3, #148	; 0x94
 8016142:	2168      	movs	r1, #104	; 0x68
 8016144:	4618      	mov	r0, r3
 8016146:	f005 ff6f 	bl	801c028 <nk_zero>
 801614a:	e014      	b.n	8016176 <nk_panel_end+0xe96>
    } else {
        window->property.old = window->property.seq;
 801614c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8016150:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
 8016154:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8016158:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
        window->property.prev = window->property.active;
 801615c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8016160:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8016164:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8016168:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        window->property.seq = 0;
 801616c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8016170:	2200      	movs	r2, #0
 8016172:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
    }
    /* edit garbage collector */
    if (window->edit.active && window->edit.old != window->edit.seq &&
 8016176:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801617a:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 801617e:	2b00      	cmp	r3, #0
 8016180:	d01c      	beq.n	80161bc <nk_panel_end+0xedc>
 8016182:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8016186:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
 801618a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801618e:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 8016192:	429a      	cmp	r2, r3
 8016194:	d012      	beq.n	80161bc <nk_panel_end+0xedc>
       window->edit.active == window->edit.prev) {
 8016196:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801619a:	f8d3 214c 	ldr.w	r2, [r3, #332]	; 0x14c
 801619e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80161a2:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
    if (window->edit.active && window->edit.old != window->edit.seq &&
 80161a6:	429a      	cmp	r2, r3
 80161a8:	d108      	bne.n	80161bc <nk_panel_end+0xedc>
        nk_zero(&window->edit, sizeof(window->edit));
 80161aa:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80161ae:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 80161b2:	212c      	movs	r1, #44	; 0x2c
 80161b4:	4618      	mov	r0, r3
 80161b6:	f005 ff37 	bl	801c028 <nk_zero>
 80161ba:	e014      	b.n	80161e6 <nk_panel_end+0xf06>
    } else {
        window->edit.old = window->edit.seq;
 80161bc:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80161c0:	f8d3 2144 	ldr.w	r2, [r3, #324]	; 0x144
 80161c4:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80161c8:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
        window->edit.prev = window->edit.active;
 80161cc:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80161d0:	f8d3 214c 	ldr.w	r2, [r3, #332]	; 0x14c
 80161d4:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80161d8:	f8c3 2150 	str.w	r2, [r3, #336]	; 0x150
        window->edit.seq = 0;
 80161dc:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80161e0:	2200      	movs	r2, #0
 80161e2:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
    }
    /* contextual garbage collector */
    if (window->popup.active_con && window->popup.con_old != window->popup.con_count) {
 80161e6:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80161ea:	f8d3 312c 	ldr.w	r3, [r3, #300]	; 0x12c
 80161ee:	2b00      	cmp	r3, #0
 80161f0:	d019      	beq.n	8016226 <nk_panel_end+0xf46>
 80161f2:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80161f6:	f8d3 2128 	ldr.w	r2, [r3, #296]	; 0x128
 80161fa:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80161fe:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
 8016202:	429a      	cmp	r2, r3
 8016204:	d00f      	beq.n	8016226 <nk_panel_end+0xf46>
        window->popup.con_count = 0;
 8016206:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801620a:	2200      	movs	r2, #0
 801620c:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
        window->popup.con_old = 0;
 8016210:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8016214:	2200      	movs	r2, #0
 8016216:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
        window->popup.active_con = 0;
 801621a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801621e:	2200      	movs	r2, #0
 8016220:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c
 8016224:	e00c      	b.n	8016240 <nk_panel_end+0xf60>
    } else {
        window->popup.con_old = window->popup.con_count;
 8016226:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801622a:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
 801622e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8016232:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
        window->popup.con_count = 0;
 8016236:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801623a:	2200      	movs	r2, #0
 801623c:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
    }
    window->popup.combo_count = 0;
 8016240:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8016244:	2200      	movs	r2, #0
 8016246:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    /* helper to make sure you have a 'nk_tree_push' for every 'nk_tree_pop' */
    NK_ASSERT(!layout->row.tree_depth);
 801624a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801624e:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8016252:	2b00      	cmp	r3, #0
 8016254:	d007      	beq.n	8016266 <nk_panel_end+0xf86>
 8016256:	4b05      	ldr	r3, [pc, #20]	; (801626c <nk_panel_end+0xf8c>)
 8016258:	4a05      	ldr	r2, [pc, #20]	; (8016270 <nk_panel_end+0xf90>)
 801625a:	f240 216b 	movw	r1, #619	; 0x26b
 801625e:	4805      	ldr	r0, [pc, #20]	; (8016274 <nk_panel_end+0xf94>)
 8016260:	f007 fbda 	bl	801da18 <__assert_func>
        return;
 8016264:	bf00      	nop
}
 8016266:	37c4      	adds	r7, #196	; 0xc4
 8016268:	46bd      	mov	sp, r7
 801626a:	bd90      	pop	{r4, r7, pc}
 801626c:	080219cc 	.word	0x080219cc
 8016270:	080235b4 	.word	0x080235b4
 8016274:	08021988 	.word	0x08021988

08016278 <nk_pool_init>:
 *
 * ===============================================================*/
NK_LIB void
nk_pool_init(struct nk_pool *pool, struct nk_allocator *alloc,
    unsigned int capacity)
{
 8016278:	b580      	push	{r7, lr}
 801627a:	b084      	sub	sp, #16
 801627c:	af00      	add	r7, sp, #0
 801627e:	60f8      	str	r0, [r7, #12]
 8016280:	60b9      	str	r1, [r7, #8]
 8016282:	607a      	str	r2, [r7, #4]
    NK_ASSERT(capacity >= 1);
 8016284:	687b      	ldr	r3, [r7, #4]
 8016286:	2b00      	cmp	r3, #0
 8016288:	d105      	bne.n	8016296 <nk_pool_init+0x1e>
 801628a:	4b0e      	ldr	r3, [pc, #56]	; (80162c4 <nk_pool_init+0x4c>)
 801628c:	4a0e      	ldr	r2, [pc, #56]	; (80162c8 <nk_pool_init+0x50>)
 801628e:	210d      	movs	r1, #13
 8016290:	480e      	ldr	r0, [pc, #56]	; (80162cc <nk_pool_init+0x54>)
 8016292:	f007 fbc1 	bl	801da18 <__assert_func>
    nk_zero(pool, sizeof(*pool));
 8016296:	2128      	movs	r1, #40	; 0x28
 8016298:	68f8      	ldr	r0, [r7, #12]
 801629a:	f005 fec5 	bl	801c028 <nk_zero>
    pool->alloc = *alloc;
 801629e:	68fb      	ldr	r3, [r7, #12]
 80162a0:	68ba      	ldr	r2, [r7, #8]
 80162a2:	ca07      	ldmia	r2, {r0, r1, r2}
 80162a4:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    pool->capacity = capacity;
 80162a8:	68fb      	ldr	r3, [r7, #12]
 80162aa:	687a      	ldr	r2, [r7, #4]
 80162ac:	61da      	str	r2, [r3, #28]
    pool->type = NK_BUFFER_DYNAMIC;
 80162ae:	68fb      	ldr	r3, [r7, #12]
 80162b0:	2201      	movs	r2, #1
 80162b2:	731a      	strb	r2, [r3, #12]
    pool->pages = 0;
 80162b4:	68fb      	ldr	r3, [r7, #12]
 80162b6:	2200      	movs	r2, #0
 80162b8:	615a      	str	r2, [r3, #20]
}
 80162ba:	bf00      	nop
 80162bc:	3710      	adds	r7, #16
 80162be:	46bd      	mov	sp, r7
 80162c0:	bd80      	pop	{r7, pc}
 80162c2:	bf00      	nop
 80162c4:	080219e4 	.word	0x080219e4
 80162c8:	080235c4 	.word	0x080235c4
 80162cc:	080219f4 	.word	0x080219f4

080162d0 <nk_pool_init_fixed>:
        iter = next;
    }
}
NK_LIB void
nk_pool_init_fixed(struct nk_pool *pool, void *memory, nk_size size)
{
 80162d0:	b580      	push	{r7, lr}
 80162d2:	b084      	sub	sp, #16
 80162d4:	af00      	add	r7, sp, #0
 80162d6:	60f8      	str	r0, [r7, #12]
 80162d8:	60b9      	str	r1, [r7, #8]
 80162da:	607a      	str	r2, [r7, #4]
    nk_zero(pool, sizeof(*pool));
 80162dc:	2128      	movs	r1, #40	; 0x28
 80162de:	68f8      	ldr	r0, [r7, #12]
 80162e0:	f005 fea2 	bl	801c028 <nk_zero>
    NK_ASSERT(size >= sizeof(struct nk_page));
 80162e4:	687b      	ldr	r3, [r7, #4]
 80162e6:	f5b3 7fdc 	cmp.w	r3, #440	; 0x1b8
 80162ea:	d205      	bcs.n	80162f8 <nk_pool_init_fixed+0x28>
 80162ec:	4b10      	ldr	r3, [pc, #64]	; (8016330 <nk_pool_init_fixed+0x60>)
 80162ee:	4a11      	ldr	r2, [pc, #68]	; (8016334 <nk_pool_init_fixed+0x64>)
 80162f0:	2125      	movs	r1, #37	; 0x25
 80162f2:	4811      	ldr	r0, [pc, #68]	; (8016338 <nk_pool_init_fixed+0x68>)
 80162f4:	f007 fb90 	bl	801da18 <__assert_func>
    if (size < sizeof(struct nk_page)) return;
 80162f8:	687b      	ldr	r3, [r7, #4]
 80162fa:	f5b3 7fdc 	cmp.w	r3, #440	; 0x1b8
 80162fe:	d313      	bcc.n	8016328 <nk_pool_init_fixed+0x58>
    /* first nk_page_element is embedded in nk_page, additional elements follow in adjacent space */
    pool->capacity = (unsigned)(1 + (size - sizeof(struct nk_page)) / sizeof(struct nk_page_element));
 8016300:	687b      	ldr	r3, [r7, #4]
 8016302:	f5a3 73dc 	sub.w	r3, r3, #440	; 0x1b8
 8016306:	091b      	lsrs	r3, r3, #4
 8016308:	4a0c      	ldr	r2, [pc, #48]	; (801633c <nk_pool_init_fixed+0x6c>)
 801630a:	fba2 2303 	umull	r2, r3, r2, r3
 801630e:	1c5a      	adds	r2, r3, #1
 8016310:	68fb      	ldr	r3, [r7, #12]
 8016312:	61da      	str	r2, [r3, #28]
    pool->pages = (struct nk_page*)memory;
 8016314:	68fb      	ldr	r3, [r7, #12]
 8016316:	68ba      	ldr	r2, [r7, #8]
 8016318:	615a      	str	r2, [r3, #20]
    pool->type = NK_BUFFER_FIXED;
 801631a:	68fb      	ldr	r3, [r7, #12]
 801631c:	2200      	movs	r2, #0
 801631e:	731a      	strb	r2, [r3, #12]
    pool->size = size;
 8016320:	68fb      	ldr	r3, [r7, #12]
 8016322:	687a      	ldr	r2, [r7, #4]
 8016324:	621a      	str	r2, [r3, #32]
 8016326:	e000      	b.n	801632a <nk_pool_init_fixed+0x5a>
    if (size < sizeof(struct nk_page)) return;
 8016328:	bf00      	nop
}
 801632a:	3710      	adds	r7, #16
 801632c:	46bd      	mov	sp, r7
 801632e:	bd80      	pop	{r7, pc}
 8016330:	08021a10 	.word	0x08021a10
 8016334:	080235d4 	.word	0x080235d4
 8016338:	080219f4 	.word	0x080219f4
 801633c:	097b425f 	.word	0x097b425f

08016340 <nk_pool_alloc>:
NK_LIB struct nk_page_element*
nk_pool_alloc(struct nk_pool *pool)
{
 8016340:	b580      	push	{r7, lr}
 8016342:	b084      	sub	sp, #16
 8016344:	af00      	add	r7, sp, #0
 8016346:	6078      	str	r0, [r7, #4]
    if (!pool->pages || pool->pages->size >= pool->capacity) {
 8016348:	687b      	ldr	r3, [r7, #4]
 801634a:	695b      	ldr	r3, [r3, #20]
 801634c:	2b00      	cmp	r3, #0
 801634e:	d006      	beq.n	801635e <nk_pool_alloc+0x1e>
 8016350:	687b      	ldr	r3, [r7, #4]
 8016352:	695b      	ldr	r3, [r3, #20]
 8016354:	681a      	ldr	r2, [r3, #0]
 8016356:	687b      	ldr	r3, [r7, #4]
 8016358:	69db      	ldr	r3, [r3, #28]
 801635a:	429a      	cmp	r2, r3
 801635c:	d342      	bcc.n	80163e4 <nk_pool_alloc+0xa4>
        /* allocate new page */
        struct nk_page *page;
        if (pool->type == NK_BUFFER_FIXED) {
 801635e:	687b      	ldr	r3, [r7, #4]
 8016360:	7b1b      	ldrb	r3, [r3, #12]
 8016362:	2b00      	cmp	r3, #0
 8016364:	d11e      	bne.n	80163a4 <nk_pool_alloc+0x64>
            NK_ASSERT(pool->pages);
 8016366:	687b      	ldr	r3, [r7, #4]
 8016368:	695b      	ldr	r3, [r3, #20]
 801636a:	2b00      	cmp	r3, #0
 801636c:	d105      	bne.n	801637a <nk_pool_alloc+0x3a>
 801636e:	4b26      	ldr	r3, [pc, #152]	; (8016408 <nk_pool_alloc+0xc8>)
 8016370:	4a26      	ldr	r2, [pc, #152]	; (801640c <nk_pool_alloc+0xcc>)
 8016372:	2134      	movs	r1, #52	; 0x34
 8016374:	4826      	ldr	r0, [pc, #152]	; (8016410 <nk_pool_alloc+0xd0>)
 8016376:	f007 fb4f 	bl	801da18 <__assert_func>
            if (!pool->pages) return 0;
 801637a:	687b      	ldr	r3, [r7, #4]
 801637c:	695b      	ldr	r3, [r3, #20]
 801637e:	2b00      	cmp	r3, #0
 8016380:	d101      	bne.n	8016386 <nk_pool_alloc+0x46>
 8016382:	2300      	movs	r3, #0
 8016384:	e03b      	b.n	80163fe <nk_pool_alloc+0xbe>
            NK_ASSERT(pool->pages->size < pool->capacity);
 8016386:	687b      	ldr	r3, [r7, #4]
 8016388:	695b      	ldr	r3, [r3, #20]
 801638a:	681a      	ldr	r2, [r3, #0]
 801638c:	687b      	ldr	r3, [r7, #4]
 801638e:	69db      	ldr	r3, [r3, #28]
 8016390:	429a      	cmp	r2, r3
 8016392:	d305      	bcc.n	80163a0 <nk_pool_alloc+0x60>
 8016394:	4b1f      	ldr	r3, [pc, #124]	; (8016414 <nk_pool_alloc+0xd4>)
 8016396:	4a1d      	ldr	r2, [pc, #116]	; (801640c <nk_pool_alloc+0xcc>)
 8016398:	2136      	movs	r1, #54	; 0x36
 801639a:	481d      	ldr	r0, [pc, #116]	; (8016410 <nk_pool_alloc+0xd0>)
 801639c:	f007 fb3c 	bl	801da18 <__assert_func>
            return 0;
 80163a0:	2300      	movs	r3, #0
 80163a2:	e02c      	b.n	80163fe <nk_pool_alloc+0xbe>
        } else {
            nk_size size = sizeof(struct nk_page);
 80163a4:	f44f 73dc 	mov.w	r3, #440	; 0x1b8
 80163a8:	60fb      	str	r3, [r7, #12]
            size += (pool->capacity - 1) * sizeof(struct nk_page_element);
 80163aa:	687b      	ldr	r3, [r7, #4]
 80163ac:	69db      	ldr	r3, [r3, #28]
 80163ae:	f44f 72d8 	mov.w	r2, #432	; 0x1b0
 80163b2:	fb03 f202 	mul.w	r2, r3, r2
 80163b6:	68fb      	ldr	r3, [r7, #12]
 80163b8:	4413      	add	r3, r2
 80163ba:	f5a3 73d8 	sub.w	r3, r3, #432	; 0x1b0
 80163be:	60fb      	str	r3, [r7, #12]
            page = (struct nk_page*)pool->alloc.alloc(pool->alloc.userdata,0, size);
 80163c0:	687b      	ldr	r3, [r7, #4]
 80163c2:	685b      	ldr	r3, [r3, #4]
 80163c4:	6878      	ldr	r0, [r7, #4]
 80163c6:	68fa      	ldr	r2, [r7, #12]
 80163c8:	2100      	movs	r1, #0
 80163ca:	6800      	ldr	r0, [r0, #0]
 80163cc:	4798      	blx	r3
 80163ce:	60b8      	str	r0, [r7, #8]
            page->next = pool->pages;
 80163d0:	687b      	ldr	r3, [r7, #4]
 80163d2:	695a      	ldr	r2, [r3, #20]
 80163d4:	68bb      	ldr	r3, [r7, #8]
 80163d6:	605a      	str	r2, [r3, #4]
            pool->pages = page;
 80163d8:	687b      	ldr	r3, [r7, #4]
 80163da:	68ba      	ldr	r2, [r7, #8]
 80163dc:	615a      	str	r2, [r3, #20]
            page->size = 0;
 80163de:	68bb      	ldr	r3, [r7, #8]
 80163e0:	2200      	movs	r2, #0
 80163e2:	601a      	str	r2, [r3, #0]
        }
    } return &pool->pages->win[pool->pages->size++];
 80163e4:	687b      	ldr	r3, [r7, #4]
 80163e6:	6959      	ldr	r1, [r3, #20]
 80163e8:	687b      	ldr	r3, [r7, #4]
 80163ea:	695a      	ldr	r2, [r3, #20]
 80163ec:	6813      	ldr	r3, [r2, #0]
 80163ee:	1c58      	adds	r0, r3, #1
 80163f0:	6010      	str	r0, [r2, #0]
 80163f2:	f44f 72d8 	mov.w	r2, #432	; 0x1b0
 80163f6:	fb02 f303 	mul.w	r3, r2, r3
 80163fa:	3308      	adds	r3, #8
 80163fc:	440b      	add	r3, r1
}
 80163fe:	4618      	mov	r0, r3
 8016400:	3710      	adds	r7, #16
 8016402:	46bd      	mov	sp, r7
 8016404:	bd80      	pop	{r7, pc}
 8016406:	bf00      	nop
 8016408:	08021a30 	.word	0x08021a30
 801640c:	080235e8 	.word	0x080235e8
 8016410:	080219f4 	.word	0x080219f4
 8016414:	08021a3c 	.word	0x08021a3c

08016418 <nk_nonblock_begin>:
}
NK_LIB nk_bool
nk_nonblock_begin(struct nk_context *ctx,
    nk_flags flags, struct nk_rect body, struct nk_rect header,
    enum nk_panel_type panel_type)
{
 8016418:	b5b0      	push	{r4, r5, r7, lr}
 801641a:	b096      	sub	sp, #88	; 0x58
 801641c:	af00      	add	r7, sp, #0
 801641e:	62f8      	str	r0, [r7, #44]	; 0x2c
 8016420:	62b9      	str	r1, [r7, #40]	; 0x28
 8016422:	eeb0 4a40 	vmov.f32	s8, s0
 8016426:	eef0 4a60 	vmov.f32	s9, s1
 801642a:	eeb0 5a41 	vmov.f32	s10, s2
 801642e:	eef0 5a61 	vmov.f32	s11, s3
 8016432:	eeb0 6a42 	vmov.f32	s12, s4
 8016436:	eef0 6a62 	vmov.f32	s13, s5
 801643a:	eeb0 7a43 	vmov.f32	s14, s6
 801643e:	eef0 7a63 	vmov.f32	s15, s7
 8016442:	4613      	mov	r3, r2
 8016444:	ed87 4a06 	vstr	s8, [r7, #24]
 8016448:	edc7 4a07 	vstr	s9, [r7, #28]
 801644c:	ed87 5a08 	vstr	s10, [r7, #32]
 8016450:	edc7 5a09 	vstr	s11, [r7, #36]	; 0x24
 8016454:	ed87 6a02 	vstr	s12, [r7, #8]
 8016458:	edc7 6a03 	vstr	s13, [r7, #12]
 801645c:	ed87 7a04 	vstr	s14, [r7, #16]
 8016460:	edc7 7a05 	vstr	s15, [r7, #20]
 8016464:	71fb      	strb	r3, [r7, #7]
    struct nk_window *popup;
    struct nk_window *win;
    struct nk_panel *panel;
    int is_active = nk_true;
 8016466:	2301      	movs	r3, #1
 8016468:	653b      	str	r3, [r7, #80]	; 0x50

    NK_ASSERT(ctx);
 801646a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801646c:	2b00      	cmp	r3, #0
 801646e:	d105      	bne.n	801647c <nk_nonblock_begin+0x64>
 8016470:	4baf      	ldr	r3, [pc, #700]	; (8016730 <nk_nonblock_begin+0x318>)
 8016472:	4ab0      	ldr	r2, [pc, #704]	; (8016734 <nk_nonblock_begin+0x31c>)
 8016474:	2173      	movs	r1, #115	; 0x73
 8016476:	48b0      	ldr	r0, [pc, #704]	; (8016738 <nk_nonblock_begin+0x320>)
 8016478:	f007 face 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 801647c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801647e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8016482:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8016486:	2b00      	cmp	r3, #0
 8016488:	d105      	bne.n	8016496 <nk_nonblock_begin+0x7e>
 801648a:	4bac      	ldr	r3, [pc, #688]	; (801673c <nk_nonblock_begin+0x324>)
 801648c:	4aa9      	ldr	r2, [pc, #676]	; (8016734 <nk_nonblock_begin+0x31c>)
 801648e:	2174      	movs	r1, #116	; 0x74
 8016490:	48a9      	ldr	r0, [pc, #676]	; (8016738 <nk_nonblock_begin+0x320>)
 8016492:	f007 fac1 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 8016496:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016498:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801649c:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 80164a0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80164a4:	2b00      	cmp	r3, #0
 80164a6:	d105      	bne.n	80164b4 <nk_nonblock_begin+0x9c>
 80164a8:	4ba5      	ldr	r3, [pc, #660]	; (8016740 <nk_nonblock_begin+0x328>)
 80164aa:	4aa2      	ldr	r2, [pc, #648]	; (8016734 <nk_nonblock_begin+0x31c>)
 80164ac:	2175      	movs	r1, #117	; 0x75
 80164ae:	48a2      	ldr	r0, [pc, #648]	; (8016738 <nk_nonblock_begin+0x320>)
 80164b0:	f007 fab2 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout)
 80164b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80164b6:	2b00      	cmp	r3, #0
 80164b8:	d00f      	beq.n	80164da <nk_nonblock_begin+0xc2>
 80164ba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80164bc:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80164c0:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 80164c4:	2b00      	cmp	r3, #0
 80164c6:	d008      	beq.n	80164da <nk_nonblock_begin+0xc2>
 80164c8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80164ca:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80164ce:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 80164d2:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80164d6:	2b00      	cmp	r3, #0
 80164d8:	d101      	bne.n	80164de <nk_nonblock_begin+0xc6>
        return 0;
 80164da:	2300      	movs	r3, #0
 80164dc:	e146      	b.n	801676c <nk_nonblock_begin+0x354>

    /* popups cannot have popups */
    win = ctx->current;
 80164de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80164e0:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80164e4:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 80164e8:	647b      	str	r3, [r7, #68]	; 0x44
    panel = win->layout;
 80164ea:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80164ec:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80164f0:	643b      	str	r3, [r7, #64]	; 0x40
    NK_ASSERT(!(panel->type & NK_PANEL_SET_POPUP));
 80164f2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80164f4:	781b      	ldrb	r3, [r3, #0]
 80164f6:	f003 03f4 	and.w	r3, r3, #244	; 0xf4
 80164fa:	2b00      	cmp	r3, #0
 80164fc:	d005      	beq.n	801650a <nk_nonblock_begin+0xf2>
 80164fe:	4b91      	ldr	r3, [pc, #580]	; (8016744 <nk_nonblock_begin+0x32c>)
 8016500:	4a8c      	ldr	r2, [pc, #560]	; (8016734 <nk_nonblock_begin+0x31c>)
 8016502:	217c      	movs	r1, #124	; 0x7c
 8016504:	488c      	ldr	r0, [pc, #560]	; (8016738 <nk_nonblock_begin+0x320>)
 8016506:	f007 fa87 	bl	801da18 <__assert_func>
    (void)panel;
    popup = win->popup.win;
 801650a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801650c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 8016510:	657b      	str	r3, [r7, #84]	; 0x54
    if (!popup) {
 8016512:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016514:	2b00      	cmp	r3, #0
 8016516:	d11b      	bne.n	8016550 <nk_nonblock_begin+0x138>
        /* create window for nonblocking popup */
        popup = (struct nk_window*)nk_create_window(ctx);
 8016518:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801651a:	f006 f99d 	bl	801c858 <nk_create_window>
 801651e:	6578      	str	r0, [r7, #84]	; 0x54
        popup->parent = win;
 8016520:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016522:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8016524:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
        win->popup.win = popup;
 8016528:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801652a:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801652c:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
        win->popup.type = panel_type;
 8016530:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016532:	79fa      	ldrb	r2, [r7, #7]
 8016534:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100
        nk_command_buffer_init(&popup->buffer, &ctx->memory, NK_CLIPPING_ON);
 8016538:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801653a:	f103 0064 	add.w	r0, r3, #100	; 0x64
 801653e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016540:	f503 53d4 	add.w	r3, r3, #6784	; 0x1a80
 8016544:	330c      	adds	r3, #12
 8016546:	2201      	movs	r2, #1
 8016548:	4619      	mov	r1, r3
 801654a:	f7fa f955 	bl	80107f8 <nk_command_buffer_init>
 801654e:	e03a      	b.n	80165c6 <nk_nonblock_begin+0x1ae>
        /* close the popup if user pressed outside or in the header */
        int pressed, in_body, in_header;
#ifdef NK_BUTTON_TRIGGER_ON_RELEASE
        pressed = nk_input_is_mouse_released(&ctx->input, NK_BUTTON_LEFT);
#else
        pressed = nk_input_is_mouse_pressed(&ctx->input, NK_BUTTON_LEFT);
 8016550:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016552:	2100      	movs	r1, #0
 8016554:	4618      	mov	r0, r3
 8016556:	f7fc f89e 	bl	8012696 <nk_input_is_mouse_pressed>
 801655a:	63f8      	str	r0, [r7, #60]	; 0x3c
#endif
        in_body = nk_input_is_mouse_hovering_rect(&ctx->input, body);
 801655c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801655e:	ed97 6a06 	vldr	s12, [r7, #24]
 8016562:	edd7 6a07 	vldr	s13, [r7, #28]
 8016566:	ed97 7a08 	vldr	s14, [r7, #32]
 801656a:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 801656e:	eeb0 0a46 	vmov.f32	s0, s12
 8016572:	eef0 0a66 	vmov.f32	s1, s13
 8016576:	eeb0 1a47 	vmov.f32	s2, s14
 801657a:	eef0 1a67 	vmov.f32	s3, s15
 801657e:	4618      	mov	r0, r3
 8016580:	f7fb ffcd 	bl	801251e <nk_input_is_mouse_hovering_rect>
 8016584:	63b8      	str	r0, [r7, #56]	; 0x38
        in_header = nk_input_is_mouse_hovering_rect(&ctx->input, header);
 8016586:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016588:	ed97 6a02 	vldr	s12, [r7, #8]
 801658c:	edd7 6a03 	vldr	s13, [r7, #12]
 8016590:	ed97 7a04 	vldr	s14, [r7, #16]
 8016594:	edd7 7a05 	vldr	s15, [r7, #20]
 8016598:	eeb0 0a46 	vmov.f32	s0, s12
 801659c:	eef0 0a66 	vmov.f32	s1, s13
 80165a0:	eeb0 1a47 	vmov.f32	s2, s14
 80165a4:	eef0 1a67 	vmov.f32	s3, s15
 80165a8:	4618      	mov	r0, r3
 80165aa:	f7fb ffb8 	bl	801251e <nk_input_is_mouse_hovering_rect>
 80165ae:	6378      	str	r0, [r7, #52]	; 0x34
        if (pressed && (!in_body || in_header))
 80165b0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80165b2:	2b00      	cmp	r3, #0
 80165b4:	d007      	beq.n	80165c6 <nk_nonblock_begin+0x1ae>
 80165b6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80165b8:	2b00      	cmp	r3, #0
 80165ba:	d002      	beq.n	80165c2 <nk_nonblock_begin+0x1aa>
 80165bc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80165be:	2b00      	cmp	r3, #0
 80165c0:	d001      	beq.n	80165c6 <nk_nonblock_begin+0x1ae>
            is_active = nk_false;
 80165c2:	2300      	movs	r3, #0
 80165c4:	653b      	str	r3, [r7, #80]	; 0x50
    }
    win->popup.header = header;
 80165c6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80165c8:	f503 7498 	add.w	r4, r3, #304	; 0x130
 80165cc:	f107 0308 	add.w	r3, r7, #8
 80165d0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80165d2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

    if (!is_active) {
 80165d6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80165d8:	2b00      	cmp	r3, #0
 80165da:	d113      	bne.n	8016604 <nk_nonblock_begin+0x1ec>
        /* remove read only mode from all parent panels */
        struct nk_panel *root = win->layout;
 80165dc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80165de:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80165e2:	64fb      	str	r3, [r7, #76]	; 0x4c
        while (root) {
 80165e4:	e009      	b.n	80165fa <nk_nonblock_begin+0x1e2>
            root->flags |= NK_WINDOW_REMOVE_ROM;
 80165e6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80165e8:	685b      	ldr	r3, [r3, #4]
 80165ea:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 80165ee:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80165f0:	605a      	str	r2, [r3, #4]
            root = root->parent;
 80165f2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80165f4:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 80165f8:	64fb      	str	r3, [r7, #76]	; 0x4c
        while (root) {
 80165fa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80165fc:	2b00      	cmp	r3, #0
 80165fe:	d1f2      	bne.n	80165e6 <nk_nonblock_begin+0x1ce>
        }
        return is_active;
 8016600:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016602:	e0b3      	b.n	801676c <nk_nonblock_begin+0x354>
    }
    popup->bounds = body;
 8016604:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016606:	f103 044c 	add.w	r4, r3, #76	; 0x4c
 801660a:	f107 0318 	add.w	r3, r7, #24
 801660e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8016610:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    popup->parent = win;
 8016614:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016616:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8016618:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    popup->layout = (struct nk_panel*)nk_create_panel(ctx);
 801661c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801661e:	f7fd fcaf 	bl	8013f80 <nk_create_panel>
 8016622:	4602      	mov	r2, r0
 8016624:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016626:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    popup->flags = flags;
 801662a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801662c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801662e:	649a      	str	r2, [r3, #72]	; 0x48
    popup->flags |= NK_WINDOW_BORDER;
 8016630:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016632:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016634:	f043 0201 	orr.w	r2, r3, #1
 8016638:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801663a:	649a      	str	r2, [r3, #72]	; 0x48
    popup->flags |= NK_WINDOW_DYNAMIC;
 801663c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801663e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016640:	f443 6200 	orr.w	r2, r3, #2048	; 0x800
 8016644:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016646:	649a      	str	r2, [r3, #72]	; 0x48
    popup->seq = ctx->seq;
 8016648:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801664a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801664e:	f8d3 2664 	ldr.w	r2, [r3, #1636]	; 0x664
 8016652:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016654:	601a      	str	r2, [r3, #0]
    win->popup.active = 1;
 8016656:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016658:	2201      	movs	r2, #1
 801665a:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
    NK_ASSERT(popup->layout);
 801665e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016660:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8016664:	2b00      	cmp	r3, #0
 8016666:	d105      	bne.n	8016674 <nk_nonblock_begin+0x25c>
 8016668:	4b37      	ldr	r3, [pc, #220]	; (8016748 <nk_nonblock_begin+0x330>)
 801666a:	4a32      	ldr	r2, [pc, #200]	; (8016734 <nk_nonblock_begin+0x31c>)
 801666c:	21a6      	movs	r1, #166	; 0xa6
 801666e:	4832      	ldr	r0, [pc, #200]	; (8016738 <nk_nonblock_begin+0x320>)
 8016670:	f007 f9d2 	bl	801da18 <__assert_func>

    nk_start_popup(ctx, win);
 8016674:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8016676:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8016678:	f7f9 fbfe 	bl	800fe78 <nk_start_popup>
    popup->buffer = win->buffer;
 801667c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801667e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016680:	f102 0464 	add.w	r4, r2, #100	; 0x64
 8016684:	f103 0564 	add.w	r5, r3, #100	; 0x64
 8016688:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801668a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801668c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801668e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8016690:	e895 0003 	ldmia.w	r5, {r0, r1}
 8016694:	e884 0003 	stmia.w	r4, {r0, r1}
    nk_push_scissor(&popup->buffer, nk_null_rect);
 8016698:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801669a:	f103 0264 	add.w	r2, r3, #100	; 0x64
 801669e:	4b2b      	ldr	r3, [pc, #172]	; (801674c <nk_nonblock_begin+0x334>)
 80166a0:	ed93 6a00 	vldr	s12, [r3]
 80166a4:	edd3 6a01 	vldr	s13, [r3, #4]
 80166a8:	ed93 7a02 	vldr	s14, [r3, #8]
 80166ac:	edd3 7a03 	vldr	s15, [r3, #12]
 80166b0:	eeb0 0a46 	vmov.f32	s0, s12
 80166b4:	eef0 0a66 	vmov.f32	s1, s13
 80166b8:	eeb0 1a47 	vmov.f32	s2, s14
 80166bc:	eef0 1a67 	vmov.f32	s3, s15
 80166c0:	4610      	mov	r0, r2
 80166c2:	f7fa f96b 	bl	801099c <nk_push_scissor>
    ctx->current = popup;
 80166c6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80166c8:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80166cc:	461a      	mov	r2, r3
 80166ce:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80166d0:	f8c2 3658 	str.w	r3, [r2, #1624]	; 0x658

    nk_panel_begin(ctx, 0, panel_type);
 80166d4:	79fb      	ldrb	r3, [r7, #7]
 80166d6:	461a      	mov	r2, r3
 80166d8:	2100      	movs	r1, #0
 80166da:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80166dc:	f7fd febe 	bl	801445c <nk_panel_begin>
    win->buffer = popup->buffer;
 80166e0:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80166e2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80166e4:	f102 0464 	add.w	r4, r2, #100	; 0x64
 80166e8:	f103 0564 	add.w	r5, r3, #100	; 0x64
 80166ec:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80166ee:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80166f0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80166f2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80166f4:	e895 0003 	ldmia.w	r5, {r0, r1}
 80166f8:	e884 0003 	stmia.w	r4, {r0, r1}
    popup->layout->parent = win->layout;
 80166fc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80166fe:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8016702:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8016704:	f8d2 208c 	ldr.w	r2, [r2, #140]	; 0x8c
 8016708:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
    popup->layout->offset_x = &popup->scrollbar.x;
 801670c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801670e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8016712:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8016714:	325c      	adds	r2, #92	; 0x5c
 8016716:	619a      	str	r2, [r3, #24]
    popup->layout->offset_y = &popup->scrollbar.y;
 8016718:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801671a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801671e:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8016720:	3260      	adds	r2, #96	; 0x60
 8016722:	61da      	str	r2, [r3, #28]

    /* set read only mode to all parent panels */
    {struct nk_panel *root;
    root = win->layout;
 8016724:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016726:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801672a:	64bb      	str	r3, [r7, #72]	; 0x48
    while (root) {
 801672c:	e01a      	b.n	8016764 <nk_nonblock_begin+0x34c>
 801672e:	bf00      	nop
 8016730:	08021a60 	.word	0x08021a60
 8016734:	08023608 	.word	0x08023608
 8016738:	08021a64 	.word	0x08021a64
 801673c:	08021a88 	.word	0x08021a88
 8016740:	08021a98 	.word	0x08021a98
 8016744:	08021b00 	.word	0x08021b00
 8016748:	08021b24 	.word	0x08021b24
 801674c:	080235f8 	.word	0x080235f8
        root->flags |= NK_WINDOW_ROM;
 8016750:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016752:	685b      	ldr	r3, [r3, #4]
 8016754:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
 8016758:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801675a:	605a      	str	r2, [r3, #4]
        root = root->parent;
 801675c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801675e:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 8016762:	64bb      	str	r3, [r7, #72]	; 0x48
    while (root) {
 8016764:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016766:	2b00      	cmp	r3, #0
 8016768:	d1f2      	bne.n	8016750 <nk_nonblock_begin+0x338>
    }}
    return is_active;
 801676a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
}
 801676c:	4618      	mov	r0, r3
 801676e:	3758      	adds	r7, #88	; 0x58
 8016770:	46bd      	mov	sp, r7
 8016772:	bdb0      	pop	{r4, r5, r7, pc}

08016774 <nk_popup_close>:
NK_API void
nk_popup_close(struct nk_context *ctx)
{
 8016774:	b580      	push	{r7, lr}
 8016776:	b084      	sub	sp, #16
 8016778:	af00      	add	r7, sp, #0
 801677a:	6078      	str	r0, [r7, #4]
    struct nk_window *popup;
    NK_ASSERT(ctx);
 801677c:	687b      	ldr	r3, [r7, #4]
 801677e:	2b00      	cmp	r3, #0
 8016780:	d105      	bne.n	801678e <nk_popup_close+0x1a>
 8016782:	4b1d      	ldr	r3, [pc, #116]	; (80167f8 <nk_popup_close+0x84>)
 8016784:	4a1d      	ldr	r2, [pc, #116]	; (80167fc <nk_popup_close+0x88>)
 8016786:	21c0      	movs	r1, #192	; 0xc0
 8016788:	481d      	ldr	r0, [pc, #116]	; (8016800 <nk_popup_close+0x8c>)
 801678a:	f007 f945 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current) return;
 801678e:	687b      	ldr	r3, [r7, #4]
 8016790:	2b00      	cmp	r3, #0
 8016792:	d02c      	beq.n	80167ee <nk_popup_close+0x7a>
 8016794:	687b      	ldr	r3, [r7, #4]
 8016796:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801679a:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801679e:	2b00      	cmp	r3, #0
 80167a0:	d025      	beq.n	80167ee <nk_popup_close+0x7a>

    popup = ctx->current;
 80167a2:	687b      	ldr	r3, [r7, #4]
 80167a4:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80167a8:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 80167ac:	60fb      	str	r3, [r7, #12]
    NK_ASSERT(popup->parent);
 80167ae:	68fb      	ldr	r3, [r7, #12]
 80167b0:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 80167b4:	2b00      	cmp	r3, #0
 80167b6:	d105      	bne.n	80167c4 <nk_popup_close+0x50>
 80167b8:	4b12      	ldr	r3, [pc, #72]	; (8016804 <nk_popup_close+0x90>)
 80167ba:	4a10      	ldr	r2, [pc, #64]	; (80167fc <nk_popup_close+0x88>)
 80167bc:	21c4      	movs	r1, #196	; 0xc4
 80167be:	4810      	ldr	r0, [pc, #64]	; (8016800 <nk_popup_close+0x8c>)
 80167c0:	f007 f92a 	bl	801da18 <__assert_func>
    NK_ASSERT(popup->layout->type & NK_PANEL_SET_POPUP);
 80167c4:	68fb      	ldr	r3, [r7, #12]
 80167c6:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80167ca:	781b      	ldrb	r3, [r3, #0]
 80167cc:	f003 03f4 	and.w	r3, r3, #244	; 0xf4
 80167d0:	2b00      	cmp	r3, #0
 80167d2:	d105      	bne.n	80167e0 <nk_popup_close+0x6c>
 80167d4:	4b0c      	ldr	r3, [pc, #48]	; (8016808 <nk_popup_close+0x94>)
 80167d6:	4a09      	ldr	r2, [pc, #36]	; (80167fc <nk_popup_close+0x88>)
 80167d8:	21c5      	movs	r1, #197	; 0xc5
 80167da:	4809      	ldr	r0, [pc, #36]	; (8016800 <nk_popup_close+0x8c>)
 80167dc:	f007 f91c 	bl	801da18 <__assert_func>
    popup->flags |= NK_WINDOW_HIDDEN;
 80167e0:	68fb      	ldr	r3, [r7, #12]
 80167e2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80167e4:	f443 5200 	orr.w	r2, r3, #8192	; 0x2000
 80167e8:	68fb      	ldr	r3, [r7, #12]
 80167ea:	649a      	str	r2, [r3, #72]	; 0x48
 80167ec:	e000      	b.n	80167f0 <nk_popup_close+0x7c>
    if (!ctx || !ctx->current) return;
 80167ee:	bf00      	nop
}
 80167f0:	3710      	adds	r7, #16
 80167f2:	46bd      	mov	sp, r7
 80167f4:	bd80      	pop	{r7, pc}
 80167f6:	bf00      	nop
 80167f8:	08021a60 	.word	0x08021a60
 80167fc:	0802361c 	.word	0x0802361c
 8016800:	08021a64 	.word	0x08021a64
 8016804:	08021b34 	.word	0x08021b34
 8016808:	08021b44 	.word	0x08021b44

0801680c <nk_popup_end>:
NK_API void
nk_popup_end(struct nk_context *ctx)
{
 801680c:	b5b0      	push	{r4, r5, r7, lr}
 801680e:	b086      	sub	sp, #24
 8016810:	af00      	add	r7, sp, #0
 8016812:	6078      	str	r0, [r7, #4]
    struct nk_window *win;
    struct nk_window *popup;

    NK_ASSERT(ctx);
 8016814:	687b      	ldr	r3, [r7, #4]
 8016816:	2b00      	cmp	r3, #0
 8016818:	d105      	bne.n	8016826 <nk_popup_end+0x1a>
 801681a:	4b5a      	ldr	r3, [pc, #360]	; (8016984 <nk_popup_end+0x178>)
 801681c:	4a5a      	ldr	r2, [pc, #360]	; (8016988 <nk_popup_end+0x17c>)
 801681e:	21ce      	movs	r1, #206	; 0xce
 8016820:	485a      	ldr	r0, [pc, #360]	; (801698c <nk_popup_end+0x180>)
 8016822:	f007 f8f9 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 8016826:	687b      	ldr	r3, [r7, #4]
 8016828:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801682c:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8016830:	2b00      	cmp	r3, #0
 8016832:	d105      	bne.n	8016840 <nk_popup_end+0x34>
 8016834:	4b56      	ldr	r3, [pc, #344]	; (8016990 <nk_popup_end+0x184>)
 8016836:	4a54      	ldr	r2, [pc, #336]	; (8016988 <nk_popup_end+0x17c>)
 8016838:	21cf      	movs	r1, #207	; 0xcf
 801683a:	4854      	ldr	r0, [pc, #336]	; (801698c <nk_popup_end+0x180>)
 801683c:	f007 f8ec 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 8016840:	687b      	ldr	r3, [r7, #4]
 8016842:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8016846:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801684a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801684e:	2b00      	cmp	r3, #0
 8016850:	d105      	bne.n	801685e <nk_popup_end+0x52>
 8016852:	4b50      	ldr	r3, [pc, #320]	; (8016994 <nk_popup_end+0x188>)
 8016854:	4a4c      	ldr	r2, [pc, #304]	; (8016988 <nk_popup_end+0x17c>)
 8016856:	21d0      	movs	r1, #208	; 0xd0
 8016858:	484c      	ldr	r0, [pc, #304]	; (801698c <nk_popup_end+0x180>)
 801685a:	f007 f8dd 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout)
 801685e:	687b      	ldr	r3, [r7, #4]
 8016860:	2b00      	cmp	r3, #0
 8016862:	f000 8089 	beq.w	8016978 <nk_popup_end+0x16c>
 8016866:	687b      	ldr	r3, [r7, #4]
 8016868:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801686c:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8016870:	2b00      	cmp	r3, #0
 8016872:	f000 8081 	beq.w	8016978 <nk_popup_end+0x16c>
 8016876:	687b      	ldr	r3, [r7, #4]
 8016878:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801687c:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8016880:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8016884:	2b00      	cmp	r3, #0
 8016886:	d077      	beq.n	8016978 <nk_popup_end+0x16c>
        return;

    popup = ctx->current;
 8016888:	687b      	ldr	r3, [r7, #4]
 801688a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801688e:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8016892:	613b      	str	r3, [r7, #16]
    if (!popup->parent) return;
 8016894:	693b      	ldr	r3, [r7, #16]
 8016896:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 801689a:	2b00      	cmp	r3, #0
 801689c:	d06e      	beq.n	801697c <nk_popup_end+0x170>
    win = popup->parent;
 801689e:	693b      	ldr	r3, [r7, #16]
 80168a0:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 80168a4:	60fb      	str	r3, [r7, #12]
    if (popup->flags & NK_WINDOW_HIDDEN) {
 80168a6:	693b      	ldr	r3, [r7, #16]
 80168a8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80168aa:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 80168ae:	2b00      	cmp	r3, #0
 80168b0:	d015      	beq.n	80168de <nk_popup_end+0xd2>
        struct nk_panel *root;
        root = win->layout;
 80168b2:	68fb      	ldr	r3, [r7, #12]
 80168b4:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80168b8:	617b      	str	r3, [r7, #20]
        while (root) {
 80168ba:	e009      	b.n	80168d0 <nk_popup_end+0xc4>
            root->flags |= NK_WINDOW_REMOVE_ROM;
 80168bc:	697b      	ldr	r3, [r7, #20]
 80168be:	685b      	ldr	r3, [r3, #4]
 80168c0:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 80168c4:	697b      	ldr	r3, [r7, #20]
 80168c6:	605a      	str	r2, [r3, #4]
            root = root->parent;
 80168c8:	697b      	ldr	r3, [r7, #20]
 80168ca:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 80168ce:	617b      	str	r3, [r7, #20]
        while (root) {
 80168d0:	697b      	ldr	r3, [r7, #20]
 80168d2:	2b00      	cmp	r3, #0
 80168d4:	d1f2      	bne.n	80168bc <nk_popup_end+0xb0>
        }
        win->popup.active = 0;
 80168d6:	68fb      	ldr	r3, [r7, #12]
 80168d8:	2200      	movs	r2, #0
 80168da:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
    }
    nk_push_scissor(&popup->buffer, nk_null_rect);
 80168de:	693b      	ldr	r3, [r7, #16]
 80168e0:	f103 0264 	add.w	r2, r3, #100	; 0x64
 80168e4:	4b2c      	ldr	r3, [pc, #176]	; (8016998 <nk_popup_end+0x18c>)
 80168e6:	ed93 6a00 	vldr	s12, [r3]
 80168ea:	edd3 6a01 	vldr	s13, [r3, #4]
 80168ee:	ed93 7a02 	vldr	s14, [r3, #8]
 80168f2:	edd3 7a03 	vldr	s15, [r3, #12]
 80168f6:	eeb0 0a46 	vmov.f32	s0, s12
 80168fa:	eef0 0a66 	vmov.f32	s1, s13
 80168fe:	eeb0 1a47 	vmov.f32	s2, s14
 8016902:	eef0 1a67 	vmov.f32	s3, s15
 8016906:	4610      	mov	r0, r2
 8016908:	f7fa f848 	bl	801099c <nk_push_scissor>
    nk_end(ctx);
 801690c:	6878      	ldr	r0, [r7, #4]
 801690e:	f006 fe5d 	bl	801d5cc <nk_end>

    win->buffer = popup->buffer;
 8016912:	68fa      	ldr	r2, [r7, #12]
 8016914:	693b      	ldr	r3, [r7, #16]
 8016916:	f102 0464 	add.w	r4, r2, #100	; 0x64
 801691a:	f103 0564 	add.w	r5, r3, #100	; 0x64
 801691e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8016920:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8016922:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8016924:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8016926:	e895 0003 	ldmia.w	r5, {r0, r1}
 801692a:	e884 0003 	stmia.w	r4, {r0, r1}
    nk_finish_popup(ctx, win);
 801692e:	68f9      	ldr	r1, [r7, #12]
 8016930:	6878      	ldr	r0, [r7, #4]
 8016932:	f7f9 fae5 	bl	800ff00 <nk_finish_popup>
    ctx->current = win;
 8016936:	687b      	ldr	r3, [r7, #4]
 8016938:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801693c:	461a      	mov	r2, r3
 801693e:	68fb      	ldr	r3, [r7, #12]
 8016940:	f8c2 3658 	str.w	r3, [r2, #1624]	; 0x658
    nk_push_scissor(&win->buffer, win->layout->clip);
 8016944:	68fb      	ldr	r3, [r7, #12]
 8016946:	f103 0264 	add.w	r2, r3, #100	; 0x64
 801694a:	68fb      	ldr	r3, [r7, #12]
 801694c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8016950:	ed93 6a0f 	vldr	s12, [r3, #60]	; 0x3c
 8016954:	edd3 6a10 	vldr	s13, [r3, #64]	; 0x40
 8016958:	ed93 7a11 	vldr	s14, [r3, #68]	; 0x44
 801695c:	edd3 7a12 	vldr	s15, [r3, #72]	; 0x48
 8016960:	eeb0 0a46 	vmov.f32	s0, s12
 8016964:	eef0 0a66 	vmov.f32	s1, s13
 8016968:	eeb0 1a47 	vmov.f32	s2, s14
 801696c:	eef0 1a67 	vmov.f32	s3, s15
 8016970:	4610      	mov	r0, r2
 8016972:	f7fa f813 	bl	801099c <nk_push_scissor>
 8016976:	e002      	b.n	801697e <nk_popup_end+0x172>
        return;
 8016978:	bf00      	nop
 801697a:	e000      	b.n	801697e <nk_popup_end+0x172>
    if (!popup->parent) return;
 801697c:	bf00      	nop
}
 801697e:	3718      	adds	r7, #24
 8016980:	46bd      	mov	sp, r7
 8016982:	bdb0      	pop	{r4, r5, r7, pc}
 8016984:	08021a60 	.word	0x08021a60
 8016988:	0802362c 	.word	0x0802362c
 801698c:	08021a64 	.word	0x08021a64
 8016990:	08021a88 	.word	0x08021a88
 8016994:	08021a98 	.word	0x08021a98
 8016998:	080235f8 	.word	0x080235f8

0801699c <nk_scrollbar_behavior>:
nk_scrollbar_behavior(nk_flags *state, struct nk_input *in,
    int has_scrolling, const struct nk_rect *scroll,
    const struct nk_rect *cursor, const struct nk_rect *empty0,
    const struct nk_rect *empty1, float scroll_offset,
    float target, float scroll_step, enum nk_orientation o)
{
 801699c:	b580      	push	{r7, lr}
 801699e:	b092      	sub	sp, #72	; 0x48
 80169a0:	af00      	add	r7, sp, #0
 80169a2:	61f8      	str	r0, [r7, #28]
 80169a4:	61b9      	str	r1, [r7, #24]
 80169a6:	617a      	str	r2, [r7, #20]
 80169a8:	613b      	str	r3, [r7, #16]
 80169aa:	ed87 0a03 	vstr	s0, [r7, #12]
 80169ae:	edc7 0a02 	vstr	s1, [r7, #8]
 80169b2:	ed87 1a01 	vstr	s2, [r7, #4]
    nk_flags ws = 0;
 80169b6:	2300      	movs	r3, #0
 80169b8:	627b      	str	r3, [r7, #36]	; 0x24
    int left_mouse_down;
    unsigned int left_mouse_clicked;
    int left_mouse_click_in_cursor;
    float scroll_delta;

    nk_widget_state_reset(state);
 80169ba:	69fb      	ldr	r3, [r7, #28]
 80169bc:	681b      	ldr	r3, [r3, #0]
 80169be:	f003 0302 	and.w	r3, r3, #2
 80169c2:	2b00      	cmp	r3, #0
 80169c4:	d003      	beq.n	80169ce <nk_scrollbar_behavior+0x32>
 80169c6:	69fb      	ldr	r3, [r7, #28]
 80169c8:	2206      	movs	r2, #6
 80169ca:	601a      	str	r2, [r3, #0]
 80169cc:	e002      	b.n	80169d4 <nk_scrollbar_behavior+0x38>
 80169ce:	69fb      	ldr	r3, [r7, #28]
 80169d0:	2204      	movs	r2, #4
 80169d2:	601a      	str	r2, [r3, #0]
    if (!in) return scroll_offset;
 80169d4:	69bb      	ldr	r3, [r7, #24]
 80169d6:	2b00      	cmp	r3, #0
 80169d8:	d101      	bne.n	80169de <nk_scrollbar_behavior+0x42>
 80169da:	68fb      	ldr	r3, [r7, #12]
 80169dc:	e35c      	b.n	8017098 <nk_scrollbar_behavior+0x6fc>

    left_mouse_down = in->mouse.buttons[NK_BUTTON_LEFT].down;
 80169de:	69bb      	ldr	r3, [r7, #24]
 80169e0:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 80169e4:	647b      	str	r3, [r7, #68]	; 0x44
    left_mouse_clicked = in->mouse.buttons[NK_BUTTON_LEFT].clicked;
 80169e6:	69bb      	ldr	r3, [r7, #24]
 80169e8:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 80169ec:	643b      	str	r3, [r7, #64]	; 0x40
    left_mouse_click_in_cursor = nk_input_has_mouse_click_down_in_rect(in,
 80169ee:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80169f0:	ed93 6a00 	vldr	s12, [r3]
 80169f4:	edd3 6a01 	vldr	s13, [r3, #4]
 80169f8:	ed93 7a02 	vldr	s14, [r3, #8]
 80169fc:	edd3 7a03 	vldr	s15, [r3, #12]
 8016a00:	2201      	movs	r2, #1
 8016a02:	eeb0 0a46 	vmov.f32	s0, s12
 8016a06:	eef0 0a66 	vmov.f32	s1, s13
 8016a0a:	eeb0 1a47 	vmov.f32	s2, s14
 8016a0e:	eef0 1a67 	vmov.f32	s3, s15
 8016a12:	2100      	movs	r1, #0
 8016a14:	69b8      	ldr	r0, [r7, #24]
 8016a16:	f7fb fd3b 	bl	8012490 <nk_input_has_mouse_click_down_in_rect>
 8016a1a:	63f8      	str	r0, [r7, #60]	; 0x3c
        NK_BUTTON_LEFT, *cursor, nk_true);
    if (nk_input_is_mouse_hovering_rect(in, *scroll))
 8016a1c:	693b      	ldr	r3, [r7, #16]
 8016a1e:	ed93 6a00 	vldr	s12, [r3]
 8016a22:	edd3 6a01 	vldr	s13, [r3, #4]
 8016a26:	ed93 7a02 	vldr	s14, [r3, #8]
 8016a2a:	edd3 7a03 	vldr	s15, [r3, #12]
 8016a2e:	eeb0 0a46 	vmov.f32	s0, s12
 8016a32:	eef0 0a66 	vmov.f32	s1, s13
 8016a36:	eeb0 1a47 	vmov.f32	s2, s14
 8016a3a:	eef0 1a67 	vmov.f32	s3, s15
 8016a3e:	69b8      	ldr	r0, [r7, #24]
 8016a40:	f7fb fd6d 	bl	801251e <nk_input_is_mouse_hovering_rect>
 8016a44:	4603      	mov	r3, r0
 8016a46:	2b00      	cmp	r3, #0
 8016a48:	d002      	beq.n	8016a50 <nk_scrollbar_behavior+0xb4>
        *state = NK_WIDGET_STATE_HOVERED;
 8016a4a:	69fb      	ldr	r3, [r7, #28]
 8016a4c:	2212      	movs	r2, #18
 8016a4e:	601a      	str	r2, [r3, #0]

    scroll_delta = (o == NK_VERTICAL) ? in->mouse.scroll_delta.y: in->mouse.scroll_delta.x;
 8016a50:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 8016a54:	2b00      	cmp	r3, #0
 8016a56:	d103      	bne.n	8016a60 <nk_scrollbar_behavior+0xc4>
 8016a58:	69bb      	ldr	r3, [r7, #24]
 8016a5a:	f8d3 3160 	ldr.w	r3, [r3, #352]	; 0x160
 8016a5e:	e002      	b.n	8016a66 <nk_scrollbar_behavior+0xca>
 8016a60:	69bb      	ldr	r3, [r7, #24]
 8016a62:	f8d3 315c 	ldr.w	r3, [r3, #348]	; 0x15c
 8016a66:	63bb      	str	r3, [r7, #56]	; 0x38
    if (left_mouse_down && left_mouse_click_in_cursor && !left_mouse_clicked) {
 8016a68:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016a6a:	2b00      	cmp	r3, #0
 8016a6c:	f000 8122 	beq.w	8016cb4 <nk_scrollbar_behavior+0x318>
 8016a70:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016a72:	2b00      	cmp	r3, #0
 8016a74:	f000 811e 	beq.w	8016cb4 <nk_scrollbar_behavior+0x318>
 8016a78:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016a7a:	2b00      	cmp	r3, #0
 8016a7c:	f040 811a 	bne.w	8016cb4 <nk_scrollbar_behavior+0x318>
        /* update cursor by mouse dragging */
        float pixel, delta;
        *state = NK_WIDGET_STATE_ACTIVE;
 8016a80:	69fb      	ldr	r3, [r7, #28]
 8016a82:	2222      	movs	r2, #34	; 0x22
 8016a84:	601a      	str	r2, [r3, #0]
        if (o == NK_VERTICAL) {
 8016a86:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 8016a8a:	2b00      	cmp	r3, #0
 8016a8c:	f040 8089 	bne.w	8016ba2 <nk_scrollbar_behavior+0x206>
            float cursor_y;
            pixel = in->mouse.delta.y;
 8016a90:	69bb      	ldr	r3, [r7, #24]
 8016a92:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
 8016a96:	637b      	str	r3, [r7, #52]	; 0x34
            delta = (pixel / scroll->h) * target;
 8016a98:	693b      	ldr	r3, [r7, #16]
 8016a9a:	ed93 7a03 	vldr	s14, [r3, #12]
 8016a9e:	edd7 6a0d 	vldr	s13, [r7, #52]	; 0x34
 8016aa2:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8016aa6:	ed97 7a02 	vldr	s14, [r7, #8]
 8016aaa:	ee67 7a27 	vmul.f32	s15, s14, s15
 8016aae:	edc7 7a0c 	vstr	s15, [r7, #48]	; 0x30
            scroll_offset = NK_CLAMP(0, scroll_offset + delta, target - scroll->h);
 8016ab2:	ed97 7a03 	vldr	s14, [r7, #12]
 8016ab6:	edd7 7a0c 	vldr	s15, [r7, #48]	; 0x30
 8016aba:	ee37 7a27 	vadd.f32	s14, s14, s15
 8016abe:	693b      	ldr	r3, [r7, #16]
 8016ac0:	edd3 7a03 	vldr	s15, [r3, #12]
 8016ac4:	edd7 6a02 	vldr	s13, [r7, #8]
 8016ac8:	ee76 7ae7 	vsub.f32	s15, s13, s15
 8016acc:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8016ad0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016ad4:	d50e      	bpl.n	8016af4 <nk_scrollbar_behavior+0x158>
 8016ad6:	ed97 7a03 	vldr	s14, [r7, #12]
 8016ada:	edd7 7a0c 	vldr	s15, [r7, #48]	; 0x30
 8016ade:	ee77 7a27 	vadd.f32	s15, s14, s15
 8016ae2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016ae6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016aea:	bf4c      	ite	mi
 8016aec:	2301      	movmi	r3, #1
 8016aee:	2300      	movpl	r3, #0
 8016af0:	b2db      	uxtb	r3, r3
 8016af2:	e00e      	b.n	8016b12 <nk_scrollbar_behavior+0x176>
 8016af4:	693b      	ldr	r3, [r7, #16]
 8016af6:	edd3 7a03 	vldr	s15, [r3, #12]
 8016afa:	ed97 7a02 	vldr	s14, [r7, #8]
 8016afe:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016b02:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016b06:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b0a:	bf4c      	ite	mi
 8016b0c:	2301      	movmi	r3, #1
 8016b0e:	2300      	movpl	r3, #0
 8016b10:	b2db      	uxtb	r3, r3
 8016b12:	2b00      	cmp	r3, #0
 8016b14:	d002      	beq.n	8016b1c <nk_scrollbar_behavior+0x180>
 8016b16:	eddf 7acd 	vldr	s15, [pc, #820]	; 8016e4c <nk_scrollbar_behavior+0x4b0>
 8016b1a:	e01f      	b.n	8016b5c <nk_scrollbar_behavior+0x1c0>
 8016b1c:	ed97 7a03 	vldr	s14, [r7, #12]
 8016b20:	edd7 7a0c 	vldr	s15, [r7, #48]	; 0x30
 8016b24:	ee37 7a27 	vadd.f32	s14, s14, s15
 8016b28:	693b      	ldr	r3, [r7, #16]
 8016b2a:	edd3 7a03 	vldr	s15, [r3, #12]
 8016b2e:	edd7 6a02 	vldr	s13, [r7, #8]
 8016b32:	ee76 7ae7 	vsub.f32	s15, s13, s15
 8016b36:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8016b3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b3e:	d506      	bpl.n	8016b4e <nk_scrollbar_behavior+0x1b2>
 8016b40:	ed97 7a03 	vldr	s14, [r7, #12]
 8016b44:	edd7 7a0c 	vldr	s15, [r7, #48]	; 0x30
 8016b48:	ee77 7a27 	vadd.f32	s15, s14, s15
 8016b4c:	e006      	b.n	8016b5c <nk_scrollbar_behavior+0x1c0>
 8016b4e:	693b      	ldr	r3, [r7, #16]
 8016b50:	edd3 7a03 	vldr	s15, [r3, #12]
 8016b54:	ed97 7a02 	vldr	s14, [r7, #8]
 8016b58:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016b5c:	edc7 7a03 	vstr	s15, [r7, #12]
            cursor_y = scroll->y + ((scroll_offset/target) * scroll->h);
 8016b60:	693b      	ldr	r3, [r7, #16]
 8016b62:	ed93 7a01 	vldr	s14, [r3, #4]
 8016b66:	ed97 6a03 	vldr	s12, [r7, #12]
 8016b6a:	edd7 7a02 	vldr	s15, [r7, #8]
 8016b6e:	eec6 6a27 	vdiv.f32	s13, s12, s15
 8016b72:	693b      	ldr	r3, [r7, #16]
 8016b74:	edd3 7a03 	vldr	s15, [r3, #12]
 8016b78:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8016b7c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8016b80:	edc7 7a0a 	vstr	s15, [r7, #40]	; 0x28
            in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.y = cursor_y + cursor->h/2.0f;
 8016b84:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016b86:	edd3 7a03 	vldr	s15, [r3, #12]
 8016b8a:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
 8016b8e:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8016b92:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
 8016b96:	ee77 7a27 	vadd.f32	s15, s14, s15
 8016b9a:	69bb      	ldr	r3, [r7, #24]
 8016b9c:	edc3 7a44 	vstr	s15, [r3, #272]	; 0x110
    if (left_mouse_down && left_mouse_click_in_cursor && !left_mouse_clicked) {
 8016ba0:	e238      	b.n	8017014 <nk_scrollbar_behavior+0x678>
        } else {
            float cursor_x;
            pixel = in->mouse.delta.x;
 8016ba2:	69bb      	ldr	r3, [r7, #24]
 8016ba4:	f8d3 3154 	ldr.w	r3, [r3, #340]	; 0x154
 8016ba8:	637b      	str	r3, [r7, #52]	; 0x34
            delta = (pixel / scroll->w) * target;
 8016baa:	693b      	ldr	r3, [r7, #16]
 8016bac:	ed93 7a02 	vldr	s14, [r3, #8]
 8016bb0:	edd7 6a0d 	vldr	s13, [r7, #52]	; 0x34
 8016bb4:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8016bb8:	ed97 7a02 	vldr	s14, [r7, #8]
 8016bbc:	ee67 7a27 	vmul.f32	s15, s14, s15
 8016bc0:	edc7 7a0c 	vstr	s15, [r7, #48]	; 0x30
            scroll_offset = NK_CLAMP(0, scroll_offset + delta, target - scroll->w);
 8016bc4:	ed97 7a03 	vldr	s14, [r7, #12]
 8016bc8:	edd7 7a0c 	vldr	s15, [r7, #48]	; 0x30
 8016bcc:	ee37 7a27 	vadd.f32	s14, s14, s15
 8016bd0:	693b      	ldr	r3, [r7, #16]
 8016bd2:	edd3 7a02 	vldr	s15, [r3, #8]
 8016bd6:	edd7 6a02 	vldr	s13, [r7, #8]
 8016bda:	ee76 7ae7 	vsub.f32	s15, s13, s15
 8016bde:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8016be2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016be6:	d50e      	bpl.n	8016c06 <nk_scrollbar_behavior+0x26a>
 8016be8:	ed97 7a03 	vldr	s14, [r7, #12]
 8016bec:	edd7 7a0c 	vldr	s15, [r7, #48]	; 0x30
 8016bf0:	ee77 7a27 	vadd.f32	s15, s14, s15
 8016bf4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016bf8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016bfc:	bf4c      	ite	mi
 8016bfe:	2301      	movmi	r3, #1
 8016c00:	2300      	movpl	r3, #0
 8016c02:	b2db      	uxtb	r3, r3
 8016c04:	e00e      	b.n	8016c24 <nk_scrollbar_behavior+0x288>
 8016c06:	693b      	ldr	r3, [r7, #16]
 8016c08:	edd3 7a02 	vldr	s15, [r3, #8]
 8016c0c:	ed97 7a02 	vldr	s14, [r7, #8]
 8016c10:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016c14:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016c18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016c1c:	bf4c      	ite	mi
 8016c1e:	2301      	movmi	r3, #1
 8016c20:	2300      	movpl	r3, #0
 8016c22:	b2db      	uxtb	r3, r3
 8016c24:	2b00      	cmp	r3, #0
 8016c26:	d002      	beq.n	8016c2e <nk_scrollbar_behavior+0x292>
 8016c28:	eddf 7a88 	vldr	s15, [pc, #544]	; 8016e4c <nk_scrollbar_behavior+0x4b0>
 8016c2c:	e01f      	b.n	8016c6e <nk_scrollbar_behavior+0x2d2>
 8016c2e:	ed97 7a03 	vldr	s14, [r7, #12]
 8016c32:	edd7 7a0c 	vldr	s15, [r7, #48]	; 0x30
 8016c36:	ee37 7a27 	vadd.f32	s14, s14, s15
 8016c3a:	693b      	ldr	r3, [r7, #16]
 8016c3c:	edd3 7a02 	vldr	s15, [r3, #8]
 8016c40:	edd7 6a02 	vldr	s13, [r7, #8]
 8016c44:	ee76 7ae7 	vsub.f32	s15, s13, s15
 8016c48:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8016c4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016c50:	d506      	bpl.n	8016c60 <nk_scrollbar_behavior+0x2c4>
 8016c52:	ed97 7a03 	vldr	s14, [r7, #12]
 8016c56:	edd7 7a0c 	vldr	s15, [r7, #48]	; 0x30
 8016c5a:	ee77 7a27 	vadd.f32	s15, s14, s15
 8016c5e:	e006      	b.n	8016c6e <nk_scrollbar_behavior+0x2d2>
 8016c60:	693b      	ldr	r3, [r7, #16]
 8016c62:	edd3 7a02 	vldr	s15, [r3, #8]
 8016c66:	ed97 7a02 	vldr	s14, [r7, #8]
 8016c6a:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016c6e:	edc7 7a03 	vstr	s15, [r7, #12]
            cursor_x = scroll->x + ((scroll_offset/target) * scroll->w);
 8016c72:	693b      	ldr	r3, [r7, #16]
 8016c74:	ed93 7a00 	vldr	s14, [r3]
 8016c78:	ed97 6a03 	vldr	s12, [r7, #12]
 8016c7c:	edd7 7a02 	vldr	s15, [r7, #8]
 8016c80:	eec6 6a27 	vdiv.f32	s13, s12, s15
 8016c84:	693b      	ldr	r3, [r7, #16]
 8016c86:	edd3 7a02 	vldr	s15, [r3, #8]
 8016c8a:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8016c8e:	ee77 7a27 	vadd.f32	s15, s14, s15
 8016c92:	edc7 7a0b 	vstr	s15, [r7, #44]	; 0x2c
            in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x = cursor_x + cursor->w/2.0f;
 8016c96:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016c98:	edd3 7a02 	vldr	s15, [r3, #8]
 8016c9c:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
 8016ca0:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8016ca4:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
 8016ca8:	ee77 7a27 	vadd.f32	s15, s14, s15
 8016cac:	69bb      	ldr	r3, [r7, #24]
 8016cae:	edc3 7a43 	vstr	s15, [r3, #268]	; 0x10c
    if (left_mouse_down && left_mouse_click_in_cursor && !left_mouse_clicked) {
 8016cb2:	e1af      	b.n	8017014 <nk_scrollbar_behavior+0x678>
        }
    } else if ((nk_input_is_key_pressed(in, NK_KEY_SCROLL_UP) && o == NK_VERTICAL && has_scrolling)||
 8016cb4:	211d      	movs	r1, #29
 8016cb6:	69b8      	ldr	r0, [r7, #24]
 8016cb8:	f7fb fd10 	bl	80126dc <nk_input_is_key_pressed>
 8016cbc:	4603      	mov	r3, r0
 8016cbe:	2b00      	cmp	r3, #0
 8016cc0:	d006      	beq.n	8016cd0 <nk_scrollbar_behavior+0x334>
 8016cc2:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 8016cc6:	2b00      	cmp	r3, #0
 8016cc8:	d102      	bne.n	8016cd0 <nk_scrollbar_behavior+0x334>
 8016cca:	697b      	ldr	r3, [r7, #20]
 8016ccc:	2b00      	cmp	r3, #0
 8016cce:	d11a      	bne.n	8016d06 <nk_scrollbar_behavior+0x36a>
            nk_button_behavior(&ws, *empty0, in, NK_BUTTON_DEFAULT)) {
 8016cd0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016cd2:	ed93 6a00 	vldr	s12, [r3]
 8016cd6:	edd3 6a01 	vldr	s13, [r3, #4]
 8016cda:	ed93 7a02 	vldr	s14, [r3, #8]
 8016cde:	edd3 7a03 	vldr	s15, [r3, #12]
 8016ce2:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8016ce6:	2200      	movs	r2, #0
 8016ce8:	69b9      	ldr	r1, [r7, #24]
 8016cea:	eeb0 0a46 	vmov.f32	s0, s12
 8016cee:	eef0 0a66 	vmov.f32	s1, s13
 8016cf2:	eeb0 1a47 	vmov.f32	s2, s14
 8016cf6:	eef0 1a67 	vmov.f32	s3, s15
 8016cfa:	4618      	mov	r0, r3
 8016cfc:	f7f7 faa8 	bl	800e250 <nk_button_behavior>
 8016d00:	4603      	mov	r3, r0
    } else if ((nk_input_is_key_pressed(in, NK_KEY_SCROLL_UP) && o == NK_VERTICAL && has_scrolling)||
 8016d02:	2b00      	cmp	r3, #0
 8016d04:	d035      	beq.n	8016d72 <nk_scrollbar_behavior+0x3d6>
        /* scroll page up by click on empty space or shortcut */
        if (o == NK_VERTICAL)
 8016d06:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 8016d0a:	2b00      	cmp	r3, #0
 8016d0c:	d118      	bne.n	8016d40 <nk_scrollbar_behavior+0x3a4>
            scroll_offset = NK_MAX(0, scroll_offset - scroll->h);
 8016d0e:	693b      	ldr	r3, [r7, #16]
 8016d10:	edd3 7a03 	vldr	s15, [r3, #12]
 8016d14:	ed97 7a03 	vldr	s14, [r7, #12]
 8016d18:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016d1c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016d20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016d24:	dd07      	ble.n	8016d36 <nk_scrollbar_behavior+0x39a>
 8016d26:	693b      	ldr	r3, [r7, #16]
 8016d28:	edd3 7a03 	vldr	s15, [r3, #12]
 8016d2c:	ed97 7a03 	vldr	s14, [r7, #12]
 8016d30:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016d34:	e001      	b.n	8016d3a <nk_scrollbar_behavior+0x39e>
 8016d36:	eddf 7a45 	vldr	s15, [pc, #276]	; 8016e4c <nk_scrollbar_behavior+0x4b0>
 8016d3a:	edc7 7a03 	vstr	s15, [r7, #12]
        if (o == NK_VERTICAL)
 8016d3e:	e169      	b.n	8017014 <nk_scrollbar_behavior+0x678>
        else scroll_offset = NK_MAX(0, scroll_offset - scroll->w);
 8016d40:	693b      	ldr	r3, [r7, #16]
 8016d42:	edd3 7a02 	vldr	s15, [r3, #8]
 8016d46:	ed97 7a03 	vldr	s14, [r7, #12]
 8016d4a:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016d4e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016d52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016d56:	dd07      	ble.n	8016d68 <nk_scrollbar_behavior+0x3cc>
 8016d58:	693b      	ldr	r3, [r7, #16]
 8016d5a:	edd3 7a02 	vldr	s15, [r3, #8]
 8016d5e:	ed97 7a03 	vldr	s14, [r7, #12]
 8016d62:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016d66:	e001      	b.n	8016d6c <nk_scrollbar_behavior+0x3d0>
 8016d68:	eddf 7a38 	vldr	s15, [pc, #224]	; 8016e4c <nk_scrollbar_behavior+0x4b0>
 8016d6c:	edc7 7a03 	vstr	s15, [r7, #12]
        if (o == NK_VERTICAL)
 8016d70:	e150      	b.n	8017014 <nk_scrollbar_behavior+0x678>
    } else if ((nk_input_is_key_pressed(in, NK_KEY_SCROLL_DOWN) && o == NK_VERTICAL && has_scrolling) ||
 8016d72:	211c      	movs	r1, #28
 8016d74:	69b8      	ldr	r0, [r7, #24]
 8016d76:	f7fb fcb1 	bl	80126dc <nk_input_is_key_pressed>
 8016d7a:	4603      	mov	r3, r0
 8016d7c:	2b00      	cmp	r3, #0
 8016d7e:	d006      	beq.n	8016d8e <nk_scrollbar_behavior+0x3f2>
 8016d80:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 8016d84:	2b00      	cmp	r3, #0
 8016d86:	d102      	bne.n	8016d8e <nk_scrollbar_behavior+0x3f2>
 8016d88:	697b      	ldr	r3, [r7, #20]
 8016d8a:	2b00      	cmp	r3, #0
 8016d8c:	d11a      	bne.n	8016dc4 <nk_scrollbar_behavior+0x428>
        nk_button_behavior(&ws, *empty1, in, NK_BUTTON_DEFAULT)) {
 8016d8e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016d90:	ed93 6a00 	vldr	s12, [r3]
 8016d94:	edd3 6a01 	vldr	s13, [r3, #4]
 8016d98:	ed93 7a02 	vldr	s14, [r3, #8]
 8016d9c:	edd3 7a03 	vldr	s15, [r3, #12]
 8016da0:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8016da4:	2200      	movs	r2, #0
 8016da6:	69b9      	ldr	r1, [r7, #24]
 8016da8:	eeb0 0a46 	vmov.f32	s0, s12
 8016dac:	eef0 0a66 	vmov.f32	s1, s13
 8016db0:	eeb0 1a47 	vmov.f32	s2, s14
 8016db4:	eef0 1a67 	vmov.f32	s3, s15
 8016db8:	4618      	mov	r0, r3
 8016dba:	f7f7 fa49 	bl	800e250 <nk_button_behavior>
 8016dbe:	4603      	mov	r3, r0
    } else if ((nk_input_is_key_pressed(in, NK_KEY_SCROLL_DOWN) && o == NK_VERTICAL && has_scrolling) ||
 8016dc0:	2b00      	cmp	r3, #0
 8016dc2:	d04f      	beq.n	8016e64 <nk_scrollbar_behavior+0x4c8>
        /* scroll page down by click on empty space or shortcut */
        if (o == NK_VERTICAL)
 8016dc4:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 8016dc8:	2b00      	cmp	r3, #0
 8016dca:	d124      	bne.n	8016e16 <nk_scrollbar_behavior+0x47a>
            scroll_offset = NK_MIN(scroll_offset + scroll->h, target - scroll->h);
 8016dcc:	693b      	ldr	r3, [r7, #16]
 8016dce:	ed93 7a03 	vldr	s14, [r3, #12]
 8016dd2:	edd7 7a03 	vldr	s15, [r7, #12]
 8016dd6:	ee37 7a27 	vadd.f32	s14, s14, s15
 8016dda:	693b      	ldr	r3, [r7, #16]
 8016ddc:	edd3 7a03 	vldr	s15, [r3, #12]
 8016de0:	edd7 6a02 	vldr	s13, [r7, #8]
 8016de4:	ee76 7ae7 	vsub.f32	s15, s13, s15
 8016de8:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8016dec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016df0:	d507      	bpl.n	8016e02 <nk_scrollbar_behavior+0x466>
 8016df2:	693b      	ldr	r3, [r7, #16]
 8016df4:	ed93 7a03 	vldr	s14, [r3, #12]
 8016df8:	edd7 7a03 	vldr	s15, [r7, #12]
 8016dfc:	ee77 7a27 	vadd.f32	s15, s14, s15
 8016e00:	e006      	b.n	8016e10 <nk_scrollbar_behavior+0x474>
 8016e02:	693b      	ldr	r3, [r7, #16]
 8016e04:	edd3 7a03 	vldr	s15, [r3, #12]
 8016e08:	ed97 7a02 	vldr	s14, [r7, #8]
 8016e0c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016e10:	edc7 7a03 	vstr	s15, [r7, #12]
        if (o == NK_VERTICAL)
 8016e14:	e0fe      	b.n	8017014 <nk_scrollbar_behavior+0x678>
        else scroll_offset = NK_MIN(scroll_offset + scroll->w, target - scroll->w);
 8016e16:	693b      	ldr	r3, [r7, #16]
 8016e18:	ed93 7a02 	vldr	s14, [r3, #8]
 8016e1c:	edd7 7a03 	vldr	s15, [r7, #12]
 8016e20:	ee37 7a27 	vadd.f32	s14, s14, s15
 8016e24:	693b      	ldr	r3, [r7, #16]
 8016e26:	edd3 7a02 	vldr	s15, [r3, #8]
 8016e2a:	edd7 6a02 	vldr	s13, [r7, #8]
 8016e2e:	ee76 7ae7 	vsub.f32	s15, s13, s15
 8016e32:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8016e36:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016e3a:	d509      	bpl.n	8016e50 <nk_scrollbar_behavior+0x4b4>
 8016e3c:	693b      	ldr	r3, [r7, #16]
 8016e3e:	ed93 7a02 	vldr	s14, [r3, #8]
 8016e42:	edd7 7a03 	vldr	s15, [r7, #12]
 8016e46:	ee77 7a27 	vadd.f32	s15, s14, s15
 8016e4a:	e008      	b.n	8016e5e <nk_scrollbar_behavior+0x4c2>
 8016e4c:	00000000 	.word	0x00000000
 8016e50:	693b      	ldr	r3, [r7, #16]
 8016e52:	edd3 7a02 	vldr	s15, [r3, #8]
 8016e56:	ed97 7a02 	vldr	s14, [r7, #8]
 8016e5a:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016e5e:	edc7 7a03 	vstr	s15, [r7, #12]
        if (o == NK_VERTICAL)
 8016e62:	e0d7      	b.n	8017014 <nk_scrollbar_behavior+0x678>
    } else if (has_scrolling) {
 8016e64:	697b      	ldr	r3, [r7, #20]
 8016e66:	2b00      	cmp	r3, #0
 8016e68:	f000 80d4 	beq.w	8017014 <nk_scrollbar_behavior+0x678>
        if ((scroll_delta < 0 || (scroll_delta > 0))) {
 8016e6c:	edd7 7a0e 	vldr	s15, [r7, #56]	; 0x38
 8016e70:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016e74:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016e78:	d407      	bmi.n	8016e8a <nk_scrollbar_behavior+0x4ee>
 8016e7a:	edd7 7a0e 	vldr	s15, [r7, #56]	; 0x38
 8016e7e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016e82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016e86:	f340 80a2 	ble.w	8016fce <nk_scrollbar_behavior+0x632>
            /* update cursor by mouse scrolling */
            scroll_offset = scroll_offset + scroll_step * (-scroll_delta);
 8016e8a:	edd7 7a0e 	vldr	s15, [r7, #56]	; 0x38
 8016e8e:	eeb1 7a67 	vneg.f32	s14, s15
 8016e92:	edd7 7a01 	vldr	s15, [r7, #4]
 8016e96:	ee67 7a27 	vmul.f32	s15, s14, s15
 8016e9a:	ed97 7a03 	vldr	s14, [r7, #12]
 8016e9e:	ee77 7a27 	vadd.f32	s15, s14, s15
 8016ea2:	edc7 7a03 	vstr	s15, [r7, #12]
            if (o == NK_VERTICAL)
 8016ea6:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 8016eaa:	2b00      	cmp	r3, #0
 8016eac:	d147      	bne.n	8016f3e <nk_scrollbar_behavior+0x5a2>
                scroll_offset = NK_CLAMP(0, scroll_offset, target - scroll->h);
 8016eae:	693b      	ldr	r3, [r7, #16]
 8016eb0:	edd3 7a03 	vldr	s15, [r3, #12]
 8016eb4:	ed97 7a02 	vldr	s14, [r7, #8]
 8016eb8:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016ebc:	ed97 7a03 	vldr	s14, [r7, #12]
 8016ec0:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8016ec4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016ec8:	d50a      	bpl.n	8016ee0 <nk_scrollbar_behavior+0x544>
 8016eca:	edd7 7a03 	vldr	s15, [r7, #12]
 8016ece:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016ed2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016ed6:	bf4c      	ite	mi
 8016ed8:	2301      	movmi	r3, #1
 8016eda:	2300      	movpl	r3, #0
 8016edc:	b2db      	uxtb	r3, r3
 8016ede:	e00e      	b.n	8016efe <nk_scrollbar_behavior+0x562>
 8016ee0:	693b      	ldr	r3, [r7, #16]
 8016ee2:	edd3 7a03 	vldr	s15, [r3, #12]
 8016ee6:	ed97 7a02 	vldr	s14, [r7, #8]
 8016eea:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016eee:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016ef2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016ef6:	bf4c      	ite	mi
 8016ef8:	2301      	movmi	r3, #1
 8016efa:	2300      	movpl	r3, #0
 8016efc:	b2db      	uxtb	r3, r3
 8016efe:	2b00      	cmp	r3, #0
 8016f00:	d002      	beq.n	8016f08 <nk_scrollbar_behavior+0x56c>
 8016f02:	ed5f 7a2e 	vldr	s15, [pc, #-184]	; 8016e4c <nk_scrollbar_behavior+0x4b0>
 8016f06:	e017      	b.n	8016f38 <nk_scrollbar_behavior+0x59c>
 8016f08:	693b      	ldr	r3, [r7, #16]
 8016f0a:	edd3 7a03 	vldr	s15, [r3, #12]
 8016f0e:	ed97 7a02 	vldr	s14, [r7, #8]
 8016f12:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016f16:	ed97 7a03 	vldr	s14, [r7, #12]
 8016f1a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8016f1e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016f22:	d502      	bpl.n	8016f2a <nk_scrollbar_behavior+0x58e>
 8016f24:	edd7 7a03 	vldr	s15, [r7, #12]
 8016f28:	e006      	b.n	8016f38 <nk_scrollbar_behavior+0x59c>
 8016f2a:	693b      	ldr	r3, [r7, #16]
 8016f2c:	edd3 7a03 	vldr	s15, [r3, #12]
 8016f30:	ed97 7a02 	vldr	s14, [r7, #8]
 8016f34:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016f38:	edc7 7a03 	vstr	s15, [r7, #12]
            if (o == NK_VERTICAL)
 8016f3c:	e06a      	b.n	8017014 <nk_scrollbar_behavior+0x678>
            else scroll_offset = NK_CLAMP(0, scroll_offset, target - scroll->w);
 8016f3e:	693b      	ldr	r3, [r7, #16]
 8016f40:	edd3 7a02 	vldr	s15, [r3, #8]
 8016f44:	ed97 7a02 	vldr	s14, [r7, #8]
 8016f48:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016f4c:	ed97 7a03 	vldr	s14, [r7, #12]
 8016f50:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8016f54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016f58:	d50a      	bpl.n	8016f70 <nk_scrollbar_behavior+0x5d4>
 8016f5a:	edd7 7a03 	vldr	s15, [r7, #12]
 8016f5e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016f62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016f66:	bf4c      	ite	mi
 8016f68:	2301      	movmi	r3, #1
 8016f6a:	2300      	movpl	r3, #0
 8016f6c:	b2db      	uxtb	r3, r3
 8016f6e:	e00e      	b.n	8016f8e <nk_scrollbar_behavior+0x5f2>
 8016f70:	693b      	ldr	r3, [r7, #16]
 8016f72:	edd3 7a02 	vldr	s15, [r3, #8]
 8016f76:	ed97 7a02 	vldr	s14, [r7, #8]
 8016f7a:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016f7e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016f82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016f86:	bf4c      	ite	mi
 8016f88:	2301      	movmi	r3, #1
 8016f8a:	2300      	movpl	r3, #0
 8016f8c:	b2db      	uxtb	r3, r3
 8016f8e:	2b00      	cmp	r3, #0
 8016f90:	d002      	beq.n	8016f98 <nk_scrollbar_behavior+0x5fc>
 8016f92:	ed5f 7a52 	vldr	s15, [pc, #-328]	; 8016e4c <nk_scrollbar_behavior+0x4b0>
 8016f96:	e017      	b.n	8016fc8 <nk_scrollbar_behavior+0x62c>
 8016f98:	693b      	ldr	r3, [r7, #16]
 8016f9a:	edd3 7a02 	vldr	s15, [r3, #8]
 8016f9e:	ed97 7a02 	vldr	s14, [r7, #8]
 8016fa2:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016fa6:	ed97 7a03 	vldr	s14, [r7, #12]
 8016faa:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8016fae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016fb2:	d502      	bpl.n	8016fba <nk_scrollbar_behavior+0x61e>
 8016fb4:	edd7 7a03 	vldr	s15, [r7, #12]
 8016fb8:	e006      	b.n	8016fc8 <nk_scrollbar_behavior+0x62c>
 8016fba:	693b      	ldr	r3, [r7, #16]
 8016fbc:	edd3 7a02 	vldr	s15, [r3, #8]
 8016fc0:	ed97 7a02 	vldr	s14, [r7, #8]
 8016fc4:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016fc8:	edc7 7a03 	vstr	s15, [r7, #12]
            if (o == NK_VERTICAL)
 8016fcc:	e022      	b.n	8017014 <nk_scrollbar_behavior+0x678>
        } else if (nk_input_is_key_pressed(in, NK_KEY_SCROLL_START)) {
 8016fce:	211a      	movs	r1, #26
 8016fd0:	69b8      	ldr	r0, [r7, #24]
 8016fd2:	f7fb fb83 	bl	80126dc <nk_input_is_key_pressed>
 8016fd6:	4603      	mov	r3, r0
 8016fd8:	2b00      	cmp	r3, #0
 8016fda:	d007      	beq.n	8016fec <nk_scrollbar_behavior+0x650>
            /* update cursor to the beginning  */
            if (o == NK_VERTICAL) scroll_offset = 0;
 8016fdc:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 8016fe0:	2b00      	cmp	r3, #0
 8016fe2:	d117      	bne.n	8017014 <nk_scrollbar_behavior+0x678>
 8016fe4:	f04f 0300 	mov.w	r3, #0
 8016fe8:	60fb      	str	r3, [r7, #12]
 8016fea:	e013      	b.n	8017014 <nk_scrollbar_behavior+0x678>
        } else if (nk_input_is_key_pressed(in, NK_KEY_SCROLL_END)) {
 8016fec:	211b      	movs	r1, #27
 8016fee:	69b8      	ldr	r0, [r7, #24]
 8016ff0:	f7fb fb74 	bl	80126dc <nk_input_is_key_pressed>
 8016ff4:	4603      	mov	r3, r0
 8016ff6:	2b00      	cmp	r3, #0
 8016ff8:	d00c      	beq.n	8017014 <nk_scrollbar_behavior+0x678>
            /* update cursor to the end */
            if (o == NK_VERTICAL) scroll_offset = target - scroll->h;
 8016ffa:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 8016ffe:	2b00      	cmp	r3, #0
 8017000:	d108      	bne.n	8017014 <nk_scrollbar_behavior+0x678>
 8017002:	693b      	ldr	r3, [r7, #16]
 8017004:	edd3 7a03 	vldr	s15, [r3, #12]
 8017008:	ed97 7a02 	vldr	s14, [r7, #8]
 801700c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017010:	edc7 7a03 	vstr	s15, [r7, #12]
        }
    }
    if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(in, *scroll))
 8017014:	69fb      	ldr	r3, [r7, #28]
 8017016:	681b      	ldr	r3, [r3, #0]
 8017018:	f003 0310 	and.w	r3, r3, #16
 801701c:	2b00      	cmp	r3, #0
 801701e:	d01d      	beq.n	801705c <nk_scrollbar_behavior+0x6c0>
 8017020:	693b      	ldr	r3, [r7, #16]
 8017022:	ed93 6a00 	vldr	s12, [r3]
 8017026:	edd3 6a01 	vldr	s13, [r3, #4]
 801702a:	ed93 7a02 	vldr	s14, [r3, #8]
 801702e:	edd3 7a03 	vldr	s15, [r3, #12]
 8017032:	eeb0 0a46 	vmov.f32	s0, s12
 8017036:	eef0 0a66 	vmov.f32	s1, s13
 801703a:	eeb0 1a47 	vmov.f32	s2, s14
 801703e:	eef0 1a67 	vmov.f32	s3, s15
 8017042:	69b8      	ldr	r0, [r7, #24]
 8017044:	f7fb fabd 	bl	80125c2 <nk_input_is_mouse_prev_hovering_rect>
 8017048:	4603      	mov	r3, r0
 801704a:	2b00      	cmp	r3, #0
 801704c:	d106      	bne.n	801705c <nk_scrollbar_behavior+0x6c0>
        *state |= NK_WIDGET_STATE_ENTERED;
 801704e:	69fb      	ldr	r3, [r7, #28]
 8017050:	681b      	ldr	r3, [r3, #0]
 8017052:	f043 0208 	orr.w	r2, r3, #8
 8017056:	69fb      	ldr	r3, [r7, #28]
 8017058:	601a      	str	r2, [r3, #0]
 801705a:	e01c      	b.n	8017096 <nk_scrollbar_behavior+0x6fa>
    else if (nk_input_is_mouse_prev_hovering_rect(in, *scroll))
 801705c:	693b      	ldr	r3, [r7, #16]
 801705e:	ed93 6a00 	vldr	s12, [r3]
 8017062:	edd3 6a01 	vldr	s13, [r3, #4]
 8017066:	ed93 7a02 	vldr	s14, [r3, #8]
 801706a:	edd3 7a03 	vldr	s15, [r3, #12]
 801706e:	eeb0 0a46 	vmov.f32	s0, s12
 8017072:	eef0 0a66 	vmov.f32	s1, s13
 8017076:	eeb0 1a47 	vmov.f32	s2, s14
 801707a:	eef0 1a67 	vmov.f32	s3, s15
 801707e:	69b8      	ldr	r0, [r7, #24]
 8017080:	f7fb fa9f 	bl	80125c2 <nk_input_is_mouse_prev_hovering_rect>
 8017084:	4603      	mov	r3, r0
 8017086:	2b00      	cmp	r3, #0
 8017088:	d005      	beq.n	8017096 <nk_scrollbar_behavior+0x6fa>
        *state |= NK_WIDGET_STATE_LEFT;
 801708a:	69fb      	ldr	r3, [r7, #28]
 801708c:	681b      	ldr	r3, [r3, #0]
 801708e:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8017092:	69fb      	ldr	r3, [r7, #28]
 8017094:	601a      	str	r2, [r3, #0]
    return scroll_offset;
 8017096:	68fb      	ldr	r3, [r7, #12]
}
 8017098:	ee07 3a90 	vmov	s15, r3
 801709c:	eeb0 0a67 	vmov.f32	s0, s15
 80170a0:	3748      	adds	r7, #72	; 0x48
 80170a2:	46bd      	mov	sp, r7
 80170a4:	bd80      	pop	{r7, pc}
 80170a6:	bf00      	nop

080170a8 <nk_draw_scrollbar>:
NK_LIB void
nk_draw_scrollbar(struct nk_command_buffer *out, nk_flags state,
    const struct nk_style_scrollbar *style, const struct nk_rect *bounds,
    const struct nk_rect *scroll)
{
 80170a8:	b580      	push	{r7, lr}
 80170aa:	b086      	sub	sp, #24
 80170ac:	af00      	add	r7, sp, #0
 80170ae:	60f8      	str	r0, [r7, #12]
 80170b0:	60b9      	str	r1, [r7, #8]
 80170b2:	607a      	str	r2, [r7, #4]
 80170b4:	603b      	str	r3, [r7, #0]
    const struct nk_style_item *background;
    const struct nk_style_item *cursor;

    /* select correct colors/images to draw */
    if (state & NK_WIDGET_STATE_ACTIVED) {
 80170b6:	68bb      	ldr	r3, [r7, #8]
 80170b8:	f003 0320 	and.w	r3, r3, #32
 80170bc:	2b00      	cmp	r3, #0
 80170be:	d006      	beq.n	80170ce <nk_draw_scrollbar+0x26>
        background = &style->active;
 80170c0:	687b      	ldr	r3, [r7, #4]
 80170c2:	3338      	adds	r3, #56	; 0x38
 80170c4:	617b      	str	r3, [r7, #20]
        cursor = &style->cursor_active;
 80170c6:	687b      	ldr	r3, [r7, #4]
 80170c8:	3390      	adds	r3, #144	; 0x90
 80170ca:	613b      	str	r3, [r7, #16]
 80170cc:	e010      	b.n	80170f0 <nk_draw_scrollbar+0x48>
    } else if (state & NK_WIDGET_STATE_HOVER) {
 80170ce:	68bb      	ldr	r3, [r7, #8]
 80170d0:	f003 0310 	and.w	r3, r3, #16
 80170d4:	2b00      	cmp	r3, #0
 80170d6:	d006      	beq.n	80170e6 <nk_draw_scrollbar+0x3e>
        background = &style->hover;
 80170d8:	687b      	ldr	r3, [r7, #4]
 80170da:	331c      	adds	r3, #28
 80170dc:	617b      	str	r3, [r7, #20]
        cursor = &style->cursor_hover;
 80170de:	687b      	ldr	r3, [r7, #4]
 80170e0:	3374      	adds	r3, #116	; 0x74
 80170e2:	613b      	str	r3, [r7, #16]
 80170e4:	e004      	b.n	80170f0 <nk_draw_scrollbar+0x48>
    } else {
        background = &style->normal;
 80170e6:	687b      	ldr	r3, [r7, #4]
 80170e8:	617b      	str	r3, [r7, #20]
        cursor = &style->cursor_normal;
 80170ea:	687b      	ldr	r3, [r7, #4]
 80170ec:	3358      	adds	r3, #88	; 0x58
 80170ee:	613b      	str	r3, [r7, #16]
    }

    /* draw background */
    switch (background->type) {
 80170f0:	697b      	ldr	r3, [r7, #20]
 80170f2:	781b      	ldrb	r3, [r3, #0]
 80170f4:	2b02      	cmp	r3, #2
 80170f6:	d01e      	beq.n	8017136 <nk_draw_scrollbar+0x8e>
 80170f8:	2b02      	cmp	r3, #2
 80170fa:	dc71      	bgt.n	80171e0 <nk_draw_scrollbar+0x138>
 80170fc:	2b00      	cmp	r3, #0
 80170fe:	d033      	beq.n	8017168 <nk_draw_scrollbar+0xc0>
 8017100:	2b01      	cmp	r3, #1
 8017102:	d16d      	bne.n	80171e0 <nk_draw_scrollbar+0x138>
        case NK_STYLE_ITEM_IMAGE:
            nk_draw_image(out, *bounds, &background->data.image, nk_white);
 8017104:	697b      	ldr	r3, [r7, #20]
 8017106:	1d19      	adds	r1, r3, #4
 8017108:	4a74      	ldr	r2, [pc, #464]	; (80172dc <nk_draw_scrollbar+0x234>)
 801710a:	683b      	ldr	r3, [r7, #0]
 801710c:	ed93 6a00 	vldr	s12, [r3]
 8017110:	edd3 6a01 	vldr	s13, [r3, #4]
 8017114:	ed93 7a02 	vldr	s14, [r3, #8]
 8017118:	edd3 7a03 	vldr	s15, [r3, #12]
 801711c:	6812      	ldr	r2, [r2, #0]
 801711e:	eeb0 0a46 	vmov.f32	s0, s12
 8017122:	eef0 0a66 	vmov.f32	s1, s13
 8017126:	eeb0 1a47 	vmov.f32	s2, s14
 801712a:	eef0 1a67 	vmov.f32	s3, s15
 801712e:	68f8      	ldr	r0, [r7, #12]
 8017130:	f7fa f90e 	bl	8011350 <nk_draw_image>
            break;
 8017134:	e054      	b.n	80171e0 <nk_draw_scrollbar+0x138>
        case NK_STYLE_ITEM_NINE_SLICE:
            nk_draw_nine_slice(out, *bounds, &background->data.slice, nk_white);
 8017136:	697b      	ldr	r3, [r7, #20]
 8017138:	1d19      	adds	r1, r3, #4
 801713a:	4a68      	ldr	r2, [pc, #416]	; (80172dc <nk_draw_scrollbar+0x234>)
 801713c:	683b      	ldr	r3, [r7, #0]
 801713e:	ed93 6a00 	vldr	s12, [r3]
 8017142:	edd3 6a01 	vldr	s13, [r3, #4]
 8017146:	ed93 7a02 	vldr	s14, [r3, #8]
 801714a:	edd3 7a03 	vldr	s15, [r3, #12]
 801714e:	6812      	ldr	r2, [r2, #0]
 8017150:	eeb0 0a46 	vmov.f32	s0, s12
 8017154:	eef0 0a66 	vmov.f32	s1, s13
 8017158:	eeb0 1a47 	vmov.f32	s2, s14
 801715c:	eef0 1a67 	vmov.f32	s3, s15
 8017160:	68f8      	ldr	r0, [r7, #12]
 8017162:	f7fa f9e7 	bl	8011534 <nk_draw_nine_slice>
            break;
 8017166:	e03b      	b.n	80171e0 <nk_draw_scrollbar+0x138>
        case NK_STYLE_ITEM_COLOR:
            nk_fill_rect(out, *bounds, style->rounding, background->data.color);
 8017168:	687b      	ldr	r3, [r7, #4]
 801716a:	edd3 5a2d 	vldr	s11, [r3, #180]	; 0xb4
 801716e:	697a      	ldr	r2, [r7, #20]
 8017170:	683b      	ldr	r3, [r7, #0]
 8017172:	ed93 6a00 	vldr	s12, [r3]
 8017176:	edd3 6a01 	vldr	s13, [r3, #4]
 801717a:	ed93 7a02 	vldr	s14, [r3, #8]
 801717e:	edd3 7a03 	vldr	s15, [r3, #12]
 8017182:	6851      	ldr	r1, [r2, #4]
 8017184:	eeb0 2a65 	vmov.f32	s4, s11
 8017188:	eeb0 0a46 	vmov.f32	s0, s12
 801718c:	eef0 0a66 	vmov.f32	s1, s13
 8017190:	eeb0 1a47 	vmov.f32	s2, s14
 8017194:	eef0 1a67 	vmov.f32	s3, s15
 8017198:	68f8      	ldr	r0, [r7, #12]
 801719a:	f7f9 fd7f 	bl	8010c9c <nk_fill_rect>
            nk_stroke_rect(out, *bounds, style->rounding, style->border, style->border_color);
 801719e:	687b      	ldr	r3, [r7, #4]
 80171a0:	edd3 5a2d 	vldr	s11, [r3, #180]	; 0xb4
 80171a4:	687b      	ldr	r3, [r7, #4]
 80171a6:	ed93 5a2c 	vldr	s10, [r3, #176]	; 0xb0
 80171aa:	687a      	ldr	r2, [r7, #4]
 80171ac:	683b      	ldr	r3, [r7, #0]
 80171ae:	ed93 6a00 	vldr	s12, [r3]
 80171b2:	edd3 6a01 	vldr	s13, [r3, #4]
 80171b6:	ed93 7a02 	vldr	s14, [r3, #8]
 80171ba:	edd3 7a03 	vldr	s15, [r3, #12]
 80171be:	6d51      	ldr	r1, [r2, #84]	; 0x54
 80171c0:	eef0 2a45 	vmov.f32	s5, s10
 80171c4:	eeb0 2a65 	vmov.f32	s4, s11
 80171c8:	eeb0 0a46 	vmov.f32	s0, s12
 80171cc:	eef0 0a66 	vmov.f32	s1, s13
 80171d0:	eeb0 1a47 	vmov.f32	s2, s14
 80171d4:	eef0 1a67 	vmov.f32	s3, s15
 80171d8:	68f8      	ldr	r0, [r7, #12]
 80171da:	f7f9 fc57 	bl	8010a8c <nk_stroke_rect>
            break;
 80171de:	bf00      	nop
    }

    /* draw cursor */
    switch (cursor->type) {
 80171e0:	693b      	ldr	r3, [r7, #16]
 80171e2:	781b      	ldrb	r3, [r3, #0]
 80171e4:	2b02      	cmp	r3, #2
 80171e6:	d01e      	beq.n	8017226 <nk_draw_scrollbar+0x17e>
 80171e8:	2b02      	cmp	r3, #2
 80171ea:	dc72      	bgt.n	80172d2 <nk_draw_scrollbar+0x22a>
 80171ec:	2b00      	cmp	r3, #0
 80171ee:	d033      	beq.n	8017258 <nk_draw_scrollbar+0x1b0>
 80171f0:	2b01      	cmp	r3, #1
 80171f2:	d16e      	bne.n	80172d2 <nk_draw_scrollbar+0x22a>
        case NK_STYLE_ITEM_IMAGE:
            nk_draw_image(out, *scroll, &cursor->data.image, nk_white);
 80171f4:	693b      	ldr	r3, [r7, #16]
 80171f6:	1d19      	adds	r1, r3, #4
 80171f8:	4a38      	ldr	r2, [pc, #224]	; (80172dc <nk_draw_scrollbar+0x234>)
 80171fa:	6a3b      	ldr	r3, [r7, #32]
 80171fc:	ed93 6a00 	vldr	s12, [r3]
 8017200:	edd3 6a01 	vldr	s13, [r3, #4]
 8017204:	ed93 7a02 	vldr	s14, [r3, #8]
 8017208:	edd3 7a03 	vldr	s15, [r3, #12]
 801720c:	6812      	ldr	r2, [r2, #0]
 801720e:	eeb0 0a46 	vmov.f32	s0, s12
 8017212:	eef0 0a66 	vmov.f32	s1, s13
 8017216:	eeb0 1a47 	vmov.f32	s2, s14
 801721a:	eef0 1a67 	vmov.f32	s3, s15
 801721e:	68f8      	ldr	r0, [r7, #12]
 8017220:	f7fa f896 	bl	8011350 <nk_draw_image>
            break;
 8017224:	e055      	b.n	80172d2 <nk_draw_scrollbar+0x22a>
        case NK_STYLE_ITEM_NINE_SLICE:
            nk_draw_nine_slice(out, *scroll, &cursor->data.slice, nk_white);
 8017226:	693b      	ldr	r3, [r7, #16]
 8017228:	1d19      	adds	r1, r3, #4
 801722a:	4a2c      	ldr	r2, [pc, #176]	; (80172dc <nk_draw_scrollbar+0x234>)
 801722c:	6a3b      	ldr	r3, [r7, #32]
 801722e:	ed93 6a00 	vldr	s12, [r3]
 8017232:	edd3 6a01 	vldr	s13, [r3, #4]
 8017236:	ed93 7a02 	vldr	s14, [r3, #8]
 801723a:	edd3 7a03 	vldr	s15, [r3, #12]
 801723e:	6812      	ldr	r2, [r2, #0]
 8017240:	eeb0 0a46 	vmov.f32	s0, s12
 8017244:	eef0 0a66 	vmov.f32	s1, s13
 8017248:	eeb0 1a47 	vmov.f32	s2, s14
 801724c:	eef0 1a67 	vmov.f32	s3, s15
 8017250:	68f8      	ldr	r0, [r7, #12]
 8017252:	f7fa f96f 	bl	8011534 <nk_draw_nine_slice>
            break;
 8017256:	e03c      	b.n	80172d2 <nk_draw_scrollbar+0x22a>
        case NK_STYLE_ITEM_COLOR:
            nk_fill_rect(out, *scroll, style->rounding_cursor, cursor->data.color);
 8017258:	687b      	ldr	r3, [r7, #4]
 801725a:	edd3 5a2f 	vldr	s11, [r3, #188]	; 0xbc
 801725e:	693a      	ldr	r2, [r7, #16]
 8017260:	6a3b      	ldr	r3, [r7, #32]
 8017262:	ed93 6a00 	vldr	s12, [r3]
 8017266:	edd3 6a01 	vldr	s13, [r3, #4]
 801726a:	ed93 7a02 	vldr	s14, [r3, #8]
 801726e:	edd3 7a03 	vldr	s15, [r3, #12]
 8017272:	6851      	ldr	r1, [r2, #4]
 8017274:	eeb0 2a65 	vmov.f32	s4, s11
 8017278:	eeb0 0a46 	vmov.f32	s0, s12
 801727c:	eef0 0a66 	vmov.f32	s1, s13
 8017280:	eeb0 1a47 	vmov.f32	s2, s14
 8017284:	eef0 1a67 	vmov.f32	s3, s15
 8017288:	68f8      	ldr	r0, [r7, #12]
 801728a:	f7f9 fd07 	bl	8010c9c <nk_fill_rect>
            nk_stroke_rect(out, *scroll, style->rounding_cursor, style->border_cursor, style->cursor_border_color);
 801728e:	687b      	ldr	r3, [r7, #4]
 8017290:	edd3 5a2f 	vldr	s11, [r3, #188]	; 0xbc
 8017294:	687b      	ldr	r3, [r7, #4]
 8017296:	ed93 5a2e 	vldr	s10, [r3, #184]	; 0xb8
 801729a:	687a      	ldr	r2, [r7, #4]
 801729c:	6a3b      	ldr	r3, [r7, #32]
 801729e:	ed93 6a00 	vldr	s12, [r3]
 80172a2:	edd3 6a01 	vldr	s13, [r3, #4]
 80172a6:	ed93 7a02 	vldr	s14, [r3, #8]
 80172aa:	edd3 7a03 	vldr	s15, [r3, #12]
 80172ae:	f8d2 10ac 	ldr.w	r1, [r2, #172]	; 0xac
 80172b2:	eef0 2a45 	vmov.f32	s5, s10
 80172b6:	eeb0 2a65 	vmov.f32	s4, s11
 80172ba:	eeb0 0a46 	vmov.f32	s0, s12
 80172be:	eef0 0a66 	vmov.f32	s1, s13
 80172c2:	eeb0 1a47 	vmov.f32	s2, s14
 80172c6:	eef0 1a67 	vmov.f32	s3, s15
 80172ca:	68f8      	ldr	r0, [r7, #12]
 80172cc:	f7f9 fbde 	bl	8010a8c <nk_stroke_rect>
            break;
 80172d0:	bf00      	nop
    }
}
 80172d2:	bf00      	nop
 80172d4:	3718      	adds	r7, #24
 80172d6:	46bd      	mov	sp, r7
 80172d8:	bd80      	pop	{r7, pc}
 80172da:	bf00      	nop
 80172dc:	0802363c 	.word	0x0802363c

080172e0 <nk_do_scrollbarv>:
nk_do_scrollbarv(nk_flags *state,
    struct nk_command_buffer *out, struct nk_rect scroll, int has_scrolling,
    float offset, float target, float step, float button_pixel_inc,
    const struct nk_style_scrollbar *style, struct nk_input *in,
    const struct nk_user_font *font)
{
 80172e0:	b580      	push	{r7, lr}
 80172e2:	b0a6      	sub	sp, #152	; 0x98
 80172e4:	af04      	add	r7, sp, #16
 80172e6:	62f8      	str	r0, [r7, #44]	; 0x2c
 80172e8:	62b9      	str	r1, [r7, #40]	; 0x28
 80172ea:	eeb0 6a40 	vmov.f32	s12, s0
 80172ee:	eef0 6a60 	vmov.f32	s13, s1
 80172f2:	eeb0 7a41 	vmov.f32	s14, s2
 80172f6:	eef0 7a61 	vmov.f32	s15, s3
 80172fa:	617a      	str	r2, [r7, #20]
 80172fc:	ed87 2a04 	vstr	s4, [r7, #16]
 8017300:	edc7 2a03 	vstr	s5, [r7, #12]
 8017304:	ed87 3a02 	vstr	s6, [r7, #8]
 8017308:	edc7 3a01 	vstr	s7, [r7, #4]
 801730c:	603b      	str	r3, [r7, #0]
 801730e:	ed87 6a06 	vstr	s12, [r7, #24]
 8017312:	edc7 6a07 	vstr	s13, [r7, #28]
 8017316:	ed87 7a08 	vstr	s14, [r7, #32]
 801731a:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
    float scroll_step;
    float scroll_offset;
    float scroll_off;
    float scroll_ratio;

    NK_ASSERT(out);
 801731e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017320:	2b00      	cmp	r3, #0
 8017322:	d105      	bne.n	8017330 <nk_do_scrollbarv+0x50>
 8017324:	4bb6      	ldr	r3, [pc, #728]	; (8017600 <nk_do_scrollbarv+0x320>)
 8017326:	4ab7      	ldr	r2, [pc, #732]	; (8017604 <nk_do_scrollbarv+0x324>)
 8017328:	2195      	movs	r1, #149	; 0x95
 801732a:	48b7      	ldr	r0, [pc, #732]	; (8017608 <nk_do_scrollbarv+0x328>)
 801732c:	f006 fb74 	bl	801da18 <__assert_func>
    NK_ASSERT(style);
 8017330:	683b      	ldr	r3, [r7, #0]
 8017332:	2b00      	cmp	r3, #0
 8017334:	d105      	bne.n	8017342 <nk_do_scrollbarv+0x62>
 8017336:	4bb5      	ldr	r3, [pc, #724]	; (801760c <nk_do_scrollbarv+0x32c>)
 8017338:	4ab2      	ldr	r2, [pc, #712]	; (8017604 <nk_do_scrollbarv+0x324>)
 801733a:	2196      	movs	r1, #150	; 0x96
 801733c:	48b2      	ldr	r0, [pc, #712]	; (8017608 <nk_do_scrollbarv+0x328>)
 801733e:	f006 fb6b 	bl	801da18 <__assert_func>
    NK_ASSERT(state);
 8017342:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017344:	2b00      	cmp	r3, #0
 8017346:	d105      	bne.n	8017354 <nk_do_scrollbarv+0x74>
 8017348:	4bb1      	ldr	r3, [pc, #708]	; (8017610 <nk_do_scrollbarv+0x330>)
 801734a:	4aae      	ldr	r2, [pc, #696]	; (8017604 <nk_do_scrollbarv+0x324>)
 801734c:	2197      	movs	r1, #151	; 0x97
 801734e:	48ae      	ldr	r0, [pc, #696]	; (8017608 <nk_do_scrollbarv+0x328>)
 8017350:	f006 fb62 	bl	801da18 <__assert_func>
    if (!out || !style) return 0;
 8017354:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017356:	2b00      	cmp	r3, #0
 8017358:	d002      	beq.n	8017360 <nk_do_scrollbarv+0x80>
 801735a:	683b      	ldr	r3, [r7, #0]
 801735c:	2b00      	cmp	r3, #0
 801735e:	d102      	bne.n	8017366 <nk_do_scrollbarv+0x86>
 8017360:	f04f 0300 	mov.w	r3, #0
 8017364:	e253      	b.n	801780e <nk_do_scrollbarv+0x52e>

    scroll.w = NK_MAX(scroll.w, 1);
 8017366:	edd7 7a08 	vldr	s15, [r7, #32]
 801736a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801736e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8017372:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017376:	d502      	bpl.n	801737e <nk_do_scrollbarv+0x9e>
 8017378:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 801737c:	e000      	b.n	8017380 <nk_do_scrollbarv+0xa0>
 801737e:	6a3b      	ldr	r3, [r7, #32]
 8017380:	623b      	str	r3, [r7, #32]
    scroll.h = NK_MAX(scroll.h, 0);
 8017382:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8017386:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801738a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801738e:	d502      	bpl.n	8017396 <nk_do_scrollbarv+0xb6>
 8017390:	f04f 0300 	mov.w	r3, #0
 8017394:	e000      	b.n	8017398 <nk_do_scrollbarv+0xb8>
 8017396:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017398:	627b      	str	r3, [r7, #36]	; 0x24
    if (target <= scroll.h) return 0;
 801739a:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 801739e:	ed97 7a03 	vldr	s14, [r7, #12]
 80173a2:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80173a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80173aa:	d802      	bhi.n	80173b2 <nk_do_scrollbarv+0xd2>
 80173ac:	f04f 0300 	mov.w	r3, #0
 80173b0:	e22d      	b.n	801780e <nk_do_scrollbarv+0x52e>

    /* optional scrollbar buttons */
    if (style->show_buttons) {
 80173b2:	683b      	ldr	r3, [r7, #0]
 80173b4:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 80173b8:	2b00      	cmp	r3, #0
 80173ba:	f000 80a4 	beq.w	8017506 <nk_do_scrollbarv+0x226>
        nk_flags ws;
        float scroll_h;
        struct nk_rect button;

        button.x = scroll.x;
 80173be:	69bb      	ldr	r3, [r7, #24]
 80173c0:	633b      	str	r3, [r7, #48]	; 0x30
        button.w = scroll.w;
 80173c2:	6a3b      	ldr	r3, [r7, #32]
 80173c4:	63bb      	str	r3, [r7, #56]	; 0x38
        button.h = scroll.w;
 80173c6:	6a3b      	ldr	r3, [r7, #32]
 80173c8:	63fb      	str	r3, [r7, #60]	; 0x3c

        scroll_h = NK_MAX(scroll.h - 2 * button.h,0);
 80173ca:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 80173ce:	edd7 7a0f 	vldr	s15, [r7, #60]	; 0x3c
 80173d2:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80173d6:	ee77 7a67 	vsub.f32	s15, s14, s15
 80173da:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80173de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80173e2:	d502      	bpl.n	80173ea <nk_do_scrollbarv+0x10a>
 80173e4:	eddf 7a8b 	vldr	s15, [pc, #556]	; 8017614 <nk_do_scrollbarv+0x334>
 80173e8:	e007      	b.n	80173fa <nk_do_scrollbarv+0x11a>
 80173ea:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 80173ee:	edd7 7a0f 	vldr	s15, [r7, #60]	; 0x3c
 80173f2:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80173f6:	ee77 7a67 	vsub.f32	s15, s14, s15
 80173fa:	edc7 7a21 	vstr	s15, [r7, #132]	; 0x84
        scroll_step = NK_MIN(step, button_pixel_inc);
 80173fe:	ed97 7a02 	vldr	s14, [r7, #8]
 8017402:	edd7 7a01 	vldr	s15, [r7, #4]
 8017406:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801740a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801740e:	d501      	bpl.n	8017414 <nk_do_scrollbarv+0x134>
 8017410:	68bb      	ldr	r3, [r7, #8]
 8017412:	e000      	b.n	8017416 <nk_do_scrollbarv+0x136>
 8017414:	687b      	ldr	r3, [r7, #4]
 8017416:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

        /* decrement button */
        button.y = scroll.y;
 801741a:	69fb      	ldr	r3, [r7, #28]
 801741c:	637b      	str	r3, [r7, #52]	; 0x34
        if (nk_do_button_symbol(&ws, out, button, style->dec_symbol,
 801741e:	683b      	ldr	r3, [r7, #0]
 8017420:	f893 11fd 	ldrb.w	r1, [r3, #509]	; 0x1fd
 8017424:	683b      	ldr	r3, [r7, #0]
 8017426:	f503 73b2 	add.w	r3, r3, #356	; 0x164
 801742a:	ed97 6a0c 	vldr	s12, [r7, #48]	; 0x30
 801742e:	edd7 6a0d 	vldr	s13, [r7, #52]	; 0x34
 8017432:	ed97 7a0e 	vldr	s14, [r7, #56]	; 0x38
 8017436:	edd7 7a0f 	vldr	s15, [r7, #60]	; 0x3c
 801743a:	f107 0040 	add.w	r0, r7, #64	; 0x40
 801743e:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8017442:	9202      	str	r2, [sp, #8]
 8017444:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8017448:	9201      	str	r2, [sp, #4]
 801744a:	9300      	str	r3, [sp, #0]
 801744c:	2301      	movs	r3, #1
 801744e:	460a      	mov	r2, r1
 8017450:	eeb0 0a46 	vmov.f32	s0, s12
 8017454:	eef0 0a66 	vmov.f32	s1, s13
 8017458:	eeb0 1a47 	vmov.f32	s2, s14
 801745c:	eef0 1a67 	vmov.f32	s3, s15
 8017460:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8017462:	f7f7 fa87 	bl	800e974 <nk_do_button_symbol>
 8017466:	4603      	mov	r3, r0
 8017468:	2b00      	cmp	r3, #0
 801746a:	d007      	beq.n	801747c <nk_do_scrollbarv+0x19c>
            NK_BUTTON_REPEATER, &style->dec_button, in, font))
            offset = offset - scroll_step;
 801746c:	ed97 7a04 	vldr	s14, [r7, #16]
 8017470:	edd7 7a20 	vldr	s15, [r7, #128]	; 0x80
 8017474:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017478:	edc7 7a04 	vstr	s15, [r7, #16]

        /* increment button */
        button.y = scroll.y + scroll.h - button.h;
 801747c:	ed97 7a07 	vldr	s14, [r7, #28]
 8017480:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8017484:	ee37 7a27 	vadd.f32	s14, s14, s15
 8017488:	edd7 7a0f 	vldr	s15, [r7, #60]	; 0x3c
 801748c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017490:	edc7 7a0d 	vstr	s15, [r7, #52]	; 0x34
        if (nk_do_button_symbol(&ws, out, button, style->inc_symbol,
 8017494:	683b      	ldr	r3, [r7, #0]
 8017496:	f893 11fc 	ldrb.w	r1, [r3, #508]	; 0x1fc
 801749a:	683b      	ldr	r3, [r7, #0]
 801749c:	33cc      	adds	r3, #204	; 0xcc
 801749e:	ed97 6a0c 	vldr	s12, [r7, #48]	; 0x30
 80174a2:	edd7 6a0d 	vldr	s13, [r7, #52]	; 0x34
 80174a6:	ed97 7a0e 	vldr	s14, [r7, #56]	; 0x38
 80174aa:	edd7 7a0f 	vldr	s15, [r7, #60]	; 0x3c
 80174ae:	f107 0040 	add.w	r0, r7, #64	; 0x40
 80174b2:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 80174b6:	9202      	str	r2, [sp, #8]
 80174b8:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 80174bc:	9201      	str	r2, [sp, #4]
 80174be:	9300      	str	r3, [sp, #0]
 80174c0:	2301      	movs	r3, #1
 80174c2:	460a      	mov	r2, r1
 80174c4:	eeb0 0a46 	vmov.f32	s0, s12
 80174c8:	eef0 0a66 	vmov.f32	s1, s13
 80174cc:	eeb0 1a47 	vmov.f32	s2, s14
 80174d0:	eef0 1a67 	vmov.f32	s3, s15
 80174d4:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80174d6:	f7f7 fa4d 	bl	800e974 <nk_do_button_symbol>
 80174da:	4603      	mov	r3, r0
 80174dc:	2b00      	cmp	r3, #0
 80174de:	d007      	beq.n	80174f0 <nk_do_scrollbarv+0x210>
            NK_BUTTON_REPEATER, &style->inc_button, in, font))
            offset = offset + scroll_step;
 80174e0:	ed97 7a04 	vldr	s14, [r7, #16]
 80174e4:	edd7 7a20 	vldr	s15, [r7, #128]	; 0x80
 80174e8:	ee77 7a27 	vadd.f32	s15, s14, s15
 80174ec:	edc7 7a04 	vstr	s15, [r7, #16]

        scroll.y = scroll.y + button.h;
 80174f0:	ed97 7a07 	vldr	s14, [r7, #28]
 80174f4:	edd7 7a0f 	vldr	s15, [r7, #60]	; 0x3c
 80174f8:	ee77 7a27 	vadd.f32	s15, s14, s15
 80174fc:	edc7 7a07 	vstr	s15, [r7, #28]
        scroll.h = scroll_h;
 8017500:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017504:	627b      	str	r3, [r7, #36]	; 0x24
    }

    /* calculate scrollbar constants */
    scroll_step = NK_MIN(step, scroll.h);
 8017506:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 801750a:	ed97 7a02 	vldr	s14, [r7, #8]
 801750e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8017512:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017516:	d501      	bpl.n	801751c <nk_do_scrollbarv+0x23c>
 8017518:	68bb      	ldr	r3, [r7, #8]
 801751a:	e000      	b.n	801751e <nk_do_scrollbarv+0x23e>
 801751c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801751e:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
    scroll_offset = NK_CLAMP(0, offset, target - scroll.h);
 8017522:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8017526:	ed97 7a03 	vldr	s14, [r7, #12]
 801752a:	ee77 7a67 	vsub.f32	s15, s14, s15
 801752e:	ed97 7a04 	vldr	s14, [r7, #16]
 8017532:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8017536:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801753a:	d50a      	bpl.n	8017552 <nk_do_scrollbarv+0x272>
 801753c:	edd7 7a04 	vldr	s15, [r7, #16]
 8017540:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8017544:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017548:	bf4c      	ite	mi
 801754a:	2301      	movmi	r3, #1
 801754c:	2300      	movpl	r3, #0
 801754e:	b2db      	uxtb	r3, r3
 8017550:	e00d      	b.n	801756e <nk_do_scrollbarv+0x28e>
 8017552:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8017556:	ed97 7a03 	vldr	s14, [r7, #12]
 801755a:	ee77 7a67 	vsub.f32	s15, s14, s15
 801755e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8017562:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017566:	bf4c      	ite	mi
 8017568:	2301      	movmi	r3, #1
 801756a:	2300      	movpl	r3, #0
 801756c:	b2db      	uxtb	r3, r3
 801756e:	2b00      	cmp	r3, #0
 8017570:	d002      	beq.n	8017578 <nk_do_scrollbarv+0x298>
 8017572:	eddf 7a28 	vldr	s15, [pc, #160]	; 8017614 <nk_do_scrollbarv+0x334>
 8017576:	e015      	b.n	80175a4 <nk_do_scrollbarv+0x2c4>
 8017578:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 801757c:	ed97 7a03 	vldr	s14, [r7, #12]
 8017580:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017584:	ed97 7a04 	vldr	s14, [r7, #16]
 8017588:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801758c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017590:	d502      	bpl.n	8017598 <nk_do_scrollbarv+0x2b8>
 8017592:	edd7 7a04 	vldr	s15, [r7, #16]
 8017596:	e005      	b.n	80175a4 <nk_do_scrollbarv+0x2c4>
 8017598:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 801759c:	ed97 7a03 	vldr	s14, [r7, #12]
 80175a0:	ee77 7a67 	vsub.f32	s15, s14, s15
 80175a4:	edc7 7a1f 	vstr	s15, [r7, #124]	; 0x7c
    scroll_ratio = scroll.h / target;
 80175a8:	edd7 6a09 	vldr	s13, [r7, #36]	; 0x24
 80175ac:	ed97 7a03 	vldr	s14, [r7, #12]
 80175b0:	eec6 7a87 	vdiv.f32	s15, s13, s14
 80175b4:	edc7 7a1e 	vstr	s15, [r7, #120]	; 0x78
    scroll_off = scroll_offset / target;
 80175b8:	edd7 6a1f 	vldr	s13, [r7, #124]	; 0x7c
 80175bc:	ed97 7a03 	vldr	s14, [r7, #12]
 80175c0:	eec6 7a87 	vdiv.f32	s15, s13, s14
 80175c4:	edc7 7a1d 	vstr	s15, [r7, #116]	; 0x74

    /* calculate scrollbar cursor bounds */
    cursor.h = NK_MAX((scroll_ratio * scroll.h) - (2*style->border + 2*style->padding.y), 0);
 80175c8:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 80175cc:	edd7 7a1e 	vldr	s15, [r7, #120]	; 0x78
 80175d0:	ee27 7a27 	vmul.f32	s14, s14, s15
 80175d4:	683b      	ldr	r3, [r7, #0]
 80175d6:	edd3 7a2c 	vldr	s15, [r3, #176]	; 0xb0
 80175da:	ee77 6aa7 	vadd.f32	s13, s15, s15
 80175de:	683b      	ldr	r3, [r7, #0]
 80175e0:	edd3 7a31 	vldr	s15, [r3, #196]	; 0xc4
 80175e4:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80175e8:	ee76 7aa7 	vadd.f32	s15, s13, s15
 80175ec:	ee77 7a67 	vsub.f32	s15, s14, s15
 80175f0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80175f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80175f8:	d50e      	bpl.n	8017618 <nk_do_scrollbarv+0x338>
 80175fa:	eddf 7a06 	vldr	s15, [pc, #24]	; 8017614 <nk_do_scrollbarv+0x334>
 80175fe:	e01f      	b.n	8017640 <nk_do_scrollbarv+0x360>
 8017600:	08021b70 	.word	0x08021b70
 8017604:	08023640 	.word	0x08023640
 8017608:	08021b74 	.word	0x08021b74
 801760c:	08021b94 	.word	0x08021b94
 8017610:	08021b9c 	.word	0x08021b9c
 8017614:	00000000 	.word	0x00000000
 8017618:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 801761c:	edd7 7a1e 	vldr	s15, [r7, #120]	; 0x78
 8017620:	ee27 7a27 	vmul.f32	s14, s14, s15
 8017624:	683b      	ldr	r3, [r7, #0]
 8017626:	edd3 7a2c 	vldr	s15, [r3, #176]	; 0xb0
 801762a:	ee77 6aa7 	vadd.f32	s13, s15, s15
 801762e:	683b      	ldr	r3, [r7, #0]
 8017630:	edd3 7a31 	vldr	s15, [r3, #196]	; 0xc4
 8017634:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8017638:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801763c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017640:	edc7 7a14 	vstr	s15, [r7, #80]	; 0x50
    cursor.y = scroll.y + (scroll_off * scroll.h) + style->border + style->padding.y;
 8017644:	ed97 7a07 	vldr	s14, [r7, #28]
 8017648:	edd7 6a09 	vldr	s13, [r7, #36]	; 0x24
 801764c:	edd7 7a1d 	vldr	s15, [r7, #116]	; 0x74
 8017650:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8017654:	ee37 7a27 	vadd.f32	s14, s14, s15
 8017658:	683b      	ldr	r3, [r7, #0]
 801765a:	edd3 7a2c 	vldr	s15, [r3, #176]	; 0xb0
 801765e:	ee37 7a27 	vadd.f32	s14, s14, s15
 8017662:	683b      	ldr	r3, [r7, #0]
 8017664:	edd3 7a31 	vldr	s15, [r3, #196]	; 0xc4
 8017668:	ee77 7a27 	vadd.f32	s15, s14, s15
 801766c:	edc7 7a12 	vstr	s15, [r7, #72]	; 0x48
    cursor.w = scroll.w - (2 * style->border + 2 * style->padding.x);
 8017670:	ed97 7a08 	vldr	s14, [r7, #32]
 8017674:	683b      	ldr	r3, [r7, #0]
 8017676:	edd3 7a2c 	vldr	s15, [r3, #176]	; 0xb0
 801767a:	ee77 6aa7 	vadd.f32	s13, s15, s15
 801767e:	683b      	ldr	r3, [r7, #0]
 8017680:	edd3 7a30 	vldr	s15, [r3, #192]	; 0xc0
 8017684:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8017688:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801768c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017690:	edc7 7a13 	vstr	s15, [r7, #76]	; 0x4c
    cursor.x = scroll.x + style->border + style->padding.x;
 8017694:	ed97 7a06 	vldr	s14, [r7, #24]
 8017698:	683b      	ldr	r3, [r7, #0]
 801769a:	edd3 7a2c 	vldr	s15, [r3, #176]	; 0xb0
 801769e:	ee37 7a27 	vadd.f32	s14, s14, s15
 80176a2:	683b      	ldr	r3, [r7, #0]
 80176a4:	edd3 7a30 	vldr	s15, [r3, #192]	; 0xc0
 80176a8:	ee77 7a27 	vadd.f32	s15, s14, s15
 80176ac:	edc7 7a11 	vstr	s15, [r7, #68]	; 0x44

    /* calculate empty space around cursor */
    empty_north.x = scroll.x;
 80176b0:	69bb      	ldr	r3, [r7, #24]
 80176b2:	667b      	str	r3, [r7, #100]	; 0x64
    empty_north.y = scroll.y;
 80176b4:	69fb      	ldr	r3, [r7, #28]
 80176b6:	66bb      	str	r3, [r7, #104]	; 0x68
    empty_north.w = scroll.w;
 80176b8:	6a3b      	ldr	r3, [r7, #32]
 80176ba:	66fb      	str	r3, [r7, #108]	; 0x6c
    empty_north.h = NK_MAX(cursor.y - scroll.y, 0);
 80176bc:	ed97 7a12 	vldr	s14, [r7, #72]	; 0x48
 80176c0:	edd7 7a07 	vldr	s15, [r7, #28]
 80176c4:	ee77 7a67 	vsub.f32	s15, s14, s15
 80176c8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80176cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80176d0:	d502      	bpl.n	80176d8 <nk_do_scrollbarv+0x3f8>
 80176d2:	ed5f 7a30 	vldr	s15, [pc, #-192]	; 8017614 <nk_do_scrollbarv+0x334>
 80176d6:	e005      	b.n	80176e4 <nk_do_scrollbarv+0x404>
 80176d8:	ed97 7a12 	vldr	s14, [r7, #72]	; 0x48
 80176dc:	edd7 7a07 	vldr	s15, [r7, #28]
 80176e0:	ee77 7a67 	vsub.f32	s15, s14, s15
 80176e4:	edc7 7a1c 	vstr	s15, [r7, #112]	; 0x70

    empty_south.x = scroll.x;
 80176e8:	69bb      	ldr	r3, [r7, #24]
 80176ea:	657b      	str	r3, [r7, #84]	; 0x54
    empty_south.y = cursor.y + cursor.h;
 80176ec:	ed97 7a12 	vldr	s14, [r7, #72]	; 0x48
 80176f0:	edd7 7a14 	vldr	s15, [r7, #80]	; 0x50
 80176f4:	ee77 7a27 	vadd.f32	s15, s14, s15
 80176f8:	edc7 7a16 	vstr	s15, [r7, #88]	; 0x58
    empty_south.w = scroll.w;
 80176fc:	6a3b      	ldr	r3, [r7, #32]
 80176fe:	65fb      	str	r3, [r7, #92]	; 0x5c
    empty_south.h = NK_MAX((scroll.y + scroll.h) - (cursor.y + cursor.h), 0);
 8017700:	ed97 7a07 	vldr	s14, [r7, #28]
 8017704:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8017708:	ee37 7a27 	vadd.f32	s14, s14, s15
 801770c:	edd7 6a12 	vldr	s13, [r7, #72]	; 0x48
 8017710:	edd7 7a14 	vldr	s15, [r7, #80]	; 0x50
 8017714:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8017718:	ee77 7a67 	vsub.f32	s15, s14, s15
 801771c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8017720:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017724:	d502      	bpl.n	801772c <nk_do_scrollbarv+0x44c>
 8017726:	ed5f 7a45 	vldr	s15, [pc, #-276]	; 8017614 <nk_do_scrollbarv+0x334>
 801772a:	e00d      	b.n	8017748 <nk_do_scrollbarv+0x468>
 801772c:	ed97 7a07 	vldr	s14, [r7, #28]
 8017730:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8017734:	ee37 7a27 	vadd.f32	s14, s14, s15
 8017738:	edd7 6a12 	vldr	s13, [r7, #72]	; 0x48
 801773c:	edd7 7a14 	vldr	s15, [r7, #80]	; 0x50
 8017740:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8017744:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017748:	edc7 7a18 	vstr	s15, [r7, #96]	; 0x60

    /* update scrollbar */
    scroll_offset = nk_scrollbar_behavior(state, in, has_scrolling, &scroll, &cursor,
 801774c:	f107 0218 	add.w	r2, r7, #24
 8017750:	2300      	movs	r3, #0
 8017752:	9303      	str	r3, [sp, #12]
 8017754:	f107 0354 	add.w	r3, r7, #84	; 0x54
 8017758:	9302      	str	r3, [sp, #8]
 801775a:	f107 0364 	add.w	r3, r7, #100	; 0x64
 801775e:	9301      	str	r3, [sp, #4]
 8017760:	f107 0344 	add.w	r3, r7, #68	; 0x44
 8017764:	9300      	str	r3, [sp, #0]
 8017766:	ed97 1a20 	vldr	s2, [r7, #128]	; 0x80
 801776a:	edd7 0a03 	vldr	s1, [r7, #12]
 801776e:	ed97 0a1f 	vldr	s0, [r7, #124]	; 0x7c
 8017772:	4613      	mov	r3, r2
 8017774:	697a      	ldr	r2, [r7, #20]
 8017776:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
 801777a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801777c:	f7ff f90e 	bl	801699c <nk_scrollbar_behavior>
 8017780:	ed87 0a1f 	vstr	s0, [r7, #124]	; 0x7c
        &empty_north, &empty_south, scroll_offset, target, scroll_step, NK_VERTICAL);
    scroll_off = scroll_offset / target;
 8017784:	edd7 6a1f 	vldr	s13, [r7, #124]	; 0x7c
 8017788:	ed97 7a03 	vldr	s14, [r7, #12]
 801778c:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8017790:	edc7 7a1d 	vstr	s15, [r7, #116]	; 0x74
    cursor.y = scroll.y + (scroll_off * scroll.h) + style->border_cursor + style->padding.y;
 8017794:	ed97 7a07 	vldr	s14, [r7, #28]
 8017798:	edd7 6a09 	vldr	s13, [r7, #36]	; 0x24
 801779c:	edd7 7a1d 	vldr	s15, [r7, #116]	; 0x74
 80177a0:	ee66 7aa7 	vmul.f32	s15, s13, s15
 80177a4:	ee37 7a27 	vadd.f32	s14, s14, s15
 80177a8:	683b      	ldr	r3, [r7, #0]
 80177aa:	edd3 7a2e 	vldr	s15, [r3, #184]	; 0xb8
 80177ae:	ee37 7a27 	vadd.f32	s14, s14, s15
 80177b2:	683b      	ldr	r3, [r7, #0]
 80177b4:	edd3 7a31 	vldr	s15, [r3, #196]	; 0xc4
 80177b8:	ee77 7a27 	vadd.f32	s15, s14, s15
 80177bc:	edc7 7a12 	vstr	s15, [r7, #72]	; 0x48

    /* draw scrollbar */
    if (style->draw_begin) style->draw_begin(out, style->userdata);
 80177c0:	683b      	ldr	r3, [r7, #0]
 80177c2:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 80177c6:	2b00      	cmp	r3, #0
 80177c8:	d007      	beq.n	80177da <nk_do_scrollbarv+0x4fa>
 80177ca:	683b      	ldr	r3, [r7, #0]
 80177cc:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 80177d0:	683a      	ldr	r2, [r7, #0]
 80177d2:	f8d2 1200 	ldr.w	r1, [r2, #512]	; 0x200
 80177d6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80177d8:	4798      	blx	r3
    nk_draw_scrollbar(out, *state, style, &scroll, &cursor);
 80177da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80177dc:	6819      	ldr	r1, [r3, #0]
 80177de:	f107 0218 	add.w	r2, r7, #24
 80177e2:	f107 0344 	add.w	r3, r7, #68	; 0x44
 80177e6:	9300      	str	r3, [sp, #0]
 80177e8:	4613      	mov	r3, r2
 80177ea:	683a      	ldr	r2, [r7, #0]
 80177ec:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80177ee:	f7ff fc5b 	bl	80170a8 <nk_draw_scrollbar>
    if (style->draw_end) style->draw_end(out, style->userdata);
 80177f2:	683b      	ldr	r3, [r7, #0]
 80177f4:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
 80177f8:	2b00      	cmp	r3, #0
 80177fa:	d007      	beq.n	801780c <nk_do_scrollbarv+0x52c>
 80177fc:	683b      	ldr	r3, [r7, #0]
 80177fe:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
 8017802:	683a      	ldr	r2, [r7, #0]
 8017804:	f8d2 1200 	ldr.w	r1, [r2, #512]	; 0x200
 8017808:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801780a:	4798      	blx	r3
    return scroll_offset;
 801780c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
}
 801780e:	ee07 3a90 	vmov	s15, r3
 8017812:	eeb0 0a67 	vmov.f32	s0, s15
 8017816:	3788      	adds	r7, #136	; 0x88
 8017818:	46bd      	mov	sp, r7
 801781a:	bd80      	pop	{r7, pc}

0801781c <nk_do_scrollbarh>:
nk_do_scrollbarh(nk_flags *state,
    struct nk_command_buffer *out, struct nk_rect scroll, int has_scrolling,
    float offset, float target, float step, float button_pixel_inc,
    const struct nk_style_scrollbar *style, struct nk_input *in,
    const struct nk_user_font *font)
{
 801781c:	b580      	push	{r7, lr}
 801781e:	b0a6      	sub	sp, #152	; 0x98
 8017820:	af04      	add	r7, sp, #16
 8017822:	62f8      	str	r0, [r7, #44]	; 0x2c
 8017824:	62b9      	str	r1, [r7, #40]	; 0x28
 8017826:	eeb0 6a40 	vmov.f32	s12, s0
 801782a:	eef0 6a60 	vmov.f32	s13, s1
 801782e:	eeb0 7a41 	vmov.f32	s14, s2
 8017832:	eef0 7a61 	vmov.f32	s15, s3
 8017836:	617a      	str	r2, [r7, #20]
 8017838:	ed87 2a04 	vstr	s4, [r7, #16]
 801783c:	edc7 2a03 	vstr	s5, [r7, #12]
 8017840:	ed87 3a02 	vstr	s6, [r7, #8]
 8017844:	edc7 3a01 	vstr	s7, [r7, #4]
 8017848:	603b      	str	r3, [r7, #0]
 801784a:	ed87 6a06 	vstr	s12, [r7, #24]
 801784e:	edc7 6a07 	vstr	s13, [r7, #28]
 8017852:	ed87 7a08 	vstr	s14, [r7, #32]
 8017856:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
    float scroll_step;
    float scroll_offset;
    float scroll_off;
    float scroll_ratio;

    NK_ASSERT(out);
 801785a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801785c:	2b00      	cmp	r3, #0
 801785e:	d105      	bne.n	801786c <nk_do_scrollbarh+0x50>
 8017860:	4b94      	ldr	r3, [pc, #592]	; (8017ab4 <nk_do_scrollbarh+0x298>)
 8017862:	4a95      	ldr	r2, [pc, #596]	; (8017ab8 <nk_do_scrollbarh+0x29c>)
 8017864:	21ee      	movs	r1, #238	; 0xee
 8017866:	4895      	ldr	r0, [pc, #596]	; (8017abc <nk_do_scrollbarh+0x2a0>)
 8017868:	f006 f8d6 	bl	801da18 <__assert_func>
    NK_ASSERT(style);
 801786c:	683b      	ldr	r3, [r7, #0]
 801786e:	2b00      	cmp	r3, #0
 8017870:	d105      	bne.n	801787e <nk_do_scrollbarh+0x62>
 8017872:	4b93      	ldr	r3, [pc, #588]	; (8017ac0 <nk_do_scrollbarh+0x2a4>)
 8017874:	4a90      	ldr	r2, [pc, #576]	; (8017ab8 <nk_do_scrollbarh+0x29c>)
 8017876:	21ef      	movs	r1, #239	; 0xef
 8017878:	4890      	ldr	r0, [pc, #576]	; (8017abc <nk_do_scrollbarh+0x2a0>)
 801787a:	f006 f8cd 	bl	801da18 <__assert_func>
    if (!out || !style) return 0;
 801787e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017880:	2b00      	cmp	r3, #0
 8017882:	d002      	beq.n	801788a <nk_do_scrollbarh+0x6e>
 8017884:	683b      	ldr	r3, [r7, #0]
 8017886:	2b00      	cmp	r3, #0
 8017888:	d102      	bne.n	8017890 <nk_do_scrollbarh+0x74>
 801788a:	f04f 0300 	mov.w	r3, #0
 801788e:	e200      	b.n	8017c92 <nk_do_scrollbarh+0x476>

    /* scrollbar background */
    scroll.h = NK_MAX(scroll.h, 1);
 8017890:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8017894:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8017898:	eef4 7ac7 	vcmpe.f32	s15, s14
 801789c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80178a0:	d502      	bpl.n	80178a8 <nk_do_scrollbarh+0x8c>
 80178a2:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 80178a6:	e000      	b.n	80178aa <nk_do_scrollbarh+0x8e>
 80178a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80178aa:	627b      	str	r3, [r7, #36]	; 0x24
    scroll.w = NK_MAX(scroll.w, 2 * scroll.h);
 80178ac:	ed97 7a08 	vldr	s14, [r7, #32]
 80178b0:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 80178b4:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80178b8:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80178bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80178c0:	d504      	bpl.n	80178cc <nk_do_scrollbarh+0xb0>
 80178c2:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 80178c6:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80178ca:	e001      	b.n	80178d0 <nk_do_scrollbarh+0xb4>
 80178cc:	edd7 7a08 	vldr	s15, [r7, #32]
 80178d0:	edc7 7a08 	vstr	s15, [r7, #32]
    if (target <= scroll.w) return 0;
 80178d4:	edd7 7a08 	vldr	s15, [r7, #32]
 80178d8:	ed97 7a03 	vldr	s14, [r7, #12]
 80178dc:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80178e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80178e4:	d802      	bhi.n	80178ec <nk_do_scrollbarh+0xd0>
 80178e6:	f04f 0300 	mov.w	r3, #0
 80178ea:	e1d2      	b.n	8017c92 <nk_do_scrollbarh+0x476>

    /* optional scrollbar buttons */
    if (style->show_buttons) {
 80178ec:	683b      	ldr	r3, [r7, #0]
 80178ee:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 80178f2:	2b00      	cmp	r3, #0
 80178f4:	f000 8094 	beq.w	8017a20 <nk_do_scrollbarh+0x204>
        nk_flags ws;
        float scroll_w;
        struct nk_rect button;
        button.y = scroll.y;
 80178f8:	69fb      	ldr	r3, [r7, #28]
 80178fa:	637b      	str	r3, [r7, #52]	; 0x34
        button.w = scroll.h;
 80178fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80178fe:	63bb      	str	r3, [r7, #56]	; 0x38
        button.h = scroll.h;
 8017900:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017902:	63fb      	str	r3, [r7, #60]	; 0x3c

        scroll_w = scroll.w - 2 * button.w;
 8017904:	ed97 7a08 	vldr	s14, [r7, #32]
 8017908:	edd7 7a0e 	vldr	s15, [r7, #56]	; 0x38
 801790c:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8017910:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017914:	edc7 7a21 	vstr	s15, [r7, #132]	; 0x84
        scroll_step = NK_MIN(step, button_pixel_inc);
 8017918:	ed97 7a02 	vldr	s14, [r7, #8]
 801791c:	edd7 7a01 	vldr	s15, [r7, #4]
 8017920:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8017924:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017928:	d501      	bpl.n	801792e <nk_do_scrollbarh+0x112>
 801792a:	68bb      	ldr	r3, [r7, #8]
 801792c:	e000      	b.n	8017930 <nk_do_scrollbarh+0x114>
 801792e:	687b      	ldr	r3, [r7, #4]
 8017930:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

        /* decrement button */
        button.x = scroll.x;
 8017934:	69bb      	ldr	r3, [r7, #24]
 8017936:	633b      	str	r3, [r7, #48]	; 0x30
        if (nk_do_button_symbol(&ws, out, button, style->dec_symbol,
 8017938:	683b      	ldr	r3, [r7, #0]
 801793a:	f893 11fd 	ldrb.w	r1, [r3, #509]	; 0x1fd
 801793e:	683b      	ldr	r3, [r7, #0]
 8017940:	f503 73b2 	add.w	r3, r3, #356	; 0x164
 8017944:	ed97 6a0c 	vldr	s12, [r7, #48]	; 0x30
 8017948:	edd7 6a0d 	vldr	s13, [r7, #52]	; 0x34
 801794c:	ed97 7a0e 	vldr	s14, [r7, #56]	; 0x38
 8017950:	edd7 7a0f 	vldr	s15, [r7, #60]	; 0x3c
 8017954:	f107 0040 	add.w	r0, r7, #64	; 0x40
 8017958:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 801795c:	9202      	str	r2, [sp, #8]
 801795e:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8017962:	9201      	str	r2, [sp, #4]
 8017964:	9300      	str	r3, [sp, #0]
 8017966:	2301      	movs	r3, #1
 8017968:	460a      	mov	r2, r1
 801796a:	eeb0 0a46 	vmov.f32	s0, s12
 801796e:	eef0 0a66 	vmov.f32	s1, s13
 8017972:	eeb0 1a47 	vmov.f32	s2, s14
 8017976:	eef0 1a67 	vmov.f32	s3, s15
 801797a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801797c:	f7f6 fffa 	bl	800e974 <nk_do_button_symbol>
 8017980:	4603      	mov	r3, r0
 8017982:	2b00      	cmp	r3, #0
 8017984:	d007      	beq.n	8017996 <nk_do_scrollbarh+0x17a>
            NK_BUTTON_REPEATER, &style->dec_button, in, font))
            offset = offset - scroll_step;
 8017986:	ed97 7a04 	vldr	s14, [r7, #16]
 801798a:	edd7 7a20 	vldr	s15, [r7, #128]	; 0x80
 801798e:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017992:	edc7 7a04 	vstr	s15, [r7, #16]

        /* increment button */
        button.x = scroll.x + scroll.w - button.w;
 8017996:	ed97 7a06 	vldr	s14, [r7, #24]
 801799a:	edd7 7a08 	vldr	s15, [r7, #32]
 801799e:	ee37 7a27 	vadd.f32	s14, s14, s15
 80179a2:	edd7 7a0e 	vldr	s15, [r7, #56]	; 0x38
 80179a6:	ee77 7a67 	vsub.f32	s15, s14, s15
 80179aa:	edc7 7a0c 	vstr	s15, [r7, #48]	; 0x30
        if (nk_do_button_symbol(&ws, out, button, style->inc_symbol,
 80179ae:	683b      	ldr	r3, [r7, #0]
 80179b0:	f893 11fc 	ldrb.w	r1, [r3, #508]	; 0x1fc
 80179b4:	683b      	ldr	r3, [r7, #0]
 80179b6:	33cc      	adds	r3, #204	; 0xcc
 80179b8:	ed97 6a0c 	vldr	s12, [r7, #48]	; 0x30
 80179bc:	edd7 6a0d 	vldr	s13, [r7, #52]	; 0x34
 80179c0:	ed97 7a0e 	vldr	s14, [r7, #56]	; 0x38
 80179c4:	edd7 7a0f 	vldr	s15, [r7, #60]	; 0x3c
 80179c8:	f107 0040 	add.w	r0, r7, #64	; 0x40
 80179cc:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 80179d0:	9202      	str	r2, [sp, #8]
 80179d2:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 80179d6:	9201      	str	r2, [sp, #4]
 80179d8:	9300      	str	r3, [sp, #0]
 80179da:	2301      	movs	r3, #1
 80179dc:	460a      	mov	r2, r1
 80179de:	eeb0 0a46 	vmov.f32	s0, s12
 80179e2:	eef0 0a66 	vmov.f32	s1, s13
 80179e6:	eeb0 1a47 	vmov.f32	s2, s14
 80179ea:	eef0 1a67 	vmov.f32	s3, s15
 80179ee:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80179f0:	f7f6 ffc0 	bl	800e974 <nk_do_button_symbol>
 80179f4:	4603      	mov	r3, r0
 80179f6:	2b00      	cmp	r3, #0
 80179f8:	d007      	beq.n	8017a0a <nk_do_scrollbarh+0x1ee>
            NK_BUTTON_REPEATER, &style->inc_button, in, font))
            offset = offset + scroll_step;
 80179fa:	ed97 7a04 	vldr	s14, [r7, #16]
 80179fe:	edd7 7a20 	vldr	s15, [r7, #128]	; 0x80
 8017a02:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017a06:	edc7 7a04 	vstr	s15, [r7, #16]

        scroll.x = scroll.x + button.w;
 8017a0a:	ed97 7a06 	vldr	s14, [r7, #24]
 8017a0e:	edd7 7a0e 	vldr	s15, [r7, #56]	; 0x38
 8017a12:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017a16:	edc7 7a06 	vstr	s15, [r7, #24]
        scroll.w = scroll_w;
 8017a1a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017a1e:	623b      	str	r3, [r7, #32]
    }

    /* calculate scrollbar constants */
    scroll_step = NK_MIN(step, scroll.w);
 8017a20:	edd7 7a08 	vldr	s15, [r7, #32]
 8017a24:	ed97 7a02 	vldr	s14, [r7, #8]
 8017a28:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8017a2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017a30:	d501      	bpl.n	8017a36 <nk_do_scrollbarh+0x21a>
 8017a32:	68bb      	ldr	r3, [r7, #8]
 8017a34:	e000      	b.n	8017a38 <nk_do_scrollbarh+0x21c>
 8017a36:	6a3b      	ldr	r3, [r7, #32]
 8017a38:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
    scroll_offset = NK_CLAMP(0, offset, target - scroll.w);
 8017a3c:	edd7 7a08 	vldr	s15, [r7, #32]
 8017a40:	ed97 7a03 	vldr	s14, [r7, #12]
 8017a44:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017a48:	ed97 7a04 	vldr	s14, [r7, #16]
 8017a4c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8017a50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017a54:	d50a      	bpl.n	8017a6c <nk_do_scrollbarh+0x250>
 8017a56:	edd7 7a04 	vldr	s15, [r7, #16]
 8017a5a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8017a5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017a62:	bf4c      	ite	mi
 8017a64:	2301      	movmi	r3, #1
 8017a66:	2300      	movpl	r3, #0
 8017a68:	b2db      	uxtb	r3, r3
 8017a6a:	e00d      	b.n	8017a88 <nk_do_scrollbarh+0x26c>
 8017a6c:	edd7 7a08 	vldr	s15, [r7, #32]
 8017a70:	ed97 7a03 	vldr	s14, [r7, #12]
 8017a74:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017a78:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8017a7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017a80:	bf4c      	ite	mi
 8017a82:	2301      	movmi	r3, #1
 8017a84:	2300      	movpl	r3, #0
 8017a86:	b2db      	uxtb	r3, r3
 8017a88:	2b00      	cmp	r3, #0
 8017a8a:	d002      	beq.n	8017a92 <nk_do_scrollbarh+0x276>
 8017a8c:	eddf 7a0d 	vldr	s15, [pc, #52]	; 8017ac4 <nk_do_scrollbarh+0x2a8>
 8017a90:	e020      	b.n	8017ad4 <nk_do_scrollbarh+0x2b8>
 8017a92:	edd7 7a08 	vldr	s15, [r7, #32]
 8017a96:	ed97 7a03 	vldr	s14, [r7, #12]
 8017a9a:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017a9e:	ed97 7a04 	vldr	s14, [r7, #16]
 8017aa2:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8017aa6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017aaa:	d50d      	bpl.n	8017ac8 <nk_do_scrollbarh+0x2ac>
 8017aac:	edd7 7a04 	vldr	s15, [r7, #16]
 8017ab0:	e010      	b.n	8017ad4 <nk_do_scrollbarh+0x2b8>
 8017ab2:	bf00      	nop
 8017ab4:	08021b70 	.word	0x08021b70
 8017ab8:	08023654 	.word	0x08023654
 8017abc:	08021b74 	.word	0x08021b74
 8017ac0:	08021b94 	.word	0x08021b94
 8017ac4:	00000000 	.word	0x00000000
 8017ac8:	edd7 7a08 	vldr	s15, [r7, #32]
 8017acc:	ed97 7a03 	vldr	s14, [r7, #12]
 8017ad0:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017ad4:	edc7 7a1f 	vstr	s15, [r7, #124]	; 0x7c
    scroll_ratio = scroll.w / target;
 8017ad8:	edd7 6a08 	vldr	s13, [r7, #32]
 8017adc:	ed97 7a03 	vldr	s14, [r7, #12]
 8017ae0:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8017ae4:	edc7 7a1e 	vstr	s15, [r7, #120]	; 0x78
    scroll_off = scroll_offset / target;
 8017ae8:	edd7 6a1f 	vldr	s13, [r7, #124]	; 0x7c
 8017aec:	ed97 7a03 	vldr	s14, [r7, #12]
 8017af0:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8017af4:	edc7 7a1d 	vstr	s15, [r7, #116]	; 0x74

    /* calculate cursor bounds */
    cursor.w = (scroll_ratio * scroll.w) - (2*style->border + 2*style->padding.x);
 8017af8:	ed97 7a08 	vldr	s14, [r7, #32]
 8017afc:	edd7 7a1e 	vldr	s15, [r7, #120]	; 0x78
 8017b00:	ee27 7a27 	vmul.f32	s14, s14, s15
 8017b04:	683b      	ldr	r3, [r7, #0]
 8017b06:	edd3 7a2c 	vldr	s15, [r3, #176]	; 0xb0
 8017b0a:	ee77 6aa7 	vadd.f32	s13, s15, s15
 8017b0e:	683b      	ldr	r3, [r7, #0]
 8017b10:	edd3 7a30 	vldr	s15, [r3, #192]	; 0xc0
 8017b14:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8017b18:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8017b1c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017b20:	edc7 7a1b 	vstr	s15, [r7, #108]	; 0x6c
    cursor.x = scroll.x + (scroll_off * scroll.w) + style->border + style->padding.x;
 8017b24:	ed97 7a06 	vldr	s14, [r7, #24]
 8017b28:	edd7 6a08 	vldr	s13, [r7, #32]
 8017b2c:	edd7 7a1d 	vldr	s15, [r7, #116]	; 0x74
 8017b30:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8017b34:	ee37 7a27 	vadd.f32	s14, s14, s15
 8017b38:	683b      	ldr	r3, [r7, #0]
 8017b3a:	edd3 7a2c 	vldr	s15, [r3, #176]	; 0xb0
 8017b3e:	ee37 7a27 	vadd.f32	s14, s14, s15
 8017b42:	683b      	ldr	r3, [r7, #0]
 8017b44:	edd3 7a30 	vldr	s15, [r3, #192]	; 0xc0
 8017b48:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017b4c:	edc7 7a19 	vstr	s15, [r7, #100]	; 0x64
    cursor.h = scroll.h - (2 * style->border + 2 * style->padding.y);
 8017b50:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 8017b54:	683b      	ldr	r3, [r7, #0]
 8017b56:	edd3 7a2c 	vldr	s15, [r3, #176]	; 0xb0
 8017b5a:	ee77 6aa7 	vadd.f32	s13, s15, s15
 8017b5e:	683b      	ldr	r3, [r7, #0]
 8017b60:	edd3 7a31 	vldr	s15, [r3, #196]	; 0xc4
 8017b64:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8017b68:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8017b6c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017b70:	edc7 7a1c 	vstr	s15, [r7, #112]	; 0x70
    cursor.y = scroll.y + style->border + style->padding.y;
 8017b74:	ed97 7a07 	vldr	s14, [r7, #28]
 8017b78:	683b      	ldr	r3, [r7, #0]
 8017b7a:	edd3 7a2c 	vldr	s15, [r3, #176]	; 0xb0
 8017b7e:	ee37 7a27 	vadd.f32	s14, s14, s15
 8017b82:	683b      	ldr	r3, [r7, #0]
 8017b84:	edd3 7a31 	vldr	s15, [r3, #196]	; 0xc4
 8017b88:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017b8c:	edc7 7a1a 	vstr	s15, [r7, #104]	; 0x68

    /* calculate empty space around cursor */
    empty_west.x = scroll.x;
 8017b90:	69bb      	ldr	r3, [r7, #24]
 8017b92:	657b      	str	r3, [r7, #84]	; 0x54
    empty_west.y = scroll.y;
 8017b94:	69fb      	ldr	r3, [r7, #28]
 8017b96:	65bb      	str	r3, [r7, #88]	; 0x58
    empty_west.w = cursor.x - scroll.x;
 8017b98:	ed97 7a19 	vldr	s14, [r7, #100]	; 0x64
 8017b9c:	edd7 7a06 	vldr	s15, [r7, #24]
 8017ba0:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017ba4:	edc7 7a17 	vstr	s15, [r7, #92]	; 0x5c
    empty_west.h = scroll.h;
 8017ba8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017baa:	663b      	str	r3, [r7, #96]	; 0x60

    empty_east.x = cursor.x + cursor.w;
 8017bac:	ed97 7a19 	vldr	s14, [r7, #100]	; 0x64
 8017bb0:	edd7 7a1b 	vldr	s15, [r7, #108]	; 0x6c
 8017bb4:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017bb8:	edc7 7a11 	vstr	s15, [r7, #68]	; 0x44
    empty_east.y = scroll.y;
 8017bbc:	69fb      	ldr	r3, [r7, #28]
 8017bbe:	64bb      	str	r3, [r7, #72]	; 0x48
    empty_east.w = (scroll.x + scroll.w) - (cursor.x + cursor.w);
 8017bc0:	ed97 7a06 	vldr	s14, [r7, #24]
 8017bc4:	edd7 7a08 	vldr	s15, [r7, #32]
 8017bc8:	ee37 7a27 	vadd.f32	s14, s14, s15
 8017bcc:	edd7 6a19 	vldr	s13, [r7, #100]	; 0x64
 8017bd0:	edd7 7a1b 	vldr	s15, [r7, #108]	; 0x6c
 8017bd4:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8017bd8:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017bdc:	edc7 7a13 	vstr	s15, [r7, #76]	; 0x4c
    empty_east.h = scroll.h;
 8017be0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017be2:	653b      	str	r3, [r7, #80]	; 0x50

    /* update scrollbar */
    scroll_offset = nk_scrollbar_behavior(state, in, has_scrolling, &scroll, &cursor,
 8017be4:	f107 0218 	add.w	r2, r7, #24
 8017be8:	2301      	movs	r3, #1
 8017bea:	9303      	str	r3, [sp, #12]
 8017bec:	f107 0344 	add.w	r3, r7, #68	; 0x44
 8017bf0:	9302      	str	r3, [sp, #8]
 8017bf2:	f107 0354 	add.w	r3, r7, #84	; 0x54
 8017bf6:	9301      	str	r3, [sp, #4]
 8017bf8:	f107 0364 	add.w	r3, r7, #100	; 0x64
 8017bfc:	9300      	str	r3, [sp, #0]
 8017bfe:	ed97 1a20 	vldr	s2, [r7, #128]	; 0x80
 8017c02:	edd7 0a03 	vldr	s1, [r7, #12]
 8017c06:	ed97 0a1f 	vldr	s0, [r7, #124]	; 0x7c
 8017c0a:	4613      	mov	r3, r2
 8017c0c:	697a      	ldr	r2, [r7, #20]
 8017c0e:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
 8017c12:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8017c14:	f7fe fec2 	bl	801699c <nk_scrollbar_behavior>
 8017c18:	ed87 0a1f 	vstr	s0, [r7, #124]	; 0x7c
        &empty_west, &empty_east, scroll_offset, target, scroll_step, NK_HORIZONTAL);
    scroll_off = scroll_offset / target;
 8017c1c:	edd7 6a1f 	vldr	s13, [r7, #124]	; 0x7c
 8017c20:	ed97 7a03 	vldr	s14, [r7, #12]
 8017c24:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8017c28:	edc7 7a1d 	vstr	s15, [r7, #116]	; 0x74
    cursor.x = scroll.x + (scroll_off * scroll.w);
 8017c2c:	ed97 7a06 	vldr	s14, [r7, #24]
 8017c30:	edd7 6a08 	vldr	s13, [r7, #32]
 8017c34:	edd7 7a1d 	vldr	s15, [r7, #116]	; 0x74
 8017c38:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8017c3c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017c40:	edc7 7a19 	vstr	s15, [r7, #100]	; 0x64

    /* draw scrollbar */
    if (style->draw_begin) style->draw_begin(out, style->userdata);
 8017c44:	683b      	ldr	r3, [r7, #0]
 8017c46:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 8017c4a:	2b00      	cmp	r3, #0
 8017c4c:	d007      	beq.n	8017c5e <nk_do_scrollbarh+0x442>
 8017c4e:	683b      	ldr	r3, [r7, #0]
 8017c50:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 8017c54:	683a      	ldr	r2, [r7, #0]
 8017c56:	f8d2 1200 	ldr.w	r1, [r2, #512]	; 0x200
 8017c5a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8017c5c:	4798      	blx	r3
    nk_draw_scrollbar(out, *state, style, &scroll, &cursor);
 8017c5e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017c60:	6819      	ldr	r1, [r3, #0]
 8017c62:	f107 0218 	add.w	r2, r7, #24
 8017c66:	f107 0364 	add.w	r3, r7, #100	; 0x64
 8017c6a:	9300      	str	r3, [sp, #0]
 8017c6c:	4613      	mov	r3, r2
 8017c6e:	683a      	ldr	r2, [r7, #0]
 8017c70:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8017c72:	f7ff fa19 	bl	80170a8 <nk_draw_scrollbar>
    if (style->draw_end) style->draw_end(out, style->userdata);
 8017c76:	683b      	ldr	r3, [r7, #0]
 8017c78:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
 8017c7c:	2b00      	cmp	r3, #0
 8017c7e:	d007      	beq.n	8017c90 <nk_do_scrollbarh+0x474>
 8017c80:	683b      	ldr	r3, [r7, #0]
 8017c82:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
 8017c86:	683a      	ldr	r2, [r7, #0]
 8017c88:	f8d2 1200 	ldr.w	r1, [r2, #512]	; 0x200
 8017c8c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8017c8e:	4798      	blx	r3
    return scroll_offset;
 8017c90:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
}
 8017c92:	ee07 3a90 	vmov	s15, r3
 8017c96:	eeb0 0a67 	vmov.f32	s0, s15
 8017c9a:	3788      	adds	r7, #136	; 0x88
 8017c9c:	46bd      	mov	sp, r7
 8017c9e:	bd80      	pop	{r7, pc}

08017ca0 <nk_slider_behavior>:
NK_LIB float
nk_slider_behavior(nk_flags *state, struct nk_rect *logical_cursor,
    struct nk_rect *visual_cursor, struct nk_input *in,
    struct nk_rect bounds, float slider_min, float slider_max, float slider_value,
    float slider_step, float slider_steps)
{
 8017ca0:	b580      	push	{r7, lr}
 8017ca2:	b094      	sub	sp, #80	; 0x50
 8017ca4:	af00      	add	r7, sp, #0
 8017ca6:	6378      	str	r0, [r7, #52]	; 0x34
 8017ca8:	6339      	str	r1, [r7, #48]	; 0x30
 8017caa:	62fa      	str	r2, [r7, #44]	; 0x2c
 8017cac:	62bb      	str	r3, [r7, #40]	; 0x28
 8017cae:	eeb0 6a40 	vmov.f32	s12, s0
 8017cb2:	eef0 6a60 	vmov.f32	s13, s1
 8017cb6:	eeb0 7a41 	vmov.f32	s14, s2
 8017cba:	eef0 7a61 	vmov.f32	s15, s3
 8017cbe:	ed87 2a05 	vstr	s4, [r7, #20]
 8017cc2:	edc7 2a04 	vstr	s5, [r7, #16]
 8017cc6:	ed87 3a03 	vstr	s6, [r7, #12]
 8017cca:	edc7 3a02 	vstr	s7, [r7, #8]
 8017cce:	ed87 4a01 	vstr	s8, [r7, #4]
 8017cd2:	ed87 6a06 	vstr	s12, [r7, #24]
 8017cd6:	edc7 6a07 	vstr	s13, [r7, #28]
 8017cda:	ed87 7a08 	vstr	s14, [r7, #32]
 8017cde:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
    int left_mouse_down;
    int left_mouse_click_in_cursor;

    /* check if visual cursor is being dragged */
    nk_widget_state_reset(state);
 8017ce2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017ce4:	681b      	ldr	r3, [r3, #0]
 8017ce6:	f003 0302 	and.w	r3, r3, #2
 8017cea:	2b00      	cmp	r3, #0
 8017cec:	d003      	beq.n	8017cf6 <nk_slider_behavior+0x56>
 8017cee:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017cf0:	2206      	movs	r2, #6
 8017cf2:	601a      	str	r2, [r3, #0]
 8017cf4:	e002      	b.n	8017cfc <nk_slider_behavior+0x5c>
 8017cf6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017cf8:	2204      	movs	r2, #4
 8017cfa:	601a      	str	r2, [r3, #0]
    left_mouse_down = in && in->mouse.buttons[NK_BUTTON_LEFT].down;
 8017cfc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017cfe:	2b00      	cmp	r3, #0
 8017d00:	d006      	beq.n	8017d10 <nk_slider_behavior+0x70>
 8017d02:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017d04:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8017d08:	2b00      	cmp	r3, #0
 8017d0a:	d001      	beq.n	8017d10 <nk_slider_behavior+0x70>
 8017d0c:	2301      	movs	r3, #1
 8017d0e:	e000      	b.n	8017d12 <nk_slider_behavior+0x72>
 8017d10:	2300      	movs	r3, #0
 8017d12:	64fb      	str	r3, [r7, #76]	; 0x4c
    left_mouse_click_in_cursor = in && nk_input_has_mouse_click_down_in_rect(in,
 8017d14:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017d16:	2b00      	cmp	r3, #0
 8017d18:	d01a      	beq.n	8017d50 <nk_slider_behavior+0xb0>
 8017d1a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017d1c:	ed93 6a00 	vldr	s12, [r3]
 8017d20:	edd3 6a01 	vldr	s13, [r3, #4]
 8017d24:	ed93 7a02 	vldr	s14, [r3, #8]
 8017d28:	edd3 7a03 	vldr	s15, [r3, #12]
 8017d2c:	2201      	movs	r2, #1
 8017d2e:	eeb0 0a46 	vmov.f32	s0, s12
 8017d32:	eef0 0a66 	vmov.f32	s1, s13
 8017d36:	eeb0 1a47 	vmov.f32	s2, s14
 8017d3a:	eef0 1a67 	vmov.f32	s3, s15
 8017d3e:	2100      	movs	r1, #0
 8017d40:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8017d42:	f7fa fba5 	bl	8012490 <nk_input_has_mouse_click_down_in_rect>
 8017d46:	4603      	mov	r3, r0
 8017d48:	2b00      	cmp	r3, #0
 8017d4a:	d001      	beq.n	8017d50 <nk_slider_behavior+0xb0>
 8017d4c:	2301      	movs	r3, #1
 8017d4e:	e000      	b.n	8017d52 <nk_slider_behavior+0xb2>
 8017d50:	2300      	movs	r3, #0
 8017d52:	64bb      	str	r3, [r7, #72]	; 0x48
            NK_BUTTON_LEFT, *visual_cursor, nk_true);

    if (left_mouse_down && left_mouse_click_in_cursor) {
 8017d54:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8017d56:	2b00      	cmp	r3, #0
 8017d58:	f000 80b1 	beq.w	8017ebe <nk_slider_behavior+0x21e>
 8017d5c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017d5e:	2b00      	cmp	r3, #0
 8017d60:	f000 80ad 	beq.w	8017ebe <nk_slider_behavior+0x21e>
        float ratio = 0;
 8017d64:	f04f 0300 	mov.w	r3, #0
 8017d68:	647b      	str	r3, [r7, #68]	; 0x44
        const float d = in->mouse.pos.x - (visual_cursor->x+visual_cursor->w*0.5f);
 8017d6a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017d6c:	ed93 7a51 	vldr	s14, [r3, #324]	; 0x144
 8017d70:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017d72:	edd3 6a00 	vldr	s13, [r3]
 8017d76:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017d78:	edd3 7a02 	vldr	s15, [r3, #8]
 8017d7c:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
 8017d80:	ee67 7a86 	vmul.f32	s15, s15, s12
 8017d84:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8017d88:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017d8c:	edc7 7a10 	vstr	s15, [r7, #64]	; 0x40
        const float pxstep = bounds.w / slider_steps;
 8017d90:	edd7 6a08 	vldr	s13, [r7, #32]
 8017d94:	ed97 7a01 	vldr	s14, [r7, #4]
 8017d98:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8017d9c:	edc7 7a0f 	vstr	s15, [r7, #60]	; 0x3c

        /* only update value if the next slider step is reached */
        *state = NK_WIDGET_STATE_ACTIVE;
 8017da0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017da2:	2222      	movs	r2, #34	; 0x22
 8017da4:	601a      	str	r2, [r3, #0]
        if (NK_ABS(d) >= pxstep) {
 8017da6:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
 8017daa:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8017dae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017db2:	d504      	bpl.n	8017dbe <nk_slider_behavior+0x11e>
 8017db4:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
 8017db8:	eef1 7a67 	vneg.f32	s15, s15
 8017dbc:	e001      	b.n	8017dc2 <nk_slider_behavior+0x122>
 8017dbe:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
 8017dc2:	ed97 7a0f 	vldr	s14, [r7, #60]	; 0x3c
 8017dc6:	eef4 7ac7 	vcmpe.f32	s15, s14
 8017dca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017dce:	db76      	blt.n	8017ebe <nk_slider_behavior+0x21e>
            const float steps = (float)((int)(NK_ABS(d) / pxstep));
 8017dd0:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
 8017dd4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8017dd8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017ddc:	d504      	bpl.n	8017de8 <nk_slider_behavior+0x148>
 8017dde:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
 8017de2:	eef1 7a67 	vneg.f32	s15, s15
 8017de6:	e001      	b.n	8017dec <nk_slider_behavior+0x14c>
 8017de8:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
 8017dec:	edd7 6a0f 	vldr	s13, [r7, #60]	; 0x3c
 8017df0:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8017df4:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 8017df8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8017dfc:	edc7 7a0e 	vstr	s15, [r7, #56]	; 0x38
            slider_value += (d > 0) ? (slider_step*steps) : -(slider_step*steps);
 8017e00:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
 8017e04:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8017e08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017e0c:	dd06      	ble.n	8017e1c <nk_slider_behavior+0x17c>
 8017e0e:	ed97 7a02 	vldr	s14, [r7, #8]
 8017e12:	edd7 7a0e 	vldr	s15, [r7, #56]	; 0x38
 8017e16:	ee67 7a27 	vmul.f32	s15, s14, s15
 8017e1a:	e007      	b.n	8017e2c <nk_slider_behavior+0x18c>
 8017e1c:	ed97 7a02 	vldr	s14, [r7, #8]
 8017e20:	edd7 7a0e 	vldr	s15, [r7, #56]	; 0x38
 8017e24:	ee67 7a27 	vmul.f32	s15, s14, s15
 8017e28:	eef1 7a67 	vneg.f32	s15, s15
 8017e2c:	ed97 7a03 	vldr	s14, [r7, #12]
 8017e30:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017e34:	edc7 7a03 	vstr	s15, [r7, #12]
            slider_value = NK_CLAMP(slider_min, slider_value, slider_max);
 8017e38:	ed97 7a03 	vldr	s14, [r7, #12]
 8017e3c:	edd7 7a04 	vldr	s15, [r7, #16]
 8017e40:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8017e44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017e48:	d502      	bpl.n	8017e50 <nk_slider_behavior+0x1b0>
 8017e4a:	edd7 7a03 	vldr	s15, [r7, #12]
 8017e4e:	e001      	b.n	8017e54 <nk_slider_behavior+0x1b4>
 8017e50:	edd7 7a04 	vldr	s15, [r7, #16]
 8017e54:	ed97 7a05 	vldr	s14, [r7, #20]
 8017e58:	eef4 7ac7 	vcmpe.f32	s15, s14
 8017e5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017e60:	d501      	bpl.n	8017e66 <nk_slider_behavior+0x1c6>
 8017e62:	697b      	ldr	r3, [r7, #20]
 8017e64:	e00b      	b.n	8017e7e <nk_slider_behavior+0x1de>
 8017e66:	ed97 7a03 	vldr	s14, [r7, #12]
 8017e6a:	edd7 7a04 	vldr	s15, [r7, #16]
 8017e6e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8017e72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017e76:	d501      	bpl.n	8017e7c <nk_slider_behavior+0x1dc>
 8017e78:	68fb      	ldr	r3, [r7, #12]
 8017e7a:	e000      	b.n	8017e7e <nk_slider_behavior+0x1de>
 8017e7c:	693b      	ldr	r3, [r7, #16]
 8017e7e:	60fb      	str	r3, [r7, #12]
            ratio = (slider_value - slider_min)/slider_step;
 8017e80:	ed97 7a03 	vldr	s14, [r7, #12]
 8017e84:	edd7 7a05 	vldr	s15, [r7, #20]
 8017e88:	ee77 6a67 	vsub.f32	s13, s14, s15
 8017e8c:	ed97 7a02 	vldr	s14, [r7, #8]
 8017e90:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8017e94:	edc7 7a11 	vstr	s15, [r7, #68]	; 0x44
            logical_cursor->x = bounds.x + (logical_cursor->w * ratio);
 8017e98:	ed97 7a06 	vldr	s14, [r7, #24]
 8017e9c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017e9e:	edd3 6a02 	vldr	s13, [r3, #8]
 8017ea2:	edd7 7a11 	vldr	s15, [r7, #68]	; 0x44
 8017ea6:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8017eaa:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017eae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017eb0:	edc3 7a00 	vstr	s15, [r3]
            in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x = logical_cursor->x;
 8017eb4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017eb6:	681a      	ldr	r2, [r3, #0]
 8017eb8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017eba:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
        }
    }

    /* slider widget state */
    if (nk_input_is_mouse_hovering_rect(in, bounds))
 8017ebe:	ed97 6a06 	vldr	s12, [r7, #24]
 8017ec2:	edd7 6a07 	vldr	s13, [r7, #28]
 8017ec6:	ed97 7a08 	vldr	s14, [r7, #32]
 8017eca:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8017ece:	eeb0 0a46 	vmov.f32	s0, s12
 8017ed2:	eef0 0a66 	vmov.f32	s1, s13
 8017ed6:	eeb0 1a47 	vmov.f32	s2, s14
 8017eda:	eef0 1a67 	vmov.f32	s3, s15
 8017ede:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8017ee0:	f7fa fb1d 	bl	801251e <nk_input_is_mouse_hovering_rect>
 8017ee4:	4603      	mov	r3, r0
 8017ee6:	2b00      	cmp	r3, #0
 8017ee8:	d002      	beq.n	8017ef0 <nk_slider_behavior+0x250>
        *state = NK_WIDGET_STATE_HOVERED;
 8017eea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017eec:	2212      	movs	r2, #18
 8017eee:	601a      	str	r2, [r3, #0]
    if (*state & NK_WIDGET_STATE_HOVER &&
 8017ef0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017ef2:	681b      	ldr	r3, [r3, #0]
 8017ef4:	f003 0310 	and.w	r3, r3, #16
 8017ef8:	2b00      	cmp	r3, #0
 8017efa:	d01c      	beq.n	8017f36 <nk_slider_behavior+0x296>
        !nk_input_is_mouse_prev_hovering_rect(in, bounds))
 8017efc:	ed97 6a06 	vldr	s12, [r7, #24]
 8017f00:	edd7 6a07 	vldr	s13, [r7, #28]
 8017f04:	ed97 7a08 	vldr	s14, [r7, #32]
 8017f08:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8017f0c:	eeb0 0a46 	vmov.f32	s0, s12
 8017f10:	eef0 0a66 	vmov.f32	s1, s13
 8017f14:	eeb0 1a47 	vmov.f32	s2, s14
 8017f18:	eef0 1a67 	vmov.f32	s3, s15
 8017f1c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8017f1e:	f7fa fb50 	bl	80125c2 <nk_input_is_mouse_prev_hovering_rect>
 8017f22:	4603      	mov	r3, r0
    if (*state & NK_WIDGET_STATE_HOVER &&
 8017f24:	2b00      	cmp	r3, #0
 8017f26:	d106      	bne.n	8017f36 <nk_slider_behavior+0x296>
        *state |= NK_WIDGET_STATE_ENTERED;
 8017f28:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017f2a:	681b      	ldr	r3, [r3, #0]
 8017f2c:	f043 0208 	orr.w	r2, r3, #8
 8017f30:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017f32:	601a      	str	r2, [r3, #0]
 8017f34:	e01b      	b.n	8017f6e <nk_slider_behavior+0x2ce>
    else if (nk_input_is_mouse_prev_hovering_rect(in, bounds))
 8017f36:	ed97 6a06 	vldr	s12, [r7, #24]
 8017f3a:	edd7 6a07 	vldr	s13, [r7, #28]
 8017f3e:	ed97 7a08 	vldr	s14, [r7, #32]
 8017f42:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8017f46:	eeb0 0a46 	vmov.f32	s0, s12
 8017f4a:	eef0 0a66 	vmov.f32	s1, s13
 8017f4e:	eeb0 1a47 	vmov.f32	s2, s14
 8017f52:	eef0 1a67 	vmov.f32	s3, s15
 8017f56:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8017f58:	f7fa fb33 	bl	80125c2 <nk_input_is_mouse_prev_hovering_rect>
 8017f5c:	4603      	mov	r3, r0
 8017f5e:	2b00      	cmp	r3, #0
 8017f60:	d005      	beq.n	8017f6e <nk_slider_behavior+0x2ce>
        *state |= NK_WIDGET_STATE_LEFT;
 8017f62:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017f64:	681b      	ldr	r3, [r3, #0]
 8017f66:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8017f6a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017f6c:	601a      	str	r2, [r3, #0]
    return slider_value;
 8017f6e:	68fb      	ldr	r3, [r7, #12]
 8017f70:	ee07 3a90 	vmov	s15, r3
}
 8017f74:	eeb0 0a67 	vmov.f32	s0, s15
 8017f78:	3750      	adds	r7, #80	; 0x50
 8017f7a:	46bd      	mov	sp, r7
 8017f7c:	bd80      	pop	{r7, pc}
	...

08017f80 <nk_draw_slider>:
NK_LIB void
nk_draw_slider(struct nk_command_buffer *out, nk_flags state,
    const struct nk_style_slider *style, const struct nk_rect *bounds,
    const struct nk_rect *visual_cursor, float min, float value, float max)
{
 8017f80:	b580      	push	{r7, lr}
 8017f82:	b094      	sub	sp, #80	; 0x50
 8017f84:	af00      	add	r7, sp, #0
 8017f86:	61f8      	str	r0, [r7, #28]
 8017f88:	61b9      	str	r1, [r7, #24]
 8017f8a:	617a      	str	r2, [r7, #20]
 8017f8c:	613b      	str	r3, [r7, #16]
 8017f8e:	ed87 0a03 	vstr	s0, [r7, #12]
 8017f92:	edc7 0a02 	vstr	s1, [r7, #8]
 8017f96:	ed87 1a01 	vstr	s2, [r7, #4]

    NK_UNUSED(min);
    NK_UNUSED(max);
    NK_UNUSED(value);

    if (state & NK_WIDGET_STATE_ACTIVED) {
 8017f9a:	69bb      	ldr	r3, [r7, #24]
 8017f9c:	f003 0320 	and.w	r3, r3, #32
 8017fa0:	2b00      	cmp	r3, #0
 8017fa2:	d009      	beq.n	8017fb8 <nk_draw_slider+0x38>
        background = &style->active;
 8017fa4:	697b      	ldr	r3, [r7, #20]
 8017fa6:	3338      	adds	r3, #56	; 0x38
 8017fa8:	64fb      	str	r3, [r7, #76]	; 0x4c
        bar_color = style->bar_active;
 8017faa:	697b      	ldr	r3, [r7, #20]
 8017fac:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8017fae:	627b      	str	r3, [r7, #36]	; 0x24
        cursor = &style->cursor_active;
 8017fb0:	697b      	ldr	r3, [r7, #20]
 8017fb2:	33a0      	adds	r3, #160	; 0xa0
 8017fb4:	64bb      	str	r3, [r7, #72]	; 0x48
 8017fb6:	e016      	b.n	8017fe6 <nk_draw_slider+0x66>
    } else if (state & NK_WIDGET_STATE_HOVER) {
 8017fb8:	69bb      	ldr	r3, [r7, #24]
 8017fba:	f003 0310 	and.w	r3, r3, #16
 8017fbe:	2b00      	cmp	r3, #0
 8017fc0:	d009      	beq.n	8017fd6 <nk_draw_slider+0x56>
        background = &style->hover;
 8017fc2:	697b      	ldr	r3, [r7, #20]
 8017fc4:	331c      	adds	r3, #28
 8017fc6:	64fb      	str	r3, [r7, #76]	; 0x4c
        bar_color = style->bar_hover;
 8017fc8:	697b      	ldr	r3, [r7, #20]
 8017fca:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8017fcc:	627b      	str	r3, [r7, #36]	; 0x24
        cursor = &style->cursor_hover;
 8017fce:	697b      	ldr	r3, [r7, #20]
 8017fd0:	3384      	adds	r3, #132	; 0x84
 8017fd2:	64bb      	str	r3, [r7, #72]	; 0x48
 8017fd4:	e007      	b.n	8017fe6 <nk_draw_slider+0x66>
    } else {
        background = &style->normal;
 8017fd6:	697b      	ldr	r3, [r7, #20]
 8017fd8:	64fb      	str	r3, [r7, #76]	; 0x4c
        bar_color = style->bar_normal;
 8017fda:	697b      	ldr	r3, [r7, #20]
 8017fdc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8017fde:	627b      	str	r3, [r7, #36]	; 0x24
        cursor = &style->cursor_normal;
 8017fe0:	697b      	ldr	r3, [r7, #20]
 8017fe2:	3368      	adds	r3, #104	; 0x68
 8017fe4:	64bb      	str	r3, [r7, #72]	; 0x48
    }
    /* calculate slider background bar */
    bar.x = bounds->x;
 8017fe6:	693b      	ldr	r3, [r7, #16]
 8017fe8:	681b      	ldr	r3, [r3, #0]
 8017fea:	62bb      	str	r3, [r7, #40]	; 0x28
    bar.y = (visual_cursor->y + visual_cursor->h/2) - bounds->h/12;
 8017fec:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8017fee:	ed93 7a01 	vldr	s14, [r3, #4]
 8017ff2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8017ff4:	edd3 6a03 	vldr	s13, [r3, #12]
 8017ff8:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 8017ffc:	eec6 7a86 	vdiv.f32	s15, s13, s12
 8018000:	ee37 7a27 	vadd.f32	s14, s14, s15
 8018004:	693b      	ldr	r3, [r7, #16]
 8018006:	edd3 6a03 	vldr	s13, [r3, #12]
 801800a:	eeb2 6a08 	vmov.f32	s12, #40	; 0x41400000  12.0
 801800e:	eec6 7a86 	vdiv.f32	s15, s13, s12
 8018012:	ee77 7a67 	vsub.f32	s15, s14, s15
 8018016:	edc7 7a0b 	vstr	s15, [r7, #44]	; 0x2c
    bar.w = bounds->w;
 801801a:	693b      	ldr	r3, [r7, #16]
 801801c:	689b      	ldr	r3, [r3, #8]
 801801e:	633b      	str	r3, [r7, #48]	; 0x30
    bar.h = bounds->h/6;
 8018020:	693b      	ldr	r3, [r7, #16]
 8018022:	ed93 7a03 	vldr	s14, [r3, #12]
 8018026:	eef1 6a08 	vmov.f32	s13, #24	; 0x40c00000  6.0
 801802a:	eec7 7a26 	vdiv.f32	s15, s14, s13
 801802e:	edc7 7a0d 	vstr	s15, [r7, #52]	; 0x34

    /* filled background bar style */
    fill.w = (visual_cursor->x + (visual_cursor->w/2.0f)) - bar.x;
 8018032:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8018034:	ed93 7a00 	vldr	s14, [r3]
 8018038:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801803a:	edd3 6a02 	vldr	s13, [r3, #8]
 801803e:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 8018042:	eec6 7a86 	vdiv.f32	s15, s13, s12
 8018046:	ee37 7a27 	vadd.f32	s14, s14, s15
 801804a:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
 801804e:	ee77 7a67 	vsub.f32	s15, s14, s15
 8018052:	edc7 7a10 	vstr	s15, [r7, #64]	; 0x40
    fill.x = bar.x;
 8018056:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018058:	63bb      	str	r3, [r7, #56]	; 0x38
    fill.y = bar.y;
 801805a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801805c:	63fb      	str	r3, [r7, #60]	; 0x3c
    fill.h = bar.h;
 801805e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018060:	647b      	str	r3, [r7, #68]	; 0x44

    /* draw background */
    switch(background->type) {
 8018062:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8018064:	781b      	ldrb	r3, [r3, #0]
 8018066:	2b02      	cmp	r3, #2
 8018068:	d01e      	beq.n	80180a8 <nk_draw_slider+0x128>
 801806a:	2b02      	cmp	r3, #2
 801806c:	dc71      	bgt.n	8018152 <nk_draw_slider+0x1d2>
 801806e:	2b00      	cmp	r3, #0
 8018070:	d033      	beq.n	80180da <nk_draw_slider+0x15a>
 8018072:	2b01      	cmp	r3, #1
 8018074:	d16d      	bne.n	8018152 <nk_draw_slider+0x1d2>
        case NK_STYLE_ITEM_IMAGE:
            nk_draw_image(out, *bounds, &background->data.image, nk_white);
 8018076:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8018078:	1d19      	adds	r1, r3, #4
 801807a:	4a6b      	ldr	r2, [pc, #428]	; (8018228 <nk_draw_slider+0x2a8>)
 801807c:	693b      	ldr	r3, [r7, #16]
 801807e:	ed93 6a00 	vldr	s12, [r3]
 8018082:	edd3 6a01 	vldr	s13, [r3, #4]
 8018086:	ed93 7a02 	vldr	s14, [r3, #8]
 801808a:	edd3 7a03 	vldr	s15, [r3, #12]
 801808e:	6812      	ldr	r2, [r2, #0]
 8018090:	eeb0 0a46 	vmov.f32	s0, s12
 8018094:	eef0 0a66 	vmov.f32	s1, s13
 8018098:	eeb0 1a47 	vmov.f32	s2, s14
 801809c:	eef0 1a67 	vmov.f32	s3, s15
 80180a0:	69f8      	ldr	r0, [r7, #28]
 80180a2:	f7f9 f955 	bl	8011350 <nk_draw_image>
            break;
 80180a6:	e054      	b.n	8018152 <nk_draw_slider+0x1d2>
        case NK_STYLE_ITEM_NINE_SLICE:
            nk_draw_nine_slice(out, *bounds, &background->data.slice, nk_white);
 80180a8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80180aa:	1d19      	adds	r1, r3, #4
 80180ac:	4a5e      	ldr	r2, [pc, #376]	; (8018228 <nk_draw_slider+0x2a8>)
 80180ae:	693b      	ldr	r3, [r7, #16]
 80180b0:	ed93 6a00 	vldr	s12, [r3]
 80180b4:	edd3 6a01 	vldr	s13, [r3, #4]
 80180b8:	ed93 7a02 	vldr	s14, [r3, #8]
 80180bc:	edd3 7a03 	vldr	s15, [r3, #12]
 80180c0:	6812      	ldr	r2, [r2, #0]
 80180c2:	eeb0 0a46 	vmov.f32	s0, s12
 80180c6:	eef0 0a66 	vmov.f32	s1, s13
 80180ca:	eeb0 1a47 	vmov.f32	s2, s14
 80180ce:	eef0 1a67 	vmov.f32	s3, s15
 80180d2:	69f8      	ldr	r0, [r7, #28]
 80180d4:	f7f9 fa2e 	bl	8011534 <nk_draw_nine_slice>
            break;
 80180d8:	e03b      	b.n	8018152 <nk_draw_slider+0x1d2>
        case NK_STYLE_ITEM_COLOR:
            nk_fill_rect(out, *bounds, style->rounding, background->data.color);
 80180da:	697b      	ldr	r3, [r7, #20]
 80180dc:	edd3 5a30 	vldr	s11, [r3, #192]	; 0xc0
 80180e0:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80180e2:	693b      	ldr	r3, [r7, #16]
 80180e4:	ed93 6a00 	vldr	s12, [r3]
 80180e8:	edd3 6a01 	vldr	s13, [r3, #4]
 80180ec:	ed93 7a02 	vldr	s14, [r3, #8]
 80180f0:	edd3 7a03 	vldr	s15, [r3, #12]
 80180f4:	6851      	ldr	r1, [r2, #4]
 80180f6:	eeb0 2a65 	vmov.f32	s4, s11
 80180fa:	eeb0 0a46 	vmov.f32	s0, s12
 80180fe:	eef0 0a66 	vmov.f32	s1, s13
 8018102:	eeb0 1a47 	vmov.f32	s2, s14
 8018106:	eef0 1a67 	vmov.f32	s3, s15
 801810a:	69f8      	ldr	r0, [r7, #28]
 801810c:	f7f8 fdc6 	bl	8010c9c <nk_fill_rect>
            nk_stroke_rect(out, *bounds, style->rounding, style->border, style->border_color);
 8018110:	697b      	ldr	r3, [r7, #20]
 8018112:	edd3 5a30 	vldr	s11, [r3, #192]	; 0xc0
 8018116:	697b      	ldr	r3, [r7, #20]
 8018118:	ed93 5a2f 	vldr	s10, [r3, #188]	; 0xbc
 801811c:	697a      	ldr	r2, [r7, #20]
 801811e:	693b      	ldr	r3, [r7, #16]
 8018120:	ed93 6a00 	vldr	s12, [r3]
 8018124:	edd3 6a01 	vldr	s13, [r3, #4]
 8018128:	ed93 7a02 	vldr	s14, [r3, #8]
 801812c:	edd3 7a03 	vldr	s15, [r3, #12]
 8018130:	6d51      	ldr	r1, [r2, #84]	; 0x54
 8018132:	eef0 2a45 	vmov.f32	s5, s10
 8018136:	eeb0 2a65 	vmov.f32	s4, s11
 801813a:	eeb0 0a46 	vmov.f32	s0, s12
 801813e:	eef0 0a66 	vmov.f32	s1, s13
 8018142:	eeb0 1a47 	vmov.f32	s2, s14
 8018146:	eef0 1a67 	vmov.f32	s3, s15
 801814a:	69f8      	ldr	r0, [r7, #28]
 801814c:	f7f8 fc9e 	bl	8010a8c <nk_stroke_rect>
            break;
 8018150:	bf00      	nop
    }

    /* draw slider bar */
    nk_fill_rect(out, bar, style->rounding, bar_color);
 8018152:	697b      	ldr	r3, [r7, #20]
 8018154:	edd3 5a30 	vldr	s11, [r3, #192]	; 0xc0
 8018158:	ed97 6a0a 	vldr	s12, [r7, #40]	; 0x28
 801815c:	edd7 6a0b 	vldr	s13, [r7, #44]	; 0x2c
 8018160:	ed97 7a0c 	vldr	s14, [r7, #48]	; 0x30
 8018164:	edd7 7a0d 	vldr	s15, [r7, #52]	; 0x34
 8018168:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801816a:	eeb0 2a65 	vmov.f32	s4, s11
 801816e:	eeb0 0a46 	vmov.f32	s0, s12
 8018172:	eef0 0a66 	vmov.f32	s1, s13
 8018176:	eeb0 1a47 	vmov.f32	s2, s14
 801817a:	eef0 1a67 	vmov.f32	s3, s15
 801817e:	69f8      	ldr	r0, [r7, #28]
 8018180:	f7f8 fd8c 	bl	8010c9c <nk_fill_rect>
    nk_fill_rect(out, fill, style->rounding, style->bar_filled);
 8018184:	697b      	ldr	r3, [r7, #20]
 8018186:	edd3 5a30 	vldr	s11, [r3, #192]	; 0xc0
 801818a:	697b      	ldr	r3, [r7, #20]
 801818c:	ed97 6a0e 	vldr	s12, [r7, #56]	; 0x38
 8018190:	edd7 6a0f 	vldr	s13, [r7, #60]	; 0x3c
 8018194:	ed97 7a10 	vldr	s14, [r7, #64]	; 0x40
 8018198:	edd7 7a11 	vldr	s15, [r7, #68]	; 0x44
 801819c:	6e59      	ldr	r1, [r3, #100]	; 0x64
 801819e:	eeb0 2a65 	vmov.f32	s4, s11
 80181a2:	eeb0 0a46 	vmov.f32	s0, s12
 80181a6:	eef0 0a66 	vmov.f32	s1, s13
 80181aa:	eeb0 1a47 	vmov.f32	s2, s14
 80181ae:	eef0 1a67 	vmov.f32	s3, s15
 80181b2:	69f8      	ldr	r0, [r7, #28]
 80181b4:	f7f8 fd72 	bl	8010c9c <nk_fill_rect>

    /* draw cursor */
    if (cursor->type == NK_STYLE_ITEM_IMAGE)
 80181b8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80181ba:	781b      	ldrb	r3, [r3, #0]
 80181bc:	2b01      	cmp	r3, #1
 80181be:	d118      	bne.n	80181f2 <nk_draw_slider+0x272>
        nk_draw_image(out, *visual_cursor, &cursor->data.image, nk_white);
 80181c0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80181c2:	1d19      	adds	r1, r3, #4
 80181c4:	4a18      	ldr	r2, [pc, #96]	; (8018228 <nk_draw_slider+0x2a8>)
 80181c6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80181c8:	ed93 6a00 	vldr	s12, [r3]
 80181cc:	edd3 6a01 	vldr	s13, [r3, #4]
 80181d0:	ed93 7a02 	vldr	s14, [r3, #8]
 80181d4:	edd3 7a03 	vldr	s15, [r3, #12]
 80181d8:	6812      	ldr	r2, [r2, #0]
 80181da:	eeb0 0a46 	vmov.f32	s0, s12
 80181de:	eef0 0a66 	vmov.f32	s1, s13
 80181e2:	eeb0 1a47 	vmov.f32	s2, s14
 80181e6:	eef0 1a67 	vmov.f32	s3, s15
 80181ea:	69f8      	ldr	r0, [r7, #28]
 80181ec:	f7f9 f8b0 	bl	8011350 <nk_draw_image>
    else
        nk_fill_circle(out, *visual_cursor, cursor->data.color);
}
 80181f0:	e015      	b.n	801821e <nk_draw_slider+0x29e>
        nk_fill_circle(out, *visual_cursor, cursor->data.color);
 80181f2:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80181f4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80181f6:	ed93 6a00 	vldr	s12, [r3]
 80181fa:	edd3 6a01 	vldr	s13, [r3, #4]
 80181fe:	ed93 7a02 	vldr	s14, [r3, #8]
 8018202:	edd3 7a03 	vldr	s15, [r3, #12]
 8018206:	6851      	ldr	r1, [r2, #4]
 8018208:	eeb0 0a46 	vmov.f32	s0, s12
 801820c:	eef0 0a66 	vmov.f32	s1, s13
 8018210:	eeb0 1a47 	vmov.f32	s2, s14
 8018214:	eef0 1a67 	vmov.f32	s3, s15
 8018218:	69f8      	ldr	r0, [r7, #28]
 801821a:	f7f8 fe35 	bl	8010e88 <nk_fill_circle>
}
 801821e:	bf00      	nop
 8018220:	3750      	adds	r7, #80	; 0x50
 8018222:	46bd      	mov	sp, r7
 8018224:	bd80      	pop	{r7, pc}
 8018226:	bf00      	nop
 8018228:	08023668 	.word	0x08023668

0801822c <nk_do_slider>:
nk_do_slider(nk_flags *state,
    struct nk_command_buffer *out, struct nk_rect bounds,
    float min, float val, float max, float step,
    const struct nk_style_slider *style, struct nk_input *in,
    const struct nk_user_font *font)
{
 801822c:	b580      	push	{r7, lr}
 801822e:	b0a4      	sub	sp, #144	; 0x90
 8018230:	af04      	add	r7, sp, #16
 8018232:	62f8      	str	r0, [r7, #44]	; 0x2c
 8018234:	62b9      	str	r1, [r7, #40]	; 0x28
 8018236:	eeb0 6a40 	vmov.f32	s12, s0
 801823a:	eef0 6a60 	vmov.f32	s13, s1
 801823e:	eeb0 7a41 	vmov.f32	s14, s2
 8018242:	eef0 7a61 	vmov.f32	s15, s3
 8018246:	ed87 2a05 	vstr	s4, [r7, #20]
 801824a:	edc7 2a04 	vstr	s5, [r7, #16]
 801824e:	ed87 3a03 	vstr	s6, [r7, #12]
 8018252:	edc7 3a02 	vstr	s7, [r7, #8]
 8018256:	607a      	str	r2, [r7, #4]
 8018258:	603b      	str	r3, [r7, #0]
 801825a:	ed87 6a06 	vstr	s12, [r7, #24]
 801825e:	edc7 6a07 	vstr	s13, [r7, #28]
 8018262:	ed87 7a08 	vstr	s14, [r7, #32]
 8018266:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
    float cursor_offset;

    struct nk_rect visual_cursor;
    struct nk_rect logical_cursor;

    NK_ASSERT(style);
 801826a:	687b      	ldr	r3, [r7, #4]
 801826c:	2b00      	cmp	r3, #0
 801826e:	d105      	bne.n	801827c <nk_do_slider+0x50>
 8018270:	4bad      	ldr	r3, [pc, #692]	; (8018528 <nk_do_slider+0x2fc>)
 8018272:	4aae      	ldr	r2, [pc, #696]	; (801852c <nk_do_slider+0x300>)
 8018274:	2186      	movs	r1, #134	; 0x86
 8018276:	48ae      	ldr	r0, [pc, #696]	; (8018530 <nk_do_slider+0x304>)
 8018278:	f005 fbce 	bl	801da18 <__assert_func>
    NK_ASSERT(out);
 801827c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801827e:	2b00      	cmp	r3, #0
 8018280:	d105      	bne.n	801828e <nk_do_slider+0x62>
 8018282:	4bac      	ldr	r3, [pc, #688]	; (8018534 <nk_do_slider+0x308>)
 8018284:	4aa9      	ldr	r2, [pc, #676]	; (801852c <nk_do_slider+0x300>)
 8018286:	2187      	movs	r1, #135	; 0x87
 8018288:	48a9      	ldr	r0, [pc, #676]	; (8018530 <nk_do_slider+0x304>)
 801828a:	f005 fbc5 	bl	801da18 <__assert_func>
    if (!out || !style)
 801828e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018290:	2b00      	cmp	r3, #0
 8018292:	d002      	beq.n	801829a <nk_do_slider+0x6e>
 8018294:	687b      	ldr	r3, [r7, #4]
 8018296:	2b00      	cmp	r3, #0
 8018298:	d102      	bne.n	80182a0 <nk_do_slider+0x74>
        return 0;
 801829a:	f04f 0300 	mov.w	r3, #0
 801829e:	e206      	b.n	80186ae <nk_do_slider+0x482>

    /* remove padding from slider bounds */
    bounds.x = bounds.x + style->padding.x;
 80182a0:	ed97 7a06 	vldr	s14, [r7, #24]
 80182a4:	687b      	ldr	r3, [r7, #4]
 80182a6:	edd3 7a32 	vldr	s15, [r3, #200]	; 0xc8
 80182aa:	ee77 7a27 	vadd.f32	s15, s14, s15
 80182ae:	edc7 7a06 	vstr	s15, [r7, #24]
    bounds.y = bounds.y + style->padding.y;
 80182b2:	ed97 7a07 	vldr	s14, [r7, #28]
 80182b6:	687b      	ldr	r3, [r7, #4]
 80182b8:	edd3 7a33 	vldr	s15, [r3, #204]	; 0xcc
 80182bc:	ee77 7a27 	vadd.f32	s15, s14, s15
 80182c0:	edc7 7a07 	vstr	s15, [r7, #28]
    bounds.h = NK_MAX(bounds.h, 2*style->padding.y);
 80182c4:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 80182c8:	687b      	ldr	r3, [r7, #4]
 80182ca:	edd3 7a33 	vldr	s15, [r3, #204]	; 0xcc
 80182ce:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80182d2:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80182d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80182da:	d505      	bpl.n	80182e8 <nk_do_slider+0xbc>
 80182dc:	687b      	ldr	r3, [r7, #4]
 80182de:	edd3 7a33 	vldr	s15, [r3, #204]	; 0xcc
 80182e2:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80182e6:	e001      	b.n	80182ec <nk_do_slider+0xc0>
 80182e8:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 80182ec:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
    bounds.w = NK_MAX(bounds.w, 2*style->padding.x + style->cursor_size.x);
 80182f0:	ed97 7a08 	vldr	s14, [r7, #32]
 80182f4:	687b      	ldr	r3, [r7, #4]
 80182f6:	edd3 7a32 	vldr	s15, [r3, #200]	; 0xc8
 80182fa:	ee77 6aa7 	vadd.f32	s13, s15, s15
 80182fe:	687b      	ldr	r3, [r7, #4]
 8018300:	edd3 7a36 	vldr	s15, [r3, #216]	; 0xd8
 8018304:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8018308:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801830c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018310:	d50a      	bpl.n	8018328 <nk_do_slider+0xfc>
 8018312:	687b      	ldr	r3, [r7, #4]
 8018314:	edd3 7a32 	vldr	s15, [r3, #200]	; 0xc8
 8018318:	ee37 7aa7 	vadd.f32	s14, s15, s15
 801831c:	687b      	ldr	r3, [r7, #4]
 801831e:	edd3 7a36 	vldr	s15, [r3, #216]	; 0xd8
 8018322:	ee77 7a27 	vadd.f32	s15, s14, s15
 8018326:	e001      	b.n	801832c <nk_do_slider+0x100>
 8018328:	edd7 7a08 	vldr	s15, [r7, #32]
 801832c:	edc7 7a08 	vstr	s15, [r7, #32]
    bounds.w -= 2 * style->padding.x;
 8018330:	ed97 7a08 	vldr	s14, [r7, #32]
 8018334:	687b      	ldr	r3, [r7, #4]
 8018336:	edd3 7a32 	vldr	s15, [r3, #200]	; 0xc8
 801833a:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801833e:	ee77 7a67 	vsub.f32	s15, s14, s15
 8018342:	edc7 7a08 	vstr	s15, [r7, #32]
    bounds.h -= 2 * style->padding.y;
 8018346:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 801834a:	687b      	ldr	r3, [r7, #4]
 801834c:	edd3 7a33 	vldr	s15, [r3, #204]	; 0xcc
 8018350:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8018354:	ee77 7a67 	vsub.f32	s15, s14, s15
 8018358:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24

    /* optional buttons */
    if (style->show_buttons) {
 801835c:	687b      	ldr	r3, [r7, #4]
 801835e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8018362:	2b00      	cmp	r3, #0
 8018364:	f000 808d 	beq.w	8018482 <nk_do_slider+0x256>
        nk_flags ws;
        struct nk_rect button;
        button.y = bounds.y;
 8018368:	69fb      	ldr	r3, [r7, #28]
 801836a:	63bb      	str	r3, [r7, #56]	; 0x38
        button.w = bounds.h;
 801836c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801836e:	63fb      	str	r3, [r7, #60]	; 0x3c
        button.h = bounds.h;
 8018370:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018372:	643b      	str	r3, [r7, #64]	; 0x40

        /* decrement button */
        button.x = bounds.x;
 8018374:	69bb      	ldr	r3, [r7, #24]
 8018376:	637b      	str	r3, [r7, #52]	; 0x34
        if (nk_do_button_symbol(&ws, out, button, style->dec_symbol, NK_BUTTON_DEFAULT,
 8018378:	687b      	ldr	r3, [r7, #4]
 801837a:	f893 1215 	ldrb.w	r1, [r3, #533]	; 0x215
 801837e:	687b      	ldr	r3, [r7, #4]
 8018380:	f503 73be 	add.w	r3, r3, #380	; 0x17c
 8018384:	ed97 6a0d 	vldr	s12, [r7, #52]	; 0x34
 8018388:	edd7 6a0e 	vldr	s13, [r7, #56]	; 0x38
 801838c:	ed97 7a0f 	vldr	s14, [r7, #60]	; 0x3c
 8018390:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
 8018394:	f107 0044 	add.w	r0, r7, #68	; 0x44
 8018398:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 801839c:	9202      	str	r2, [sp, #8]
 801839e:	683a      	ldr	r2, [r7, #0]
 80183a0:	9201      	str	r2, [sp, #4]
 80183a2:	9300      	str	r3, [sp, #0]
 80183a4:	2300      	movs	r3, #0
 80183a6:	460a      	mov	r2, r1
 80183a8:	eeb0 0a46 	vmov.f32	s0, s12
 80183ac:	eef0 0a66 	vmov.f32	s1, s13
 80183b0:	eeb0 1a47 	vmov.f32	s2, s14
 80183b4:	eef0 1a67 	vmov.f32	s3, s15
 80183b8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80183ba:	f7f6 fadb 	bl	800e974 <nk_do_button_symbol>
 80183be:	4603      	mov	r3, r0
 80183c0:	2b00      	cmp	r3, #0
 80183c2:	d007      	beq.n	80183d4 <nk_do_slider+0x1a8>
            &style->dec_button, in, font))
            val -= step;
 80183c4:	ed97 7a04 	vldr	s14, [r7, #16]
 80183c8:	edd7 7a02 	vldr	s15, [r7, #8]
 80183cc:	ee77 7a67 	vsub.f32	s15, s14, s15
 80183d0:	edc7 7a04 	vstr	s15, [r7, #16]

        /* increment button */
        button.x = (bounds.x + bounds.w) - button.w;
 80183d4:	ed97 7a06 	vldr	s14, [r7, #24]
 80183d8:	edd7 7a08 	vldr	s15, [r7, #32]
 80183dc:	ee37 7a27 	vadd.f32	s14, s14, s15
 80183e0:	edd7 7a0f 	vldr	s15, [r7, #60]	; 0x3c
 80183e4:	ee77 7a67 	vsub.f32	s15, s14, s15
 80183e8:	edc7 7a0d 	vstr	s15, [r7, #52]	; 0x34
        if (nk_do_button_symbol(&ws, out, button, style->inc_symbol, NK_BUTTON_DEFAULT,
 80183ec:	687b      	ldr	r3, [r7, #4]
 80183ee:	f893 1214 	ldrb.w	r1, [r3, #532]	; 0x214
 80183f2:	687b      	ldr	r3, [r7, #4]
 80183f4:	33e4      	adds	r3, #228	; 0xe4
 80183f6:	ed97 6a0d 	vldr	s12, [r7, #52]	; 0x34
 80183fa:	edd7 6a0e 	vldr	s13, [r7, #56]	; 0x38
 80183fe:	ed97 7a0f 	vldr	s14, [r7, #60]	; 0x3c
 8018402:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
 8018406:	f107 0044 	add.w	r0, r7, #68	; 0x44
 801840a:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 801840e:	9202      	str	r2, [sp, #8]
 8018410:	683a      	ldr	r2, [r7, #0]
 8018412:	9201      	str	r2, [sp, #4]
 8018414:	9300      	str	r3, [sp, #0]
 8018416:	2300      	movs	r3, #0
 8018418:	460a      	mov	r2, r1
 801841a:	eeb0 0a46 	vmov.f32	s0, s12
 801841e:	eef0 0a66 	vmov.f32	s1, s13
 8018422:	eeb0 1a47 	vmov.f32	s2, s14
 8018426:	eef0 1a67 	vmov.f32	s3, s15
 801842a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801842c:	f7f6 faa2 	bl	800e974 <nk_do_button_symbol>
 8018430:	4603      	mov	r3, r0
 8018432:	2b00      	cmp	r3, #0
 8018434:	d007      	beq.n	8018446 <nk_do_slider+0x21a>
            &style->inc_button, in, font))
            val += step;
 8018436:	ed97 7a04 	vldr	s14, [r7, #16]
 801843a:	edd7 7a02 	vldr	s15, [r7, #8]
 801843e:	ee77 7a27 	vadd.f32	s15, s14, s15
 8018442:	edc7 7a04 	vstr	s15, [r7, #16]

        bounds.x = bounds.x + button.w + style->spacing.x;
 8018446:	ed97 7a06 	vldr	s14, [r7, #24]
 801844a:	edd7 7a0f 	vldr	s15, [r7, #60]	; 0x3c
 801844e:	ee37 7a27 	vadd.f32	s14, s14, s15
 8018452:	687b      	ldr	r3, [r7, #4]
 8018454:	edd3 7a34 	vldr	s15, [r3, #208]	; 0xd0
 8018458:	ee77 7a27 	vadd.f32	s15, s14, s15
 801845c:	edc7 7a06 	vstr	s15, [r7, #24]
        bounds.w = bounds.w - (2*button.w + 2*style->spacing.x);
 8018460:	ed97 7a08 	vldr	s14, [r7, #32]
 8018464:	edd7 7a0f 	vldr	s15, [r7, #60]	; 0x3c
 8018468:	ee77 6aa7 	vadd.f32	s13, s15, s15
 801846c:	687b      	ldr	r3, [r7, #4]
 801846e:	edd3 7a34 	vldr	s15, [r3, #208]	; 0xd0
 8018472:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8018476:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801847a:	ee77 7a67 	vsub.f32	s15, s14, s15
 801847e:	edc7 7a08 	vstr	s15, [r7, #32]
    }

    /* remove one cursor size to support visual cursor */
    bounds.x += style->cursor_size.x*0.5f;
 8018482:	ed97 7a06 	vldr	s14, [r7, #24]
 8018486:	687b      	ldr	r3, [r7, #4]
 8018488:	edd3 7a36 	vldr	s15, [r3, #216]	; 0xd8
 801848c:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 8018490:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8018494:	ee77 7a27 	vadd.f32	s15, s14, s15
 8018498:	edc7 7a06 	vstr	s15, [r7, #24]
    bounds.w -= style->cursor_size.x;
 801849c:	ed97 7a08 	vldr	s14, [r7, #32]
 80184a0:	687b      	ldr	r3, [r7, #4]
 80184a2:	edd3 7a36 	vldr	s15, [r3, #216]	; 0xd8
 80184a6:	ee77 7a67 	vsub.f32	s15, s14, s15
 80184aa:	edc7 7a08 	vstr	s15, [r7, #32]

    /* make sure the provided values are correct */
    slider_max = NK_MAX(min, max);
 80184ae:	ed97 7a05 	vldr	s14, [r7, #20]
 80184b2:	edd7 7a03 	vldr	s15, [r7, #12]
 80184b6:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80184ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80184be:	d501      	bpl.n	80184c4 <nk_do_slider+0x298>
 80184c0:	68fb      	ldr	r3, [r7, #12]
 80184c2:	e000      	b.n	80184c6 <nk_do_slider+0x29a>
 80184c4:	697b      	ldr	r3, [r7, #20]
 80184c6:	67fb      	str	r3, [r7, #124]	; 0x7c
    slider_min = NK_MIN(min, max);
 80184c8:	ed97 7a05 	vldr	s14, [r7, #20]
 80184cc:	edd7 7a03 	vldr	s15, [r7, #12]
 80184d0:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80184d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80184d8:	d501      	bpl.n	80184de <nk_do_slider+0x2b2>
 80184da:	697b      	ldr	r3, [r7, #20]
 80184dc:	e000      	b.n	80184e0 <nk_do_slider+0x2b4>
 80184de:	68fb      	ldr	r3, [r7, #12]
 80184e0:	67bb      	str	r3, [r7, #120]	; 0x78
    slider_value = NK_CLAMP(slider_min, val, slider_max);
 80184e2:	ed97 7a04 	vldr	s14, [r7, #16]
 80184e6:	edd7 7a1f 	vldr	s15, [r7, #124]	; 0x7c
 80184ea:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80184ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80184f2:	d502      	bpl.n	80184fa <nk_do_slider+0x2ce>
 80184f4:	edd7 7a04 	vldr	s15, [r7, #16]
 80184f8:	e001      	b.n	80184fe <nk_do_slider+0x2d2>
 80184fa:	edd7 7a1f 	vldr	s15, [r7, #124]	; 0x7c
 80184fe:	ed97 7a1e 	vldr	s14, [r7, #120]	; 0x78
 8018502:	eef4 7ac7 	vcmpe.f32	s15, s14
 8018506:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801850a:	d501      	bpl.n	8018510 <nk_do_slider+0x2e4>
 801850c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 801850e:	e014      	b.n	801853a <nk_do_slider+0x30e>
 8018510:	ed97 7a04 	vldr	s14, [r7, #16]
 8018514:	edd7 7a1f 	vldr	s15, [r7, #124]	; 0x7c
 8018518:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801851c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018520:	d50a      	bpl.n	8018538 <nk_do_slider+0x30c>
 8018522:	693b      	ldr	r3, [r7, #16]
 8018524:	e009      	b.n	801853a <nk_do_slider+0x30e>
 8018526:	bf00      	nop
 8018528:	08021ba4 	.word	0x08021ba4
 801852c:	0802366c 	.word	0x0802366c
 8018530:	08021bac 	.word	0x08021bac
 8018534:	08021bc8 	.word	0x08021bc8
 8018538:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 801853a:	677b      	str	r3, [r7, #116]	; 0x74
    slider_range = slider_max - slider_min;
 801853c:	ed97 7a1f 	vldr	s14, [r7, #124]	; 0x7c
 8018540:	edd7 7a1e 	vldr	s15, [r7, #120]	; 0x78
 8018544:	ee77 7a67 	vsub.f32	s15, s14, s15
 8018548:	edc7 7a1c 	vstr	s15, [r7, #112]	; 0x70
    slider_steps = slider_range / step;
 801854c:	edd7 6a1c 	vldr	s13, [r7, #112]	; 0x70
 8018550:	ed97 7a02 	vldr	s14, [r7, #8]
 8018554:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8018558:	edc7 7a1b 	vstr	s15, [r7, #108]	; 0x6c
    cursor_offset = (slider_value - slider_min) / step;
 801855c:	ed97 7a1d 	vldr	s14, [r7, #116]	; 0x74
 8018560:	edd7 7a1e 	vldr	s15, [r7, #120]	; 0x78
 8018564:	ee77 6a67 	vsub.f32	s13, s14, s15
 8018568:	ed97 7a02 	vldr	s14, [r7, #8]
 801856c:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8018570:	edc7 7a1a 	vstr	s15, [r7, #104]	; 0x68

    /* calculate cursor
    Basically you have two cursors. One for visual representation and interaction
    and one for updating the actual cursor value. */
    logical_cursor.h = bounds.h;
 8018574:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018576:	657b      	str	r3, [r7, #84]	; 0x54
    logical_cursor.w = bounds.w / slider_steps;
 8018578:	edd7 6a08 	vldr	s13, [r7, #32]
 801857c:	ed97 7a1b 	vldr	s14, [r7, #108]	; 0x6c
 8018580:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8018584:	edc7 7a14 	vstr	s15, [r7, #80]	; 0x50
    logical_cursor.x = bounds.x + (logical_cursor.w * cursor_offset);
 8018588:	ed97 7a06 	vldr	s14, [r7, #24]
 801858c:	edd7 6a14 	vldr	s13, [r7, #80]	; 0x50
 8018590:	edd7 7a1a 	vldr	s15, [r7, #104]	; 0x68
 8018594:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8018598:	ee77 7a27 	vadd.f32	s15, s14, s15
 801859c:	edc7 7a12 	vstr	s15, [r7, #72]	; 0x48
    logical_cursor.y = bounds.y;
 80185a0:	69fb      	ldr	r3, [r7, #28]
 80185a2:	64fb      	str	r3, [r7, #76]	; 0x4c

    visual_cursor.h = style->cursor_size.y;
 80185a4:	687b      	ldr	r3, [r7, #4]
 80185a6:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 80185aa:	667b      	str	r3, [r7, #100]	; 0x64
    visual_cursor.w = style->cursor_size.x;
 80185ac:	687b      	ldr	r3, [r7, #4]
 80185ae:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 80185b2:	663b      	str	r3, [r7, #96]	; 0x60
    visual_cursor.y = (bounds.y + bounds.h*0.5f) - visual_cursor.h*0.5f;
 80185b4:	ed97 7a07 	vldr	s14, [r7, #28]
 80185b8:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 80185bc:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 80185c0:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80185c4:	ee37 7a27 	vadd.f32	s14, s14, s15
 80185c8:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
 80185cc:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 80185d0:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80185d4:	ee77 7a67 	vsub.f32	s15, s14, s15
 80185d8:	edc7 7a17 	vstr	s15, [r7, #92]	; 0x5c
    visual_cursor.x = logical_cursor.x - visual_cursor.w*0.5f;
 80185dc:	ed97 7a12 	vldr	s14, [r7, #72]	; 0x48
 80185e0:	edd7 7a18 	vldr	s15, [r7, #96]	; 0x60
 80185e4:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 80185e8:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80185ec:	ee77 7a67 	vsub.f32	s15, s14, s15
 80185f0:	edc7 7a16 	vstr	s15, [r7, #88]	; 0x58

    slider_value = nk_slider_behavior(state, &logical_cursor, &visual_cursor,
 80185f4:	ed97 6a06 	vldr	s12, [r7, #24]
 80185f8:	edd7 6a07 	vldr	s13, [r7, #28]
 80185fc:	ed97 7a08 	vldr	s14, [r7, #32]
 8018600:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8018604:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8018608:	f107 0148 	add.w	r1, r7, #72	; 0x48
 801860c:	ed97 4a1b 	vldr	s8, [r7, #108]	; 0x6c
 8018610:	edd7 3a02 	vldr	s7, [r7, #8]
 8018614:	ed97 3a1d 	vldr	s6, [r7, #116]	; 0x74
 8018618:	edd7 2a1f 	vldr	s5, [r7, #124]	; 0x7c
 801861c:	ed97 2a1e 	vldr	s4, [r7, #120]	; 0x78
 8018620:	eeb0 0a46 	vmov.f32	s0, s12
 8018624:	eef0 0a66 	vmov.f32	s1, s13
 8018628:	eeb0 1a47 	vmov.f32	s2, s14
 801862c:	eef0 1a67 	vmov.f32	s3, s15
 8018630:	683b      	ldr	r3, [r7, #0]
 8018632:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8018634:	f7ff fb34 	bl	8017ca0 <nk_slider_behavior>
 8018638:	ed87 0a1d 	vstr	s0, [r7, #116]	; 0x74
        in, bounds, slider_min, slider_max, slider_value, step, slider_steps);
    visual_cursor.x = logical_cursor.x - visual_cursor.w*0.5f;
 801863c:	ed97 7a12 	vldr	s14, [r7, #72]	; 0x48
 8018640:	edd7 7a18 	vldr	s15, [r7, #96]	; 0x60
 8018644:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 8018648:	ee67 7aa6 	vmul.f32	s15, s15, s13
 801864c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8018650:	edc7 7a16 	vstr	s15, [r7, #88]	; 0x58

    /* draw slider */
    if (style->draw_begin) style->draw_begin(out, style->userdata);
 8018654:	687b      	ldr	r3, [r7, #4]
 8018656:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 801865a:	2b00      	cmp	r3, #0
 801865c:	d007      	beq.n	801866e <nk_do_slider+0x442>
 801865e:	687b      	ldr	r3, [r7, #4]
 8018660:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 8018664:	687a      	ldr	r2, [r7, #4]
 8018666:	f8d2 1218 	ldr.w	r1, [r2, #536]	; 0x218
 801866a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801866c:	4798      	blx	r3
    nk_draw_slider(out, *state, style, &bounds, &visual_cursor, slider_min, slider_value, slider_max);
 801866e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018670:	6819      	ldr	r1, [r3, #0]
 8018672:	f107 0218 	add.w	r2, r7, #24
 8018676:	f107 0358 	add.w	r3, r7, #88	; 0x58
 801867a:	9300      	str	r3, [sp, #0]
 801867c:	ed97 1a1f 	vldr	s2, [r7, #124]	; 0x7c
 8018680:	edd7 0a1d 	vldr	s1, [r7, #116]	; 0x74
 8018684:	ed97 0a1e 	vldr	s0, [r7, #120]	; 0x78
 8018688:	4613      	mov	r3, r2
 801868a:	687a      	ldr	r2, [r7, #4]
 801868c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801868e:	f7ff fc77 	bl	8017f80 <nk_draw_slider>
    if (style->draw_end) style->draw_end(out, style->userdata);
 8018692:	687b      	ldr	r3, [r7, #4]
 8018694:	f8d3 3220 	ldr.w	r3, [r3, #544]	; 0x220
 8018698:	2b00      	cmp	r3, #0
 801869a:	d007      	beq.n	80186ac <nk_do_slider+0x480>
 801869c:	687b      	ldr	r3, [r7, #4]
 801869e:	f8d3 3220 	ldr.w	r3, [r3, #544]	; 0x220
 80186a2:	687a      	ldr	r2, [r7, #4]
 80186a4:	f8d2 1218 	ldr.w	r1, [r2, #536]	; 0x218
 80186a8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80186aa:	4798      	blx	r3
    return slider_value;
 80186ac:	6f7b      	ldr	r3, [r7, #116]	; 0x74
}
 80186ae:	ee07 3a90 	vmov	s15, r3
 80186b2:	eeb0 0a67 	vmov.f32	s0, s15
 80186b6:	3780      	adds	r7, #128	; 0x80
 80186b8:	46bd      	mov	sp, r7
 80186ba:	bd80      	pop	{r7, pc}

080186bc <nk_slider_float>:
NK_API nk_bool
nk_slider_float(struct nk_context *ctx, float min_value, float *value, float max_value,
    float value_step)
{
 80186bc:	b580      	push	{r7, lr}
 80186be:	b094      	sub	sp, #80	; 0x50
 80186c0:	af02      	add	r7, sp, #8
 80186c2:	6178      	str	r0, [r7, #20]
 80186c4:	ed87 0a04 	vstr	s0, [r7, #16]
 80186c8:	60f9      	str	r1, [r7, #12]
 80186ca:	edc7 0a02 	vstr	s1, [r7, #8]
 80186ce:	ed87 1a01 	vstr	s2, [r7, #4]
    struct nk_window *win;
    struct nk_panel *layout;
    struct nk_input *in;
    const struct nk_style *style;

    int ret = 0;
 80186d2:	2300      	movs	r3, #0
 80186d4:	647b      	str	r3, [r7, #68]	; 0x44
    float old_value;
    struct nk_rect bounds;
    enum nk_widget_layout_states state;

    NK_ASSERT(ctx);
 80186d6:	697b      	ldr	r3, [r7, #20]
 80186d8:	2b00      	cmp	r3, #0
 80186da:	d105      	bne.n	80186e8 <nk_slider_float+0x2c>
 80186dc:	4b5a      	ldr	r3, [pc, #360]	; (8018848 <nk_slider_float+0x18c>)
 80186de:	4a5b      	ldr	r2, [pc, #364]	; (801884c <nk_slider_float+0x190>)
 80186e0:	21dc      	movs	r1, #220	; 0xdc
 80186e2:	485b      	ldr	r0, [pc, #364]	; (8018850 <nk_slider_float+0x194>)
 80186e4:	f005 f998 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 80186e8:	697b      	ldr	r3, [r7, #20]
 80186ea:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80186ee:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 80186f2:	2b00      	cmp	r3, #0
 80186f4:	d105      	bne.n	8018702 <nk_slider_float+0x46>
 80186f6:	4b57      	ldr	r3, [pc, #348]	; (8018854 <nk_slider_float+0x198>)
 80186f8:	4a54      	ldr	r2, [pc, #336]	; (801884c <nk_slider_float+0x190>)
 80186fa:	21dd      	movs	r1, #221	; 0xdd
 80186fc:	4854      	ldr	r0, [pc, #336]	; (8018850 <nk_slider_float+0x194>)
 80186fe:	f005 f98b 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 8018702:	697b      	ldr	r3, [r7, #20]
 8018704:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8018708:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801870c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8018710:	2b00      	cmp	r3, #0
 8018712:	d105      	bne.n	8018720 <nk_slider_float+0x64>
 8018714:	4b50      	ldr	r3, [pc, #320]	; (8018858 <nk_slider_float+0x19c>)
 8018716:	4a4d      	ldr	r2, [pc, #308]	; (801884c <nk_slider_float+0x190>)
 8018718:	21de      	movs	r1, #222	; 0xde
 801871a:	484d      	ldr	r0, [pc, #308]	; (8018850 <nk_slider_float+0x194>)
 801871c:	f005 f97c 	bl	801da18 <__assert_func>
    NK_ASSERT(value);
 8018720:	68fb      	ldr	r3, [r7, #12]
 8018722:	2b00      	cmp	r3, #0
 8018724:	d105      	bne.n	8018732 <nk_slider_float+0x76>
 8018726:	4b4d      	ldr	r3, [pc, #308]	; (801885c <nk_slider_float+0x1a0>)
 8018728:	4a48      	ldr	r2, [pc, #288]	; (801884c <nk_slider_float+0x190>)
 801872a:	21df      	movs	r1, #223	; 0xdf
 801872c:	4848      	ldr	r0, [pc, #288]	; (8018850 <nk_slider_float+0x194>)
 801872e:	f005 f973 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout || !value)
 8018732:	697b      	ldr	r3, [r7, #20]
 8018734:	2b00      	cmp	r3, #0
 8018736:	d012      	beq.n	801875e <nk_slider_float+0xa2>
 8018738:	697b      	ldr	r3, [r7, #20]
 801873a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801873e:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8018742:	2b00      	cmp	r3, #0
 8018744:	d00b      	beq.n	801875e <nk_slider_float+0xa2>
 8018746:	697b      	ldr	r3, [r7, #20]
 8018748:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801874c:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 8018750:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8018754:	2b00      	cmp	r3, #0
 8018756:	d002      	beq.n	801875e <nk_slider_float+0xa2>
 8018758:	68fb      	ldr	r3, [r7, #12]
 801875a:	2b00      	cmp	r3, #0
 801875c:	d101      	bne.n	8018762 <nk_slider_float+0xa6>
        return ret;
 801875e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018760:	e06d      	b.n	801883e <nk_slider_float+0x182>

    win = ctx->current;
 8018762:	697b      	ldr	r3, [r7, #20]
 8018764:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8018768:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801876c:	643b      	str	r3, [r7, #64]	; 0x40
    style = &ctx->style;
 801876e:	697b      	ldr	r3, [r7, #20]
 8018770:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 8018774:	63fb      	str	r3, [r7, #60]	; 0x3c
    layout = win->layout;
 8018776:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8018778:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801877c:	63bb      	str	r3, [r7, #56]	; 0x38

    state = nk_widget(&bounds, ctx);
 801877e:	f107 031c 	add.w	r3, r7, #28
 8018782:	6979      	ldr	r1, [r7, #20]
 8018784:	4618      	mov	r0, r3
 8018786:	f003 fe5f 	bl	801c448 <nk_widget>
 801878a:	4603      	mov	r3, r0
 801878c:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    if (!state) return ret;
 8018790:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8018794:	2b00      	cmp	r3, #0
 8018796:	d101      	bne.n	801879c <nk_slider_float+0xe0>
 8018798:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801879a:	e050      	b.n	801883e <nk_slider_float+0x182>
    in = (/*state == NK_WIDGET_ROM || */ layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
 801879c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801879e:	685b      	ldr	r3, [r3, #4]
 80187a0:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80187a4:	2b00      	cmp	r3, #0
 80187a6:	d101      	bne.n	80187ac <nk_slider_float+0xf0>
 80187a8:	697b      	ldr	r3, [r7, #20]
 80187aa:	e000      	b.n	80187ae <nk_slider_float+0xf2>
 80187ac:	2300      	movs	r3, #0
 80187ae:	633b      	str	r3, [r7, #48]	; 0x30

    old_value = *value;
 80187b0:	68fb      	ldr	r3, [r7, #12]
 80187b2:	681b      	ldr	r3, [r3, #0]
 80187b4:	62fb      	str	r3, [r7, #44]	; 0x2c
    *value = nk_do_slider(&ctx->last_widget_state, &win->buffer, bounds, min_value,
 80187b6:	697b      	ldr	r3, [r7, #20]
 80187b8:	f503 50d6 	add.w	r0, r3, #6848	; 0x1ac0
 80187bc:	3014      	adds	r0, #20
 80187be:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80187c0:	f103 0164 	add.w	r1, r3, #100	; 0x64
 80187c4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80187c6:	f503 6290 	add.w	r2, r3, #1152	; 0x480
                old_value, max_value, value_step, &style->slider, in, style->font);
 80187ca:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80187cc:	681b      	ldr	r3, [r3, #0]
    *value = nk_do_slider(&ctx->last_widget_state, &win->buffer, bounds, min_value,
 80187ce:	ed97 6a07 	vldr	s12, [r7, #28]
 80187d2:	edd7 6a08 	vldr	s13, [r7, #32]
 80187d6:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 80187da:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
 80187de:	9300      	str	r3, [sp, #0]
 80187e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80187e2:	edd7 3a01 	vldr	s7, [r7, #4]
 80187e6:	ed97 3a02 	vldr	s6, [r7, #8]
 80187ea:	edd7 2a0b 	vldr	s5, [r7, #44]	; 0x2c
 80187ee:	ed97 2a04 	vldr	s4, [r7, #16]
 80187f2:	eeb0 0a46 	vmov.f32	s0, s12
 80187f6:	eef0 0a66 	vmov.f32	s1, s13
 80187fa:	eeb0 1a47 	vmov.f32	s2, s14
 80187fe:	eef0 1a67 	vmov.f32	s3, s15
 8018802:	f7ff fd13 	bl	801822c <nk_do_slider>
 8018806:	eef0 7a40 	vmov.f32	s15, s0
 801880a:	68fb      	ldr	r3, [r7, #12]
 801880c:	edc3 7a00 	vstr	s15, [r3]
    return (old_value > *value || old_value < *value);
 8018810:	68fb      	ldr	r3, [r7, #12]
 8018812:	edd3 7a00 	vldr	s15, [r3]
 8018816:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
 801881a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801881e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018822:	dc09      	bgt.n	8018838 <nk_slider_float+0x17c>
 8018824:	68fb      	ldr	r3, [r7, #12]
 8018826:	edd3 7a00 	vldr	s15, [r3]
 801882a:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
 801882e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018832:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018836:	d501      	bpl.n	801883c <nk_slider_float+0x180>
 8018838:	2301      	movs	r3, #1
 801883a:	e000      	b.n	801883e <nk_slider_float+0x182>
 801883c:	2300      	movs	r3, #0
}
 801883e:	4618      	mov	r0, r3
 8018840:	3748      	adds	r7, #72	; 0x48
 8018842:	46bd      	mov	sp, r7
 8018844:	bd80      	pop	{r7, pc}
 8018846:	bf00      	nop
 8018848:	08021bcc 	.word	0x08021bcc
 801884c:	0802367c 	.word	0x0802367c
 8018850:	08021bac 	.word	0x08021bac
 8018854:	08021bd0 	.word	0x08021bd0
 8018858:	08021be0 	.word	0x08021be0
 801885c:	08021bf8 	.word	0x08021bf8

08018860 <nk_style_default>:
/* ===============================================================
 *
 *                              STYLE
 *
 * ===============================================================*/
NK_API void nk_style_default(struct nk_context *ctx){nk_style_from_table(ctx, 0);}
 8018860:	b580      	push	{r7, lr}
 8018862:	b082      	sub	sp, #8
 8018864:	af00      	add	r7, sp, #0
 8018866:	6078      	str	r0, [r7, #4]
 8018868:	2100      	movs	r1, #0
 801886a:	6878      	ldr	r0, [r7, #4]
 801886c:	f000 f838 	bl	80188e0 <nk_style_from_table>
 8018870:	bf00      	nop
 8018872:	3708      	adds	r7, #8
 8018874:	46bd      	mov	sp, r7
 8018876:	bd80      	pop	{r7, pc}

08018878 <nk_style_item_color>:
{
    return nk_color_names[c];
}
NK_API struct nk_style_item
nk_style_item_color(struct nk_color col)
{
 8018878:	b4b0      	push	{r4, r5, r7}
 801887a:	b08b      	sub	sp, #44	; 0x2c
 801887c:	af00      	add	r7, sp, #0
 801887e:	6078      	str	r0, [r7, #4]
 8018880:	6039      	str	r1, [r7, #0]
    struct nk_style_item i;
    i.type = NK_STYLE_ITEM_COLOR;
 8018882:	2300      	movs	r3, #0
 8018884:	733b      	strb	r3, [r7, #12]
    i.data.color = col;
 8018886:	683b      	ldr	r3, [r7, #0]
 8018888:	613b      	str	r3, [r7, #16]
    return i;
 801888a:	687b      	ldr	r3, [r7, #4]
 801888c:	461d      	mov	r5, r3
 801888e:	f107 040c 	add.w	r4, r7, #12
 8018892:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8018894:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8018896:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 801889a:	e885 0007 	stmia.w	r5, {r0, r1, r2}
}
 801889e:	6878      	ldr	r0, [r7, #4]
 80188a0:	372c      	adds	r7, #44	; 0x2c
 80188a2:	46bd      	mov	sp, r7
 80188a4:	bcb0      	pop	{r4, r5, r7}
 80188a6:	4770      	bx	lr

080188a8 <nk_style_item_hide>:
    i.data.slice = slice;
    return i;
}
NK_API struct nk_style_item
nk_style_item_hide(void)
{
 80188a8:	b5b0      	push	{r4, r5, r7, lr}
 80188aa:	b08a      	sub	sp, #40	; 0x28
 80188ac:	af00      	add	r7, sp, #0
 80188ae:	6078      	str	r0, [r7, #4]
    struct nk_style_item i;
    i.type = NK_STYLE_ITEM_COLOR;
 80188b0:	2300      	movs	r3, #0
 80188b2:	733b      	strb	r3, [r7, #12]
    i.data.color = nk_rgba(0,0,0,0);
 80188b4:	2300      	movs	r3, #0
 80188b6:	2200      	movs	r2, #0
 80188b8:	2100      	movs	r1, #0
 80188ba:	2000      	movs	r0, #0
 80188bc:	f7f6 fae0 	bl	800ee80 <nk_rgba>
 80188c0:	4603      	mov	r3, r0
 80188c2:	613b      	str	r3, [r7, #16]
    return i;
 80188c4:	687b      	ldr	r3, [r7, #4]
 80188c6:	461d      	mov	r5, r3
 80188c8:	f107 040c 	add.w	r4, r7, #12
 80188cc:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80188ce:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80188d0:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 80188d4:	e885 0007 	stmia.w	r5, {r0, r1, r2}
}
 80188d8:	6878      	ldr	r0, [r7, #4]
 80188da:	3728      	adds	r7, #40	; 0x28
 80188dc:	46bd      	mov	sp, r7
 80188de:	bdb0      	pop	{r4, r5, r7, pc}

080188e0 <nk_style_from_table>:
NK_API void
nk_style_from_table(struct nk_context *ctx, const struct nk_color *table)
{
 80188e0:	b5b0      	push	{r4, r5, r7, lr}
 80188e2:	b09e      	sub	sp, #120	; 0x78
 80188e4:	af00      	add	r7, sp, #0
 80188e6:	6278      	str	r0, [r7, #36]	; 0x24
 80188e8:	6239      	str	r1, [r7, #32]
    struct nk_style_combo *combo;
    struct nk_style_chart *chart;
    struct nk_style_tab *tab;
    struct nk_style_window *win;

    NK_ASSERT(ctx);
 80188ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80188ec:	2b00      	cmp	r3, #0
 80188ee:	d105      	bne.n	80188fc <nk_style_from_table+0x1c>
 80188f0:	4b09      	ldr	r3, [pc, #36]	; (8018918 <nk_style_from_table+0x38>)
 80188f2:	4a0a      	ldr	r2, [pc, #40]	; (801891c <nk_style_from_table+0x3c>)
 80188f4:	216b      	movs	r1, #107	; 0x6b
 80188f6:	480a      	ldr	r0, [pc, #40]	; (8018920 <nk_style_from_table+0x40>)
 80188f8:	f005 f88e 	bl	801da18 <__assert_func>
    if (!ctx) return;
 80188fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80188fe:	2b00      	cmp	r3, #0
 8018900:	f002 8079 	beq.w	801a9f6 <nk_style_from_table+0x2116>
    style = &ctx->style;
 8018904:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018906:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 801890a:	677b      	str	r3, [r7, #116]	; 0x74
    table = (!table) ? nk_default_color_style: table;
 801890c:	6a3b      	ldr	r3, [r7, #32]
 801890e:	2b00      	cmp	r3, #0
 8018910:	d008      	beq.n	8018924 <nk_style_from_table+0x44>
 8018912:	6a3b      	ldr	r3, [r7, #32]
 8018914:	e007      	b.n	8018926 <nk_style_from_table+0x46>
 8018916:	bf00      	nop
 8018918:	08021e6c 	.word	0x08021e6c
 801891c:	080236fc 	.word	0x080236fc
 8018920:	08021e70 	.word	0x08021e70
 8018924:	4bc6      	ldr	r3, [pc, #792]	; (8018c40 <nk_style_from_table+0x360>)
 8018926:	623b      	str	r3, [r7, #32]

    /* default text */
    text = &style->text;
 8018928:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801892a:	332c      	adds	r3, #44	; 0x2c
 801892c:	673b      	str	r3, [r7, #112]	; 0x70
    text->color = table[NK_COLOR_TEXT];
 801892e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8018930:	6a3a      	ldr	r2, [r7, #32]
 8018932:	6810      	ldr	r0, [r2, #0]
 8018934:	6018      	str	r0, [r3, #0]
    text->padding = nk_vec2(0,0);
 8018936:	6f3c      	ldr	r4, [r7, #112]	; 0x70
 8018938:	eddf 0ac2 	vldr	s1, [pc, #776]	; 8018c44 <nk_style_from_table+0x364>
 801893c:	ed9f 0ac1 	vldr	s0, [pc, #772]	; 8018c44 <nk_style_from_table+0x364>
 8018940:	f7fa ffba 	bl	80138b8 <nk_vec2>
 8018944:	eeb0 7a40 	vmov.f32	s14, s0
 8018948:	eef0 7a60 	vmov.f32	s15, s1
 801894c:	ed84 7a01 	vstr	s14, [r4, #4]
 8018950:	edc4 7a02 	vstr	s15, [r4, #8]

    /* default button */
    button = &style->button;
 8018954:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018956:	3338      	adds	r3, #56	; 0x38
 8018958:	66fb      	str	r3, [r7, #108]	; 0x6c
    nk_zero_struct(*button);
 801895a:	2198      	movs	r1, #152	; 0x98
 801895c:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 801895e:	f003 fb63 	bl	801c028 <nk_zero>
    button->normal          = nk_style_item_color(table[NK_COLOR_BUTTON]);
 8018962:	6a3b      	ldr	r3, [r7, #32]
 8018964:	3310      	adds	r3, #16
 8018966:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8018968:	463a      	mov	r2, r7
 801896a:	6819      	ldr	r1, [r3, #0]
 801896c:	460b      	mov	r3, r1
 801896e:	4619      	mov	r1, r3
 8018970:	4610      	mov	r0, r2
 8018972:	f7ff ff81 	bl	8018878 <nk_style_item_color>
 8018976:	4625      	mov	r5, r4
 8018978:	463c      	mov	r4, r7
 801897a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801897c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801897e:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8018982:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    button->hover           = nk_style_item_color(table[NK_COLOR_BUTTON_HOVER]);
 8018986:	6a3b      	ldr	r3, [r7, #32]
 8018988:	3314      	adds	r3, #20
 801898a:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801898c:	463a      	mov	r2, r7
 801898e:	6819      	ldr	r1, [r3, #0]
 8018990:	460b      	mov	r3, r1
 8018992:	4619      	mov	r1, r3
 8018994:	4610      	mov	r0, r2
 8018996:	f7ff ff6f 	bl	8018878 <nk_style_item_color>
 801899a:	341c      	adds	r4, #28
 801899c:	463d      	mov	r5, r7
 801899e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80189a0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80189a2:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 80189a6:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->active          = nk_style_item_color(table[NK_COLOR_BUTTON_ACTIVE]);
 80189aa:	6a3b      	ldr	r3, [r7, #32]
 80189ac:	3318      	adds	r3, #24
 80189ae:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 80189b0:	463a      	mov	r2, r7
 80189b2:	6819      	ldr	r1, [r3, #0]
 80189b4:	460b      	mov	r3, r1
 80189b6:	4619      	mov	r1, r3
 80189b8:	4610      	mov	r0, r2
 80189ba:	f7ff ff5d 	bl	8018878 <nk_style_item_color>
 80189be:	3438      	adds	r4, #56	; 0x38
 80189c0:	463d      	mov	r5, r7
 80189c2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80189c4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80189c6:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 80189ca:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->border_color    = table[NK_COLOR_BORDER];
 80189ce:	6a3b      	ldr	r3, [r7, #32]
 80189d0:	f103 020c 	add.w	r2, r3, #12
 80189d4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80189d6:	3354      	adds	r3, #84	; 0x54
 80189d8:	6810      	ldr	r0, [r2, #0]
 80189da:	6018      	str	r0, [r3, #0]
    button->text_background = table[NK_COLOR_BUTTON];
 80189dc:	6a3b      	ldr	r3, [r7, #32]
 80189de:	f103 0210 	add.w	r2, r3, #16
 80189e2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80189e4:	3358      	adds	r3, #88	; 0x58
 80189e6:	6810      	ldr	r0, [r2, #0]
 80189e8:	6018      	str	r0, [r3, #0]
    button->text_normal     = table[NK_COLOR_TEXT];
 80189ea:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80189ec:	6a3a      	ldr	r2, [r7, #32]
 80189ee:	335c      	adds	r3, #92	; 0x5c
 80189f0:	6810      	ldr	r0, [r2, #0]
 80189f2:	6018      	str	r0, [r3, #0]
    button->text_hover      = table[NK_COLOR_TEXT];
 80189f4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80189f6:	6a3a      	ldr	r2, [r7, #32]
 80189f8:	3360      	adds	r3, #96	; 0x60
 80189fa:	6810      	ldr	r0, [r2, #0]
 80189fc:	6018      	str	r0, [r3, #0]
    button->text_active     = table[NK_COLOR_TEXT];
 80189fe:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018a00:	6a3a      	ldr	r2, [r7, #32]
 8018a02:	3364      	adds	r3, #100	; 0x64
 8018a04:	6810      	ldr	r0, [r2, #0]
 8018a06:	6018      	str	r0, [r3, #0]
    button->padding         = nk_vec2(2.0f,2.0f);
 8018a08:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8018a0a:	eef0 0a00 	vmov.f32	s1, #0	; 0x40000000  2.0
 8018a0e:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8018a12:	f7fa ff51 	bl	80138b8 <nk_vec2>
 8018a16:	eeb0 7a40 	vmov.f32	s14, s0
 8018a1a:	eef0 7a60 	vmov.f32	s15, s1
 8018a1e:	ed84 7a1d 	vstr	s14, [r4, #116]	; 0x74
 8018a22:	edc4 7a1e 	vstr	s15, [r4, #120]	; 0x78
    button->image_padding   = nk_vec2(0.0f,0.0f);
 8018a26:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8018a28:	eddf 0a86 	vldr	s1, [pc, #536]	; 8018c44 <nk_style_from_table+0x364>
 8018a2c:	ed9f 0a85 	vldr	s0, [pc, #532]	; 8018c44 <nk_style_from_table+0x364>
 8018a30:	f7fa ff42 	bl	80138b8 <nk_vec2>
 8018a34:	eeb0 7a40 	vmov.f32	s14, s0
 8018a38:	eef0 7a60 	vmov.f32	s15, s1
 8018a3c:	ed84 7a1f 	vstr	s14, [r4, #124]	; 0x7c
 8018a40:	edc4 7a20 	vstr	s15, [r4, #128]	; 0x80
    button->touch_padding   = nk_vec2(0.0f, 0.0f);
 8018a44:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8018a46:	eddf 0a7f 	vldr	s1, [pc, #508]	; 8018c44 <nk_style_from_table+0x364>
 8018a4a:	ed9f 0a7e 	vldr	s0, [pc, #504]	; 8018c44 <nk_style_from_table+0x364>
 8018a4e:	f7fa ff33 	bl	80138b8 <nk_vec2>
 8018a52:	eeb0 7a40 	vmov.f32	s14, s0
 8018a56:	eef0 7a60 	vmov.f32	s15, s1
 8018a5a:	ed84 7a21 	vstr	s14, [r4, #132]	; 0x84
 8018a5e:	edc4 7a22 	vstr	s15, [r4, #136]	; 0x88
    button->userdata        = nk_handle_ptr(0);
 8018a62:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8018a64:	2000      	movs	r0, #0
 8018a66:	f7f9 fadb 	bl	8012020 <nk_handle_ptr>
 8018a6a:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    button->text_alignment  = NK_TEXT_CENTERED;
 8018a6e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018a70:	2212      	movs	r2, #18
 8018a72:	669a      	str	r2, [r3, #104]	; 0x68
    button->border          = 1.0f;
 8018a74:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018a76:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8018a7a:	66da      	str	r2, [r3, #108]	; 0x6c
    button->rounding        = 4.0f;
 8018a7c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018a7e:	f04f 4281 	mov.w	r2, #1082130432	; 0x40800000
 8018a82:	671a      	str	r2, [r3, #112]	; 0x70
    button->draw_begin      = 0;
 8018a84:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018a86:	2200      	movs	r2, #0
 8018a88:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    button->draw_end        = 0;
 8018a8c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018a8e:	2200      	movs	r2, #0
 8018a90:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

    /* contextual button */
    button = &style->contextual_button;
 8018a94:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018a96:	33d0      	adds	r3, #208	; 0xd0
 8018a98:	66fb      	str	r3, [r7, #108]	; 0x6c
    nk_zero_struct(*button);
 8018a9a:	2198      	movs	r1, #152	; 0x98
 8018a9c:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 8018a9e:	f003 fac3 	bl	801c028 <nk_zero>
    button->normal          = nk_style_item_color(table[NK_COLOR_WINDOW]);
 8018aa2:	6a3b      	ldr	r3, [r7, #32]
 8018aa4:	3304      	adds	r3, #4
 8018aa6:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8018aa8:	463a      	mov	r2, r7
 8018aaa:	6819      	ldr	r1, [r3, #0]
 8018aac:	460b      	mov	r3, r1
 8018aae:	4619      	mov	r1, r3
 8018ab0:	4610      	mov	r0, r2
 8018ab2:	f7ff fee1 	bl	8018878 <nk_style_item_color>
 8018ab6:	4625      	mov	r5, r4
 8018ab8:	463c      	mov	r4, r7
 8018aba:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8018abc:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8018abe:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8018ac2:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    button->hover           = nk_style_item_color(table[NK_COLOR_BUTTON_HOVER]);
 8018ac6:	6a3b      	ldr	r3, [r7, #32]
 8018ac8:	3314      	adds	r3, #20
 8018aca:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8018acc:	463a      	mov	r2, r7
 8018ace:	6819      	ldr	r1, [r3, #0]
 8018ad0:	460b      	mov	r3, r1
 8018ad2:	4619      	mov	r1, r3
 8018ad4:	4610      	mov	r0, r2
 8018ad6:	f7ff fecf 	bl	8018878 <nk_style_item_color>
 8018ada:	341c      	adds	r4, #28
 8018adc:	463d      	mov	r5, r7
 8018ade:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018ae0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8018ae2:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8018ae6:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->active          = nk_style_item_color(table[NK_COLOR_BUTTON_ACTIVE]);
 8018aea:	6a3b      	ldr	r3, [r7, #32]
 8018aec:	3318      	adds	r3, #24
 8018aee:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8018af0:	463a      	mov	r2, r7
 8018af2:	6819      	ldr	r1, [r3, #0]
 8018af4:	460b      	mov	r3, r1
 8018af6:	4619      	mov	r1, r3
 8018af8:	4610      	mov	r0, r2
 8018afa:	f7ff febd 	bl	8018878 <nk_style_item_color>
 8018afe:	3438      	adds	r4, #56	; 0x38
 8018b00:	463d      	mov	r5, r7
 8018b02:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018b04:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8018b06:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8018b0a:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->border_color    = table[NK_COLOR_WINDOW];
 8018b0e:	6a3b      	ldr	r3, [r7, #32]
 8018b10:	1d1a      	adds	r2, r3, #4
 8018b12:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018b14:	3354      	adds	r3, #84	; 0x54
 8018b16:	6810      	ldr	r0, [r2, #0]
 8018b18:	6018      	str	r0, [r3, #0]
    button->text_background = table[NK_COLOR_WINDOW];
 8018b1a:	6a3b      	ldr	r3, [r7, #32]
 8018b1c:	1d1a      	adds	r2, r3, #4
 8018b1e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018b20:	3358      	adds	r3, #88	; 0x58
 8018b22:	6810      	ldr	r0, [r2, #0]
 8018b24:	6018      	str	r0, [r3, #0]
    button->text_normal     = table[NK_COLOR_TEXT];
 8018b26:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018b28:	6a3a      	ldr	r2, [r7, #32]
 8018b2a:	335c      	adds	r3, #92	; 0x5c
 8018b2c:	6810      	ldr	r0, [r2, #0]
 8018b2e:	6018      	str	r0, [r3, #0]
    button->text_hover      = table[NK_COLOR_TEXT];
 8018b30:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018b32:	6a3a      	ldr	r2, [r7, #32]
 8018b34:	3360      	adds	r3, #96	; 0x60
 8018b36:	6810      	ldr	r0, [r2, #0]
 8018b38:	6018      	str	r0, [r3, #0]
    button->text_active     = table[NK_COLOR_TEXT];
 8018b3a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018b3c:	6a3a      	ldr	r2, [r7, #32]
 8018b3e:	3364      	adds	r3, #100	; 0x64
 8018b40:	6810      	ldr	r0, [r2, #0]
 8018b42:	6018      	str	r0, [r3, #0]
    button->padding         = nk_vec2(2.0f,2.0f);
 8018b44:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8018b46:	eef0 0a00 	vmov.f32	s1, #0	; 0x40000000  2.0
 8018b4a:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8018b4e:	f7fa feb3 	bl	80138b8 <nk_vec2>
 8018b52:	eeb0 7a40 	vmov.f32	s14, s0
 8018b56:	eef0 7a60 	vmov.f32	s15, s1
 8018b5a:	ed84 7a1d 	vstr	s14, [r4, #116]	; 0x74
 8018b5e:	edc4 7a1e 	vstr	s15, [r4, #120]	; 0x78
    button->touch_padding   = nk_vec2(0.0f,0.0f);
 8018b62:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8018b64:	eddf 0a37 	vldr	s1, [pc, #220]	; 8018c44 <nk_style_from_table+0x364>
 8018b68:	ed9f 0a36 	vldr	s0, [pc, #216]	; 8018c44 <nk_style_from_table+0x364>
 8018b6c:	f7fa fea4 	bl	80138b8 <nk_vec2>
 8018b70:	eeb0 7a40 	vmov.f32	s14, s0
 8018b74:	eef0 7a60 	vmov.f32	s15, s1
 8018b78:	ed84 7a21 	vstr	s14, [r4, #132]	; 0x84
 8018b7c:	edc4 7a22 	vstr	s15, [r4, #136]	; 0x88
    button->userdata        = nk_handle_ptr(0);
 8018b80:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8018b82:	2000      	movs	r0, #0
 8018b84:	f7f9 fa4c 	bl	8012020 <nk_handle_ptr>
 8018b88:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    button->text_alignment  = NK_TEXT_CENTERED;
 8018b8c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018b8e:	2212      	movs	r2, #18
 8018b90:	669a      	str	r2, [r3, #104]	; 0x68
    button->border          = 0.0f;
 8018b92:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018b94:	f04f 0200 	mov.w	r2, #0
 8018b98:	66da      	str	r2, [r3, #108]	; 0x6c
    button->rounding        = 0.0f;
 8018b9a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018b9c:	f04f 0200 	mov.w	r2, #0
 8018ba0:	671a      	str	r2, [r3, #112]	; 0x70
    button->draw_begin      = 0;
 8018ba2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018ba4:	2200      	movs	r2, #0
 8018ba6:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    button->draw_end        = 0;
 8018baa:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018bac:	2200      	movs	r2, #0
 8018bae:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

    /* menu button */
    button = &style->menu_button;
 8018bb2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018bb4:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 8018bb8:	66fb      	str	r3, [r7, #108]	; 0x6c
    nk_zero_struct(*button);
 8018bba:	2198      	movs	r1, #152	; 0x98
 8018bbc:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 8018bbe:	f003 fa33 	bl	801c028 <nk_zero>
    button->normal          = nk_style_item_color(table[NK_COLOR_WINDOW]);
 8018bc2:	6a3b      	ldr	r3, [r7, #32]
 8018bc4:	3304      	adds	r3, #4
 8018bc6:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8018bc8:	463a      	mov	r2, r7
 8018bca:	6819      	ldr	r1, [r3, #0]
 8018bcc:	460b      	mov	r3, r1
 8018bce:	4619      	mov	r1, r3
 8018bd0:	4610      	mov	r0, r2
 8018bd2:	f7ff fe51 	bl	8018878 <nk_style_item_color>
 8018bd6:	4625      	mov	r5, r4
 8018bd8:	463c      	mov	r4, r7
 8018bda:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8018bdc:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8018bde:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8018be2:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    button->hover           = nk_style_item_color(table[NK_COLOR_WINDOW]);
 8018be6:	6a3b      	ldr	r3, [r7, #32]
 8018be8:	3304      	adds	r3, #4
 8018bea:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8018bec:	463a      	mov	r2, r7
 8018bee:	6819      	ldr	r1, [r3, #0]
 8018bf0:	460b      	mov	r3, r1
 8018bf2:	4619      	mov	r1, r3
 8018bf4:	4610      	mov	r0, r2
 8018bf6:	f7ff fe3f 	bl	8018878 <nk_style_item_color>
 8018bfa:	341c      	adds	r4, #28
 8018bfc:	463d      	mov	r5, r7
 8018bfe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018c00:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8018c02:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8018c06:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->active          = nk_style_item_color(table[NK_COLOR_WINDOW]);
 8018c0a:	6a3b      	ldr	r3, [r7, #32]
 8018c0c:	3304      	adds	r3, #4
 8018c0e:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8018c10:	463a      	mov	r2, r7
 8018c12:	6819      	ldr	r1, [r3, #0]
 8018c14:	460b      	mov	r3, r1
 8018c16:	4619      	mov	r1, r3
 8018c18:	4610      	mov	r0, r2
 8018c1a:	f7ff fe2d 	bl	8018878 <nk_style_item_color>
 8018c1e:	3438      	adds	r4, #56	; 0x38
 8018c20:	463d      	mov	r5, r7
 8018c22:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018c24:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8018c26:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8018c2a:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->border_color    = table[NK_COLOR_WINDOW];
 8018c2e:	6a3b      	ldr	r3, [r7, #32]
 8018c30:	1d1a      	adds	r2, r3, #4
 8018c32:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018c34:	3354      	adds	r3, #84	; 0x54
 8018c36:	6810      	ldr	r0, [r2, #0]
 8018c38:	6018      	str	r0, [r3, #0]
    button->text_background = table[NK_COLOR_WINDOW];
 8018c3a:	6a3b      	ldr	r3, [r7, #32]
 8018c3c:	1d1a      	adds	r2, r3, #4
 8018c3e:	e003      	b.n	8018c48 <nk_style_from_table+0x368>
 8018c40:	0802368c 	.word	0x0802368c
 8018c44:	00000000 	.word	0x00000000
 8018c48:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018c4a:	3358      	adds	r3, #88	; 0x58
 8018c4c:	6810      	ldr	r0, [r2, #0]
 8018c4e:	6018      	str	r0, [r3, #0]
    button->text_normal     = table[NK_COLOR_TEXT];
 8018c50:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018c52:	6a3a      	ldr	r2, [r7, #32]
 8018c54:	335c      	adds	r3, #92	; 0x5c
 8018c56:	6810      	ldr	r0, [r2, #0]
 8018c58:	6018      	str	r0, [r3, #0]
    button->text_hover      = table[NK_COLOR_TEXT];
 8018c5a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018c5c:	6a3a      	ldr	r2, [r7, #32]
 8018c5e:	3360      	adds	r3, #96	; 0x60
 8018c60:	6810      	ldr	r0, [r2, #0]
 8018c62:	6018      	str	r0, [r3, #0]
    button->text_active     = table[NK_COLOR_TEXT];
 8018c64:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018c66:	6a3a      	ldr	r2, [r7, #32]
 8018c68:	3364      	adds	r3, #100	; 0x64
 8018c6a:	6810      	ldr	r0, [r2, #0]
 8018c6c:	6018      	str	r0, [r3, #0]
    button->padding         = nk_vec2(2.0f,2.0f);
 8018c6e:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8018c70:	eef0 0a00 	vmov.f32	s1, #0	; 0x40000000  2.0
 8018c74:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8018c78:	f7fa fe1e 	bl	80138b8 <nk_vec2>
 8018c7c:	eeb0 7a40 	vmov.f32	s14, s0
 8018c80:	eef0 7a60 	vmov.f32	s15, s1
 8018c84:	ed84 7a1d 	vstr	s14, [r4, #116]	; 0x74
 8018c88:	edc4 7a1e 	vstr	s15, [r4, #120]	; 0x78
    button->touch_padding   = nk_vec2(0.0f,0.0f);
 8018c8c:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8018c8e:	ed5f 0a13 	vldr	s1, [pc, #-76]	; 8018c44 <nk_style_from_table+0x364>
 8018c92:	ed1f 0a14 	vldr	s0, [pc, #-80]	; 8018c44 <nk_style_from_table+0x364>
 8018c96:	f7fa fe0f 	bl	80138b8 <nk_vec2>
 8018c9a:	eeb0 7a40 	vmov.f32	s14, s0
 8018c9e:	eef0 7a60 	vmov.f32	s15, s1
 8018ca2:	ed84 7a21 	vstr	s14, [r4, #132]	; 0x84
 8018ca6:	edc4 7a22 	vstr	s15, [r4, #136]	; 0x88
    button->userdata        = nk_handle_ptr(0);
 8018caa:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8018cac:	2000      	movs	r0, #0
 8018cae:	f7f9 f9b7 	bl	8012020 <nk_handle_ptr>
 8018cb2:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    button->text_alignment  = NK_TEXT_CENTERED;
 8018cb6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018cb8:	2212      	movs	r2, #18
 8018cba:	669a      	str	r2, [r3, #104]	; 0x68
    button->border          = 0.0f;
 8018cbc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018cbe:	f04f 0200 	mov.w	r2, #0
 8018cc2:	66da      	str	r2, [r3, #108]	; 0x6c
    button->rounding        = 1.0f;
 8018cc4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018cc6:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8018cca:	671a      	str	r2, [r3, #112]	; 0x70
    button->draw_begin      = 0;
 8018ccc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018cce:	2200      	movs	r2, #0
 8018cd0:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    button->draw_end        = 0;
 8018cd4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018cd6:	2200      	movs	r2, #0
 8018cd8:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

    /* checkbox toggle */
    toggle = &style->checkbox;
 8018cdc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018cde:	f503 7332 	add.w	r3, r3, #712	; 0x2c8
 8018ce2:	66bb      	str	r3, [r7, #104]	; 0x68
    nk_zero_struct(*toggle);
 8018ce4:	21c8      	movs	r1, #200	; 0xc8
 8018ce6:	6eb8      	ldr	r0, [r7, #104]	; 0x68
 8018ce8:	f003 f99e 	bl	801c028 <nk_zero>
    toggle->normal          = nk_style_item_color(table[NK_COLOR_TOGGLE]);
 8018cec:	6a3b      	ldr	r3, [r7, #32]
 8018cee:	331c      	adds	r3, #28
 8018cf0:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 8018cf2:	463a      	mov	r2, r7
 8018cf4:	6819      	ldr	r1, [r3, #0]
 8018cf6:	460b      	mov	r3, r1
 8018cf8:	4619      	mov	r1, r3
 8018cfa:	4610      	mov	r0, r2
 8018cfc:	f7ff fdbc 	bl	8018878 <nk_style_item_color>
 8018d00:	4625      	mov	r5, r4
 8018d02:	463c      	mov	r4, r7
 8018d04:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8018d06:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8018d08:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8018d0c:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    toggle->hover           = nk_style_item_color(table[NK_COLOR_TOGGLE_HOVER]);
 8018d10:	6a3b      	ldr	r3, [r7, #32]
 8018d12:	3320      	adds	r3, #32
 8018d14:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 8018d16:	463a      	mov	r2, r7
 8018d18:	6819      	ldr	r1, [r3, #0]
 8018d1a:	460b      	mov	r3, r1
 8018d1c:	4619      	mov	r1, r3
 8018d1e:	4610      	mov	r0, r2
 8018d20:	f7ff fdaa 	bl	8018878 <nk_style_item_color>
 8018d24:	341c      	adds	r4, #28
 8018d26:	463d      	mov	r5, r7
 8018d28:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018d2a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8018d2c:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8018d30:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    toggle->active          = nk_style_item_color(table[NK_COLOR_TOGGLE_HOVER]);
 8018d34:	6a3b      	ldr	r3, [r7, #32]
 8018d36:	3320      	adds	r3, #32
 8018d38:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 8018d3a:	463a      	mov	r2, r7
 8018d3c:	6819      	ldr	r1, [r3, #0]
 8018d3e:	460b      	mov	r3, r1
 8018d40:	4619      	mov	r1, r3
 8018d42:	4610      	mov	r0, r2
 8018d44:	f7ff fd98 	bl	8018878 <nk_style_item_color>
 8018d48:	3438      	adds	r4, #56	; 0x38
 8018d4a:	463d      	mov	r5, r7
 8018d4c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018d4e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8018d50:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8018d54:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    toggle->cursor_normal   = nk_style_item_color(table[NK_COLOR_TOGGLE_CURSOR]);
 8018d58:	6a3b      	ldr	r3, [r7, #32]
 8018d5a:	3324      	adds	r3, #36	; 0x24
 8018d5c:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 8018d5e:	463a      	mov	r2, r7
 8018d60:	6819      	ldr	r1, [r3, #0]
 8018d62:	460b      	mov	r3, r1
 8018d64:	4619      	mov	r1, r3
 8018d66:	4610      	mov	r0, r2
 8018d68:	f7ff fd86 	bl	8018878 <nk_style_item_color>
 8018d6c:	3458      	adds	r4, #88	; 0x58
 8018d6e:	463d      	mov	r5, r7
 8018d70:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018d72:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8018d74:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8018d78:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    toggle->cursor_hover    = nk_style_item_color(table[NK_COLOR_TOGGLE_CURSOR]);
 8018d7c:	6a3b      	ldr	r3, [r7, #32]
 8018d7e:	3324      	adds	r3, #36	; 0x24
 8018d80:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 8018d82:	463a      	mov	r2, r7
 8018d84:	6819      	ldr	r1, [r3, #0]
 8018d86:	460b      	mov	r3, r1
 8018d88:	4619      	mov	r1, r3
 8018d8a:	4610      	mov	r0, r2
 8018d8c:	f7ff fd74 	bl	8018878 <nk_style_item_color>
 8018d90:	3474      	adds	r4, #116	; 0x74
 8018d92:	463d      	mov	r5, r7
 8018d94:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018d96:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8018d98:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8018d9c:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    toggle->userdata        = nk_handle_ptr(0);
 8018da0:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 8018da2:	2000      	movs	r0, #0
 8018da4:	f7f9 f93c 	bl	8012020 <nk_handle_ptr>
 8018da8:	f8c4 00bc 	str.w	r0, [r4, #188]	; 0xbc
    toggle->text_background = table[NK_COLOR_WINDOW];
 8018dac:	6a3b      	ldr	r3, [r7, #32]
 8018dae:	1d1a      	adds	r2, r3, #4
 8018db0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018db2:	339c      	adds	r3, #156	; 0x9c
 8018db4:	6810      	ldr	r0, [r2, #0]
 8018db6:	6018      	str	r0, [r3, #0]
    toggle->text_normal     = table[NK_COLOR_TEXT];
 8018db8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018dba:	6a3a      	ldr	r2, [r7, #32]
 8018dbc:	3390      	adds	r3, #144	; 0x90
 8018dbe:	6810      	ldr	r0, [r2, #0]
 8018dc0:	6018      	str	r0, [r3, #0]
    toggle->text_hover      = table[NK_COLOR_TEXT];
 8018dc2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018dc4:	6a3a      	ldr	r2, [r7, #32]
 8018dc6:	3394      	adds	r3, #148	; 0x94
 8018dc8:	6810      	ldr	r0, [r2, #0]
 8018dca:	6018      	str	r0, [r3, #0]
    toggle->text_active     = table[NK_COLOR_TEXT];
 8018dcc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018dce:	6a3a      	ldr	r2, [r7, #32]
 8018dd0:	3398      	adds	r3, #152	; 0x98
 8018dd2:	6810      	ldr	r0, [r2, #0]
 8018dd4:	6018      	str	r0, [r3, #0]
    toggle->padding         = nk_vec2(2.0f, 2.0f);
 8018dd6:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 8018dd8:	eef0 0a00 	vmov.f32	s1, #0	; 0x40000000  2.0
 8018ddc:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8018de0:	f7fa fd6a 	bl	80138b8 <nk_vec2>
 8018de4:	eeb0 7a40 	vmov.f32	s14, s0
 8018de8:	eef0 7a60 	vmov.f32	s15, s1
 8018dec:	ed84 7a29 	vstr	s14, [r4, #164]	; 0xa4
 8018df0:	edc4 7a2a 	vstr	s15, [r4, #168]	; 0xa8
    toggle->touch_padding   = nk_vec2(0,0);
 8018df4:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 8018df6:	ed5f 0a6d 	vldr	s1, [pc, #-436]	; 8018c44 <nk_style_from_table+0x364>
 8018dfa:	ed1f 0a6e 	vldr	s0, [pc, #-440]	; 8018c44 <nk_style_from_table+0x364>
 8018dfe:	f7fa fd5b 	bl	80138b8 <nk_vec2>
 8018e02:	eeb0 7a40 	vmov.f32	s14, s0
 8018e06:	eef0 7a60 	vmov.f32	s15, s1
 8018e0a:	ed84 7a2b 	vstr	s14, [r4, #172]	; 0xac
 8018e0e:	edc4 7a2c 	vstr	s15, [r4, #176]	; 0xb0
    toggle->border_color    = nk_rgba(0,0,0,0);
 8018e12:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 8018e14:	2300      	movs	r3, #0
 8018e16:	2200      	movs	r2, #0
 8018e18:	2100      	movs	r1, #0
 8018e1a:	2000      	movs	r0, #0
 8018e1c:	f7f6 f830 	bl	800ee80 <nk_rgba>
 8018e20:	4603      	mov	r3, r0
 8018e22:	6563      	str	r3, [r4, #84]	; 0x54
    toggle->border          = 0.0f;
 8018e24:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018e26:	f04f 0200 	mov.w	r2, #0
 8018e2a:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
    toggle->spacing         = 4;
 8018e2e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018e30:	f04f 4281 	mov.w	r2, #1082130432	; 0x40800000
 8018e34:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4

    /* option toggle */
    toggle = &style->option;
 8018e38:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018e3a:	f503 7300 	add.w	r3, r3, #512	; 0x200
 8018e3e:	66bb      	str	r3, [r7, #104]	; 0x68
    nk_zero_struct(*toggle);
 8018e40:	21c8      	movs	r1, #200	; 0xc8
 8018e42:	6eb8      	ldr	r0, [r7, #104]	; 0x68
 8018e44:	f003 f8f0 	bl	801c028 <nk_zero>
    toggle->normal          = nk_style_item_color(table[NK_COLOR_TOGGLE]);
 8018e48:	6a3b      	ldr	r3, [r7, #32]
 8018e4a:	331c      	adds	r3, #28
 8018e4c:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 8018e4e:	463a      	mov	r2, r7
 8018e50:	6819      	ldr	r1, [r3, #0]
 8018e52:	460b      	mov	r3, r1
 8018e54:	4619      	mov	r1, r3
 8018e56:	4610      	mov	r0, r2
 8018e58:	f7ff fd0e 	bl	8018878 <nk_style_item_color>
 8018e5c:	4625      	mov	r5, r4
 8018e5e:	463c      	mov	r4, r7
 8018e60:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8018e62:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8018e64:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8018e68:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    toggle->hover           = nk_style_item_color(table[NK_COLOR_TOGGLE_HOVER]);
 8018e6c:	6a3b      	ldr	r3, [r7, #32]
 8018e6e:	3320      	adds	r3, #32
 8018e70:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 8018e72:	463a      	mov	r2, r7
 8018e74:	6819      	ldr	r1, [r3, #0]
 8018e76:	460b      	mov	r3, r1
 8018e78:	4619      	mov	r1, r3
 8018e7a:	4610      	mov	r0, r2
 8018e7c:	f7ff fcfc 	bl	8018878 <nk_style_item_color>
 8018e80:	341c      	adds	r4, #28
 8018e82:	463d      	mov	r5, r7
 8018e84:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018e86:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8018e88:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8018e8c:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    toggle->active          = nk_style_item_color(table[NK_COLOR_TOGGLE_HOVER]);
 8018e90:	6a3b      	ldr	r3, [r7, #32]
 8018e92:	3320      	adds	r3, #32
 8018e94:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 8018e96:	463a      	mov	r2, r7
 8018e98:	6819      	ldr	r1, [r3, #0]
 8018e9a:	460b      	mov	r3, r1
 8018e9c:	4619      	mov	r1, r3
 8018e9e:	4610      	mov	r0, r2
 8018ea0:	f7ff fcea 	bl	8018878 <nk_style_item_color>
 8018ea4:	3438      	adds	r4, #56	; 0x38
 8018ea6:	463d      	mov	r5, r7
 8018ea8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018eaa:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8018eac:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8018eb0:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    toggle->cursor_normal   = nk_style_item_color(table[NK_COLOR_TOGGLE_CURSOR]);
 8018eb4:	6a3b      	ldr	r3, [r7, #32]
 8018eb6:	3324      	adds	r3, #36	; 0x24
 8018eb8:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 8018eba:	463a      	mov	r2, r7
 8018ebc:	6819      	ldr	r1, [r3, #0]
 8018ebe:	460b      	mov	r3, r1
 8018ec0:	4619      	mov	r1, r3
 8018ec2:	4610      	mov	r0, r2
 8018ec4:	f7ff fcd8 	bl	8018878 <nk_style_item_color>
 8018ec8:	3458      	adds	r4, #88	; 0x58
 8018eca:	463d      	mov	r5, r7
 8018ecc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018ece:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8018ed0:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8018ed4:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    toggle->cursor_hover    = nk_style_item_color(table[NK_COLOR_TOGGLE_CURSOR]);
 8018ed8:	6a3b      	ldr	r3, [r7, #32]
 8018eda:	3324      	adds	r3, #36	; 0x24
 8018edc:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 8018ede:	463a      	mov	r2, r7
 8018ee0:	6819      	ldr	r1, [r3, #0]
 8018ee2:	460b      	mov	r3, r1
 8018ee4:	4619      	mov	r1, r3
 8018ee6:	4610      	mov	r0, r2
 8018ee8:	f7ff fcc6 	bl	8018878 <nk_style_item_color>
 8018eec:	3474      	adds	r4, #116	; 0x74
 8018eee:	463d      	mov	r5, r7
 8018ef0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018ef2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8018ef4:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8018ef8:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    toggle->userdata        = nk_handle_ptr(0);
 8018efc:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 8018efe:	2000      	movs	r0, #0
 8018f00:	f7f9 f88e 	bl	8012020 <nk_handle_ptr>
 8018f04:	f8c4 00bc 	str.w	r0, [r4, #188]	; 0xbc
    toggle->text_background = table[NK_COLOR_WINDOW];
 8018f08:	6a3b      	ldr	r3, [r7, #32]
 8018f0a:	1d1a      	adds	r2, r3, #4
 8018f0c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018f0e:	339c      	adds	r3, #156	; 0x9c
 8018f10:	6810      	ldr	r0, [r2, #0]
 8018f12:	6018      	str	r0, [r3, #0]
    toggle->text_normal     = table[NK_COLOR_TEXT];
 8018f14:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018f16:	6a3a      	ldr	r2, [r7, #32]
 8018f18:	3390      	adds	r3, #144	; 0x90
 8018f1a:	6810      	ldr	r0, [r2, #0]
 8018f1c:	6018      	str	r0, [r3, #0]
    toggle->text_hover      = table[NK_COLOR_TEXT];
 8018f1e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018f20:	6a3a      	ldr	r2, [r7, #32]
 8018f22:	3394      	adds	r3, #148	; 0x94
 8018f24:	6810      	ldr	r0, [r2, #0]
 8018f26:	6018      	str	r0, [r3, #0]
    toggle->text_active     = table[NK_COLOR_TEXT];
 8018f28:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018f2a:	6a3a      	ldr	r2, [r7, #32]
 8018f2c:	3398      	adds	r3, #152	; 0x98
 8018f2e:	6810      	ldr	r0, [r2, #0]
 8018f30:	6018      	str	r0, [r3, #0]
    toggle->padding         = nk_vec2(3.0f, 3.0f);
 8018f32:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 8018f34:	eef0 0a08 	vmov.f32	s1, #8	; 0x40400000  3.0
 8018f38:	eeb0 0a08 	vmov.f32	s0, #8	; 0x40400000  3.0
 8018f3c:	f7fa fcbc 	bl	80138b8 <nk_vec2>
 8018f40:	eeb0 7a40 	vmov.f32	s14, s0
 8018f44:	eef0 7a60 	vmov.f32	s15, s1
 8018f48:	ed84 7a29 	vstr	s14, [r4, #164]	; 0xa4
 8018f4c:	edc4 7a2a 	vstr	s15, [r4, #168]	; 0xa8
    toggle->touch_padding   = nk_vec2(0,0);
 8018f50:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 8018f52:	ed5f 0ac4 	vldr	s1, [pc, #-784]	; 8018c44 <nk_style_from_table+0x364>
 8018f56:	ed1f 0ac5 	vldr	s0, [pc, #-788]	; 8018c44 <nk_style_from_table+0x364>
 8018f5a:	f7fa fcad 	bl	80138b8 <nk_vec2>
 8018f5e:	eeb0 7a40 	vmov.f32	s14, s0
 8018f62:	eef0 7a60 	vmov.f32	s15, s1
 8018f66:	ed84 7a2b 	vstr	s14, [r4, #172]	; 0xac
 8018f6a:	edc4 7a2c 	vstr	s15, [r4, #176]	; 0xb0
    toggle->border_color    = nk_rgba(0,0,0,0);
 8018f6e:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 8018f70:	2300      	movs	r3, #0
 8018f72:	2200      	movs	r2, #0
 8018f74:	2100      	movs	r1, #0
 8018f76:	2000      	movs	r0, #0
 8018f78:	f7f5 ff82 	bl	800ee80 <nk_rgba>
 8018f7c:	4603      	mov	r3, r0
 8018f7e:	6563      	str	r3, [r4, #84]	; 0x54
    toggle->border          = 0.0f;
 8018f80:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018f82:	f04f 0200 	mov.w	r2, #0
 8018f86:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
    toggle->spacing         = 4;
 8018f8a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018f8c:	f04f 4281 	mov.w	r2, #1082130432	; 0x40800000
 8018f90:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4

    /* selectable */
    select = &style->selectable;
 8018f94:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018f96:	f503 7364 	add.w	r3, r3, #912	; 0x390
 8018f9a:	667b      	str	r3, [r7, #100]	; 0x64
    nk_zero_struct(*select);
 8018f9c:	21f0      	movs	r1, #240	; 0xf0
 8018f9e:	6e78      	ldr	r0, [r7, #100]	; 0x64
 8018fa0:	f003 f842 	bl	801c028 <nk_zero>
    select->normal          = nk_style_item_color(table[NK_COLOR_SELECT]);
 8018fa4:	6a3b      	ldr	r3, [r7, #32]
 8018fa6:	3328      	adds	r3, #40	; 0x28
 8018fa8:	6e7c      	ldr	r4, [r7, #100]	; 0x64
 8018faa:	463a      	mov	r2, r7
 8018fac:	6819      	ldr	r1, [r3, #0]
 8018fae:	460b      	mov	r3, r1
 8018fb0:	4619      	mov	r1, r3
 8018fb2:	4610      	mov	r0, r2
 8018fb4:	f7ff fc60 	bl	8018878 <nk_style_item_color>
 8018fb8:	4625      	mov	r5, r4
 8018fba:	463c      	mov	r4, r7
 8018fbc:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8018fbe:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8018fc0:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8018fc4:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    select->hover           = nk_style_item_color(table[NK_COLOR_SELECT]);
 8018fc8:	6a3b      	ldr	r3, [r7, #32]
 8018fca:	3328      	adds	r3, #40	; 0x28
 8018fcc:	6e7c      	ldr	r4, [r7, #100]	; 0x64
 8018fce:	463a      	mov	r2, r7
 8018fd0:	6819      	ldr	r1, [r3, #0]
 8018fd2:	460b      	mov	r3, r1
 8018fd4:	4619      	mov	r1, r3
 8018fd6:	4610      	mov	r0, r2
 8018fd8:	f7ff fc4e 	bl	8018878 <nk_style_item_color>
 8018fdc:	341c      	adds	r4, #28
 8018fde:	463d      	mov	r5, r7
 8018fe0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018fe2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8018fe4:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8018fe8:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    select->pressed         = nk_style_item_color(table[NK_COLOR_SELECT]);
 8018fec:	6a3b      	ldr	r3, [r7, #32]
 8018fee:	3328      	adds	r3, #40	; 0x28
 8018ff0:	6e7c      	ldr	r4, [r7, #100]	; 0x64
 8018ff2:	463a      	mov	r2, r7
 8018ff4:	6819      	ldr	r1, [r3, #0]
 8018ff6:	460b      	mov	r3, r1
 8018ff8:	4619      	mov	r1, r3
 8018ffa:	4610      	mov	r0, r2
 8018ffc:	f7ff fc3c 	bl	8018878 <nk_style_item_color>
 8019000:	3438      	adds	r4, #56	; 0x38
 8019002:	463d      	mov	r5, r7
 8019004:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019006:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019008:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801900c:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    select->normal_active   = nk_style_item_color(table[NK_COLOR_SELECT_ACTIVE]);
 8019010:	6a3b      	ldr	r3, [r7, #32]
 8019012:	332c      	adds	r3, #44	; 0x2c
 8019014:	6e7c      	ldr	r4, [r7, #100]	; 0x64
 8019016:	463a      	mov	r2, r7
 8019018:	6819      	ldr	r1, [r3, #0]
 801901a:	460b      	mov	r3, r1
 801901c:	4619      	mov	r1, r3
 801901e:	4610      	mov	r0, r2
 8019020:	f7ff fc2a 	bl	8018878 <nk_style_item_color>
 8019024:	3454      	adds	r4, #84	; 0x54
 8019026:	463d      	mov	r5, r7
 8019028:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801902a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801902c:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019030:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    select->hover_active    = nk_style_item_color(table[NK_COLOR_SELECT_ACTIVE]);
 8019034:	6a3b      	ldr	r3, [r7, #32]
 8019036:	332c      	adds	r3, #44	; 0x2c
 8019038:	6e7c      	ldr	r4, [r7, #100]	; 0x64
 801903a:	463a      	mov	r2, r7
 801903c:	6819      	ldr	r1, [r3, #0]
 801903e:	460b      	mov	r3, r1
 8019040:	4619      	mov	r1, r3
 8019042:	4610      	mov	r0, r2
 8019044:	f7ff fc18 	bl	8018878 <nk_style_item_color>
 8019048:	3470      	adds	r4, #112	; 0x70
 801904a:	463d      	mov	r5, r7
 801904c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801904e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019050:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019054:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    select->pressed_active  = nk_style_item_color(table[NK_COLOR_SELECT_ACTIVE]);
 8019058:	6a3b      	ldr	r3, [r7, #32]
 801905a:	332c      	adds	r3, #44	; 0x2c
 801905c:	6e7c      	ldr	r4, [r7, #100]	; 0x64
 801905e:	463a      	mov	r2, r7
 8019060:	6819      	ldr	r1, [r3, #0]
 8019062:	460b      	mov	r3, r1
 8019064:	4619      	mov	r1, r3
 8019066:	4610      	mov	r0, r2
 8019068:	f7ff fc06 	bl	8018878 <nk_style_item_color>
 801906c:	348c      	adds	r4, #140	; 0x8c
 801906e:	463d      	mov	r5, r7
 8019070:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019072:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019074:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019078:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    select->text_normal     = table[NK_COLOR_TEXT];
 801907c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801907e:	6a3a      	ldr	r2, [r7, #32]
 8019080:	33a8      	adds	r3, #168	; 0xa8
 8019082:	6810      	ldr	r0, [r2, #0]
 8019084:	6018      	str	r0, [r3, #0]
    select->text_hover      = table[NK_COLOR_TEXT];
 8019086:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8019088:	6a3a      	ldr	r2, [r7, #32]
 801908a:	33ac      	adds	r3, #172	; 0xac
 801908c:	6810      	ldr	r0, [r2, #0]
 801908e:	6018      	str	r0, [r3, #0]
    select->text_pressed    = table[NK_COLOR_TEXT];
 8019090:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8019092:	6a3a      	ldr	r2, [r7, #32]
 8019094:	33b0      	adds	r3, #176	; 0xb0
 8019096:	6810      	ldr	r0, [r2, #0]
 8019098:	6018      	str	r0, [r3, #0]
    select->text_normal_active  = table[NK_COLOR_TEXT];
 801909a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801909c:	6a3a      	ldr	r2, [r7, #32]
 801909e:	33b4      	adds	r3, #180	; 0xb4
 80190a0:	6810      	ldr	r0, [r2, #0]
 80190a2:	6018      	str	r0, [r3, #0]
    select->text_hover_active   = table[NK_COLOR_TEXT];
 80190a4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80190a6:	6a3a      	ldr	r2, [r7, #32]
 80190a8:	33b8      	adds	r3, #184	; 0xb8
 80190aa:	6810      	ldr	r0, [r2, #0]
 80190ac:	6018      	str	r0, [r3, #0]
    select->text_pressed_active = table[NK_COLOR_TEXT];
 80190ae:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80190b0:	6a3a      	ldr	r2, [r7, #32]
 80190b2:	33bc      	adds	r3, #188	; 0xbc
 80190b4:	6810      	ldr	r0, [r2, #0]
 80190b6:	6018      	str	r0, [r3, #0]
    select->padding         = nk_vec2(2.0f,2.0f);
 80190b8:	6e7c      	ldr	r4, [r7, #100]	; 0x64
 80190ba:	eef0 0a00 	vmov.f32	s1, #0	; 0x40000000  2.0
 80190be:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 80190c2:	f7fa fbf9 	bl	80138b8 <nk_vec2>
 80190c6:	eeb0 7a40 	vmov.f32	s14, s0
 80190ca:	eef0 7a60 	vmov.f32	s15, s1
 80190ce:	ed84 7a33 	vstr	s14, [r4, #204]	; 0xcc
 80190d2:	edc4 7a34 	vstr	s15, [r4, #208]	; 0xd0
    select->image_padding   = nk_vec2(2.0f,2.0f);
 80190d6:	6e7c      	ldr	r4, [r7, #100]	; 0x64
 80190d8:	eef0 0a00 	vmov.f32	s1, #0	; 0x40000000  2.0
 80190dc:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 80190e0:	f7fa fbea 	bl	80138b8 <nk_vec2>
 80190e4:	eeb0 7a40 	vmov.f32	s14, s0
 80190e8:	eef0 7a60 	vmov.f32	s15, s1
 80190ec:	ed84 7a37 	vstr	s14, [r4, #220]	; 0xdc
 80190f0:	edc4 7a38 	vstr	s15, [r4, #224]	; 0xe0
    select->touch_padding   = nk_vec2(0,0);
 80190f4:	6e7c      	ldr	r4, [r7, #100]	; 0x64
 80190f6:	eddf 0ad0 	vldr	s1, [pc, #832]	; 8019438 <nk_style_from_table+0xb58>
 80190fa:	ed9f 0acf 	vldr	s0, [pc, #828]	; 8019438 <nk_style_from_table+0xb58>
 80190fe:	f7fa fbdb 	bl	80138b8 <nk_vec2>
 8019102:	eeb0 7a40 	vmov.f32	s14, s0
 8019106:	eef0 7a60 	vmov.f32	s15, s1
 801910a:	ed84 7a35 	vstr	s14, [r4, #212]	; 0xd4
 801910e:	edc4 7a36 	vstr	s15, [r4, #216]	; 0xd8
    select->userdata        = nk_handle_ptr(0);
 8019112:	6e7c      	ldr	r4, [r7, #100]	; 0x64
 8019114:	2000      	movs	r0, #0
 8019116:	f7f8 ff83 	bl	8012020 <nk_handle_ptr>
 801911a:	f8c4 00e4 	str.w	r0, [r4, #228]	; 0xe4
    select->rounding        = 0.0f;
 801911e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8019120:	f04f 0200 	mov.w	r2, #0
 8019124:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    select->draw_begin      = 0;
 8019128:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801912a:	2200      	movs	r2, #0
 801912c:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
    select->draw_end        = 0;
 8019130:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8019132:	2200      	movs	r2, #0
 8019134:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec

    /* slider */
    slider = &style->slider;
 8019138:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801913a:	f503 6390 	add.w	r3, r3, #1152	; 0x480
 801913e:	663b      	str	r3, [r7, #96]	; 0x60
    nk_zero_struct(*slider);
 8019140:	f44f 7109 	mov.w	r1, #548	; 0x224
 8019144:	6e38      	ldr	r0, [r7, #96]	; 0x60
 8019146:	f002 ff6f 	bl	801c028 <nk_zero>
    slider->normal          = nk_style_item_hide();
 801914a:	6e3c      	ldr	r4, [r7, #96]	; 0x60
 801914c:	463b      	mov	r3, r7
 801914e:	4618      	mov	r0, r3
 8019150:	f7ff fbaa 	bl	80188a8 <nk_style_item_hide>
 8019154:	4625      	mov	r5, r4
 8019156:	463c      	mov	r4, r7
 8019158:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801915a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801915c:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8019160:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    slider->hover           = nk_style_item_hide();
 8019164:	6e3c      	ldr	r4, [r7, #96]	; 0x60
 8019166:	463b      	mov	r3, r7
 8019168:	4618      	mov	r0, r3
 801916a:	f7ff fb9d 	bl	80188a8 <nk_style_item_hide>
 801916e:	341c      	adds	r4, #28
 8019170:	463d      	mov	r5, r7
 8019172:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019174:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019176:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801917a:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    slider->active          = nk_style_item_hide();
 801917e:	6e3c      	ldr	r4, [r7, #96]	; 0x60
 8019180:	463b      	mov	r3, r7
 8019182:	4618      	mov	r0, r3
 8019184:	f7ff fb90 	bl	80188a8 <nk_style_item_hide>
 8019188:	3438      	adds	r4, #56	; 0x38
 801918a:	463d      	mov	r5, r7
 801918c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801918e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019190:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019194:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    slider->bar_normal      = table[NK_COLOR_SLIDER];
 8019198:	6a3b      	ldr	r3, [r7, #32]
 801919a:	f103 0230 	add.w	r2, r3, #48	; 0x30
 801919e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80191a0:	3358      	adds	r3, #88	; 0x58
 80191a2:	6810      	ldr	r0, [r2, #0]
 80191a4:	6018      	str	r0, [r3, #0]
    slider->bar_hover       = table[NK_COLOR_SLIDER];
 80191a6:	6a3b      	ldr	r3, [r7, #32]
 80191a8:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80191ac:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80191ae:	335c      	adds	r3, #92	; 0x5c
 80191b0:	6810      	ldr	r0, [r2, #0]
 80191b2:	6018      	str	r0, [r3, #0]
    slider->bar_active      = table[NK_COLOR_SLIDER];
 80191b4:	6a3b      	ldr	r3, [r7, #32]
 80191b6:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80191ba:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80191bc:	3360      	adds	r3, #96	; 0x60
 80191be:	6810      	ldr	r0, [r2, #0]
 80191c0:	6018      	str	r0, [r3, #0]
    slider->bar_filled      = table[NK_COLOR_SLIDER_CURSOR];
 80191c2:	6a3b      	ldr	r3, [r7, #32]
 80191c4:	f103 0234 	add.w	r2, r3, #52	; 0x34
 80191c8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80191ca:	3364      	adds	r3, #100	; 0x64
 80191cc:	6810      	ldr	r0, [r2, #0]
 80191ce:	6018      	str	r0, [r3, #0]
    slider->cursor_normal   = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR]);
 80191d0:	6a3b      	ldr	r3, [r7, #32]
 80191d2:	3334      	adds	r3, #52	; 0x34
 80191d4:	6e3c      	ldr	r4, [r7, #96]	; 0x60
 80191d6:	463a      	mov	r2, r7
 80191d8:	6819      	ldr	r1, [r3, #0]
 80191da:	460b      	mov	r3, r1
 80191dc:	4619      	mov	r1, r3
 80191de:	4610      	mov	r0, r2
 80191e0:	f7ff fb4a 	bl	8018878 <nk_style_item_color>
 80191e4:	3468      	adds	r4, #104	; 0x68
 80191e6:	463d      	mov	r5, r7
 80191e8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80191ea:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80191ec:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 80191f0:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    slider->cursor_hover    = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR_HOVER]);
 80191f4:	6a3b      	ldr	r3, [r7, #32]
 80191f6:	3338      	adds	r3, #56	; 0x38
 80191f8:	6e3c      	ldr	r4, [r7, #96]	; 0x60
 80191fa:	463a      	mov	r2, r7
 80191fc:	6819      	ldr	r1, [r3, #0]
 80191fe:	460b      	mov	r3, r1
 8019200:	4619      	mov	r1, r3
 8019202:	4610      	mov	r0, r2
 8019204:	f7ff fb38 	bl	8018878 <nk_style_item_color>
 8019208:	3484      	adds	r4, #132	; 0x84
 801920a:	463d      	mov	r5, r7
 801920c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801920e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019210:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019214:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    slider->cursor_active   = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR_ACTIVE]);
 8019218:	6a3b      	ldr	r3, [r7, #32]
 801921a:	333c      	adds	r3, #60	; 0x3c
 801921c:	6e3c      	ldr	r4, [r7, #96]	; 0x60
 801921e:	463a      	mov	r2, r7
 8019220:	6819      	ldr	r1, [r3, #0]
 8019222:	460b      	mov	r3, r1
 8019224:	4619      	mov	r1, r3
 8019226:	4610      	mov	r0, r2
 8019228:	f7ff fb26 	bl	8018878 <nk_style_item_color>
 801922c:	34a0      	adds	r4, #160	; 0xa0
 801922e:	463d      	mov	r5, r7
 8019230:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019232:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019234:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019238:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    slider->inc_symbol      = NK_SYMBOL_TRIANGLE_RIGHT;
 801923c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801923e:	220a      	movs	r2, #10
 8019240:	f883 2214 	strb.w	r2, [r3, #532]	; 0x214
    slider->dec_symbol      = NK_SYMBOL_TRIANGLE_LEFT;
 8019244:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8019246:	2209      	movs	r2, #9
 8019248:	f883 2215 	strb.w	r2, [r3, #533]	; 0x215
    slider->cursor_size     = nk_vec2(16,16);
 801924c:	6e3c      	ldr	r4, [r7, #96]	; 0x60
 801924e:	eef3 0a00 	vmov.f32	s1, #48	; 0x41800000  16.0
 8019252:	eeb3 0a00 	vmov.f32	s0, #48	; 0x41800000  16.0
 8019256:	f7fa fb2f 	bl	80138b8 <nk_vec2>
 801925a:	eeb0 7a40 	vmov.f32	s14, s0
 801925e:	eef0 7a60 	vmov.f32	s15, s1
 8019262:	ed84 7a36 	vstr	s14, [r4, #216]	; 0xd8
 8019266:	edc4 7a37 	vstr	s15, [r4, #220]	; 0xdc
    slider->padding         = nk_vec2(2,2);
 801926a:	6e3c      	ldr	r4, [r7, #96]	; 0x60
 801926c:	eef0 0a00 	vmov.f32	s1, #0	; 0x40000000  2.0
 8019270:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8019274:	f7fa fb20 	bl	80138b8 <nk_vec2>
 8019278:	eeb0 7a40 	vmov.f32	s14, s0
 801927c:	eef0 7a60 	vmov.f32	s15, s1
 8019280:	ed84 7a32 	vstr	s14, [r4, #200]	; 0xc8
 8019284:	edc4 7a33 	vstr	s15, [r4, #204]	; 0xcc
    slider->spacing         = nk_vec2(2,2);
 8019288:	6e3c      	ldr	r4, [r7, #96]	; 0x60
 801928a:	eef0 0a00 	vmov.f32	s1, #0	; 0x40000000  2.0
 801928e:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8019292:	f7fa fb11 	bl	80138b8 <nk_vec2>
 8019296:	eeb0 7a40 	vmov.f32	s14, s0
 801929a:	eef0 7a60 	vmov.f32	s15, s1
 801929e:	ed84 7a34 	vstr	s14, [r4, #208]	; 0xd0
 80192a2:	edc4 7a35 	vstr	s15, [r4, #212]	; 0xd4
    slider->userdata        = nk_handle_ptr(0);
 80192a6:	6e3c      	ldr	r4, [r7, #96]	; 0x60
 80192a8:	2000      	movs	r0, #0
 80192aa:	f7f8 feb9 	bl	8012020 <nk_handle_ptr>
 80192ae:	f8c4 0218 	str.w	r0, [r4, #536]	; 0x218
    slider->show_buttons    = nk_false;
 80192b2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80192b4:	2200      	movs	r2, #0
 80192b6:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
    slider->bar_height      = 8;
 80192ba:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80192bc:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
 80192c0:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
    slider->rounding        = 0;
 80192c4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80192c6:	f04f 0200 	mov.w	r2, #0
 80192ca:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    slider->draw_begin      = 0;
 80192ce:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80192d0:	2200      	movs	r2, #0
 80192d2:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c
    slider->draw_end        = 0;
 80192d6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80192d8:	2200      	movs	r2, #0
 80192da:	f8c3 2220 	str.w	r2, [r3, #544]	; 0x220

    /* slider buttons */
    button = &style->slider.inc_button;
 80192de:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80192e0:	f203 5364 	addw	r3, r3, #1380	; 0x564
 80192e4:	66fb      	str	r3, [r7, #108]	; 0x6c
    button->normal          = nk_style_item_color(nk_rgb(40,40,40));
 80192e6:	2228      	movs	r2, #40	; 0x28
 80192e8:	2128      	movs	r1, #40	; 0x28
 80192ea:	2028      	movs	r0, #40	; 0x28
 80192ec:	f7f5 fe18 	bl	800ef20 <nk_rgb>
 80192f0:	4603      	mov	r3, r0
 80192f2:	62bb      	str	r3, [r7, #40]	; 0x28
 80192f4:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 80192f6:	463b      	mov	r3, r7
 80192f8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80192fa:	4618      	mov	r0, r3
 80192fc:	f7ff fabc 	bl	8018878 <nk_style_item_color>
 8019300:	4625      	mov	r5, r4
 8019302:	463c      	mov	r4, r7
 8019304:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8019306:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8019308:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 801930c:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    button->hover           = nk_style_item_color(nk_rgb(42,42,42));
 8019310:	222a      	movs	r2, #42	; 0x2a
 8019312:	212a      	movs	r1, #42	; 0x2a
 8019314:	202a      	movs	r0, #42	; 0x2a
 8019316:	f7f5 fe03 	bl	800ef20 <nk_rgb>
 801931a:	4603      	mov	r3, r0
 801931c:	62fb      	str	r3, [r7, #44]	; 0x2c
 801931e:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8019320:	463b      	mov	r3, r7
 8019322:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8019324:	4618      	mov	r0, r3
 8019326:	f7ff faa7 	bl	8018878 <nk_style_item_color>
 801932a:	341c      	adds	r4, #28
 801932c:	463d      	mov	r5, r7
 801932e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019330:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019332:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019336:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->active          = nk_style_item_color(nk_rgb(44,44,44));
 801933a:	222c      	movs	r2, #44	; 0x2c
 801933c:	212c      	movs	r1, #44	; 0x2c
 801933e:	202c      	movs	r0, #44	; 0x2c
 8019340:	f7f5 fdee 	bl	800ef20 <nk_rgb>
 8019344:	4603      	mov	r3, r0
 8019346:	633b      	str	r3, [r7, #48]	; 0x30
 8019348:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801934a:	463b      	mov	r3, r7
 801934c:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801934e:	4618      	mov	r0, r3
 8019350:	f7ff fa92 	bl	8018878 <nk_style_item_color>
 8019354:	3438      	adds	r4, #56	; 0x38
 8019356:	463d      	mov	r5, r7
 8019358:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801935a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801935c:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019360:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->border_color    = nk_rgb(65,65,65);
 8019364:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8019366:	2241      	movs	r2, #65	; 0x41
 8019368:	2141      	movs	r1, #65	; 0x41
 801936a:	2041      	movs	r0, #65	; 0x41
 801936c:	f7f5 fdd8 	bl	800ef20 <nk_rgb>
 8019370:	4603      	mov	r3, r0
 8019372:	6563      	str	r3, [r4, #84]	; 0x54
    button->text_background = nk_rgb(40,40,40);
 8019374:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8019376:	2228      	movs	r2, #40	; 0x28
 8019378:	2128      	movs	r1, #40	; 0x28
 801937a:	2028      	movs	r0, #40	; 0x28
 801937c:	f7f5 fdd0 	bl	800ef20 <nk_rgb>
 8019380:	4603      	mov	r3, r0
 8019382:	65a3      	str	r3, [r4, #88]	; 0x58
    button->text_normal     = nk_rgb(175,175,175);
 8019384:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8019386:	22af      	movs	r2, #175	; 0xaf
 8019388:	21af      	movs	r1, #175	; 0xaf
 801938a:	20af      	movs	r0, #175	; 0xaf
 801938c:	f7f5 fdc8 	bl	800ef20 <nk_rgb>
 8019390:	4603      	mov	r3, r0
 8019392:	65e3      	str	r3, [r4, #92]	; 0x5c
    button->text_hover      = nk_rgb(175,175,175);
 8019394:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8019396:	22af      	movs	r2, #175	; 0xaf
 8019398:	21af      	movs	r1, #175	; 0xaf
 801939a:	20af      	movs	r0, #175	; 0xaf
 801939c:	f7f5 fdc0 	bl	800ef20 <nk_rgb>
 80193a0:	4603      	mov	r3, r0
 80193a2:	6623      	str	r3, [r4, #96]	; 0x60
    button->text_active     = nk_rgb(175,175,175);
 80193a4:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 80193a6:	22af      	movs	r2, #175	; 0xaf
 80193a8:	21af      	movs	r1, #175	; 0xaf
 80193aa:	20af      	movs	r0, #175	; 0xaf
 80193ac:	f7f5 fdb8 	bl	800ef20 <nk_rgb>
 80193b0:	4603      	mov	r3, r0
 80193b2:	6663      	str	r3, [r4, #100]	; 0x64
    button->padding         = nk_vec2(8.0f,8.0f);
 80193b4:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 80193b6:	eef2 0a00 	vmov.f32	s1, #32	; 0x41000000  8.0
 80193ba:	eeb2 0a00 	vmov.f32	s0, #32	; 0x41000000  8.0
 80193be:	f7fa fa7b 	bl	80138b8 <nk_vec2>
 80193c2:	eeb0 7a40 	vmov.f32	s14, s0
 80193c6:	eef0 7a60 	vmov.f32	s15, s1
 80193ca:	ed84 7a1d 	vstr	s14, [r4, #116]	; 0x74
 80193ce:	edc4 7a1e 	vstr	s15, [r4, #120]	; 0x78
    button->touch_padding   = nk_vec2(0.0f,0.0f);
 80193d2:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 80193d4:	eddf 0a18 	vldr	s1, [pc, #96]	; 8019438 <nk_style_from_table+0xb58>
 80193d8:	ed9f 0a17 	vldr	s0, [pc, #92]	; 8019438 <nk_style_from_table+0xb58>
 80193dc:	f7fa fa6c 	bl	80138b8 <nk_vec2>
 80193e0:	eeb0 7a40 	vmov.f32	s14, s0
 80193e4:	eef0 7a60 	vmov.f32	s15, s1
 80193e8:	ed84 7a21 	vstr	s14, [r4, #132]	; 0x84
 80193ec:	edc4 7a22 	vstr	s15, [r4, #136]	; 0x88
    button->userdata        = nk_handle_ptr(0);
 80193f0:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 80193f2:	2000      	movs	r0, #0
 80193f4:	f7f8 fe14 	bl	8012020 <nk_handle_ptr>
 80193f8:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    button->text_alignment  = NK_TEXT_CENTERED;
 80193fc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80193fe:	2212      	movs	r2, #18
 8019400:	669a      	str	r2, [r3, #104]	; 0x68
    button->border          = 1.0f;
 8019402:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8019404:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8019408:	66da      	str	r2, [r3, #108]	; 0x6c
    button->rounding        = 0.0f;
 801940a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801940c:	f04f 0200 	mov.w	r2, #0
 8019410:	671a      	str	r2, [r3, #112]	; 0x70
    button->draw_begin      = 0;
 8019412:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8019414:	2200      	movs	r2, #0
 8019416:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    button->draw_end        = 0;
 801941a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801941c:	2200      	movs	r2, #0
 801941e:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    style->slider.dec_button = style->slider.inc_button;
 8019422:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8019424:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019426:	f202 50fc 	addw	r0, r2, #1532	; 0x5fc
 801942a:	f203 5364 	addw	r3, r3, #1380	; 0x564
 801942e:	2298      	movs	r2, #152	; 0x98
 8019430:	4619      	mov	r1, r3
 8019432:	f005 f919 	bl	801e668 <memcpy>
 8019436:	e003      	b.n	8019440 <nk_style_from_table+0xb60>
	...

    /* progressbar */
    prog = &style->progress;
 8019440:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019442:	f203 63a4 	addw	r3, r3, #1700	; 0x6a4
 8019446:	65fb      	str	r3, [r7, #92]	; 0x5c
    nk_zero_struct(*prog);
 8019448:	21d4      	movs	r1, #212	; 0xd4
 801944a:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 801944c:	f002 fdec 	bl	801c028 <nk_zero>
    prog->normal            = nk_style_item_color(table[NK_COLOR_SLIDER]);
 8019450:	6a3b      	ldr	r3, [r7, #32]
 8019452:	3330      	adds	r3, #48	; 0x30
 8019454:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
 8019456:	463a      	mov	r2, r7
 8019458:	6819      	ldr	r1, [r3, #0]
 801945a:	460b      	mov	r3, r1
 801945c:	4619      	mov	r1, r3
 801945e:	4610      	mov	r0, r2
 8019460:	f7ff fa0a 	bl	8018878 <nk_style_item_color>
 8019464:	4625      	mov	r5, r4
 8019466:	463c      	mov	r4, r7
 8019468:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801946a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801946c:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8019470:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    prog->hover             = nk_style_item_color(table[NK_COLOR_SLIDER]);
 8019474:	6a3b      	ldr	r3, [r7, #32]
 8019476:	3330      	adds	r3, #48	; 0x30
 8019478:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
 801947a:	463a      	mov	r2, r7
 801947c:	6819      	ldr	r1, [r3, #0]
 801947e:	460b      	mov	r3, r1
 8019480:	4619      	mov	r1, r3
 8019482:	4610      	mov	r0, r2
 8019484:	f7ff f9f8 	bl	8018878 <nk_style_item_color>
 8019488:	341c      	adds	r4, #28
 801948a:	463d      	mov	r5, r7
 801948c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801948e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019490:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019494:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    prog->active            = nk_style_item_color(table[NK_COLOR_SLIDER]);
 8019498:	6a3b      	ldr	r3, [r7, #32]
 801949a:	3330      	adds	r3, #48	; 0x30
 801949c:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
 801949e:	463a      	mov	r2, r7
 80194a0:	6819      	ldr	r1, [r3, #0]
 80194a2:	460b      	mov	r3, r1
 80194a4:	4619      	mov	r1, r3
 80194a6:	4610      	mov	r0, r2
 80194a8:	f7ff f9e6 	bl	8018878 <nk_style_item_color>
 80194ac:	3438      	adds	r4, #56	; 0x38
 80194ae:	463d      	mov	r5, r7
 80194b0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80194b2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80194b4:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 80194b8:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    prog->cursor_normal     = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR]);
 80194bc:	6a3b      	ldr	r3, [r7, #32]
 80194be:	3334      	adds	r3, #52	; 0x34
 80194c0:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
 80194c2:	463a      	mov	r2, r7
 80194c4:	6819      	ldr	r1, [r3, #0]
 80194c6:	460b      	mov	r3, r1
 80194c8:	4619      	mov	r1, r3
 80194ca:	4610      	mov	r0, r2
 80194cc:	f7ff f9d4 	bl	8018878 <nk_style_item_color>
 80194d0:	3458      	adds	r4, #88	; 0x58
 80194d2:	463d      	mov	r5, r7
 80194d4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80194d6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80194d8:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 80194dc:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    prog->cursor_hover      = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR_HOVER]);
 80194e0:	6a3b      	ldr	r3, [r7, #32]
 80194e2:	3338      	adds	r3, #56	; 0x38
 80194e4:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
 80194e6:	463a      	mov	r2, r7
 80194e8:	6819      	ldr	r1, [r3, #0]
 80194ea:	460b      	mov	r3, r1
 80194ec:	4619      	mov	r1, r3
 80194ee:	4610      	mov	r0, r2
 80194f0:	f7ff f9c2 	bl	8018878 <nk_style_item_color>
 80194f4:	3474      	adds	r4, #116	; 0x74
 80194f6:	463d      	mov	r5, r7
 80194f8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80194fa:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80194fc:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019500:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    prog->cursor_active     = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR_ACTIVE]);
 8019504:	6a3b      	ldr	r3, [r7, #32]
 8019506:	333c      	adds	r3, #60	; 0x3c
 8019508:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
 801950a:	463a      	mov	r2, r7
 801950c:	6819      	ldr	r1, [r3, #0]
 801950e:	460b      	mov	r3, r1
 8019510:	4619      	mov	r1, r3
 8019512:	4610      	mov	r0, r2
 8019514:	f7ff f9b0 	bl	8018878 <nk_style_item_color>
 8019518:	3490      	adds	r4, #144	; 0x90
 801951a:	463d      	mov	r5, r7
 801951c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801951e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019520:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019524:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    prog->border_color      = nk_rgba(0,0,0,0);
 8019528:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
 801952a:	2300      	movs	r3, #0
 801952c:	2200      	movs	r2, #0
 801952e:	2100      	movs	r1, #0
 8019530:	2000      	movs	r0, #0
 8019532:	f7f5 fca5 	bl	800ee80 <nk_rgba>
 8019536:	4603      	mov	r3, r0
 8019538:	6563      	str	r3, [r4, #84]	; 0x54
    prog->cursor_border_color = nk_rgba(0,0,0,0);
 801953a:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
 801953c:	2300      	movs	r3, #0
 801953e:	2200      	movs	r2, #0
 8019540:	2100      	movs	r1, #0
 8019542:	2000      	movs	r0, #0
 8019544:	f7f5 fc9c 	bl	800ee80 <nk_rgba>
 8019548:	4603      	mov	r3, r0
 801954a:	f8c4 30ac 	str.w	r3, [r4, #172]	; 0xac
    prog->userdata          = nk_handle_ptr(0);
 801954e:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
 8019550:	2000      	movs	r0, #0
 8019552:	f7f8 fd65 	bl	8012020 <nk_handle_ptr>
 8019556:	f8c4 00c8 	str.w	r0, [r4, #200]	; 0xc8
    prog->padding           = nk_vec2(4,4);
 801955a:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
 801955c:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 8019560:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 8019564:	f7fa f9a8 	bl	80138b8 <nk_vec2>
 8019568:	eeb0 7a40 	vmov.f32	s14, s0
 801956c:	eef0 7a60 	vmov.f32	s15, s1
 8019570:	ed84 7a30 	vstr	s14, [r4, #192]	; 0xc0
 8019574:	edc4 7a31 	vstr	s15, [r4, #196]	; 0xc4
    prog->rounding          = 0;
 8019578:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801957a:	f04f 0200 	mov.w	r2, #0
 801957e:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
    prog->border            = 0;
 8019582:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8019584:	f04f 0200 	mov.w	r2, #0
 8019588:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
    prog->cursor_rounding   = 0;
 801958c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801958e:	f04f 0200 	mov.w	r2, #0
 8019592:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
    prog->cursor_border     = 0;
 8019596:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8019598:	f04f 0200 	mov.w	r2, #0
 801959c:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
    prog->draw_begin        = 0;
 80195a0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80195a2:	2200      	movs	r2, #0
 80195a4:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
    prog->draw_end          = 0;
 80195a8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80195aa:	2200      	movs	r2, #0
 80195ac:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0

    /* scrollbars */
    scroll = &style->scrollh;
 80195b0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80195b2:	f603 63c4 	addw	r3, r3, #3780	; 0xec4
 80195b6:	65bb      	str	r3, [r7, #88]	; 0x58
    nk_zero_struct(*scroll);
 80195b8:	f44f 7103 	mov.w	r1, #524	; 0x20c
 80195bc:	6db8      	ldr	r0, [r7, #88]	; 0x58
 80195be:	f002 fd33 	bl	801c028 <nk_zero>
    scroll->normal          = nk_style_item_color(table[NK_COLOR_SCROLLBAR]);
 80195c2:	6a3b      	ldr	r3, [r7, #32]
 80195c4:	335c      	adds	r3, #92	; 0x5c
 80195c6:	6dbc      	ldr	r4, [r7, #88]	; 0x58
 80195c8:	463a      	mov	r2, r7
 80195ca:	6819      	ldr	r1, [r3, #0]
 80195cc:	460b      	mov	r3, r1
 80195ce:	4619      	mov	r1, r3
 80195d0:	4610      	mov	r0, r2
 80195d2:	f7ff f951 	bl	8018878 <nk_style_item_color>
 80195d6:	4625      	mov	r5, r4
 80195d8:	463c      	mov	r4, r7
 80195da:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80195dc:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80195de:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 80195e2:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    scroll->hover           = nk_style_item_color(table[NK_COLOR_SCROLLBAR]);
 80195e6:	6a3b      	ldr	r3, [r7, #32]
 80195e8:	335c      	adds	r3, #92	; 0x5c
 80195ea:	6dbc      	ldr	r4, [r7, #88]	; 0x58
 80195ec:	463a      	mov	r2, r7
 80195ee:	6819      	ldr	r1, [r3, #0]
 80195f0:	460b      	mov	r3, r1
 80195f2:	4619      	mov	r1, r3
 80195f4:	4610      	mov	r0, r2
 80195f6:	f7ff f93f 	bl	8018878 <nk_style_item_color>
 80195fa:	341c      	adds	r4, #28
 80195fc:	463d      	mov	r5, r7
 80195fe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019600:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019602:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019606:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    scroll->active          = nk_style_item_color(table[NK_COLOR_SCROLLBAR]);
 801960a:	6a3b      	ldr	r3, [r7, #32]
 801960c:	335c      	adds	r3, #92	; 0x5c
 801960e:	6dbc      	ldr	r4, [r7, #88]	; 0x58
 8019610:	463a      	mov	r2, r7
 8019612:	6819      	ldr	r1, [r3, #0]
 8019614:	460b      	mov	r3, r1
 8019616:	4619      	mov	r1, r3
 8019618:	4610      	mov	r0, r2
 801961a:	f7ff f92d 	bl	8018878 <nk_style_item_color>
 801961e:	3438      	adds	r4, #56	; 0x38
 8019620:	463d      	mov	r5, r7
 8019622:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019624:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019626:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801962a:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    scroll->cursor_normal   = nk_style_item_color(table[NK_COLOR_SCROLLBAR_CURSOR]);
 801962e:	6a3b      	ldr	r3, [r7, #32]
 8019630:	3360      	adds	r3, #96	; 0x60
 8019632:	6dbc      	ldr	r4, [r7, #88]	; 0x58
 8019634:	463a      	mov	r2, r7
 8019636:	6819      	ldr	r1, [r3, #0]
 8019638:	460b      	mov	r3, r1
 801963a:	4619      	mov	r1, r3
 801963c:	4610      	mov	r0, r2
 801963e:	f7ff f91b 	bl	8018878 <nk_style_item_color>
 8019642:	3458      	adds	r4, #88	; 0x58
 8019644:	463d      	mov	r5, r7
 8019646:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019648:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801964a:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801964e:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    scroll->cursor_hover    = nk_style_item_color(table[NK_COLOR_SCROLLBAR_CURSOR_HOVER]);
 8019652:	6a3b      	ldr	r3, [r7, #32]
 8019654:	3364      	adds	r3, #100	; 0x64
 8019656:	6dbc      	ldr	r4, [r7, #88]	; 0x58
 8019658:	463a      	mov	r2, r7
 801965a:	6819      	ldr	r1, [r3, #0]
 801965c:	460b      	mov	r3, r1
 801965e:	4619      	mov	r1, r3
 8019660:	4610      	mov	r0, r2
 8019662:	f7ff f909 	bl	8018878 <nk_style_item_color>
 8019666:	3474      	adds	r4, #116	; 0x74
 8019668:	463d      	mov	r5, r7
 801966a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801966c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801966e:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019672:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    scroll->cursor_active   = nk_style_item_color(table[NK_COLOR_SCROLLBAR_CURSOR_ACTIVE]);
 8019676:	6a3b      	ldr	r3, [r7, #32]
 8019678:	3368      	adds	r3, #104	; 0x68
 801967a:	6dbc      	ldr	r4, [r7, #88]	; 0x58
 801967c:	463a      	mov	r2, r7
 801967e:	6819      	ldr	r1, [r3, #0]
 8019680:	460b      	mov	r3, r1
 8019682:	4619      	mov	r1, r3
 8019684:	4610      	mov	r0, r2
 8019686:	f7ff f8f7 	bl	8018878 <nk_style_item_color>
 801968a:	3490      	adds	r4, #144	; 0x90
 801968c:	463d      	mov	r5, r7
 801968e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019690:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019692:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019696:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    scroll->dec_symbol      = NK_SYMBOL_CIRCLE_SOLID;
 801969a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801969c:	2203      	movs	r2, #3
 801969e:	f883 21fd 	strb.w	r2, [r3, #509]	; 0x1fd
    scroll->inc_symbol      = NK_SYMBOL_CIRCLE_SOLID;
 80196a2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80196a4:	2203      	movs	r2, #3
 80196a6:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
    scroll->userdata        = nk_handle_ptr(0);
 80196aa:	6dbc      	ldr	r4, [r7, #88]	; 0x58
 80196ac:	2000      	movs	r0, #0
 80196ae:	f7f8 fcb7 	bl	8012020 <nk_handle_ptr>
 80196b2:	f8c4 0200 	str.w	r0, [r4, #512]	; 0x200
    scroll->border_color    = table[NK_COLOR_SCROLLBAR];
 80196b6:	6a3b      	ldr	r3, [r7, #32]
 80196b8:	f103 025c 	add.w	r2, r3, #92	; 0x5c
 80196bc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80196be:	3354      	adds	r3, #84	; 0x54
 80196c0:	6810      	ldr	r0, [r2, #0]
 80196c2:	6018      	str	r0, [r3, #0]
    scroll->cursor_border_color = table[NK_COLOR_SCROLLBAR];
 80196c4:	6a3b      	ldr	r3, [r7, #32]
 80196c6:	f103 025c 	add.w	r2, r3, #92	; 0x5c
 80196ca:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80196cc:	33ac      	adds	r3, #172	; 0xac
 80196ce:	6810      	ldr	r0, [r2, #0]
 80196d0:	6018      	str	r0, [r3, #0]
    scroll->padding         = nk_vec2(0,0);
 80196d2:	6dbc      	ldr	r4, [r7, #88]	; 0x58
 80196d4:	ed5f 0aa7 	vldr	s1, [pc, #-668]	; 801943c <nk_style_from_table+0xb5c>
 80196d8:	ed1f 0aa8 	vldr	s0, [pc, #-672]	; 801943c <nk_style_from_table+0xb5c>
 80196dc:	f7fa f8ec 	bl	80138b8 <nk_vec2>
 80196e0:	eeb0 7a40 	vmov.f32	s14, s0
 80196e4:	eef0 7a60 	vmov.f32	s15, s1
 80196e8:	ed84 7a30 	vstr	s14, [r4, #192]	; 0xc0
 80196ec:	edc4 7a31 	vstr	s15, [r4, #196]	; 0xc4
    scroll->show_buttons    = nk_false;
 80196f0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80196f2:	2200      	movs	r2, #0
 80196f4:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    scroll->border          = 0;
 80196f8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80196fa:	f04f 0200 	mov.w	r2, #0
 80196fe:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
    scroll->rounding        = 0;
 8019702:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8019704:	f04f 0200 	mov.w	r2, #0
 8019708:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
    scroll->border_cursor   = 0;
 801970c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801970e:	f04f 0200 	mov.w	r2, #0
 8019712:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
    scroll->rounding_cursor = 0;
 8019716:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8019718:	f04f 0200 	mov.w	r2, #0
 801971c:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
    scroll->draw_begin      = 0;
 8019720:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8019722:	2200      	movs	r2, #0
 8019724:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
    scroll->draw_end        = 0;
 8019728:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801972a:	2200      	movs	r2, #0
 801972c:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
    style->scrollv = style->scrollh;
 8019730:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019732:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8019736:	461a      	mov	r2, r3
 8019738:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801973a:	f102 00d0 	add.w	r0, r2, #208	; 0xd0
 801973e:	f603 63c4 	addw	r3, r3, #3780	; 0xec4
 8019742:	f44f 7203 	mov.w	r2, #524	; 0x20c
 8019746:	4619      	mov	r1, r3
 8019748:	f004 ff8e 	bl	801e668 <memcpy>

    /* scrollbars buttons */
    button = &style->scrollh.inc_button;
 801974c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801974e:	f503 6379 	add.w	r3, r3, #3984	; 0xf90
 8019752:	66fb      	str	r3, [r7, #108]	; 0x6c
    button->normal          = nk_style_item_color(nk_rgb(40,40,40));
 8019754:	2228      	movs	r2, #40	; 0x28
 8019756:	2128      	movs	r1, #40	; 0x28
 8019758:	2028      	movs	r0, #40	; 0x28
 801975a:	f7f5 fbe1 	bl	800ef20 <nk_rgb>
 801975e:	4603      	mov	r3, r0
 8019760:	637b      	str	r3, [r7, #52]	; 0x34
 8019762:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8019764:	463b      	mov	r3, r7
 8019766:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8019768:	4618      	mov	r0, r3
 801976a:	f7ff f885 	bl	8018878 <nk_style_item_color>
 801976e:	4625      	mov	r5, r4
 8019770:	463c      	mov	r4, r7
 8019772:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8019774:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8019776:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 801977a:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    button->hover           = nk_style_item_color(nk_rgb(42,42,42));
 801977e:	222a      	movs	r2, #42	; 0x2a
 8019780:	212a      	movs	r1, #42	; 0x2a
 8019782:	202a      	movs	r0, #42	; 0x2a
 8019784:	f7f5 fbcc 	bl	800ef20 <nk_rgb>
 8019788:	4603      	mov	r3, r0
 801978a:	63bb      	str	r3, [r7, #56]	; 0x38
 801978c:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801978e:	463b      	mov	r3, r7
 8019790:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8019792:	4618      	mov	r0, r3
 8019794:	f7ff f870 	bl	8018878 <nk_style_item_color>
 8019798:	341c      	adds	r4, #28
 801979a:	463d      	mov	r5, r7
 801979c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801979e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80197a0:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 80197a4:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->active          = nk_style_item_color(nk_rgb(44,44,44));
 80197a8:	222c      	movs	r2, #44	; 0x2c
 80197aa:	212c      	movs	r1, #44	; 0x2c
 80197ac:	202c      	movs	r0, #44	; 0x2c
 80197ae:	f7f5 fbb7 	bl	800ef20 <nk_rgb>
 80197b2:	4603      	mov	r3, r0
 80197b4:	63fb      	str	r3, [r7, #60]	; 0x3c
 80197b6:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 80197b8:	463b      	mov	r3, r7
 80197ba:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 80197bc:	4618      	mov	r0, r3
 80197be:	f7ff f85b 	bl	8018878 <nk_style_item_color>
 80197c2:	3438      	adds	r4, #56	; 0x38
 80197c4:	463d      	mov	r5, r7
 80197c6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80197c8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80197ca:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 80197ce:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->border_color    = nk_rgb(65,65,65);
 80197d2:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 80197d4:	2241      	movs	r2, #65	; 0x41
 80197d6:	2141      	movs	r1, #65	; 0x41
 80197d8:	2041      	movs	r0, #65	; 0x41
 80197da:	f7f5 fba1 	bl	800ef20 <nk_rgb>
 80197de:	4603      	mov	r3, r0
 80197e0:	6563      	str	r3, [r4, #84]	; 0x54
    button->text_background = nk_rgb(40,40,40);
 80197e2:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 80197e4:	2228      	movs	r2, #40	; 0x28
 80197e6:	2128      	movs	r1, #40	; 0x28
 80197e8:	2028      	movs	r0, #40	; 0x28
 80197ea:	f7f5 fb99 	bl	800ef20 <nk_rgb>
 80197ee:	4603      	mov	r3, r0
 80197f0:	65a3      	str	r3, [r4, #88]	; 0x58
    button->text_normal     = nk_rgb(175,175,175);
 80197f2:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 80197f4:	22af      	movs	r2, #175	; 0xaf
 80197f6:	21af      	movs	r1, #175	; 0xaf
 80197f8:	20af      	movs	r0, #175	; 0xaf
 80197fa:	f7f5 fb91 	bl	800ef20 <nk_rgb>
 80197fe:	4603      	mov	r3, r0
 8019800:	65e3      	str	r3, [r4, #92]	; 0x5c
    button->text_hover      = nk_rgb(175,175,175);
 8019802:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8019804:	22af      	movs	r2, #175	; 0xaf
 8019806:	21af      	movs	r1, #175	; 0xaf
 8019808:	20af      	movs	r0, #175	; 0xaf
 801980a:	f7f5 fb89 	bl	800ef20 <nk_rgb>
 801980e:	4603      	mov	r3, r0
 8019810:	6623      	str	r3, [r4, #96]	; 0x60
    button->text_active     = nk_rgb(175,175,175);
 8019812:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8019814:	22af      	movs	r2, #175	; 0xaf
 8019816:	21af      	movs	r1, #175	; 0xaf
 8019818:	20af      	movs	r0, #175	; 0xaf
 801981a:	f7f5 fb81 	bl	800ef20 <nk_rgb>
 801981e:	4603      	mov	r3, r0
 8019820:	6663      	str	r3, [r4, #100]	; 0x64
    button->padding         = nk_vec2(4.0f,4.0f);
 8019822:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8019824:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 8019828:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 801982c:	f7fa f844 	bl	80138b8 <nk_vec2>
 8019830:	eeb0 7a40 	vmov.f32	s14, s0
 8019834:	eef0 7a60 	vmov.f32	s15, s1
 8019838:	ed84 7a1d 	vstr	s14, [r4, #116]	; 0x74
 801983c:	edc4 7a1e 	vstr	s15, [r4, #120]	; 0x78
    button->touch_padding   = nk_vec2(0.0f,0.0f);
 8019840:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8019842:	eddf 0ac9 	vldr	s1, [pc, #804]	; 8019b68 <nk_style_from_table+0x1288>
 8019846:	ed9f 0ac8 	vldr	s0, [pc, #800]	; 8019b68 <nk_style_from_table+0x1288>
 801984a:	f7fa f835 	bl	80138b8 <nk_vec2>
 801984e:	eeb0 7a40 	vmov.f32	s14, s0
 8019852:	eef0 7a60 	vmov.f32	s15, s1
 8019856:	ed84 7a21 	vstr	s14, [r4, #132]	; 0x84
 801985a:	edc4 7a22 	vstr	s15, [r4, #136]	; 0x88
    button->userdata        = nk_handle_ptr(0);
 801985e:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8019860:	2000      	movs	r0, #0
 8019862:	f7f8 fbdd 	bl	8012020 <nk_handle_ptr>
 8019866:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    button->text_alignment  = NK_TEXT_CENTERED;
 801986a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801986c:	2212      	movs	r2, #18
 801986e:	669a      	str	r2, [r3, #104]	; 0x68
    button->border          = 1.0f;
 8019870:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8019872:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8019876:	66da      	str	r2, [r3, #108]	; 0x6c
    button->rounding        = 0.0f;
 8019878:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801987a:	f04f 0200 	mov.w	r2, #0
 801987e:	671a      	str	r2, [r3, #112]	; 0x70
    button->draw_begin      = 0;
 8019880:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8019882:	2200      	movs	r2, #0
 8019884:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    button->draw_end        = 0;
 8019888:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801988a:	2200      	movs	r2, #0
 801988c:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    style->scrollh.dec_button = style->scrollh.inc_button;
 8019890:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019892:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8019896:	461a      	mov	r2, r3
 8019898:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801989a:	f102 0028 	add.w	r0, r2, #40	; 0x28
 801989e:	f503 6379 	add.w	r3, r3, #3984	; 0xf90
 80198a2:	2298      	movs	r2, #152	; 0x98
 80198a4:	4619      	mov	r1, r3
 80198a6:	f004 fedf 	bl	801e668 <memcpy>
    style->scrollv.inc_button = style->scrollh.inc_button;
 80198aa:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80198ac:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80198b0:	461a      	mov	r2, r3
 80198b2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80198b4:	f502 70ce 	add.w	r0, r2, #412	; 0x19c
 80198b8:	f503 6379 	add.w	r3, r3, #3984	; 0xf90
 80198bc:	2298      	movs	r2, #152	; 0x98
 80198be:	4619      	mov	r1, r3
 80198c0:	f004 fed2 	bl	801e668 <memcpy>
    style->scrollv.dec_button = style->scrollh.inc_button;
 80198c4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80198c6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80198ca:	461a      	mov	r2, r3
 80198cc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80198ce:	f502 700d 	add.w	r0, r2, #564	; 0x234
 80198d2:	f503 6379 	add.w	r3, r3, #3984	; 0xf90
 80198d6:	2298      	movs	r2, #152	; 0x98
 80198d8:	4619      	mov	r1, r3
 80198da:	f004 fec5 	bl	801e668 <memcpy>

    /* edit */
    edit = &style->edit;
 80198de:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80198e0:	f603 33dc 	addw	r3, r3, #3036	; 0xbdc
 80198e4:	657b      	str	r3, [r7, #84]	; 0x54
    nk_zero_struct(*edit);
 80198e6:	f44f 712c 	mov.w	r1, #688	; 0x2b0
 80198ea:	6d78      	ldr	r0, [r7, #84]	; 0x54
 80198ec:	f002 fb9c 	bl	801c028 <nk_zero>
    edit->normal            = nk_style_item_color(table[NK_COLOR_EDIT]);
 80198f0:	6a3b      	ldr	r3, [r7, #32]
 80198f2:	3344      	adds	r3, #68	; 0x44
 80198f4:	6d7c      	ldr	r4, [r7, #84]	; 0x54
 80198f6:	463a      	mov	r2, r7
 80198f8:	6819      	ldr	r1, [r3, #0]
 80198fa:	460b      	mov	r3, r1
 80198fc:	4619      	mov	r1, r3
 80198fe:	4610      	mov	r0, r2
 8019900:	f7fe ffba 	bl	8018878 <nk_style_item_color>
 8019904:	4625      	mov	r5, r4
 8019906:	463c      	mov	r4, r7
 8019908:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801990a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801990c:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8019910:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    edit->hover             = nk_style_item_color(table[NK_COLOR_EDIT]);
 8019914:	6a3b      	ldr	r3, [r7, #32]
 8019916:	3344      	adds	r3, #68	; 0x44
 8019918:	6d7c      	ldr	r4, [r7, #84]	; 0x54
 801991a:	463a      	mov	r2, r7
 801991c:	6819      	ldr	r1, [r3, #0]
 801991e:	460b      	mov	r3, r1
 8019920:	4619      	mov	r1, r3
 8019922:	4610      	mov	r0, r2
 8019924:	f7fe ffa8 	bl	8018878 <nk_style_item_color>
 8019928:	341c      	adds	r4, #28
 801992a:	463d      	mov	r5, r7
 801992c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801992e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019930:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019934:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    edit->active            = nk_style_item_color(table[NK_COLOR_EDIT]);
 8019938:	6a3b      	ldr	r3, [r7, #32]
 801993a:	3344      	adds	r3, #68	; 0x44
 801993c:	6d7c      	ldr	r4, [r7, #84]	; 0x54
 801993e:	463a      	mov	r2, r7
 8019940:	6819      	ldr	r1, [r3, #0]
 8019942:	460b      	mov	r3, r1
 8019944:	4619      	mov	r1, r3
 8019946:	4610      	mov	r0, r2
 8019948:	f7fe ff96 	bl	8018878 <nk_style_item_color>
 801994c:	3438      	adds	r4, #56	; 0x38
 801994e:	463d      	mov	r5, r7
 8019950:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019952:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019954:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019958:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    edit->cursor_normal     = table[NK_COLOR_TEXT];
 801995c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801995e:	6a3a      	ldr	r2, [r7, #32]
 8019960:	f503 7319 	add.w	r3, r3, #612	; 0x264
 8019964:	6810      	ldr	r0, [r2, #0]
 8019966:	6018      	str	r0, [r3, #0]
    edit->cursor_hover      = table[NK_COLOR_TEXT];
 8019968:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801996a:	6a3a      	ldr	r2, [r7, #32]
 801996c:	f503 731a 	add.w	r3, r3, #616	; 0x268
 8019970:	6810      	ldr	r0, [r2, #0]
 8019972:	6018      	str	r0, [r3, #0]
    edit->cursor_text_normal= table[NK_COLOR_EDIT];
 8019974:	6a3b      	ldr	r3, [r7, #32]
 8019976:	f103 0244 	add.w	r2, r3, #68	; 0x44
 801997a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801997c:	f503 731b 	add.w	r3, r3, #620	; 0x26c
 8019980:	6810      	ldr	r0, [r2, #0]
 8019982:	6018      	str	r0, [r3, #0]
    edit->cursor_text_hover = table[NK_COLOR_EDIT];
 8019984:	6a3b      	ldr	r3, [r7, #32]
 8019986:	f103 0244 	add.w	r2, r3, #68	; 0x44
 801998a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801998c:	f503 731c 	add.w	r3, r3, #624	; 0x270
 8019990:	6810      	ldr	r0, [r2, #0]
 8019992:	6018      	str	r0, [r3, #0]
    edit->border_color      = table[NK_COLOR_BORDER];
 8019994:	6a3b      	ldr	r3, [r7, #32]
 8019996:	f103 020c 	add.w	r2, r3, #12
 801999a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801999c:	3354      	adds	r3, #84	; 0x54
 801999e:	6810      	ldr	r0, [r2, #0]
 80199a0:	6018      	str	r0, [r3, #0]
    edit->text_normal       = table[NK_COLOR_TEXT];
 80199a2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80199a4:	6a3a      	ldr	r2, [r7, #32]
 80199a6:	f503 731d 	add.w	r3, r3, #628	; 0x274
 80199aa:	6810      	ldr	r0, [r2, #0]
 80199ac:	6018      	str	r0, [r3, #0]
    edit->text_hover        = table[NK_COLOR_TEXT];
 80199ae:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80199b0:	6a3a      	ldr	r2, [r7, #32]
 80199b2:	f503 731e 	add.w	r3, r3, #632	; 0x278
 80199b6:	6810      	ldr	r0, [r2, #0]
 80199b8:	6018      	str	r0, [r3, #0]
    edit->text_active       = table[NK_COLOR_TEXT];
 80199ba:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80199bc:	6a3a      	ldr	r2, [r7, #32]
 80199be:	f503 731f 	add.w	r3, r3, #636	; 0x27c
 80199c2:	6810      	ldr	r0, [r2, #0]
 80199c4:	6018      	str	r0, [r3, #0]
    edit->selected_normal   = table[NK_COLOR_TEXT];
 80199c6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80199c8:	6a3a      	ldr	r2, [r7, #32]
 80199ca:	f503 7320 	add.w	r3, r3, #640	; 0x280
 80199ce:	6810      	ldr	r0, [r2, #0]
 80199d0:	6018      	str	r0, [r3, #0]
    edit->selected_hover    = table[NK_COLOR_TEXT];
 80199d2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80199d4:	6a3a      	ldr	r2, [r7, #32]
 80199d6:	f503 7321 	add.w	r3, r3, #644	; 0x284
 80199da:	6810      	ldr	r0, [r2, #0]
 80199dc:	6018      	str	r0, [r3, #0]
    edit->selected_text_normal  = table[NK_COLOR_EDIT];
 80199de:	6a3b      	ldr	r3, [r7, #32]
 80199e0:	f103 0244 	add.w	r2, r3, #68	; 0x44
 80199e4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80199e6:	f503 7322 	add.w	r3, r3, #648	; 0x288
 80199ea:	6810      	ldr	r0, [r2, #0]
 80199ec:	6018      	str	r0, [r3, #0]
    edit->selected_text_hover   = table[NK_COLOR_EDIT];
 80199ee:	6a3b      	ldr	r3, [r7, #32]
 80199f0:	f103 0244 	add.w	r2, r3, #68	; 0x44
 80199f4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80199f6:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 80199fa:	6810      	ldr	r0, [r2, #0]
 80199fc:	6018      	str	r0, [r3, #0]
    edit->scrollbar_size    = nk_vec2(10,10);
 80199fe:	6d7c      	ldr	r4, [r7, #84]	; 0x54
 8019a00:	eef2 0a04 	vmov.f32	s1, #36	; 0x41200000  10.0
 8019a04:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 8019a08:	f7f9 ff56 	bl	80138b8 <nk_vec2>
 8019a0c:	eeb0 7a40 	vmov.f32	s14, s0
 8019a10:	eef0 7a60 	vmov.f32	s15, s1
 8019a14:	ed84 7aa7 	vstr	s14, [r4, #668]	; 0x29c
 8019a18:	edc4 7aa8 	vstr	s15, [r4, #672]	; 0x2a0
    edit->scrollbar         = style->scrollv;
 8019a1c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019a1e:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8019a20:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8019a24:	3358      	adds	r3, #88	; 0x58
 8019a26:	f102 01d0 	add.w	r1, r2, #208	; 0xd0
 8019a2a:	f44f 7203 	mov.w	r2, #524	; 0x20c
 8019a2e:	4618      	mov	r0, r3
 8019a30:	f004 fe1a 	bl	801e668 <memcpy>
    edit->padding           = nk_vec2(4,4);
 8019a34:	6d7c      	ldr	r4, [r7, #84]	; 0x54
 8019a36:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 8019a3a:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 8019a3e:	f7f9 ff3b 	bl	80138b8 <nk_vec2>
 8019a42:	eeb0 7a40 	vmov.f32	s14, s0
 8019a46:	eef0 7a60 	vmov.f32	s15, s1
 8019a4a:	ed84 7aa9 	vstr	s14, [r4, #676]	; 0x2a4
 8019a4e:	edc4 7aaa 	vstr	s15, [r4, #680]	; 0x2a8
    edit->row_padding       = 2;
 8019a52:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019a54:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8019a58:	f8c3 22ac 	str.w	r2, [r3, #684]	; 0x2ac
    edit->cursor_size       = 4;
 8019a5c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019a5e:	f04f 4281 	mov.w	r2, #1082130432	; 0x40800000
 8019a62:	f8c3 2298 	str.w	r2, [r3, #664]	; 0x298
    edit->border            = 1;
 8019a66:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019a68:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8019a6c:	f8c3 2290 	str.w	r2, [r3, #656]	; 0x290
    edit->rounding          = 0;
 8019a70:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019a72:	f04f 0200 	mov.w	r2, #0
 8019a76:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294

    /* property */
    property = &style->property;
 8019a7a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019a7c:	f503 63ef 	add.w	r3, r3, #1912	; 0x778
 8019a80:	653b      	str	r3, [r7, #80]	; 0x50
    nk_zero_struct(*property);
 8019a82:	f240 4164 	movw	r1, #1124	; 0x464
 8019a86:	6d38      	ldr	r0, [r7, #80]	; 0x50
 8019a88:	f002 face 	bl	801c028 <nk_zero>
    property->normal        = nk_style_item_color(table[NK_COLOR_PROPERTY]);
 8019a8c:	6a3b      	ldr	r3, [r7, #32]
 8019a8e:	3340      	adds	r3, #64	; 0x40
 8019a90:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8019a92:	463a      	mov	r2, r7
 8019a94:	6819      	ldr	r1, [r3, #0]
 8019a96:	460b      	mov	r3, r1
 8019a98:	4619      	mov	r1, r3
 8019a9a:	4610      	mov	r0, r2
 8019a9c:	f7fe feec 	bl	8018878 <nk_style_item_color>
 8019aa0:	4625      	mov	r5, r4
 8019aa2:	463c      	mov	r4, r7
 8019aa4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8019aa6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8019aa8:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8019aac:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    property->hover         = nk_style_item_color(table[NK_COLOR_PROPERTY]);
 8019ab0:	6a3b      	ldr	r3, [r7, #32]
 8019ab2:	3340      	adds	r3, #64	; 0x40
 8019ab4:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8019ab6:	463a      	mov	r2, r7
 8019ab8:	6819      	ldr	r1, [r3, #0]
 8019aba:	460b      	mov	r3, r1
 8019abc:	4619      	mov	r1, r3
 8019abe:	4610      	mov	r0, r2
 8019ac0:	f7fe feda 	bl	8018878 <nk_style_item_color>
 8019ac4:	341c      	adds	r4, #28
 8019ac6:	463d      	mov	r5, r7
 8019ac8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019aca:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019acc:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019ad0:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    property->active        = nk_style_item_color(table[NK_COLOR_PROPERTY]);
 8019ad4:	6a3b      	ldr	r3, [r7, #32]
 8019ad6:	3340      	adds	r3, #64	; 0x40
 8019ad8:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8019ada:	463a      	mov	r2, r7
 8019adc:	6819      	ldr	r1, [r3, #0]
 8019ade:	460b      	mov	r3, r1
 8019ae0:	4619      	mov	r1, r3
 8019ae2:	4610      	mov	r0, r2
 8019ae4:	f7fe fec8 	bl	8018878 <nk_style_item_color>
 8019ae8:	3438      	adds	r4, #56	; 0x38
 8019aea:	463d      	mov	r5, r7
 8019aec:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019aee:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019af0:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019af4:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    property->border_color  = table[NK_COLOR_BORDER];
 8019af8:	6a3b      	ldr	r3, [r7, #32]
 8019afa:	f103 020c 	add.w	r2, r3, #12
 8019afe:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019b00:	3354      	adds	r3, #84	; 0x54
 8019b02:	6810      	ldr	r0, [r2, #0]
 8019b04:	6018      	str	r0, [r3, #0]
    property->label_normal  = table[NK_COLOR_TEXT];
 8019b06:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019b08:	6a3a      	ldr	r2, [r7, #32]
 8019b0a:	3358      	adds	r3, #88	; 0x58
 8019b0c:	6810      	ldr	r0, [r2, #0]
 8019b0e:	6018      	str	r0, [r3, #0]
    property->label_hover   = table[NK_COLOR_TEXT];
 8019b10:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019b12:	6a3a      	ldr	r2, [r7, #32]
 8019b14:	335c      	adds	r3, #92	; 0x5c
 8019b16:	6810      	ldr	r0, [r2, #0]
 8019b18:	6018      	str	r0, [r3, #0]
    property->label_active  = table[NK_COLOR_TEXT];
 8019b1a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019b1c:	6a3a      	ldr	r2, [r7, #32]
 8019b1e:	3360      	adds	r3, #96	; 0x60
 8019b20:	6810      	ldr	r0, [r2, #0]
 8019b22:	6018      	str	r0, [r3, #0]
    property->sym_left      = NK_SYMBOL_TRIANGLE_LEFT;
 8019b24:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019b26:	2209      	movs	r2, #9
 8019b28:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
    property->sym_right     = NK_SYMBOL_TRIANGLE_RIGHT;
 8019b2c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019b2e:	220a      	movs	r2, #10
 8019b30:	f883 2065 	strb.w	r2, [r3, #101]	; 0x65
    property->userdata      = nk_handle_ptr(0);
 8019b34:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8019b36:	2000      	movs	r0, #0
 8019b38:	f7f8 fa72 	bl	8012020 <nk_handle_ptr>
 8019b3c:	f8c4 0458 	str.w	r0, [r4, #1112]	; 0x458
    property->padding       = nk_vec2(4,4);
 8019b40:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8019b42:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 8019b46:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 8019b4a:	f7f9 feb5 	bl	80138b8 <nk_vec2>
 8019b4e:	eeb0 7a40 	vmov.f32	s14, s0
 8019b52:	eef0 7a60 	vmov.f32	s15, s1
 8019b56:	ed84 7a1c 	vstr	s14, [r4, #112]	; 0x70
 8019b5a:	edc4 7a1d 	vstr	s15, [r4, #116]	; 0x74
    property->border        = 1;
 8019b5e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019b60:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8019b64:	e002      	b.n	8019b6c <nk_style_from_table+0x128c>
 8019b66:	bf00      	nop
 8019b68:	00000000 	.word	0x00000000
 8019b6c:	669a      	str	r2, [r3, #104]	; 0x68
    property->rounding      = 10;
 8019b6e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019b70:	4ac3      	ldr	r2, [pc, #780]	; (8019e80 <nk_style_from_table+0x15a0>)
 8019b72:	66da      	str	r2, [r3, #108]	; 0x6c
    property->draw_begin    = 0;
 8019b74:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019b76:	2200      	movs	r2, #0
 8019b78:	f8c3 245c 	str.w	r2, [r3, #1116]	; 0x45c
    property->draw_end      = 0;
 8019b7c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019b7e:	2200      	movs	r2, #0
 8019b80:	f8c3 2460 	str.w	r2, [r3, #1120]	; 0x460

    /* property buttons */
    button = &style->property.dec_button;
 8019b84:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019b86:	f603 3338 	addw	r3, r3, #2872	; 0xb38
 8019b8a:	66fb      	str	r3, [r7, #108]	; 0x6c
    nk_zero_struct(*button);
 8019b8c:	2198      	movs	r1, #152	; 0x98
 8019b8e:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 8019b90:	f002 fa4a 	bl	801c028 <nk_zero>
    button->normal          = nk_style_item_color(table[NK_COLOR_PROPERTY]);
 8019b94:	6a3b      	ldr	r3, [r7, #32]
 8019b96:	3340      	adds	r3, #64	; 0x40
 8019b98:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8019b9a:	463a      	mov	r2, r7
 8019b9c:	6819      	ldr	r1, [r3, #0]
 8019b9e:	460b      	mov	r3, r1
 8019ba0:	4619      	mov	r1, r3
 8019ba2:	4610      	mov	r0, r2
 8019ba4:	f7fe fe68 	bl	8018878 <nk_style_item_color>
 8019ba8:	4625      	mov	r5, r4
 8019baa:	463c      	mov	r4, r7
 8019bac:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8019bae:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8019bb0:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8019bb4:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    button->hover           = nk_style_item_color(table[NK_COLOR_PROPERTY]);
 8019bb8:	6a3b      	ldr	r3, [r7, #32]
 8019bba:	3340      	adds	r3, #64	; 0x40
 8019bbc:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8019bbe:	463a      	mov	r2, r7
 8019bc0:	6819      	ldr	r1, [r3, #0]
 8019bc2:	460b      	mov	r3, r1
 8019bc4:	4619      	mov	r1, r3
 8019bc6:	4610      	mov	r0, r2
 8019bc8:	f7fe fe56 	bl	8018878 <nk_style_item_color>
 8019bcc:	341c      	adds	r4, #28
 8019bce:	463d      	mov	r5, r7
 8019bd0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019bd2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019bd4:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019bd8:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->active          = nk_style_item_color(table[NK_COLOR_PROPERTY]);
 8019bdc:	6a3b      	ldr	r3, [r7, #32]
 8019bde:	3340      	adds	r3, #64	; 0x40
 8019be0:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8019be2:	463a      	mov	r2, r7
 8019be4:	6819      	ldr	r1, [r3, #0]
 8019be6:	460b      	mov	r3, r1
 8019be8:	4619      	mov	r1, r3
 8019bea:	4610      	mov	r0, r2
 8019bec:	f7fe fe44 	bl	8018878 <nk_style_item_color>
 8019bf0:	3438      	adds	r4, #56	; 0x38
 8019bf2:	463d      	mov	r5, r7
 8019bf4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019bf6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019bf8:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019bfc:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->border_color    = nk_rgba(0,0,0,0);
 8019c00:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8019c02:	2300      	movs	r3, #0
 8019c04:	2200      	movs	r2, #0
 8019c06:	2100      	movs	r1, #0
 8019c08:	2000      	movs	r0, #0
 8019c0a:	f7f5 f939 	bl	800ee80 <nk_rgba>
 8019c0e:	4603      	mov	r3, r0
 8019c10:	6563      	str	r3, [r4, #84]	; 0x54
    button->text_background = table[NK_COLOR_PROPERTY];
 8019c12:	6a3b      	ldr	r3, [r7, #32]
 8019c14:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8019c18:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8019c1a:	3358      	adds	r3, #88	; 0x58
 8019c1c:	6810      	ldr	r0, [r2, #0]
 8019c1e:	6018      	str	r0, [r3, #0]
    button->text_normal     = table[NK_COLOR_TEXT];
 8019c20:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8019c22:	6a3a      	ldr	r2, [r7, #32]
 8019c24:	335c      	adds	r3, #92	; 0x5c
 8019c26:	6810      	ldr	r0, [r2, #0]
 8019c28:	6018      	str	r0, [r3, #0]
    button->text_hover      = table[NK_COLOR_TEXT];
 8019c2a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8019c2c:	6a3a      	ldr	r2, [r7, #32]
 8019c2e:	3360      	adds	r3, #96	; 0x60
 8019c30:	6810      	ldr	r0, [r2, #0]
 8019c32:	6018      	str	r0, [r3, #0]
    button->text_active     = table[NK_COLOR_TEXT];
 8019c34:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8019c36:	6a3a      	ldr	r2, [r7, #32]
 8019c38:	3364      	adds	r3, #100	; 0x64
 8019c3a:	6810      	ldr	r0, [r2, #0]
 8019c3c:	6018      	str	r0, [r3, #0]
    button->padding         = nk_vec2(0.0f,0.0f);
 8019c3e:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8019c40:	eddf 0a90 	vldr	s1, [pc, #576]	; 8019e84 <nk_style_from_table+0x15a4>
 8019c44:	ed9f 0a8f 	vldr	s0, [pc, #572]	; 8019e84 <nk_style_from_table+0x15a4>
 8019c48:	f7f9 fe36 	bl	80138b8 <nk_vec2>
 8019c4c:	eeb0 7a40 	vmov.f32	s14, s0
 8019c50:	eef0 7a60 	vmov.f32	s15, s1
 8019c54:	ed84 7a1d 	vstr	s14, [r4, #116]	; 0x74
 8019c58:	edc4 7a1e 	vstr	s15, [r4, #120]	; 0x78
    button->touch_padding   = nk_vec2(0.0f,0.0f);
 8019c5c:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8019c5e:	eddf 0a89 	vldr	s1, [pc, #548]	; 8019e84 <nk_style_from_table+0x15a4>
 8019c62:	ed9f 0a88 	vldr	s0, [pc, #544]	; 8019e84 <nk_style_from_table+0x15a4>
 8019c66:	f7f9 fe27 	bl	80138b8 <nk_vec2>
 8019c6a:	eeb0 7a40 	vmov.f32	s14, s0
 8019c6e:	eef0 7a60 	vmov.f32	s15, s1
 8019c72:	ed84 7a21 	vstr	s14, [r4, #132]	; 0x84
 8019c76:	edc4 7a22 	vstr	s15, [r4, #136]	; 0x88
    button->userdata        = nk_handle_ptr(0);
 8019c7a:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8019c7c:	2000      	movs	r0, #0
 8019c7e:	f7f8 f9cf 	bl	8012020 <nk_handle_ptr>
 8019c82:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    button->text_alignment  = NK_TEXT_CENTERED;
 8019c86:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8019c88:	2212      	movs	r2, #18
 8019c8a:	669a      	str	r2, [r3, #104]	; 0x68
    button->border          = 0.0f;
 8019c8c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8019c8e:	f04f 0200 	mov.w	r2, #0
 8019c92:	66da      	str	r2, [r3, #108]	; 0x6c
    button->rounding        = 0.0f;
 8019c94:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8019c96:	f04f 0200 	mov.w	r2, #0
 8019c9a:	671a      	str	r2, [r3, #112]	; 0x70
    button->draw_begin      = 0;
 8019c9c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8019c9e:	2200      	movs	r2, #0
 8019ca0:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    button->draw_end        = 0;
 8019ca4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8019ca6:	2200      	movs	r2, #0
 8019ca8:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    style->property.inc_button = style->property.dec_button;
 8019cac:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8019cae:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019cb0:	f502 602a 	add.w	r0, r2, #2720	; 0xaa0
 8019cb4:	f603 3338 	addw	r3, r3, #2872	; 0xb38
 8019cb8:	2298      	movs	r2, #152	; 0x98
 8019cba:	4619      	mov	r1, r3
 8019cbc:	f004 fcd4 	bl	801e668 <memcpy>

    /* property edit */
    edit = &style->property.edit;
 8019cc0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019cc2:	f503 63fe 	add.w	r3, r3, #2032	; 0x7f0
 8019cc6:	657b      	str	r3, [r7, #84]	; 0x54
    nk_zero_struct(*edit);
 8019cc8:	f44f 712c 	mov.w	r1, #688	; 0x2b0
 8019ccc:	6d78      	ldr	r0, [r7, #84]	; 0x54
 8019cce:	f002 f9ab 	bl	801c028 <nk_zero>
    edit->normal            = nk_style_item_color(table[NK_COLOR_PROPERTY]);
 8019cd2:	6a3b      	ldr	r3, [r7, #32]
 8019cd4:	3340      	adds	r3, #64	; 0x40
 8019cd6:	6d7c      	ldr	r4, [r7, #84]	; 0x54
 8019cd8:	463a      	mov	r2, r7
 8019cda:	6819      	ldr	r1, [r3, #0]
 8019cdc:	460b      	mov	r3, r1
 8019cde:	4619      	mov	r1, r3
 8019ce0:	4610      	mov	r0, r2
 8019ce2:	f7fe fdc9 	bl	8018878 <nk_style_item_color>
 8019ce6:	4625      	mov	r5, r4
 8019ce8:	463c      	mov	r4, r7
 8019cea:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8019cec:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8019cee:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8019cf2:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    edit->hover             = nk_style_item_color(table[NK_COLOR_PROPERTY]);
 8019cf6:	6a3b      	ldr	r3, [r7, #32]
 8019cf8:	3340      	adds	r3, #64	; 0x40
 8019cfa:	6d7c      	ldr	r4, [r7, #84]	; 0x54
 8019cfc:	463a      	mov	r2, r7
 8019cfe:	6819      	ldr	r1, [r3, #0]
 8019d00:	460b      	mov	r3, r1
 8019d02:	4619      	mov	r1, r3
 8019d04:	4610      	mov	r0, r2
 8019d06:	f7fe fdb7 	bl	8018878 <nk_style_item_color>
 8019d0a:	341c      	adds	r4, #28
 8019d0c:	463d      	mov	r5, r7
 8019d0e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019d10:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019d12:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019d16:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    edit->active            = nk_style_item_color(table[NK_COLOR_PROPERTY]);
 8019d1a:	6a3b      	ldr	r3, [r7, #32]
 8019d1c:	3340      	adds	r3, #64	; 0x40
 8019d1e:	6d7c      	ldr	r4, [r7, #84]	; 0x54
 8019d20:	463a      	mov	r2, r7
 8019d22:	6819      	ldr	r1, [r3, #0]
 8019d24:	460b      	mov	r3, r1
 8019d26:	4619      	mov	r1, r3
 8019d28:	4610      	mov	r0, r2
 8019d2a:	f7fe fda5 	bl	8018878 <nk_style_item_color>
 8019d2e:	3438      	adds	r4, #56	; 0x38
 8019d30:	463d      	mov	r5, r7
 8019d32:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019d34:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019d36:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019d3a:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    edit->border_color      = nk_rgba(0,0,0,0);
 8019d3e:	6d7c      	ldr	r4, [r7, #84]	; 0x54
 8019d40:	2300      	movs	r3, #0
 8019d42:	2200      	movs	r2, #0
 8019d44:	2100      	movs	r1, #0
 8019d46:	2000      	movs	r0, #0
 8019d48:	f7f5 f89a 	bl	800ee80 <nk_rgba>
 8019d4c:	4603      	mov	r3, r0
 8019d4e:	6563      	str	r3, [r4, #84]	; 0x54
    edit->cursor_normal     = table[NK_COLOR_TEXT];
 8019d50:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019d52:	6a3a      	ldr	r2, [r7, #32]
 8019d54:	f503 7319 	add.w	r3, r3, #612	; 0x264
 8019d58:	6810      	ldr	r0, [r2, #0]
 8019d5a:	6018      	str	r0, [r3, #0]
    edit->cursor_hover      = table[NK_COLOR_TEXT];
 8019d5c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019d5e:	6a3a      	ldr	r2, [r7, #32]
 8019d60:	f503 731a 	add.w	r3, r3, #616	; 0x268
 8019d64:	6810      	ldr	r0, [r2, #0]
 8019d66:	6018      	str	r0, [r3, #0]
    edit->cursor_text_normal= table[NK_COLOR_EDIT];
 8019d68:	6a3b      	ldr	r3, [r7, #32]
 8019d6a:	f103 0244 	add.w	r2, r3, #68	; 0x44
 8019d6e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019d70:	f503 731b 	add.w	r3, r3, #620	; 0x26c
 8019d74:	6810      	ldr	r0, [r2, #0]
 8019d76:	6018      	str	r0, [r3, #0]
    edit->cursor_text_hover = table[NK_COLOR_EDIT];
 8019d78:	6a3b      	ldr	r3, [r7, #32]
 8019d7a:	f103 0244 	add.w	r2, r3, #68	; 0x44
 8019d7e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019d80:	f503 731c 	add.w	r3, r3, #624	; 0x270
 8019d84:	6810      	ldr	r0, [r2, #0]
 8019d86:	6018      	str	r0, [r3, #0]
    edit->text_normal       = table[NK_COLOR_TEXT];
 8019d88:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019d8a:	6a3a      	ldr	r2, [r7, #32]
 8019d8c:	f503 731d 	add.w	r3, r3, #628	; 0x274
 8019d90:	6810      	ldr	r0, [r2, #0]
 8019d92:	6018      	str	r0, [r3, #0]
    edit->text_hover        = table[NK_COLOR_TEXT];
 8019d94:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019d96:	6a3a      	ldr	r2, [r7, #32]
 8019d98:	f503 731e 	add.w	r3, r3, #632	; 0x278
 8019d9c:	6810      	ldr	r0, [r2, #0]
 8019d9e:	6018      	str	r0, [r3, #0]
    edit->text_active       = table[NK_COLOR_TEXT];
 8019da0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019da2:	6a3a      	ldr	r2, [r7, #32]
 8019da4:	f503 731f 	add.w	r3, r3, #636	; 0x27c
 8019da8:	6810      	ldr	r0, [r2, #0]
 8019daa:	6018      	str	r0, [r3, #0]
    edit->selected_normal   = table[NK_COLOR_TEXT];
 8019dac:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019dae:	6a3a      	ldr	r2, [r7, #32]
 8019db0:	f503 7320 	add.w	r3, r3, #640	; 0x280
 8019db4:	6810      	ldr	r0, [r2, #0]
 8019db6:	6018      	str	r0, [r3, #0]
    edit->selected_hover    = table[NK_COLOR_TEXT];
 8019db8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019dba:	6a3a      	ldr	r2, [r7, #32]
 8019dbc:	f503 7321 	add.w	r3, r3, #644	; 0x284
 8019dc0:	6810      	ldr	r0, [r2, #0]
 8019dc2:	6018      	str	r0, [r3, #0]
    edit->selected_text_normal  = table[NK_COLOR_EDIT];
 8019dc4:	6a3b      	ldr	r3, [r7, #32]
 8019dc6:	f103 0244 	add.w	r2, r3, #68	; 0x44
 8019dca:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019dcc:	f503 7322 	add.w	r3, r3, #648	; 0x288
 8019dd0:	6810      	ldr	r0, [r2, #0]
 8019dd2:	6018      	str	r0, [r3, #0]
    edit->selected_text_hover   = table[NK_COLOR_EDIT];
 8019dd4:	6a3b      	ldr	r3, [r7, #32]
 8019dd6:	f103 0244 	add.w	r2, r3, #68	; 0x44
 8019dda:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019ddc:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 8019de0:	6810      	ldr	r0, [r2, #0]
 8019de2:	6018      	str	r0, [r3, #0]
    edit->padding           = nk_vec2(0,0);
 8019de4:	6d7c      	ldr	r4, [r7, #84]	; 0x54
 8019de6:	eddf 0a27 	vldr	s1, [pc, #156]	; 8019e84 <nk_style_from_table+0x15a4>
 8019dea:	ed9f 0a26 	vldr	s0, [pc, #152]	; 8019e84 <nk_style_from_table+0x15a4>
 8019dee:	f7f9 fd63 	bl	80138b8 <nk_vec2>
 8019df2:	eeb0 7a40 	vmov.f32	s14, s0
 8019df6:	eef0 7a60 	vmov.f32	s15, s1
 8019dfa:	ed84 7aa9 	vstr	s14, [r4, #676]	; 0x2a4
 8019dfe:	edc4 7aaa 	vstr	s15, [r4, #680]	; 0x2a8
    edit->cursor_size       = 8;
 8019e02:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019e04:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
 8019e08:	f8c3 2298 	str.w	r2, [r3, #664]	; 0x298
    edit->border            = 0;
 8019e0c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019e0e:	f04f 0200 	mov.w	r2, #0
 8019e12:	f8c3 2290 	str.w	r2, [r3, #656]	; 0x290
    edit->rounding          = 0;
 8019e16:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019e18:	f04f 0200 	mov.w	r2, #0
 8019e1c:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294

    /* chart */
    chart = &style->chart;
 8019e20:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019e22:	f603 638c 	addw	r3, r3, #3724	; 0xe8c
 8019e26:	64fb      	str	r3, [r7, #76]	; 0x4c
    nk_zero_struct(*chart);
 8019e28:	2138      	movs	r1, #56	; 0x38
 8019e2a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8019e2c:	f002 f8fc 	bl	801c028 <nk_zero>
    chart->background       = nk_style_item_color(table[NK_COLOR_CHART]);
 8019e30:	6a3b      	ldr	r3, [r7, #32]
 8019e32:	3350      	adds	r3, #80	; 0x50
 8019e34:	6cfc      	ldr	r4, [r7, #76]	; 0x4c
 8019e36:	463a      	mov	r2, r7
 8019e38:	6819      	ldr	r1, [r3, #0]
 8019e3a:	460b      	mov	r3, r1
 8019e3c:	4619      	mov	r1, r3
 8019e3e:	4610      	mov	r0, r2
 8019e40:	f7fe fd1a 	bl	8018878 <nk_style_item_color>
 8019e44:	4625      	mov	r5, r4
 8019e46:	463c      	mov	r4, r7
 8019e48:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8019e4a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8019e4c:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8019e50:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    chart->border_color     = table[NK_COLOR_BORDER];
 8019e54:	6a3b      	ldr	r3, [r7, #32]
 8019e56:	f103 020c 	add.w	r2, r3, #12
 8019e5a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8019e5c:	331c      	adds	r3, #28
 8019e5e:	6810      	ldr	r0, [r2, #0]
 8019e60:	6018      	str	r0, [r3, #0]
    chart->selected_color   = table[NK_COLOR_CHART_COLOR_HIGHLIGHT];
 8019e62:	6a3b      	ldr	r3, [r7, #32]
 8019e64:	f103 0258 	add.w	r2, r3, #88	; 0x58
 8019e68:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8019e6a:	3320      	adds	r3, #32
 8019e6c:	6810      	ldr	r0, [r2, #0]
 8019e6e:	6018      	str	r0, [r3, #0]
    chart->color            = table[NK_COLOR_CHART_COLOR];
 8019e70:	6a3b      	ldr	r3, [r7, #32]
 8019e72:	f103 0254 	add.w	r2, r3, #84	; 0x54
 8019e76:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8019e78:	3324      	adds	r3, #36	; 0x24
 8019e7a:	6810      	ldr	r0, [r2, #0]
 8019e7c:	6018      	str	r0, [r3, #0]
 8019e7e:	e003      	b.n	8019e88 <nk_style_from_table+0x15a8>
 8019e80:	41200000 	.word	0x41200000
 8019e84:	00000000 	.word	0x00000000
    chart->padding          = nk_vec2(4,4);
 8019e88:	6cfc      	ldr	r4, [r7, #76]	; 0x4c
 8019e8a:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 8019e8e:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 8019e92:	f7f9 fd11 	bl	80138b8 <nk_vec2>
 8019e96:	eeb0 7a40 	vmov.f32	s14, s0
 8019e9a:	eef0 7a60 	vmov.f32	s15, s1
 8019e9e:	ed84 7a0c 	vstr	s14, [r4, #48]	; 0x30
 8019ea2:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
    chart->border           = 0;
 8019ea6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8019ea8:	f04f 0200 	mov.w	r2, #0
 8019eac:	629a      	str	r2, [r3, #40]	; 0x28
    chart->rounding         = 0;
 8019eae:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8019eb0:	f04f 0200 	mov.w	r2, #0
 8019eb4:	62da      	str	r2, [r3, #44]	; 0x2c

    /* combo */
    combo = &style->combo;
 8019eb6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019eb8:	f503 53ac 	add.w	r3, r3, #5504	; 0x1580
 8019ebc:	64bb      	str	r3, [r7, #72]	; 0x48
    combo->normal           = nk_style_item_color(table[NK_COLOR_COMBO]);
 8019ebe:	6a3b      	ldr	r3, [r7, #32]
 8019ec0:	334c      	adds	r3, #76	; 0x4c
 8019ec2:	6cbc      	ldr	r4, [r7, #72]	; 0x48
 8019ec4:	463a      	mov	r2, r7
 8019ec6:	6819      	ldr	r1, [r3, #0]
 8019ec8:	460b      	mov	r3, r1
 8019eca:	4619      	mov	r1, r3
 8019ecc:	4610      	mov	r0, r2
 8019ece:	f7fe fcd3 	bl	8018878 <nk_style_item_color>
 8019ed2:	4625      	mov	r5, r4
 8019ed4:	463c      	mov	r4, r7
 8019ed6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8019ed8:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8019eda:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8019ede:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    combo->hover            = nk_style_item_color(table[NK_COLOR_COMBO]);
 8019ee2:	6a3b      	ldr	r3, [r7, #32]
 8019ee4:	334c      	adds	r3, #76	; 0x4c
 8019ee6:	6cbc      	ldr	r4, [r7, #72]	; 0x48
 8019ee8:	463a      	mov	r2, r7
 8019eea:	6819      	ldr	r1, [r3, #0]
 8019eec:	460b      	mov	r3, r1
 8019eee:	4619      	mov	r1, r3
 8019ef0:	4610      	mov	r0, r2
 8019ef2:	f7fe fcc1 	bl	8018878 <nk_style_item_color>
 8019ef6:	341c      	adds	r4, #28
 8019ef8:	463d      	mov	r5, r7
 8019efa:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019efc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019efe:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019f02:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    combo->active           = nk_style_item_color(table[NK_COLOR_COMBO]);
 8019f06:	6a3b      	ldr	r3, [r7, #32]
 8019f08:	334c      	adds	r3, #76	; 0x4c
 8019f0a:	6cbc      	ldr	r4, [r7, #72]	; 0x48
 8019f0c:	463a      	mov	r2, r7
 8019f0e:	6819      	ldr	r1, [r3, #0]
 8019f10:	460b      	mov	r3, r1
 8019f12:	4619      	mov	r1, r3
 8019f14:	4610      	mov	r0, r2
 8019f16:	f7fe fcaf 	bl	8018878 <nk_style_item_color>
 8019f1a:	3438      	adds	r4, #56	; 0x38
 8019f1c:	463d      	mov	r5, r7
 8019f1e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019f20:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019f22:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8019f26:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    combo->border_color     = table[NK_COLOR_BORDER];
 8019f2a:	6a3b      	ldr	r3, [r7, #32]
 8019f2c:	f103 020c 	add.w	r2, r3, #12
 8019f30:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019f32:	3354      	adds	r3, #84	; 0x54
 8019f34:	6810      	ldr	r0, [r2, #0]
 8019f36:	6018      	str	r0, [r3, #0]
    combo->label_normal     = table[NK_COLOR_TEXT];
 8019f38:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019f3a:	6a3a      	ldr	r2, [r7, #32]
 8019f3c:	3358      	adds	r3, #88	; 0x58
 8019f3e:	6810      	ldr	r0, [r2, #0]
 8019f40:	6018      	str	r0, [r3, #0]
    combo->label_hover      = table[NK_COLOR_TEXT];
 8019f42:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019f44:	6a3a      	ldr	r2, [r7, #32]
 8019f46:	335c      	adds	r3, #92	; 0x5c
 8019f48:	6810      	ldr	r0, [r2, #0]
 8019f4a:	6018      	str	r0, [r3, #0]
    combo->label_active     = table[NK_COLOR_TEXT];
 8019f4c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019f4e:	6a3a      	ldr	r2, [r7, #32]
 8019f50:	3360      	adds	r3, #96	; 0x60
 8019f52:	6810      	ldr	r0, [r2, #0]
 8019f54:	6018      	str	r0, [r3, #0]
    combo->sym_normal       = NK_SYMBOL_TRIANGLE_DOWN;
 8019f56:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019f58:	2208      	movs	r2, #8
 8019f5a:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
    combo->sym_hover        = NK_SYMBOL_TRIANGLE_DOWN;
 8019f5e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019f60:	2208      	movs	r2, #8
 8019f62:	f883 2109 	strb.w	r2, [r3, #265]	; 0x109
    combo->sym_active       = NK_SYMBOL_TRIANGLE_DOWN;
 8019f66:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019f68:	2208      	movs	r2, #8
 8019f6a:	f883 210a 	strb.w	r2, [r3, #266]	; 0x10a
    combo->content_padding  = nk_vec2(4,4);
 8019f6e:	6cbc      	ldr	r4, [r7, #72]	; 0x48
 8019f70:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 8019f74:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 8019f78:	f7f9 fc9e 	bl	80138b8 <nk_vec2>
 8019f7c:	eeb0 7a40 	vmov.f32	s14, s0
 8019f80:	eef0 7a60 	vmov.f32	s15, s1
 8019f84:	ed84 7a45 	vstr	s14, [r4, #276]	; 0x114
 8019f88:	edc4 7a46 	vstr	s15, [r4, #280]	; 0x118
    combo->button_padding   = nk_vec2(0,4);
 8019f8c:	6cbc      	ldr	r4, [r7, #72]	; 0x48
 8019f8e:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 8019f92:	ed1f 0a44 	vldr	s0, [pc, #-272]	; 8019e84 <nk_style_from_table+0x15a4>
 8019f96:	f7f9 fc8f 	bl	80138b8 <nk_vec2>
 8019f9a:	eeb0 7a40 	vmov.f32	s14, s0
 8019f9e:	eef0 7a60 	vmov.f32	s15, s1
 8019fa2:	ed84 7a47 	vstr	s14, [r4, #284]	; 0x11c
 8019fa6:	edc4 7a48 	vstr	s15, [r4, #288]	; 0x120
    combo->spacing          = nk_vec2(4,0);
 8019faa:	6cbc      	ldr	r4, [r7, #72]	; 0x48
 8019fac:	ed5f 0a4b 	vldr	s1, [pc, #-300]	; 8019e84 <nk_style_from_table+0x15a4>
 8019fb0:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 8019fb4:	f7f9 fc80 	bl	80138b8 <nk_vec2>
 8019fb8:	eeb0 7a40 	vmov.f32	s14, s0
 8019fbc:	eef0 7a60 	vmov.f32	s15, s1
 8019fc0:	ed84 7a49 	vstr	s14, [r4, #292]	; 0x124
 8019fc4:	edc4 7a4a 	vstr	s15, [r4, #296]	; 0x128
    combo->border           = 1;
 8019fc8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019fca:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8019fce:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    combo->rounding         = 0;
 8019fd2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019fd4:	f04f 0200 	mov.w	r2, #0
 8019fd8:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110

    /* combo button */
    button = &style->combo.button;
 8019fdc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019fde:	f503 53af 	add.w	r3, r3, #5600	; 0x15e0
 8019fe2:	3310      	adds	r3, #16
 8019fe4:	66fb      	str	r3, [r7, #108]	; 0x6c
    nk_zero_struct(*button);
 8019fe6:	2198      	movs	r1, #152	; 0x98
 8019fe8:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 8019fea:	f002 f81d 	bl	801c028 <nk_zero>
    button->normal          = nk_style_item_color(table[NK_COLOR_COMBO]);
 8019fee:	6a3b      	ldr	r3, [r7, #32]
 8019ff0:	334c      	adds	r3, #76	; 0x4c
 8019ff2:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 8019ff4:	463a      	mov	r2, r7
 8019ff6:	6819      	ldr	r1, [r3, #0]
 8019ff8:	460b      	mov	r3, r1
 8019ffa:	4619      	mov	r1, r3
 8019ffc:	4610      	mov	r0, r2
 8019ffe:	f7fe fc3b 	bl	8018878 <nk_style_item_color>
 801a002:	4625      	mov	r5, r4
 801a004:	463c      	mov	r4, r7
 801a006:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801a008:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801a00a:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 801a00e:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    button->hover           = nk_style_item_color(table[NK_COLOR_COMBO]);
 801a012:	6a3b      	ldr	r3, [r7, #32]
 801a014:	334c      	adds	r3, #76	; 0x4c
 801a016:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a018:	463a      	mov	r2, r7
 801a01a:	6819      	ldr	r1, [r3, #0]
 801a01c:	460b      	mov	r3, r1
 801a01e:	4619      	mov	r1, r3
 801a020:	4610      	mov	r0, r2
 801a022:	f7fe fc29 	bl	8018878 <nk_style_item_color>
 801a026:	341c      	adds	r4, #28
 801a028:	463d      	mov	r5, r7
 801a02a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a02c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801a02e:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801a032:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->active          = nk_style_item_color(table[NK_COLOR_COMBO]);
 801a036:	6a3b      	ldr	r3, [r7, #32]
 801a038:	334c      	adds	r3, #76	; 0x4c
 801a03a:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a03c:	463a      	mov	r2, r7
 801a03e:	6819      	ldr	r1, [r3, #0]
 801a040:	460b      	mov	r3, r1
 801a042:	4619      	mov	r1, r3
 801a044:	4610      	mov	r0, r2
 801a046:	f7fe fc17 	bl	8018878 <nk_style_item_color>
 801a04a:	3438      	adds	r4, #56	; 0x38
 801a04c:	463d      	mov	r5, r7
 801a04e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a050:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801a052:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801a056:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->border_color    = nk_rgba(0,0,0,0);
 801a05a:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a05c:	2300      	movs	r3, #0
 801a05e:	2200      	movs	r2, #0
 801a060:	2100      	movs	r1, #0
 801a062:	2000      	movs	r0, #0
 801a064:	f7f4 ff0c 	bl	800ee80 <nk_rgba>
 801a068:	4603      	mov	r3, r0
 801a06a:	6563      	str	r3, [r4, #84]	; 0x54
    button->text_background = table[NK_COLOR_COMBO];
 801a06c:	6a3b      	ldr	r3, [r7, #32]
 801a06e:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 801a072:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a074:	3358      	adds	r3, #88	; 0x58
 801a076:	6810      	ldr	r0, [r2, #0]
 801a078:	6018      	str	r0, [r3, #0]
    button->text_normal     = table[NK_COLOR_TEXT];
 801a07a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a07c:	6a3a      	ldr	r2, [r7, #32]
 801a07e:	335c      	adds	r3, #92	; 0x5c
 801a080:	6810      	ldr	r0, [r2, #0]
 801a082:	6018      	str	r0, [r3, #0]
    button->text_hover      = table[NK_COLOR_TEXT];
 801a084:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a086:	6a3a      	ldr	r2, [r7, #32]
 801a088:	3360      	adds	r3, #96	; 0x60
 801a08a:	6810      	ldr	r0, [r2, #0]
 801a08c:	6018      	str	r0, [r3, #0]
    button->text_active     = table[NK_COLOR_TEXT];
 801a08e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a090:	6a3a      	ldr	r2, [r7, #32]
 801a092:	3364      	adds	r3, #100	; 0x64
 801a094:	6810      	ldr	r0, [r2, #0]
 801a096:	6018      	str	r0, [r3, #0]
    button->padding         = nk_vec2(2.0f,2.0f);
 801a098:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a09a:	eef0 0a00 	vmov.f32	s1, #0	; 0x40000000  2.0
 801a09e:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 801a0a2:	f7f9 fc09 	bl	80138b8 <nk_vec2>
 801a0a6:	eeb0 7a40 	vmov.f32	s14, s0
 801a0aa:	eef0 7a60 	vmov.f32	s15, s1
 801a0ae:	ed84 7a1d 	vstr	s14, [r4, #116]	; 0x74
 801a0b2:	edc4 7a1e 	vstr	s15, [r4, #120]	; 0x78
    button->touch_padding   = nk_vec2(0.0f,0.0f);
 801a0b6:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a0b8:	ed5f 0a8e 	vldr	s1, [pc, #-568]	; 8019e84 <nk_style_from_table+0x15a4>
 801a0bc:	ed1f 0a8f 	vldr	s0, [pc, #-572]	; 8019e84 <nk_style_from_table+0x15a4>
 801a0c0:	f7f9 fbfa 	bl	80138b8 <nk_vec2>
 801a0c4:	eeb0 7a40 	vmov.f32	s14, s0
 801a0c8:	eef0 7a60 	vmov.f32	s15, s1
 801a0cc:	ed84 7a21 	vstr	s14, [r4, #132]	; 0x84
 801a0d0:	edc4 7a22 	vstr	s15, [r4, #136]	; 0x88
    button->userdata        = nk_handle_ptr(0);
 801a0d4:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a0d6:	2000      	movs	r0, #0
 801a0d8:	f7f7 ffa2 	bl	8012020 <nk_handle_ptr>
 801a0dc:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    button->text_alignment  = NK_TEXT_CENTERED;
 801a0e0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a0e2:	2212      	movs	r2, #18
 801a0e4:	669a      	str	r2, [r3, #104]	; 0x68
    button->border          = 0.0f;
 801a0e6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a0e8:	f04f 0200 	mov.w	r2, #0
 801a0ec:	66da      	str	r2, [r3, #108]	; 0x6c
    button->rounding        = 0.0f;
 801a0ee:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a0f0:	f04f 0200 	mov.w	r2, #0
 801a0f4:	671a      	str	r2, [r3, #112]	; 0x70
    button->draw_begin      = 0;
 801a0f6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a0f8:	2200      	movs	r2, #0
 801a0fa:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    button->draw_end        = 0;
 801a0fe:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a100:	2200      	movs	r2, #0
 801a102:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

    /* tab */
    tab = &style->tab;
 801a106:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801a108:	f503 5396 	add.w	r3, r3, #4800	; 0x12c0
 801a10c:	331c      	adds	r3, #28
 801a10e:	647b      	str	r3, [r7, #68]	; 0x44
    tab->background         = nk_style_item_color(table[NK_COLOR_TAB_HEADER]);
 801a110:	6a3b      	ldr	r3, [r7, #32]
 801a112:	336c      	adds	r3, #108	; 0x6c
 801a114:	6c7c      	ldr	r4, [r7, #68]	; 0x44
 801a116:	463a      	mov	r2, r7
 801a118:	6819      	ldr	r1, [r3, #0]
 801a11a:	460b      	mov	r3, r1
 801a11c:	4619      	mov	r1, r3
 801a11e:	4610      	mov	r0, r2
 801a120:	f7fe fbaa 	bl	8018878 <nk_style_item_color>
 801a124:	4625      	mov	r5, r4
 801a126:	463c      	mov	r4, r7
 801a128:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801a12a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801a12c:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 801a130:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    tab->border_color       = table[NK_COLOR_BORDER];
 801a134:	6a3b      	ldr	r3, [r7, #32]
 801a136:	f103 020c 	add.w	r2, r3, #12
 801a13a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a13c:	331c      	adds	r3, #28
 801a13e:	6810      	ldr	r0, [r2, #0]
 801a140:	6018      	str	r0, [r3, #0]
    tab->text               = table[NK_COLOR_TEXT];
 801a142:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a144:	6a3a      	ldr	r2, [r7, #32]
 801a146:	3320      	adds	r3, #32
 801a148:	6810      	ldr	r0, [r2, #0]
 801a14a:	6018      	str	r0, [r3, #0]
    tab->sym_minimize       = NK_SYMBOL_TRIANGLE_RIGHT;
 801a14c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a14e:	220a      	movs	r2, #10
 801a150:	f883 2284 	strb.w	r2, [r3, #644]	; 0x284
    tab->sym_maximize       = NK_SYMBOL_TRIANGLE_DOWN;
 801a154:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a156:	2208      	movs	r2, #8
 801a158:	f883 2285 	strb.w	r2, [r3, #645]	; 0x285
    tab->padding            = nk_vec2(4,4);
 801a15c:	6c7c      	ldr	r4, [r7, #68]	; 0x44
 801a15e:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 801a162:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 801a166:	f7f9 fba7 	bl	80138b8 <nk_vec2>
 801a16a:	eeb0 7a40 	vmov.f32	s14, s0
 801a16e:	eef0 7a60 	vmov.f32	s15, s1
 801a172:	ed84 7aa5 	vstr	s14, [r4, #660]	; 0x294
 801a176:	edc4 7aa6 	vstr	s15, [r4, #664]	; 0x298
    tab->spacing            = nk_vec2(4,4);
 801a17a:	6c7c      	ldr	r4, [r7, #68]	; 0x44
 801a17c:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 801a180:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 801a184:	f7f9 fb98 	bl	80138b8 <nk_vec2>
 801a188:	eeb0 7a40 	vmov.f32	s14, s0
 801a18c:	eef0 7a60 	vmov.f32	s15, s1
 801a190:	ed84 7aa7 	vstr	s14, [r4, #668]	; 0x29c
 801a194:	edc4 7aa8 	vstr	s15, [r4, #672]	; 0x2a0
    tab->indent             = 10.0f;
 801a198:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a19a:	4aca      	ldr	r2, [pc, #808]	; (801a4c4 <nk_style_from_table+0x1be4>)
 801a19c:	f8c3 2290 	str.w	r2, [r3, #656]	; 0x290
    tab->border             = 1;
 801a1a0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a1a2:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 801a1a6:	f8c3 2288 	str.w	r2, [r3, #648]	; 0x288
    tab->rounding           = 0;
 801a1aa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a1ac:	f04f 0200 	mov.w	r2, #0
 801a1b0:	f8c3 228c 	str.w	r2, [r3, #652]	; 0x28c

    /* tab button */
    button = &style->tab.tab_minimize_button;
 801a1b4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801a1b6:	f503 539c 	add.w	r3, r3, #4992	; 0x1380
 801a1ba:	3318      	adds	r3, #24
 801a1bc:	66fb      	str	r3, [r7, #108]	; 0x6c
    nk_zero_struct(*button);
 801a1be:	2198      	movs	r1, #152	; 0x98
 801a1c0:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 801a1c2:	f001 ff31 	bl	801c028 <nk_zero>
    button->normal          = nk_style_item_color(table[NK_COLOR_TAB_HEADER]);
 801a1c6:	6a3b      	ldr	r3, [r7, #32]
 801a1c8:	336c      	adds	r3, #108	; 0x6c
 801a1ca:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a1cc:	463a      	mov	r2, r7
 801a1ce:	6819      	ldr	r1, [r3, #0]
 801a1d0:	460b      	mov	r3, r1
 801a1d2:	4619      	mov	r1, r3
 801a1d4:	4610      	mov	r0, r2
 801a1d6:	f7fe fb4f 	bl	8018878 <nk_style_item_color>
 801a1da:	4625      	mov	r5, r4
 801a1dc:	463c      	mov	r4, r7
 801a1de:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801a1e0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801a1e2:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 801a1e6:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    button->hover           = nk_style_item_color(table[NK_COLOR_TAB_HEADER]);
 801a1ea:	6a3b      	ldr	r3, [r7, #32]
 801a1ec:	336c      	adds	r3, #108	; 0x6c
 801a1ee:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a1f0:	463a      	mov	r2, r7
 801a1f2:	6819      	ldr	r1, [r3, #0]
 801a1f4:	460b      	mov	r3, r1
 801a1f6:	4619      	mov	r1, r3
 801a1f8:	4610      	mov	r0, r2
 801a1fa:	f7fe fb3d 	bl	8018878 <nk_style_item_color>
 801a1fe:	341c      	adds	r4, #28
 801a200:	463d      	mov	r5, r7
 801a202:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a204:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801a206:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801a20a:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->active          = nk_style_item_color(table[NK_COLOR_TAB_HEADER]);
 801a20e:	6a3b      	ldr	r3, [r7, #32]
 801a210:	336c      	adds	r3, #108	; 0x6c
 801a212:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a214:	463a      	mov	r2, r7
 801a216:	6819      	ldr	r1, [r3, #0]
 801a218:	460b      	mov	r3, r1
 801a21a:	4619      	mov	r1, r3
 801a21c:	4610      	mov	r0, r2
 801a21e:	f7fe fb2b 	bl	8018878 <nk_style_item_color>
 801a222:	3438      	adds	r4, #56	; 0x38
 801a224:	463d      	mov	r5, r7
 801a226:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a228:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801a22a:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801a22e:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->border_color    = nk_rgba(0,0,0,0);
 801a232:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a234:	2300      	movs	r3, #0
 801a236:	2200      	movs	r2, #0
 801a238:	2100      	movs	r1, #0
 801a23a:	2000      	movs	r0, #0
 801a23c:	f7f4 fe20 	bl	800ee80 <nk_rgba>
 801a240:	4603      	mov	r3, r0
 801a242:	6563      	str	r3, [r4, #84]	; 0x54
    button->text_background = table[NK_COLOR_TAB_HEADER];
 801a244:	6a3b      	ldr	r3, [r7, #32]
 801a246:	f103 026c 	add.w	r2, r3, #108	; 0x6c
 801a24a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a24c:	3358      	adds	r3, #88	; 0x58
 801a24e:	6810      	ldr	r0, [r2, #0]
 801a250:	6018      	str	r0, [r3, #0]
    button->text_normal     = table[NK_COLOR_TEXT];
 801a252:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a254:	6a3a      	ldr	r2, [r7, #32]
 801a256:	335c      	adds	r3, #92	; 0x5c
 801a258:	6810      	ldr	r0, [r2, #0]
 801a25a:	6018      	str	r0, [r3, #0]
    button->text_hover      = table[NK_COLOR_TEXT];
 801a25c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a25e:	6a3a      	ldr	r2, [r7, #32]
 801a260:	3360      	adds	r3, #96	; 0x60
 801a262:	6810      	ldr	r0, [r2, #0]
 801a264:	6018      	str	r0, [r3, #0]
    button->text_active     = table[NK_COLOR_TEXT];
 801a266:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a268:	6a3a      	ldr	r2, [r7, #32]
 801a26a:	3364      	adds	r3, #100	; 0x64
 801a26c:	6810      	ldr	r0, [r2, #0]
 801a26e:	6018      	str	r0, [r3, #0]
    button->padding         = nk_vec2(2.0f,2.0f);
 801a270:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a272:	eef0 0a00 	vmov.f32	s1, #0	; 0x40000000  2.0
 801a276:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 801a27a:	f7f9 fb1d 	bl	80138b8 <nk_vec2>
 801a27e:	eeb0 7a40 	vmov.f32	s14, s0
 801a282:	eef0 7a60 	vmov.f32	s15, s1
 801a286:	ed84 7a1d 	vstr	s14, [r4, #116]	; 0x74
 801a28a:	edc4 7a1e 	vstr	s15, [r4, #120]	; 0x78
    button->touch_padding   = nk_vec2(0.0f,0.0f);
 801a28e:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a290:	eddf 0a8d 	vldr	s1, [pc, #564]	; 801a4c8 <nk_style_from_table+0x1be8>
 801a294:	ed9f 0a8c 	vldr	s0, [pc, #560]	; 801a4c8 <nk_style_from_table+0x1be8>
 801a298:	f7f9 fb0e 	bl	80138b8 <nk_vec2>
 801a29c:	eeb0 7a40 	vmov.f32	s14, s0
 801a2a0:	eef0 7a60 	vmov.f32	s15, s1
 801a2a4:	ed84 7a21 	vstr	s14, [r4, #132]	; 0x84
 801a2a8:	edc4 7a22 	vstr	s15, [r4, #136]	; 0x88
    button->userdata        = nk_handle_ptr(0);
 801a2ac:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a2ae:	2000      	movs	r0, #0
 801a2b0:	f7f7 feb6 	bl	8012020 <nk_handle_ptr>
 801a2b4:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    button->text_alignment  = NK_TEXT_CENTERED;
 801a2b8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a2ba:	2212      	movs	r2, #18
 801a2bc:	669a      	str	r2, [r3, #104]	; 0x68
    button->border          = 0.0f;
 801a2be:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a2c0:	f04f 0200 	mov.w	r2, #0
 801a2c4:	66da      	str	r2, [r3, #108]	; 0x6c
    button->rounding        = 0.0f;
 801a2c6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a2c8:	f04f 0200 	mov.w	r2, #0
 801a2cc:	671a      	str	r2, [r3, #112]	; 0x70
    button->draw_begin      = 0;
 801a2ce:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a2d0:	2200      	movs	r2, #0
 801a2d2:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    button->draw_end        = 0;
 801a2d6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a2d8:	2200      	movs	r2, #0
 801a2da:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    style->tab.tab_maximize_button =*button;
 801a2de:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801a2e0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801a2e4:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801a2e6:	f503 7340 	add.w	r3, r3, #768	; 0x300
 801a2ea:	4611      	mov	r1, r2
 801a2ec:	2298      	movs	r2, #152	; 0x98
 801a2ee:	4618      	mov	r0, r3
 801a2f0:	f004 f9ba 	bl	801e668 <memcpy>

    /* node button */
    button = &style->tab.node_minimize_button;
 801a2f4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801a2f6:	f503 53a6 	add.w	r3, r3, #5312	; 0x14c0
 801a2fa:	3308      	adds	r3, #8
 801a2fc:	66fb      	str	r3, [r7, #108]	; 0x6c
    nk_zero_struct(*button);
 801a2fe:	2198      	movs	r1, #152	; 0x98
 801a300:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 801a302:	f001 fe91 	bl	801c028 <nk_zero>
    button->normal          = nk_style_item_color(table[NK_COLOR_WINDOW]);
 801a306:	6a3b      	ldr	r3, [r7, #32]
 801a308:	3304      	adds	r3, #4
 801a30a:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a30c:	463a      	mov	r2, r7
 801a30e:	6819      	ldr	r1, [r3, #0]
 801a310:	460b      	mov	r3, r1
 801a312:	4619      	mov	r1, r3
 801a314:	4610      	mov	r0, r2
 801a316:	f7fe faaf 	bl	8018878 <nk_style_item_color>
 801a31a:	4625      	mov	r5, r4
 801a31c:	463c      	mov	r4, r7
 801a31e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801a320:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801a322:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 801a326:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    button->hover           = nk_style_item_color(table[NK_COLOR_WINDOW]);
 801a32a:	6a3b      	ldr	r3, [r7, #32]
 801a32c:	3304      	adds	r3, #4
 801a32e:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a330:	463a      	mov	r2, r7
 801a332:	6819      	ldr	r1, [r3, #0]
 801a334:	460b      	mov	r3, r1
 801a336:	4619      	mov	r1, r3
 801a338:	4610      	mov	r0, r2
 801a33a:	f7fe fa9d 	bl	8018878 <nk_style_item_color>
 801a33e:	341c      	adds	r4, #28
 801a340:	463d      	mov	r5, r7
 801a342:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a344:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801a346:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801a34a:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->active          = nk_style_item_color(table[NK_COLOR_WINDOW]);
 801a34e:	6a3b      	ldr	r3, [r7, #32]
 801a350:	3304      	adds	r3, #4
 801a352:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a354:	463a      	mov	r2, r7
 801a356:	6819      	ldr	r1, [r3, #0]
 801a358:	460b      	mov	r3, r1
 801a35a:	4619      	mov	r1, r3
 801a35c:	4610      	mov	r0, r2
 801a35e:	f7fe fa8b 	bl	8018878 <nk_style_item_color>
 801a362:	3438      	adds	r4, #56	; 0x38
 801a364:	463d      	mov	r5, r7
 801a366:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a368:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801a36a:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801a36e:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->border_color    = nk_rgba(0,0,0,0);
 801a372:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a374:	2300      	movs	r3, #0
 801a376:	2200      	movs	r2, #0
 801a378:	2100      	movs	r1, #0
 801a37a:	2000      	movs	r0, #0
 801a37c:	f7f4 fd80 	bl	800ee80 <nk_rgba>
 801a380:	4603      	mov	r3, r0
 801a382:	6563      	str	r3, [r4, #84]	; 0x54
    button->text_background = table[NK_COLOR_TAB_HEADER];
 801a384:	6a3b      	ldr	r3, [r7, #32]
 801a386:	f103 026c 	add.w	r2, r3, #108	; 0x6c
 801a38a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a38c:	3358      	adds	r3, #88	; 0x58
 801a38e:	6810      	ldr	r0, [r2, #0]
 801a390:	6018      	str	r0, [r3, #0]
    button->text_normal     = table[NK_COLOR_TEXT];
 801a392:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a394:	6a3a      	ldr	r2, [r7, #32]
 801a396:	335c      	adds	r3, #92	; 0x5c
 801a398:	6810      	ldr	r0, [r2, #0]
 801a39a:	6018      	str	r0, [r3, #0]
    button->text_hover      = table[NK_COLOR_TEXT];
 801a39c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a39e:	6a3a      	ldr	r2, [r7, #32]
 801a3a0:	3360      	adds	r3, #96	; 0x60
 801a3a2:	6810      	ldr	r0, [r2, #0]
 801a3a4:	6018      	str	r0, [r3, #0]
    button->text_active     = table[NK_COLOR_TEXT];
 801a3a6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a3a8:	6a3a      	ldr	r2, [r7, #32]
 801a3aa:	3364      	adds	r3, #100	; 0x64
 801a3ac:	6810      	ldr	r0, [r2, #0]
 801a3ae:	6018      	str	r0, [r3, #0]
    button->padding         = nk_vec2(2.0f,2.0f);
 801a3b0:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a3b2:	eef0 0a00 	vmov.f32	s1, #0	; 0x40000000  2.0
 801a3b6:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 801a3ba:	f7f9 fa7d 	bl	80138b8 <nk_vec2>
 801a3be:	eeb0 7a40 	vmov.f32	s14, s0
 801a3c2:	eef0 7a60 	vmov.f32	s15, s1
 801a3c6:	ed84 7a1d 	vstr	s14, [r4, #116]	; 0x74
 801a3ca:	edc4 7a1e 	vstr	s15, [r4, #120]	; 0x78
    button->touch_padding   = nk_vec2(0.0f,0.0f);
 801a3ce:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a3d0:	eddf 0a3d 	vldr	s1, [pc, #244]	; 801a4c8 <nk_style_from_table+0x1be8>
 801a3d4:	ed9f 0a3c 	vldr	s0, [pc, #240]	; 801a4c8 <nk_style_from_table+0x1be8>
 801a3d8:	f7f9 fa6e 	bl	80138b8 <nk_vec2>
 801a3dc:	eeb0 7a40 	vmov.f32	s14, s0
 801a3e0:	eef0 7a60 	vmov.f32	s15, s1
 801a3e4:	ed84 7a21 	vstr	s14, [r4, #132]	; 0x84
 801a3e8:	edc4 7a22 	vstr	s15, [r4, #136]	; 0x88
    button->userdata        = nk_handle_ptr(0);
 801a3ec:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a3ee:	2000      	movs	r0, #0
 801a3f0:	f7f7 fe16 	bl	8012020 <nk_handle_ptr>
 801a3f4:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    button->text_alignment  = NK_TEXT_CENTERED;
 801a3f8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a3fa:	2212      	movs	r2, #18
 801a3fc:	669a      	str	r2, [r3, #104]	; 0x68
    button->border          = 0.0f;
 801a3fe:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a400:	f04f 0200 	mov.w	r2, #0
 801a404:	66da      	str	r2, [r3, #108]	; 0x6c
    button->rounding        = 0.0f;
 801a406:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a408:	f04f 0200 	mov.w	r2, #0
 801a40c:	671a      	str	r2, [r3, #112]	; 0x70
    button->draw_begin      = 0;
 801a40e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a410:	2200      	movs	r2, #0
 801a412:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    button->draw_end        = 0;
 801a416:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a418:	2200      	movs	r2, #0
 801a41a:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    style->tab.node_maximize_button =*button;
 801a41e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801a420:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801a424:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801a426:	f503 6386 	add.w	r3, r3, #1072	; 0x430
 801a42a:	4611      	mov	r1, r2
 801a42c:	2298      	movs	r2, #152	; 0x98
 801a42e:	4618      	mov	r0, r3
 801a430:	f004 f91a 	bl	801e668 <memcpy>

    /* window header */
    win = &style->window;
 801a434:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801a436:	f503 53b5 	add.w	r3, r3, #5792	; 0x16a0
 801a43a:	330c      	adds	r3, #12
 801a43c:	643b      	str	r3, [r7, #64]	; 0x40
    win->header.align = NK_HEADER_RIGHT;
 801a43e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a440:	2201      	movs	r2, #1
 801a442:	f883 2193 	strb.w	r2, [r3, #403]	; 0x193
    win->header.close_symbol = NK_SYMBOL_X;
 801a446:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a448:	2201      	movs	r2, #1
 801a44a:	f883 2184 	strb.w	r2, [r3, #388]	; 0x184
    win->header.minimize_symbol = NK_SYMBOL_MINUS;
 801a44e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a450:	220c      	movs	r2, #12
 801a452:	f883 2185 	strb.w	r2, [r3, #389]	; 0x185
    win->header.maximize_symbol = NK_SYMBOL_PLUS;
 801a456:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a458:	220b      	movs	r2, #11
 801a45a:	f883 2186 	strb.w	r2, [r3, #390]	; 0x186
    win->header.normal = nk_style_item_color(table[NK_COLOR_HEADER]);
 801a45e:	6a3b      	ldr	r3, [r7, #32]
 801a460:	3308      	adds	r3, #8
 801a462:	6c3c      	ldr	r4, [r7, #64]	; 0x40
 801a464:	463a      	mov	r2, r7
 801a466:	6819      	ldr	r1, [r3, #0]
 801a468:	460b      	mov	r3, r1
 801a46a:	4619      	mov	r1, r3
 801a46c:	4610      	mov	r0, r2
 801a46e:	f7fe fa03 	bl	8018878 <nk_style_item_color>
 801a472:	4625      	mov	r5, r4
 801a474:	463c      	mov	r4, r7
 801a476:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801a478:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801a47a:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 801a47e:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    win->header.hover = nk_style_item_color(table[NK_COLOR_HEADER]);
 801a482:	6a3b      	ldr	r3, [r7, #32]
 801a484:	3308      	adds	r3, #8
 801a486:	6c3c      	ldr	r4, [r7, #64]	; 0x40
 801a488:	463a      	mov	r2, r7
 801a48a:	6819      	ldr	r1, [r3, #0]
 801a48c:	460b      	mov	r3, r1
 801a48e:	4619      	mov	r1, r3
 801a490:	4610      	mov	r0, r2
 801a492:	f7fe f9f1 	bl	8018878 <nk_style_item_color>
 801a496:	341c      	adds	r4, #28
 801a498:	463d      	mov	r5, r7
 801a49a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a49c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801a49e:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801a4a2:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    win->header.active = nk_style_item_color(table[NK_COLOR_HEADER]);
 801a4a6:	6a3b      	ldr	r3, [r7, #32]
 801a4a8:	3308      	adds	r3, #8
 801a4aa:	6c3c      	ldr	r4, [r7, #64]	; 0x40
 801a4ac:	463a      	mov	r2, r7
 801a4ae:	6819      	ldr	r1, [r3, #0]
 801a4b0:	460b      	mov	r3, r1
 801a4b2:	4619      	mov	r1, r3
 801a4b4:	4610      	mov	r0, r2
 801a4b6:	f7fe f9df 	bl	8018878 <nk_style_item_color>
 801a4ba:	3438      	adds	r4, #56	; 0x38
 801a4bc:	463d      	mov	r5, r7
 801a4be:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a4c0:	e004      	b.n	801a4cc <nk_style_from_table+0x1bec>
 801a4c2:	bf00      	nop
 801a4c4:	41200000 	.word	0x41200000
 801a4c8:	00000000 	.word	0x00000000
 801a4cc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801a4ce:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801a4d2:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    win->header.label_normal = table[NK_COLOR_TEXT];
 801a4d6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a4d8:	6a3a      	ldr	r2, [r7, #32]
 801a4da:	f203 1387 	addw	r3, r3, #391	; 0x187
 801a4de:	6812      	ldr	r2, [r2, #0]
 801a4e0:	601a      	str	r2, [r3, #0]
    win->header.label_hover = table[NK_COLOR_TEXT];
 801a4e2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a4e4:	6a3a      	ldr	r2, [r7, #32]
 801a4e6:	f203 138b 	addw	r3, r3, #395	; 0x18b
 801a4ea:	6812      	ldr	r2, [r2, #0]
 801a4ec:	601a      	str	r2, [r3, #0]
    win->header.label_active = table[NK_COLOR_TEXT];
 801a4ee:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a4f0:	6a3a      	ldr	r2, [r7, #32]
 801a4f2:	f203 138f 	addw	r3, r3, #399	; 0x18f
 801a4f6:	6812      	ldr	r2, [r2, #0]
 801a4f8:	601a      	str	r2, [r3, #0]
    win->header.label_padding = nk_vec2(4,4);
 801a4fa:	6c3c      	ldr	r4, [r7, #64]	; 0x40
 801a4fc:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 801a500:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 801a504:	f7f9 f9d8 	bl	80138b8 <nk_vec2>
 801a508:	eeb0 7a40 	vmov.f32	s14, s0
 801a50c:	eef0 7a60 	vmov.f32	s15, s1
 801a510:	ed84 7a67 	vstr	s14, [r4, #412]	; 0x19c
 801a514:	edc4 7a68 	vstr	s15, [r4, #416]	; 0x1a0
    win->header.padding = nk_vec2(4,4);
 801a518:	6c3c      	ldr	r4, [r7, #64]	; 0x40
 801a51a:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 801a51e:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 801a522:	f7f9 f9c9 	bl	80138b8 <nk_vec2>
 801a526:	eeb0 7a40 	vmov.f32	s14, s0
 801a52a:	eef0 7a60 	vmov.f32	s15, s1
 801a52e:	ed84 7a65 	vstr	s14, [r4, #404]	; 0x194
 801a532:	edc4 7a66 	vstr	s15, [r4, #408]	; 0x198
    win->header.spacing = nk_vec2(0,0);
 801a536:	6c3c      	ldr	r4, [r7, #64]	; 0x40
 801a538:	ed5f 0a1d 	vldr	s1, [pc, #-116]	; 801a4c8 <nk_style_from_table+0x1be8>
 801a53c:	ed1f 0a1e 	vldr	s0, [pc, #-120]	; 801a4c8 <nk_style_from_table+0x1be8>
 801a540:	f7f9 f9ba 	bl	80138b8 <nk_vec2>
 801a544:	eeb0 7a40 	vmov.f32	s14, s0
 801a548:	eef0 7a60 	vmov.f32	s15, s1
 801a54c:	ed84 7a69 	vstr	s14, [r4, #420]	; 0x1a4
 801a550:	edc4 7a6a 	vstr	s15, [r4, #424]	; 0x1a8

    /* window header close button */
    button = &style->window.header.close_button;
 801a554:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801a556:	f503 53b8 	add.w	r3, r3, #5888	; 0x1700
 801a55a:	66fb      	str	r3, [r7, #108]	; 0x6c
    nk_zero_struct(*button);
 801a55c:	2198      	movs	r1, #152	; 0x98
 801a55e:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 801a560:	f001 fd62 	bl	801c028 <nk_zero>
    button->normal          = nk_style_item_color(table[NK_COLOR_HEADER]);
 801a564:	6a3b      	ldr	r3, [r7, #32]
 801a566:	3308      	adds	r3, #8
 801a568:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a56a:	463a      	mov	r2, r7
 801a56c:	6819      	ldr	r1, [r3, #0]
 801a56e:	460b      	mov	r3, r1
 801a570:	4619      	mov	r1, r3
 801a572:	4610      	mov	r0, r2
 801a574:	f7fe f980 	bl	8018878 <nk_style_item_color>
 801a578:	4625      	mov	r5, r4
 801a57a:	463c      	mov	r4, r7
 801a57c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801a57e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801a580:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 801a584:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    button->hover           = nk_style_item_color(table[NK_COLOR_HEADER]);
 801a588:	6a3b      	ldr	r3, [r7, #32]
 801a58a:	3308      	adds	r3, #8
 801a58c:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a58e:	463a      	mov	r2, r7
 801a590:	6819      	ldr	r1, [r3, #0]
 801a592:	460b      	mov	r3, r1
 801a594:	4619      	mov	r1, r3
 801a596:	4610      	mov	r0, r2
 801a598:	f7fe f96e 	bl	8018878 <nk_style_item_color>
 801a59c:	341c      	adds	r4, #28
 801a59e:	463d      	mov	r5, r7
 801a5a0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a5a2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801a5a4:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801a5a8:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->active          = nk_style_item_color(table[NK_COLOR_HEADER]);
 801a5ac:	6a3b      	ldr	r3, [r7, #32]
 801a5ae:	3308      	adds	r3, #8
 801a5b0:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a5b2:	463a      	mov	r2, r7
 801a5b4:	6819      	ldr	r1, [r3, #0]
 801a5b6:	460b      	mov	r3, r1
 801a5b8:	4619      	mov	r1, r3
 801a5ba:	4610      	mov	r0, r2
 801a5bc:	f7fe f95c 	bl	8018878 <nk_style_item_color>
 801a5c0:	3438      	adds	r4, #56	; 0x38
 801a5c2:	463d      	mov	r5, r7
 801a5c4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a5c6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801a5c8:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801a5cc:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->border_color    = nk_rgba(0,0,0,0);
 801a5d0:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a5d2:	2300      	movs	r3, #0
 801a5d4:	2200      	movs	r2, #0
 801a5d6:	2100      	movs	r1, #0
 801a5d8:	2000      	movs	r0, #0
 801a5da:	f7f4 fc51 	bl	800ee80 <nk_rgba>
 801a5de:	4603      	mov	r3, r0
 801a5e0:	6563      	str	r3, [r4, #84]	; 0x54
    button->text_background = table[NK_COLOR_HEADER];
 801a5e2:	6a3b      	ldr	r3, [r7, #32]
 801a5e4:	f103 0208 	add.w	r2, r3, #8
 801a5e8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a5ea:	3358      	adds	r3, #88	; 0x58
 801a5ec:	6810      	ldr	r0, [r2, #0]
 801a5ee:	6018      	str	r0, [r3, #0]
    button->text_normal     = table[NK_COLOR_TEXT];
 801a5f0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a5f2:	6a3a      	ldr	r2, [r7, #32]
 801a5f4:	335c      	adds	r3, #92	; 0x5c
 801a5f6:	6810      	ldr	r0, [r2, #0]
 801a5f8:	6018      	str	r0, [r3, #0]
    button->text_hover      = table[NK_COLOR_TEXT];
 801a5fa:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a5fc:	6a3a      	ldr	r2, [r7, #32]
 801a5fe:	3360      	adds	r3, #96	; 0x60
 801a600:	6810      	ldr	r0, [r2, #0]
 801a602:	6018      	str	r0, [r3, #0]
    button->text_active     = table[NK_COLOR_TEXT];
 801a604:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a606:	6a3a      	ldr	r2, [r7, #32]
 801a608:	3364      	adds	r3, #100	; 0x64
 801a60a:	6810      	ldr	r0, [r2, #0]
 801a60c:	6018      	str	r0, [r3, #0]
    button->padding         = nk_vec2(0.0f,0.0f);
 801a60e:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a610:	ed5f 0a53 	vldr	s1, [pc, #-332]	; 801a4c8 <nk_style_from_table+0x1be8>
 801a614:	ed1f 0a54 	vldr	s0, [pc, #-336]	; 801a4c8 <nk_style_from_table+0x1be8>
 801a618:	f7f9 f94e 	bl	80138b8 <nk_vec2>
 801a61c:	eeb0 7a40 	vmov.f32	s14, s0
 801a620:	eef0 7a60 	vmov.f32	s15, s1
 801a624:	ed84 7a1d 	vstr	s14, [r4, #116]	; 0x74
 801a628:	edc4 7a1e 	vstr	s15, [r4, #120]	; 0x78
    button->touch_padding   = nk_vec2(0.0f,0.0f);
 801a62c:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a62e:	ed5f 0a5a 	vldr	s1, [pc, #-360]	; 801a4c8 <nk_style_from_table+0x1be8>
 801a632:	ed1f 0a5b 	vldr	s0, [pc, #-364]	; 801a4c8 <nk_style_from_table+0x1be8>
 801a636:	f7f9 f93f 	bl	80138b8 <nk_vec2>
 801a63a:	eeb0 7a40 	vmov.f32	s14, s0
 801a63e:	eef0 7a60 	vmov.f32	s15, s1
 801a642:	ed84 7a21 	vstr	s14, [r4, #132]	; 0x84
 801a646:	edc4 7a22 	vstr	s15, [r4, #136]	; 0x88
    button->userdata        = nk_handle_ptr(0);
 801a64a:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a64c:	2000      	movs	r0, #0
 801a64e:	f7f7 fce7 	bl	8012020 <nk_handle_ptr>
 801a652:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    button->text_alignment  = NK_TEXT_CENTERED;
 801a656:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a658:	2212      	movs	r2, #18
 801a65a:	669a      	str	r2, [r3, #104]	; 0x68
    button->border          = 0.0f;
 801a65c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a65e:	f04f 0200 	mov.w	r2, #0
 801a662:	66da      	str	r2, [r3, #108]	; 0x6c
    button->rounding        = 0.0f;
 801a664:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a666:	f04f 0200 	mov.w	r2, #0
 801a66a:	671a      	str	r2, [r3, #112]	; 0x70
    button->draw_begin      = 0;
 801a66c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a66e:	2200      	movs	r2, #0
 801a670:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    button->draw_end        = 0;
 801a674:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a676:	2200      	movs	r2, #0
 801a678:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

    /* window header minimize button */
    button = &style->window.header.minimize_button;
 801a67c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801a67e:	f503 53bc 	add.w	r3, r3, #6016	; 0x1780
 801a682:	3318      	adds	r3, #24
 801a684:	66fb      	str	r3, [r7, #108]	; 0x6c
    nk_zero_struct(*button);
 801a686:	2198      	movs	r1, #152	; 0x98
 801a688:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 801a68a:	f001 fccd 	bl	801c028 <nk_zero>
    button->normal          = nk_style_item_color(table[NK_COLOR_HEADER]);
 801a68e:	6a3b      	ldr	r3, [r7, #32]
 801a690:	3308      	adds	r3, #8
 801a692:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a694:	463a      	mov	r2, r7
 801a696:	6819      	ldr	r1, [r3, #0]
 801a698:	460b      	mov	r3, r1
 801a69a:	4619      	mov	r1, r3
 801a69c:	4610      	mov	r0, r2
 801a69e:	f7fe f8eb 	bl	8018878 <nk_style_item_color>
 801a6a2:	4625      	mov	r5, r4
 801a6a4:	463c      	mov	r4, r7
 801a6a6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801a6a8:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801a6aa:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 801a6ae:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    button->hover           = nk_style_item_color(table[NK_COLOR_HEADER]);
 801a6b2:	6a3b      	ldr	r3, [r7, #32]
 801a6b4:	3308      	adds	r3, #8
 801a6b6:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a6b8:	463a      	mov	r2, r7
 801a6ba:	6819      	ldr	r1, [r3, #0]
 801a6bc:	460b      	mov	r3, r1
 801a6be:	4619      	mov	r1, r3
 801a6c0:	4610      	mov	r0, r2
 801a6c2:	f7fe f8d9 	bl	8018878 <nk_style_item_color>
 801a6c6:	341c      	adds	r4, #28
 801a6c8:	463d      	mov	r5, r7
 801a6ca:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a6cc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801a6ce:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801a6d2:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->active          = nk_style_item_color(table[NK_COLOR_HEADER]);
 801a6d6:	6a3b      	ldr	r3, [r7, #32]
 801a6d8:	3308      	adds	r3, #8
 801a6da:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a6dc:	463a      	mov	r2, r7
 801a6de:	6819      	ldr	r1, [r3, #0]
 801a6e0:	460b      	mov	r3, r1
 801a6e2:	4619      	mov	r1, r3
 801a6e4:	4610      	mov	r0, r2
 801a6e6:	f7fe f8c7 	bl	8018878 <nk_style_item_color>
 801a6ea:	3438      	adds	r4, #56	; 0x38
 801a6ec:	463d      	mov	r5, r7
 801a6ee:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a6f0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801a6f2:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801a6f6:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    button->border_color    = nk_rgba(0,0,0,0);
 801a6fa:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a6fc:	2300      	movs	r3, #0
 801a6fe:	2200      	movs	r2, #0
 801a700:	2100      	movs	r1, #0
 801a702:	2000      	movs	r0, #0
 801a704:	f7f4 fbbc 	bl	800ee80 <nk_rgba>
 801a708:	4603      	mov	r3, r0
 801a70a:	6563      	str	r3, [r4, #84]	; 0x54
    button->text_background = table[NK_COLOR_HEADER];
 801a70c:	6a3b      	ldr	r3, [r7, #32]
 801a70e:	f103 0208 	add.w	r2, r3, #8
 801a712:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a714:	3358      	adds	r3, #88	; 0x58
 801a716:	6810      	ldr	r0, [r2, #0]
 801a718:	6018      	str	r0, [r3, #0]
    button->text_normal     = table[NK_COLOR_TEXT];
 801a71a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a71c:	6a3a      	ldr	r2, [r7, #32]
 801a71e:	335c      	adds	r3, #92	; 0x5c
 801a720:	6810      	ldr	r0, [r2, #0]
 801a722:	6018      	str	r0, [r3, #0]
    button->text_hover      = table[NK_COLOR_TEXT];
 801a724:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a726:	6a3a      	ldr	r2, [r7, #32]
 801a728:	3360      	adds	r3, #96	; 0x60
 801a72a:	6810      	ldr	r0, [r2, #0]
 801a72c:	6018      	str	r0, [r3, #0]
    button->text_active     = table[NK_COLOR_TEXT];
 801a72e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a730:	6a3a      	ldr	r2, [r7, #32]
 801a732:	3364      	adds	r3, #100	; 0x64
 801a734:	6810      	ldr	r0, [r2, #0]
 801a736:	6018      	str	r0, [r3, #0]
    button->padding         = nk_vec2(0.0f,0.0f);
 801a738:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a73a:	ed5f 0a9d 	vldr	s1, [pc, #-628]	; 801a4c8 <nk_style_from_table+0x1be8>
 801a73e:	ed1f 0a9e 	vldr	s0, [pc, #-632]	; 801a4c8 <nk_style_from_table+0x1be8>
 801a742:	f7f9 f8b9 	bl	80138b8 <nk_vec2>
 801a746:	eeb0 7a40 	vmov.f32	s14, s0
 801a74a:	eef0 7a60 	vmov.f32	s15, s1
 801a74e:	ed84 7a1d 	vstr	s14, [r4, #116]	; 0x74
 801a752:	edc4 7a1e 	vstr	s15, [r4, #120]	; 0x78
    button->touch_padding   = nk_vec2(0.0f,0.0f);
 801a756:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a758:	ed5f 0aa5 	vldr	s1, [pc, #-660]	; 801a4c8 <nk_style_from_table+0x1be8>
 801a75c:	ed1f 0aa6 	vldr	s0, [pc, #-664]	; 801a4c8 <nk_style_from_table+0x1be8>
 801a760:	f7f9 f8aa 	bl	80138b8 <nk_vec2>
 801a764:	eeb0 7a40 	vmov.f32	s14, s0
 801a768:	eef0 7a60 	vmov.f32	s15, s1
 801a76c:	ed84 7a21 	vstr	s14, [r4, #132]	; 0x84
 801a770:	edc4 7a22 	vstr	s15, [r4, #136]	; 0x88
    button->userdata        = nk_handle_ptr(0);
 801a774:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 801a776:	2000      	movs	r0, #0
 801a778:	f7f7 fc52 	bl	8012020 <nk_handle_ptr>
 801a77c:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    button->text_alignment  = NK_TEXT_CENTERED;
 801a780:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a782:	2212      	movs	r2, #18
 801a784:	669a      	str	r2, [r3, #104]	; 0x68
    button->border          = 0.0f;
 801a786:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a788:	f04f 0200 	mov.w	r2, #0
 801a78c:	66da      	str	r2, [r3, #108]	; 0x6c
    button->rounding        = 0.0f;
 801a78e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a790:	f04f 0200 	mov.w	r2, #0
 801a794:	671a      	str	r2, [r3, #112]	; 0x70
    button->draw_begin      = 0;
 801a796:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a798:	2200      	movs	r2, #0
 801a79a:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    button->draw_end        = 0;
 801a79e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a7a0:	2200      	movs	r2, #0
 801a7a2:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

    /* window */
    win->background = table[NK_COLOR_WINDOW];
 801a7a6:	6a3b      	ldr	r3, [r7, #32]
 801a7a8:	1d1a      	adds	r2, r3, #4
 801a7aa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a7ac:	f503 73e4 	add.w	r3, r3, #456	; 0x1c8
 801a7b0:	6810      	ldr	r0, [r2, #0]
 801a7b2:	6018      	str	r0, [r3, #0]
    win->fixed_background = nk_style_item_color(table[NK_COLOR_WINDOW]);
 801a7b4:	6a3b      	ldr	r3, [r7, #32]
 801a7b6:	3304      	adds	r3, #4
 801a7b8:	6c3c      	ldr	r4, [r7, #64]	; 0x40
 801a7ba:	463a      	mov	r2, r7
 801a7bc:	6819      	ldr	r1, [r3, #0]
 801a7be:	460b      	mov	r3, r1
 801a7c0:	4619      	mov	r1, r3
 801a7c2:	4610      	mov	r0, r2
 801a7c4:	f7fe f858 	bl	8018878 <nk_style_item_color>
 801a7c8:	f504 74d6 	add.w	r4, r4, #428	; 0x1ac
 801a7cc:	463d      	mov	r5, r7
 801a7ce:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a7d0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801a7d2:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801a7d6:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    win->border_color = table[NK_COLOR_BORDER];
 801a7da:	6a3b      	ldr	r3, [r7, #32]
 801a7dc:	f103 020c 	add.w	r2, r3, #12
 801a7e0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a7e2:	f503 73e6 	add.w	r3, r3, #460	; 0x1cc
 801a7e6:	6810      	ldr	r0, [r2, #0]
 801a7e8:	6018      	str	r0, [r3, #0]
    win->popup_border_color = table[NK_COLOR_BORDER];
 801a7ea:	6a3b      	ldr	r3, [r7, #32]
 801a7ec:	f103 020c 	add.w	r2, r3, #12
 801a7f0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a7f2:	f503 73e8 	add.w	r3, r3, #464	; 0x1d0
 801a7f6:	6810      	ldr	r0, [r2, #0]
 801a7f8:	6018      	str	r0, [r3, #0]
    win->combo_border_color = table[NK_COLOR_BORDER];
 801a7fa:	6a3b      	ldr	r3, [r7, #32]
 801a7fc:	f103 020c 	add.w	r2, r3, #12
 801a800:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a802:	f503 73ea 	add.w	r3, r3, #468	; 0x1d4
 801a806:	6810      	ldr	r0, [r2, #0]
 801a808:	6018      	str	r0, [r3, #0]
    win->contextual_border_color = table[NK_COLOR_BORDER];
 801a80a:	6a3b      	ldr	r3, [r7, #32]
 801a80c:	f103 020c 	add.w	r2, r3, #12
 801a810:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a812:	f503 73ec 	add.w	r3, r3, #472	; 0x1d8
 801a816:	6810      	ldr	r0, [r2, #0]
 801a818:	6018      	str	r0, [r3, #0]
    win->menu_border_color = table[NK_COLOR_BORDER];
 801a81a:	6a3b      	ldr	r3, [r7, #32]
 801a81c:	f103 020c 	add.w	r2, r3, #12
 801a820:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a822:	f503 73ee 	add.w	r3, r3, #476	; 0x1dc
 801a826:	6810      	ldr	r0, [r2, #0]
 801a828:	6018      	str	r0, [r3, #0]
    win->group_border_color = table[NK_COLOR_BORDER];
 801a82a:	6a3b      	ldr	r3, [r7, #32]
 801a82c:	f103 020c 	add.w	r2, r3, #12
 801a830:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a832:	f503 73f0 	add.w	r3, r3, #480	; 0x1e0
 801a836:	6810      	ldr	r0, [r2, #0]
 801a838:	6018      	str	r0, [r3, #0]
    win->tooltip_border_color = table[NK_COLOR_BORDER];
 801a83a:	6a3b      	ldr	r3, [r7, #32]
 801a83c:	f103 020c 	add.w	r2, r3, #12
 801a840:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a842:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
 801a846:	6810      	ldr	r0, [r2, #0]
 801a848:	6018      	str	r0, [r3, #0]
    win->scaler = nk_style_item_color(table[NK_COLOR_TEXT]);
 801a84a:	6c3c      	ldr	r4, [r7, #64]	; 0x40
 801a84c:	463a      	mov	r2, r7
 801a84e:	6a3b      	ldr	r3, [r7, #32]
 801a850:	6819      	ldr	r1, [r3, #0]
 801a852:	460b      	mov	r3, r1
 801a854:	4619      	mov	r1, r3
 801a856:	4610      	mov	r0, r2
 801a858:	f7fe f80e 	bl	8018878 <nk_style_item_color>
 801a85c:	f504 74f4 	add.w	r4, r4, #488	; 0x1e8
 801a860:	463d      	mov	r5, r7
 801a862:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a864:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801a866:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801a86a:	e884 0007 	stmia.w	r4, {r0, r1, r2}

    win->rounding = 0.0f;
 801a86e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a870:	f04f 0200 	mov.w	r2, #0
 801a874:	f8c3 2224 	str.w	r2, [r3, #548]	; 0x224
    win->spacing = nk_vec2(4,4);
 801a878:	6c3c      	ldr	r4, [r7, #64]	; 0x40
 801a87a:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 801a87e:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 801a882:	f7f9 f819 	bl	80138b8 <nk_vec2>
 801a886:	eeb0 7a40 	vmov.f32	s14, s0
 801a88a:	eef0 7a60 	vmov.f32	s15, s1
 801a88e:	ed84 7a8a 	vstr	s14, [r4, #552]	; 0x228
 801a892:	edc4 7a8b 	vstr	s15, [r4, #556]	; 0x22c
    win->scrollbar_size = nk_vec2(20,20);
 801a896:	6c3c      	ldr	r4, [r7, #64]	; 0x40
 801a898:	eef3 0a04 	vmov.f32	s1, #52	; 0x41a00000  20.0
 801a89c:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 801a8a0:	f7f9 f80a 	bl	80138b8 <nk_vec2>
 801a8a4:	eeb0 7a40 	vmov.f32	s14, s0
 801a8a8:	eef0 7a60 	vmov.f32	s15, s1
 801a8ac:	ed84 7a8c 	vstr	s14, [r4, #560]	; 0x230
 801a8b0:	edc4 7a8d 	vstr	s15, [r4, #564]	; 0x234
    win->min_size = nk_vec2(64,64);
 801a8b4:	6c3c      	ldr	r4, [r7, #64]	; 0x40
 801a8b6:	eddf 0a52 	vldr	s1, [pc, #328]	; 801aa00 <nk_style_from_table+0x2120>
 801a8ba:	ed9f 0a51 	vldr	s0, [pc, #324]	; 801aa00 <nk_style_from_table+0x2120>
 801a8be:	f7f8 fffb 	bl	80138b8 <nk_vec2>
 801a8c2:	eeb0 7a40 	vmov.f32	s14, s0
 801a8c6:	eef0 7a60 	vmov.f32	s15, s1
 801a8ca:	ed84 7a8e 	vstr	s14, [r4, #568]	; 0x238
 801a8ce:	edc4 7a8f 	vstr	s15, [r4, #572]	; 0x23c

    win->combo_border = 1.0f;
 801a8d2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a8d4:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 801a8d8:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
    win->contextual_border = 1.0f;
 801a8dc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a8de:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 801a8e2:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c
    win->menu_border = 1.0f;
 801a8e6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a8e8:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 801a8ec:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
    win->group_border = 1.0f;
 801a8f0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a8f2:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 801a8f6:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
    win->tooltip_border = 1.0f;
 801a8fa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a8fc:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 801a900:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218
    win->popup_border = 1.0f;
 801a904:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a906:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 801a90a:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c
    win->border = 2.0f;
 801a90e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a910:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 801a914:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
    win->min_row_height_padding = 8;
 801a918:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a91a:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
 801a91e:	f8c3 2220 	str.w	r2, [r3, #544]	; 0x220

    win->padding = nk_vec2(4,4);
 801a922:	6c3c      	ldr	r4, [r7, #64]	; 0x40
 801a924:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 801a928:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 801a92c:	f7f8 ffc4 	bl	80138b8 <nk_vec2>
 801a930:	eeb0 7a40 	vmov.f32	s14, s0
 801a934:	eef0 7a60 	vmov.f32	s15, s1
 801a938:	ed84 7a90 	vstr	s14, [r4, #576]	; 0x240
 801a93c:	edc4 7a91 	vstr	s15, [r4, #580]	; 0x244
    win->group_padding = nk_vec2(4,4);
 801a940:	6c3c      	ldr	r4, [r7, #64]	; 0x40
 801a942:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 801a946:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 801a94a:	f7f8 ffb5 	bl	80138b8 <nk_vec2>
 801a94e:	eeb0 7a40 	vmov.f32	s14, s0
 801a952:	eef0 7a60 	vmov.f32	s15, s1
 801a956:	ed84 7a92 	vstr	s14, [r4, #584]	; 0x248
 801a95a:	edc4 7a93 	vstr	s15, [r4, #588]	; 0x24c
    win->popup_padding = nk_vec2(4,4);
 801a95e:	6c3c      	ldr	r4, [r7, #64]	; 0x40
 801a960:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 801a964:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 801a968:	f7f8 ffa6 	bl	80138b8 <nk_vec2>
 801a96c:	eeb0 7a40 	vmov.f32	s14, s0
 801a970:	eef0 7a60 	vmov.f32	s15, s1
 801a974:	ed84 7a94 	vstr	s14, [r4, #592]	; 0x250
 801a978:	edc4 7a95 	vstr	s15, [r4, #596]	; 0x254
    win->combo_padding = nk_vec2(4,4);
 801a97c:	6c3c      	ldr	r4, [r7, #64]	; 0x40
 801a97e:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 801a982:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 801a986:	f7f8 ff97 	bl	80138b8 <nk_vec2>
 801a98a:	eeb0 7a40 	vmov.f32	s14, s0
 801a98e:	eef0 7a60 	vmov.f32	s15, s1
 801a992:	ed84 7a96 	vstr	s14, [r4, #600]	; 0x258
 801a996:	edc4 7a97 	vstr	s15, [r4, #604]	; 0x25c
    win->contextual_padding = nk_vec2(4,4);
 801a99a:	6c3c      	ldr	r4, [r7, #64]	; 0x40
 801a99c:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 801a9a0:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 801a9a4:	f7f8 ff88 	bl	80138b8 <nk_vec2>
 801a9a8:	eeb0 7a40 	vmov.f32	s14, s0
 801a9ac:	eef0 7a60 	vmov.f32	s15, s1
 801a9b0:	ed84 7a98 	vstr	s14, [r4, #608]	; 0x260
 801a9b4:	edc4 7a99 	vstr	s15, [r4, #612]	; 0x264
    win->menu_padding = nk_vec2(4,4);
 801a9b8:	6c3c      	ldr	r4, [r7, #64]	; 0x40
 801a9ba:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 801a9be:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 801a9c2:	f7f8 ff79 	bl	80138b8 <nk_vec2>
 801a9c6:	eeb0 7a40 	vmov.f32	s14, s0
 801a9ca:	eef0 7a60 	vmov.f32	s15, s1
 801a9ce:	ed84 7a9a 	vstr	s14, [r4, #616]	; 0x268
 801a9d2:	edc4 7a9b 	vstr	s15, [r4, #620]	; 0x26c
    win->tooltip_padding = nk_vec2(4,4);
 801a9d6:	6c3c      	ldr	r4, [r7, #64]	; 0x40
 801a9d8:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 801a9dc:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 801a9e0:	f7f8 ff6a 	bl	80138b8 <nk_vec2>
 801a9e4:	eeb0 7a40 	vmov.f32	s14, s0
 801a9e8:	eef0 7a60 	vmov.f32	s15, s1
 801a9ec:	ed84 7a9c 	vstr	s14, [r4, #624]	; 0x270
 801a9f0:	edc4 7a9d 	vstr	s15, [r4, #628]	; 0x274
 801a9f4:	e000      	b.n	801a9f8 <nk_style_from_table+0x2118>
    if (!ctx) return;
 801a9f6:	bf00      	nop
}
 801a9f8:	3778      	adds	r7, #120	; 0x78
 801a9fa:	46bd      	mov	sp, r7
 801a9fc:	bdb0      	pop	{r4, r5, r7, pc}
 801a9fe:	bf00      	nop
 801aa00:	42800000 	.word	0x42800000

0801aa04 <nk_create_table>:
 *                              TABLE
 *
 * ===============================================================*/
NK_LIB struct nk_table*
nk_create_table(struct nk_context *ctx)
{
 801aa04:	b580      	push	{r7, lr}
 801aa06:	b084      	sub	sp, #16
 801aa08:	af00      	add	r7, sp, #0
 801aa0a:	6078      	str	r0, [r7, #4]
    struct nk_page_element *elem;
    elem = nk_create_page_element(ctx);
 801aa0c:	6878      	ldr	r0, [r7, #4]
 801aa0e:	f7f9 f9e7 	bl	8013de0 <nk_create_page_element>
 801aa12:	60f8      	str	r0, [r7, #12]
    if (!elem) return 0;
 801aa14:	68fb      	ldr	r3, [r7, #12]
 801aa16:	2b00      	cmp	r3, #0
 801aa18:	d101      	bne.n	801aa1e <nk_create_table+0x1a>
 801aa1a:	2300      	movs	r3, #0
 801aa1c:	e005      	b.n	801aa2a <nk_create_table+0x26>
    nk_zero_struct(*elem);
 801aa1e:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 801aa22:	68f8      	ldr	r0, [r7, #12]
 801aa24:	f001 fb00 	bl	801c028 <nk_zero>
    return &elem->data.tbl;
 801aa28:	68fb      	ldr	r3, [r7, #12]
}
 801aa2a:	4618      	mov	r0, r3
 801aa2c:	3710      	adds	r7, #16
 801aa2e:	46bd      	mov	sp, r7
 801aa30:	bd80      	pop	{r7, pc}

0801aa32 <nk_free_table>:
NK_LIB void
nk_free_table(struct nk_context *ctx, struct nk_table *tbl)
{
 801aa32:	b580      	push	{r7, lr}
 801aa34:	b084      	sub	sp, #16
 801aa36:	af00      	add	r7, sp, #0
 801aa38:	6078      	str	r0, [r7, #4]
 801aa3a:	6039      	str	r1, [r7, #0]
    union nk_page_data *pd = NK_CONTAINER_OF(tbl, union nk_page_data, tbl);
 801aa3c:	683b      	ldr	r3, [r7, #0]
 801aa3e:	60fb      	str	r3, [r7, #12]
    struct nk_page_element *pe = NK_CONTAINER_OF(pd, struct nk_page_element, data);
 801aa40:	68fb      	ldr	r3, [r7, #12]
 801aa42:	60bb      	str	r3, [r7, #8]
    nk_free_page_element(ctx, pe);
 801aa44:	68b9      	ldr	r1, [r7, #8]
 801aa46:	6878      	ldr	r0, [r7, #4]
 801aa48:	f7f9 fa61 	bl	8013f0e <nk_free_page_element>
}
 801aa4c:	bf00      	nop
 801aa4e:	3710      	adds	r7, #16
 801aa50:	46bd      	mov	sp, r7
 801aa52:	bd80      	pop	{r7, pc}

0801aa54 <nk_push_table>:
NK_LIB void
nk_push_table(struct nk_window *win, struct nk_table *tbl)
{
 801aa54:	b480      	push	{r7}
 801aa56:	b083      	sub	sp, #12
 801aa58:	af00      	add	r7, sp, #0
 801aa5a:	6078      	str	r0, [r7, #4]
 801aa5c:	6039      	str	r1, [r7, #0]
    if (!win->tables) {
 801aa5e:	687b      	ldr	r3, [r7, #4]
 801aa60:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
 801aa64:	2b00      	cmp	r3, #0
 801aa66:	d113      	bne.n	801aa90 <nk_push_table+0x3c>
        win->tables = tbl;
 801aa68:	687b      	ldr	r3, [r7, #4]
 801aa6a:	683a      	ldr	r2, [r7, #0]
 801aa6c:	f8c3 2170 	str.w	r2, [r3, #368]	; 0x170
        tbl->next = 0;
 801aa70:	683b      	ldr	r3, [r7, #0]
 801aa72:	2200      	movs	r2, #0
 801aa74:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
        tbl->prev = 0;
 801aa78:	683b      	ldr	r3, [r7, #0]
 801aa7a:	2200      	movs	r2, #0
 801aa7c:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4
        tbl->size = 0;
 801aa80:	683b      	ldr	r3, [r7, #0]
 801aa82:	2200      	movs	r2, #0
 801aa84:	605a      	str	r2, [r3, #4]
        win->table_count = 1;
 801aa86:	687b      	ldr	r3, [r7, #4]
 801aa88:	2201      	movs	r2, #1
 801aa8a:	f8c3 2174 	str.w	r2, [r3, #372]	; 0x174
        return;
 801aa8e:	e01d      	b.n	801aacc <nk_push_table+0x78>
    }
    win->tables->prev = tbl;
 801aa90:	687b      	ldr	r3, [r7, #4]
 801aa92:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
 801aa96:	683a      	ldr	r2, [r7, #0]
 801aa98:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4
    tbl->next = win->tables;
 801aa9c:	687b      	ldr	r3, [r7, #4]
 801aa9e:	f8d3 2170 	ldr.w	r2, [r3, #368]	; 0x170
 801aaa2:	683b      	ldr	r3, [r7, #0]
 801aaa4:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
    tbl->prev = 0;
 801aaa8:	683b      	ldr	r3, [r7, #0]
 801aaaa:	2200      	movs	r2, #0
 801aaac:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4
    tbl->size = 0;
 801aab0:	683b      	ldr	r3, [r7, #0]
 801aab2:	2200      	movs	r2, #0
 801aab4:	605a      	str	r2, [r3, #4]
    win->tables = tbl;
 801aab6:	687b      	ldr	r3, [r7, #4]
 801aab8:	683a      	ldr	r2, [r7, #0]
 801aaba:	f8c3 2170 	str.w	r2, [r3, #368]	; 0x170
    win->table_count++;
 801aabe:	687b      	ldr	r3, [r7, #4]
 801aac0:	f8d3 3174 	ldr.w	r3, [r3, #372]	; 0x174
 801aac4:	1c5a      	adds	r2, r3, #1
 801aac6:	687b      	ldr	r3, [r7, #4]
 801aac8:	f8c3 2174 	str.w	r2, [r3, #372]	; 0x174
}
 801aacc:	370c      	adds	r7, #12
 801aace:	46bd      	mov	sp, r7
 801aad0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801aad4:	4770      	bx	lr

0801aad6 <nk_remove_table>:
NK_LIB void
nk_remove_table(struct nk_window *win, struct nk_table *tbl)
{
 801aad6:	b480      	push	{r7}
 801aad8:	b083      	sub	sp, #12
 801aada:	af00      	add	r7, sp, #0
 801aadc:	6078      	str	r0, [r7, #4]
 801aade:	6039      	str	r1, [r7, #0]
    if (win->tables == tbl)
 801aae0:	687b      	ldr	r3, [r7, #4]
 801aae2:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
 801aae6:	683a      	ldr	r2, [r7, #0]
 801aae8:	429a      	cmp	r2, r3
 801aaea:	d105      	bne.n	801aaf8 <nk_remove_table+0x22>
        win->tables = tbl->next;
 801aaec:	683b      	ldr	r3, [r7, #0]
 801aaee:	f8d3 21a0 	ldr.w	r2, [r3, #416]	; 0x1a0
 801aaf2:	687b      	ldr	r3, [r7, #4]
 801aaf4:	f8c3 2170 	str.w	r2, [r3, #368]	; 0x170
    if (tbl->next)
 801aaf8:	683b      	ldr	r3, [r7, #0]
 801aafa:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 801aafe:	2b00      	cmp	r3, #0
 801ab00:	d007      	beq.n	801ab12 <nk_remove_table+0x3c>
        tbl->next->prev = tbl->prev;
 801ab02:	683b      	ldr	r3, [r7, #0]
 801ab04:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 801ab08:	683a      	ldr	r2, [r7, #0]
 801ab0a:	f8d2 21a4 	ldr.w	r2, [r2, #420]	; 0x1a4
 801ab0e:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4
    if (tbl->prev)
 801ab12:	683b      	ldr	r3, [r7, #0]
 801ab14:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 801ab18:	2b00      	cmp	r3, #0
 801ab1a:	d007      	beq.n	801ab2c <nk_remove_table+0x56>
        tbl->prev->next = tbl->next;
 801ab1c:	683b      	ldr	r3, [r7, #0]
 801ab1e:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 801ab22:	683a      	ldr	r2, [r7, #0]
 801ab24:	f8d2 21a0 	ldr.w	r2, [r2, #416]	; 0x1a0
 801ab28:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
    tbl->next = 0;
 801ab2c:	683b      	ldr	r3, [r7, #0]
 801ab2e:	2200      	movs	r2, #0
 801ab30:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
    tbl->prev = 0;
 801ab34:	683b      	ldr	r3, [r7, #0]
 801ab36:	2200      	movs	r2, #0
 801ab38:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4
}
 801ab3c:	bf00      	nop
 801ab3e:	370c      	adds	r7, #12
 801ab40:	46bd      	mov	sp, r7
 801ab42:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ab46:	4770      	bx	lr

0801ab48 <nk_add_value>:
NK_LIB nk_uint*
nk_add_value(struct nk_context *ctx, struct nk_window *win,
            nk_hash name, nk_uint value)
{
 801ab48:	b580      	push	{r7, lr}
 801ab4a:	b086      	sub	sp, #24
 801ab4c:	af00      	add	r7, sp, #0
 801ab4e:	60f8      	str	r0, [r7, #12]
 801ab50:	60b9      	str	r1, [r7, #8]
 801ab52:	607a      	str	r2, [r7, #4]
 801ab54:	603b      	str	r3, [r7, #0]
    NK_ASSERT(ctx);
 801ab56:	68fb      	ldr	r3, [r7, #12]
 801ab58:	2b00      	cmp	r3, #0
 801ab5a:	d105      	bne.n	801ab68 <nk_add_value+0x20>
 801ab5c:	4b32      	ldr	r3, [pc, #200]	; (801ac28 <nk_add_value+0xe0>)
 801ab5e:	4a33      	ldr	r2, [pc, #204]	; (801ac2c <nk_add_value+0xe4>)
 801ab60:	213b      	movs	r1, #59	; 0x3b
 801ab62:	4833      	ldr	r0, [pc, #204]	; (801ac30 <nk_add_value+0xe8>)
 801ab64:	f002 ff58 	bl	801da18 <__assert_func>
    NK_ASSERT(win);
 801ab68:	68bb      	ldr	r3, [r7, #8]
 801ab6a:	2b00      	cmp	r3, #0
 801ab6c:	d105      	bne.n	801ab7a <nk_add_value+0x32>
 801ab6e:	4b31      	ldr	r3, [pc, #196]	; (801ac34 <nk_add_value+0xec>)
 801ab70:	4a2e      	ldr	r2, [pc, #184]	; (801ac2c <nk_add_value+0xe4>)
 801ab72:	213c      	movs	r1, #60	; 0x3c
 801ab74:	482e      	ldr	r0, [pc, #184]	; (801ac30 <nk_add_value+0xe8>)
 801ab76:	f002 ff4f 	bl	801da18 <__assert_func>
    if (!win || !ctx) return 0;
 801ab7a:	68bb      	ldr	r3, [r7, #8]
 801ab7c:	2b00      	cmp	r3, #0
 801ab7e:	d002      	beq.n	801ab86 <nk_add_value+0x3e>
 801ab80:	68fb      	ldr	r3, [r7, #12]
 801ab82:	2b00      	cmp	r3, #0
 801ab84:	d101      	bne.n	801ab8a <nk_add_value+0x42>
 801ab86:	2300      	movs	r3, #0
 801ab88:	e04a      	b.n	801ac20 <nk_add_value+0xd8>
    if (!win->tables || win->tables->size >= NK_VALUE_PAGE_CAPACITY) {
 801ab8a:	68bb      	ldr	r3, [r7, #8]
 801ab8c:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
 801ab90:	2b00      	cmp	r3, #0
 801ab92:	d005      	beq.n	801aba0 <nk_add_value+0x58>
 801ab94:	68bb      	ldr	r3, [r7, #8]
 801ab96:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
 801ab9a:	685b      	ldr	r3, [r3, #4]
 801ab9c:	2b32      	cmp	r3, #50	; 0x32
 801ab9e:	d915      	bls.n	801abcc <nk_add_value+0x84>
        struct nk_table *tbl = nk_create_table(ctx);
 801aba0:	68f8      	ldr	r0, [r7, #12]
 801aba2:	f7ff ff2f 	bl	801aa04 <nk_create_table>
 801aba6:	6178      	str	r0, [r7, #20]
        NK_ASSERT(tbl);
 801aba8:	697b      	ldr	r3, [r7, #20]
 801abaa:	2b00      	cmp	r3, #0
 801abac:	d105      	bne.n	801abba <nk_add_value+0x72>
 801abae:	4b22      	ldr	r3, [pc, #136]	; (801ac38 <nk_add_value+0xf0>)
 801abb0:	4a1e      	ldr	r2, [pc, #120]	; (801ac2c <nk_add_value+0xe4>)
 801abb2:	2140      	movs	r1, #64	; 0x40
 801abb4:	481e      	ldr	r0, [pc, #120]	; (801ac30 <nk_add_value+0xe8>)
 801abb6:	f002 ff2f 	bl	801da18 <__assert_func>
        if (!tbl) return 0;
 801abba:	697b      	ldr	r3, [r7, #20]
 801abbc:	2b00      	cmp	r3, #0
 801abbe:	d101      	bne.n	801abc4 <nk_add_value+0x7c>
 801abc0:	2300      	movs	r3, #0
 801abc2:	e02d      	b.n	801ac20 <nk_add_value+0xd8>
        nk_push_table(win, tbl);
 801abc4:	6979      	ldr	r1, [r7, #20]
 801abc6:	68b8      	ldr	r0, [r7, #8]
 801abc8:	f7ff ff44 	bl	801aa54 <nk_push_table>
    }
    win->tables->seq = win->seq;
 801abcc:	68bb      	ldr	r3, [r7, #8]
 801abce:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
 801abd2:	68ba      	ldr	r2, [r7, #8]
 801abd4:	6812      	ldr	r2, [r2, #0]
 801abd6:	601a      	str	r2, [r3, #0]
    win->tables->keys[win->tables->size] = name;
 801abd8:	68bb      	ldr	r3, [r7, #8]
 801abda:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
 801abde:	68ba      	ldr	r2, [r7, #8]
 801abe0:	f8d2 2170 	ldr.w	r2, [r2, #368]	; 0x170
 801abe4:	6852      	ldr	r2, [r2, #4]
 801abe6:	3202      	adds	r2, #2
 801abe8:	6879      	ldr	r1, [r7, #4]
 801abea:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    win->tables->values[win->tables->size] = value;
 801abee:	68bb      	ldr	r3, [r7, #8]
 801abf0:	f8d3 2170 	ldr.w	r2, [r3, #368]	; 0x170
 801abf4:	68bb      	ldr	r3, [r7, #8]
 801abf6:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
 801abfa:	685b      	ldr	r3, [r3, #4]
 801abfc:	3334      	adds	r3, #52	; 0x34
 801abfe:	009b      	lsls	r3, r3, #2
 801ac00:	4413      	add	r3, r2
 801ac02:	683a      	ldr	r2, [r7, #0]
 801ac04:	605a      	str	r2, [r3, #4]
    return &win->tables->values[win->tables->size++];
 801ac06:	68bb      	ldr	r3, [r7, #8]
 801ac08:	f8d3 1170 	ldr.w	r1, [r3, #368]	; 0x170
 801ac0c:	68bb      	ldr	r3, [r7, #8]
 801ac0e:	f8d3 2170 	ldr.w	r2, [r3, #368]	; 0x170
 801ac12:	6853      	ldr	r3, [r2, #4]
 801ac14:	1c58      	adds	r0, r3, #1
 801ac16:	6050      	str	r0, [r2, #4]
 801ac18:	3334      	adds	r3, #52	; 0x34
 801ac1a:	009b      	lsls	r3, r3, #2
 801ac1c:	440b      	add	r3, r1
 801ac1e:	3304      	adds	r3, #4
}
 801ac20:	4618      	mov	r0, r3
 801ac22:	3718      	adds	r7, #24
 801ac24:	46bd      	mov	sp, r7
 801ac26:	bd80      	pop	{r7, pc}
 801ac28:	08021f6c 	.word	0x08021f6c
 801ac2c:	08023710 	.word	0x08023710
 801ac30:	08021f70 	.word	0x08021f70
 801ac34:	08021f8c 	.word	0x08021f8c
 801ac38:	08021f90 	.word	0x08021f90

0801ac3c <nk_find_value>:
NK_LIB nk_uint*
nk_find_value(struct nk_window *win, nk_hash name)
{
 801ac3c:	b480      	push	{r7}
 801ac3e:	b087      	sub	sp, #28
 801ac40:	af00      	add	r7, sp, #0
 801ac42:	6078      	str	r0, [r7, #4]
 801ac44:	6039      	str	r1, [r7, #0]
    struct nk_table *iter = win->tables;
 801ac46:	687b      	ldr	r3, [r7, #4]
 801ac48:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
 801ac4c:	617b      	str	r3, [r7, #20]
    while (iter) {
 801ac4e:	e027      	b.n	801aca0 <nk_find_value+0x64>
        unsigned int i = 0;
 801ac50:	2300      	movs	r3, #0
 801ac52:	613b      	str	r3, [r7, #16]
        unsigned int size = iter->size;
 801ac54:	697b      	ldr	r3, [r7, #20]
 801ac56:	685b      	ldr	r3, [r3, #4]
 801ac58:	60fb      	str	r3, [r7, #12]
        for (i = 0; i < size; ++i) {
 801ac5a:	2300      	movs	r3, #0
 801ac5c:	613b      	str	r3, [r7, #16]
 801ac5e:	e015      	b.n	801ac8c <nk_find_value+0x50>
            if (iter->keys[i] == name) {
 801ac60:	697b      	ldr	r3, [r7, #20]
 801ac62:	693a      	ldr	r2, [r7, #16]
 801ac64:	3202      	adds	r2, #2
 801ac66:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801ac6a:	683a      	ldr	r2, [r7, #0]
 801ac6c:	429a      	cmp	r2, r3
 801ac6e:	d10a      	bne.n	801ac86 <nk_find_value+0x4a>
                iter->seq = win->seq;
 801ac70:	687b      	ldr	r3, [r7, #4]
 801ac72:	681a      	ldr	r2, [r3, #0]
 801ac74:	697b      	ldr	r3, [r7, #20]
 801ac76:	601a      	str	r2, [r3, #0]
                return &iter->values[i];
 801ac78:	693b      	ldr	r3, [r7, #16]
 801ac7a:	3334      	adds	r3, #52	; 0x34
 801ac7c:	009b      	lsls	r3, r3, #2
 801ac7e:	697a      	ldr	r2, [r7, #20]
 801ac80:	4413      	add	r3, r2
 801ac82:	3304      	adds	r3, #4
 801ac84:	e010      	b.n	801aca8 <nk_find_value+0x6c>
        for (i = 0; i < size; ++i) {
 801ac86:	693b      	ldr	r3, [r7, #16]
 801ac88:	3301      	adds	r3, #1
 801ac8a:	613b      	str	r3, [r7, #16]
 801ac8c:	693a      	ldr	r2, [r7, #16]
 801ac8e:	68fb      	ldr	r3, [r7, #12]
 801ac90:	429a      	cmp	r2, r3
 801ac92:	d3e5      	bcc.n	801ac60 <nk_find_value+0x24>
            }
        } size = NK_VALUE_PAGE_CAPACITY;
 801ac94:	2333      	movs	r3, #51	; 0x33
 801ac96:	60fb      	str	r3, [r7, #12]
        iter = iter->next;
 801ac98:	697b      	ldr	r3, [r7, #20]
 801ac9a:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 801ac9e:	617b      	str	r3, [r7, #20]
    while (iter) {
 801aca0:	697b      	ldr	r3, [r7, #20]
 801aca2:	2b00      	cmp	r3, #0
 801aca4:	d1d4      	bne.n	801ac50 <nk_find_value+0x14>
    }
    return 0;
 801aca6:	2300      	movs	r3, #0
}
 801aca8:	4618      	mov	r0, r3
 801acaa:	371c      	adds	r7, #28
 801acac:	46bd      	mov	sp, r7
 801acae:	f85d 7b04 	ldr.w	r7, [sp], #4
 801acb2:	4770      	bx	lr

0801acb4 <nk_widget_text>:
 * ===============================================================*/
NK_LIB void
nk_widget_text(struct nk_command_buffer *o, struct nk_rect b,
    const char *string, int len, const struct nk_text *t,
    nk_flags a, const struct nk_user_font *f)
{
 801acb4:	b580      	push	{r7, lr}
 801acb6:	b090      	sub	sp, #64	; 0x40
 801acb8:	af02      	add	r7, sp, #8
 801acba:	61f8      	str	r0, [r7, #28]
 801acbc:	eeb0 6a40 	vmov.f32	s12, s0
 801acc0:	eef0 6a60 	vmov.f32	s13, s1
 801acc4:	eeb0 7a41 	vmov.f32	s14, s2
 801acc8:	eef0 7a61 	vmov.f32	s15, s3
 801accc:	60b9      	str	r1, [r7, #8]
 801acce:	607a      	str	r2, [r7, #4]
 801acd0:	603b      	str	r3, [r7, #0]
 801acd2:	ed87 6a03 	vstr	s12, [r7, #12]
 801acd6:	edc7 6a04 	vstr	s13, [r7, #16]
 801acda:	ed87 7a05 	vstr	s14, [r7, #20]
 801acde:	edc7 7a06 	vstr	s15, [r7, #24]
    struct nk_rect label;
    float text_width;

    NK_ASSERT(o);
 801ace2:	69fb      	ldr	r3, [r7, #28]
 801ace4:	2b00      	cmp	r3, #0
 801ace6:	d105      	bne.n	801acf4 <nk_widget_text+0x40>
 801ace8:	4bb0      	ldr	r3, [pc, #704]	; (801afac <nk_widget_text+0x2f8>)
 801acea:	4ab1      	ldr	r2, [pc, #708]	; (801afb0 <nk_widget_text+0x2fc>)
 801acec:	2111      	movs	r1, #17
 801acee:	48b1      	ldr	r0, [pc, #708]	; (801afb4 <nk_widget_text+0x300>)
 801acf0:	f002 fe92 	bl	801da18 <__assert_func>
    NK_ASSERT(t);
 801acf4:	683b      	ldr	r3, [r7, #0]
 801acf6:	2b00      	cmp	r3, #0
 801acf8:	d105      	bne.n	801ad06 <nk_widget_text+0x52>
 801acfa:	4baf      	ldr	r3, [pc, #700]	; (801afb8 <nk_widget_text+0x304>)
 801acfc:	4aac      	ldr	r2, [pc, #688]	; (801afb0 <nk_widget_text+0x2fc>)
 801acfe:	2112      	movs	r1, #18
 801ad00:	48ac      	ldr	r0, [pc, #688]	; (801afb4 <nk_widget_text+0x300>)
 801ad02:	f002 fe89 	bl	801da18 <__assert_func>
    if (!o || !t) return;
 801ad06:	69fb      	ldr	r3, [r7, #28]
 801ad08:	2b00      	cmp	r3, #0
 801ad0a:	f000 81f4 	beq.w	801b0f6 <nk_widget_text+0x442>
 801ad0e:	683b      	ldr	r3, [r7, #0]
 801ad10:	2b00      	cmp	r3, #0
 801ad12:	f000 81f0 	beq.w	801b0f6 <nk_widget_text+0x442>

    b.h = NK_MAX(b.h, 2 * t->padding.y);
 801ad16:	ed97 7a06 	vldr	s14, [r7, #24]
 801ad1a:	683b      	ldr	r3, [r7, #0]
 801ad1c:	edd3 7a01 	vldr	s15, [r3, #4]
 801ad20:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801ad24:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801ad28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ad2c:	d505      	bpl.n	801ad3a <nk_widget_text+0x86>
 801ad2e:	683b      	ldr	r3, [r7, #0]
 801ad30:	edd3 7a01 	vldr	s15, [r3, #4]
 801ad34:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801ad38:	e001      	b.n	801ad3e <nk_widget_text+0x8a>
 801ad3a:	edd7 7a06 	vldr	s15, [r7, #24]
 801ad3e:	edc7 7a06 	vstr	s15, [r7, #24]
    label.x = 0; label.w = 0;
 801ad42:	f04f 0300 	mov.w	r3, #0
 801ad46:	627b      	str	r3, [r7, #36]	; 0x24
 801ad48:	f04f 0300 	mov.w	r3, #0
 801ad4c:	62fb      	str	r3, [r7, #44]	; 0x2c
    label.y = b.y + t->padding.y;
 801ad4e:	ed97 7a04 	vldr	s14, [r7, #16]
 801ad52:	683b      	ldr	r3, [r7, #0]
 801ad54:	edd3 7a01 	vldr	s15, [r3, #4]
 801ad58:	ee77 7a27 	vadd.f32	s15, s14, s15
 801ad5c:	edc7 7a0a 	vstr	s15, [r7, #40]	; 0x28
    label.h = NK_MIN(f->height, b.h - 2 * t->padding.y);
 801ad60:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ad62:	ed93 7a01 	vldr	s14, [r3, #4]
 801ad66:	edd7 6a06 	vldr	s13, [r7, #24]
 801ad6a:	683b      	ldr	r3, [r7, #0]
 801ad6c:	edd3 7a01 	vldr	s15, [r3, #4]
 801ad70:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801ad74:	ee76 7ae7 	vsub.f32	s15, s13, s15
 801ad78:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801ad7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ad80:	d503      	bpl.n	801ad8a <nk_widget_text+0xd6>
 801ad82:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ad84:	edd3 7a01 	vldr	s15, [r3, #4]
 801ad88:	e008      	b.n	801ad9c <nk_widget_text+0xe8>
 801ad8a:	ed97 7a06 	vldr	s14, [r7, #24]
 801ad8e:	683b      	ldr	r3, [r7, #0]
 801ad90:	edd3 7a01 	vldr	s15, [r3, #4]
 801ad94:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801ad98:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ad9c:	edc7 7a0c 	vstr	s15, [r7, #48]	; 0x30

    text_width = f->width(f->userdata, f->height, (const char*)string, len);
 801ada0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ada2:	689b      	ldr	r3, [r3, #8]
 801ada4:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801ada6:	edd2 7a01 	vldr	s15, [r2, #4]
 801adaa:	6c78      	ldr	r0, [r7, #68]	; 0x44
 801adac:	687a      	ldr	r2, [r7, #4]
 801adae:	68b9      	ldr	r1, [r7, #8]
 801adb0:	eeb0 0a67 	vmov.f32	s0, s15
 801adb4:	6800      	ldr	r0, [r0, #0]
 801adb6:	4798      	blx	r3
 801adb8:	ed87 0a0d 	vstr	s0, [r7, #52]	; 0x34
    text_width += (2.0f * t->padding.x);
 801adbc:	683b      	ldr	r3, [r7, #0]
 801adbe:	edd3 7a00 	vldr	s15, [r3]
 801adc2:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801adc6:	ed97 7a0d 	vldr	s14, [r7, #52]	; 0x34
 801adca:	ee77 7a27 	vadd.f32	s15, s14, s15
 801adce:	edc7 7a0d 	vstr	s15, [r7, #52]	; 0x34

    /* align in x-axis */
    if (a & NK_TEXT_ALIGN_LEFT) {
 801add2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801add4:	f003 0301 	and.w	r3, r3, #1
 801add8:	2b00      	cmp	r3, #0
 801adda:	d025      	beq.n	801ae28 <nk_widget_text+0x174>
        label.x = b.x + t->padding.x;
 801addc:	ed97 7a03 	vldr	s14, [r7, #12]
 801ade0:	683b      	ldr	r3, [r7, #0]
 801ade2:	edd3 7a00 	vldr	s15, [r3]
 801ade6:	ee77 7a27 	vadd.f32	s15, s14, s15
 801adea:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
        label.w = NK_MAX(0, b.w - 2 * t->padding.x);
 801adee:	ed97 7a05 	vldr	s14, [r7, #20]
 801adf2:	683b      	ldr	r3, [r7, #0]
 801adf4:	edd3 7a00 	vldr	s15, [r3]
 801adf8:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801adfc:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ae00:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801ae04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ae08:	dd09      	ble.n	801ae1e <nk_widget_text+0x16a>
 801ae0a:	ed97 7a05 	vldr	s14, [r7, #20]
 801ae0e:	683b      	ldr	r3, [r7, #0]
 801ae10:	edd3 7a00 	vldr	s15, [r3]
 801ae14:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801ae18:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ae1c:	e001      	b.n	801ae22 <nk_widget_text+0x16e>
 801ae1e:	eddf 7a67 	vldr	s15, [pc, #412]	; 801afbc <nk_widget_text+0x308>
 801ae22:	edc7 7a0b 	vstr	s15, [r7, #44]	; 0x2c
 801ae26:	e0df      	b.n	801afe8 <nk_widget_text+0x334>
    } else if (a & NK_TEXT_ALIGN_CENTERED) {
 801ae28:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801ae2a:	f003 0302 	and.w	r3, r3, #2
 801ae2e:	2b00      	cmp	r3, #0
 801ae30:	f000 8086 	beq.w	801af40 <nk_widget_text+0x28c>
        label.w = NK_MAX(1, 2 * t->padding.x + (float)text_width);
 801ae34:	683b      	ldr	r3, [r7, #0]
 801ae36:	edd3 7a00 	vldr	s15, [r3]
 801ae3a:	ee37 7aa7 	vadd.f32	s14, s15, s15
 801ae3e:	edd7 7a0d 	vldr	s15, [r7, #52]	; 0x34
 801ae42:	ee77 7a27 	vadd.f32	s15, s14, s15
 801ae46:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801ae4a:	eef4 7ac7 	vcmpe.f32	s15, s14
 801ae4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ae52:	dd09      	ble.n	801ae68 <nk_widget_text+0x1b4>
 801ae54:	683b      	ldr	r3, [r7, #0]
 801ae56:	edd3 7a00 	vldr	s15, [r3]
 801ae5a:	ee37 7aa7 	vadd.f32	s14, s15, s15
 801ae5e:	edd7 7a0d 	vldr	s15, [r7, #52]	; 0x34
 801ae62:	ee77 7a27 	vadd.f32	s15, s14, s15
 801ae66:	e001      	b.n	801ae6c <nk_widget_text+0x1b8>
 801ae68:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 801ae6c:	edc7 7a0b 	vstr	s15, [r7, #44]	; 0x2c
        label.x = (b.x + t->padding.x + ((b.w - 2 * t->padding.x) - label.w) / 2);
 801ae70:	ed97 7a03 	vldr	s14, [r7, #12]
 801ae74:	683b      	ldr	r3, [r7, #0]
 801ae76:	edd3 7a00 	vldr	s15, [r3]
 801ae7a:	ee37 7a27 	vadd.f32	s14, s14, s15
 801ae7e:	edd7 6a05 	vldr	s13, [r7, #20]
 801ae82:	683b      	ldr	r3, [r7, #0]
 801ae84:	edd3 7a00 	vldr	s15, [r3]
 801ae88:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801ae8c:	ee76 6ae7 	vsub.f32	s13, s13, s15
 801ae90:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
 801ae94:	ee76 6ae7 	vsub.f32	s13, s13, s15
 801ae98:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 801ae9c:	eec6 7a86 	vdiv.f32	s15, s13, s12
 801aea0:	ee77 7a27 	vadd.f32	s15, s14, s15
 801aea4:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
        label.x = NK_MAX(b.x + t->padding.x, label.x);
 801aea8:	ed97 7a03 	vldr	s14, [r7, #12]
 801aeac:	683b      	ldr	r3, [r7, #0]
 801aeae:	edd3 7a00 	vldr	s15, [r3]
 801aeb2:	ee37 7a27 	vadd.f32	s14, s14, s15
 801aeb6:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 801aeba:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801aebe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801aec2:	d502      	bpl.n	801aeca <nk_widget_text+0x216>
 801aec4:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 801aec8:	e006      	b.n	801aed8 <nk_widget_text+0x224>
 801aeca:	ed97 7a03 	vldr	s14, [r7, #12]
 801aece:	683b      	ldr	r3, [r7, #0]
 801aed0:	edd3 7a00 	vldr	s15, [r3]
 801aed4:	ee77 7a27 	vadd.f32	s15, s14, s15
 801aed8:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
        label.w = NK_MIN(b.x + b.w, label.x + label.w);
 801aedc:	ed97 7a03 	vldr	s14, [r7, #12]
 801aee0:	edd7 7a05 	vldr	s15, [r7, #20]
 801aee4:	ee37 7a27 	vadd.f32	s14, s14, s15
 801aee8:	edd7 6a09 	vldr	s13, [r7, #36]	; 0x24
 801aeec:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
 801aef0:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801aef4:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801aef8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801aefc:	d506      	bpl.n	801af0c <nk_widget_text+0x258>
 801aefe:	ed97 7a03 	vldr	s14, [r7, #12]
 801af02:	edd7 7a05 	vldr	s15, [r7, #20]
 801af06:	ee77 7a27 	vadd.f32	s15, s14, s15
 801af0a:	e005      	b.n	801af18 <nk_widget_text+0x264>
 801af0c:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 801af10:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
 801af14:	ee77 7a27 	vadd.f32	s15, s14, s15
 801af18:	edc7 7a0b 	vstr	s15, [r7, #44]	; 0x2c
        if (label.w >= label.x) label.w -= label.x;
 801af1c:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
 801af20:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 801af24:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801af28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801af2c:	db5c      	blt.n	801afe8 <nk_widget_text+0x334>
 801af2e:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
 801af32:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 801af36:	ee77 7a67 	vsub.f32	s15, s14, s15
 801af3a:	edc7 7a0b 	vstr	s15, [r7, #44]	; 0x2c
 801af3e:	e053      	b.n	801afe8 <nk_widget_text+0x334>
    } else if (a & NK_TEXT_ALIGN_RIGHT) {
 801af40:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801af42:	f003 0304 	and.w	r3, r3, #4
 801af46:	2b00      	cmp	r3, #0
 801af48:	f000 80d7 	beq.w	801b0fa <nk_widget_text+0x446>
        label.x = NK_MAX(b.x + t->padding.x, (b.x + b.w) - (2 * t->padding.x + (float)text_width));
 801af4c:	ed97 7a03 	vldr	s14, [r7, #12]
 801af50:	683b      	ldr	r3, [r7, #0]
 801af52:	edd3 7a00 	vldr	s15, [r3]
 801af56:	ee37 7a27 	vadd.f32	s14, s14, s15
 801af5a:	edd7 6a03 	vldr	s13, [r7, #12]
 801af5e:	edd7 7a05 	vldr	s15, [r7, #20]
 801af62:	ee76 6aa7 	vadd.f32	s13, s13, s15
 801af66:	683b      	ldr	r3, [r7, #0]
 801af68:	edd3 7a00 	vldr	s15, [r3]
 801af6c:	ee37 6aa7 	vadd.f32	s12, s15, s15
 801af70:	edd7 7a0d 	vldr	s15, [r7, #52]	; 0x34
 801af74:	ee76 7a27 	vadd.f32	s15, s12, s15
 801af78:	ee76 7ae7 	vsub.f32	s15, s13, s15
 801af7c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801af80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801af84:	d51c      	bpl.n	801afc0 <nk_widget_text+0x30c>
 801af86:	ed97 7a03 	vldr	s14, [r7, #12]
 801af8a:	edd7 7a05 	vldr	s15, [r7, #20]
 801af8e:	ee37 7a27 	vadd.f32	s14, s14, s15
 801af92:	683b      	ldr	r3, [r7, #0]
 801af94:	edd3 7a00 	vldr	s15, [r3]
 801af98:	ee77 6aa7 	vadd.f32	s13, s15, s15
 801af9c:	edd7 7a0d 	vldr	s15, [r7, #52]	; 0x34
 801afa0:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801afa4:	ee77 7a67 	vsub.f32	s15, s14, s15
 801afa8:	e011      	b.n	801afce <nk_widget_text+0x31a>
 801afaa:	bf00      	nop
 801afac:	08021f94 	.word	0x08021f94
 801afb0:	08023720 	.word	0x08023720
 801afb4:	08021f98 	.word	0x08021f98
 801afb8:	08021fb4 	.word	0x08021fb4
 801afbc:	00000000 	.word	0x00000000
 801afc0:	ed97 7a03 	vldr	s14, [r7, #12]
 801afc4:	683b      	ldr	r3, [r7, #0]
 801afc6:	edd3 7a00 	vldr	s15, [r3]
 801afca:	ee77 7a27 	vadd.f32	s15, s14, s15
 801afce:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
        label.w = (float)text_width + 2 * t->padding.x;
 801afd2:	683b      	ldr	r3, [r7, #0]
 801afd4:	edd3 7a00 	vldr	s15, [r3]
 801afd8:	ee37 7aa7 	vadd.f32	s14, s15, s15
 801afdc:	edd7 7a0d 	vldr	s15, [r7, #52]	; 0x34
 801afe0:	ee77 7a27 	vadd.f32	s15, s14, s15
 801afe4:	edc7 7a0b 	vstr	s15, [r7, #44]	; 0x2c
    } else return;

    /* align in y-axis */
    if (a & NK_TEXT_ALIGN_MIDDLE) {
 801afe8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801afea:	f003 0310 	and.w	r3, r3, #16
 801afee:	2b00      	cmp	r3, #0
 801aff0:	d04f      	beq.n	801b092 <nk_widget_text+0x3de>
        label.y = b.y + b.h/2.0f - (float)f->height/2.0f;
 801aff2:	ed97 7a04 	vldr	s14, [r7, #16]
 801aff6:	edd7 6a06 	vldr	s13, [r7, #24]
 801affa:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 801affe:	eec6 7a86 	vdiv.f32	s15, s13, s12
 801b002:	ee37 7a27 	vadd.f32	s14, s14, s15
 801b006:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b008:	edd3 6a01 	vldr	s13, [r3, #4]
 801b00c:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 801b010:	eec6 7a86 	vdiv.f32	s15, s13, s12
 801b014:	ee77 7a67 	vsub.f32	s15, s14, s15
 801b018:	edc7 7a0a 	vstr	s15, [r7, #40]	; 0x28
        label.h = NK_MAX(b.h/2.0f, b.h - (b.h/2.0f + f->height/2.0f));
 801b01c:	edd7 7a06 	vldr	s15, [r7, #24]
 801b020:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
 801b024:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 801b028:	edd7 6a06 	vldr	s13, [r7, #24]
 801b02c:	edd7 7a06 	vldr	s15, [r7, #24]
 801b030:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
 801b034:	ee87 6aa5 	vdiv.f32	s12, s15, s11
 801b038:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b03a:	edd3 5a01 	vldr	s11, [r3, #4]
 801b03e:	eeb0 5a00 	vmov.f32	s10, #0	; 0x40000000  2.0
 801b042:	eec5 7a85 	vdiv.f32	s15, s11, s10
 801b046:	ee76 7a27 	vadd.f32	s15, s12, s15
 801b04a:	ee76 7ae7 	vsub.f32	s15, s13, s15
 801b04e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801b052:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b056:	d513      	bpl.n	801b080 <nk_widget_text+0x3cc>
 801b058:	ed97 7a06 	vldr	s14, [r7, #24]
 801b05c:	edd7 7a06 	vldr	s15, [r7, #24]
 801b060:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 801b064:	eec7 6a86 	vdiv.f32	s13, s15, s12
 801b068:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b06a:	ed93 6a01 	vldr	s12, [r3, #4]
 801b06e:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
 801b072:	eec6 7a25 	vdiv.f32	s15, s12, s11
 801b076:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801b07a:	ee77 7a67 	vsub.f32	s15, s14, s15
 801b07e:	e005      	b.n	801b08c <nk_widget_text+0x3d8>
 801b080:	ed97 7a06 	vldr	s14, [r7, #24]
 801b084:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
 801b088:	eec7 7a26 	vdiv.f32	s15, s14, s13
 801b08c:	edc7 7a0c 	vstr	s15, [r7, #48]	; 0x30
 801b090:	e014      	b.n	801b0bc <nk_widget_text+0x408>
    } else if (a & NK_TEXT_ALIGN_BOTTOM) {
 801b092:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b094:	f003 0320 	and.w	r3, r3, #32
 801b098:	2b00      	cmp	r3, #0
 801b09a:	d00f      	beq.n	801b0bc <nk_widget_text+0x408>
        label.y = b.y + b.h - f->height;
 801b09c:	ed97 7a04 	vldr	s14, [r7, #16]
 801b0a0:	edd7 7a06 	vldr	s15, [r7, #24]
 801b0a4:	ee37 7a27 	vadd.f32	s14, s14, s15
 801b0a8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b0aa:	edd3 7a01 	vldr	s15, [r3, #4]
 801b0ae:	ee77 7a67 	vsub.f32	s15, s14, s15
 801b0b2:	edc7 7a0a 	vstr	s15, [r7, #40]	; 0x28
        label.h = f->height;
 801b0b6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b0b8:	685b      	ldr	r3, [r3, #4]
 801b0ba:	633b      	str	r3, [r7, #48]	; 0x30
    }
    nk_draw_text(o, label, (const char*)string, len, f, t->background, t->text);
 801b0bc:	ed97 6a09 	vldr	s12, [r7, #36]	; 0x24
 801b0c0:	edd7 6a0a 	vldr	s13, [r7, #40]	; 0x28
 801b0c4:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
 801b0c8:	edd7 7a0c 	vldr	s15, [r7, #48]	; 0x30
 801b0cc:	683b      	ldr	r3, [r7, #0]
 801b0ce:	68db      	ldr	r3, [r3, #12]
 801b0d0:	9301      	str	r3, [sp, #4]
 801b0d2:	683b      	ldr	r3, [r7, #0]
 801b0d4:	689b      	ldr	r3, [r3, #8]
 801b0d6:	9300      	str	r3, [sp, #0]
 801b0d8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b0da:	687a      	ldr	r2, [r7, #4]
 801b0dc:	68b9      	ldr	r1, [r7, #8]
 801b0de:	eeb0 0a46 	vmov.f32	s0, s12
 801b0e2:	eef0 0a66 	vmov.f32	s1, s13
 801b0e6:	eeb0 1a47 	vmov.f32	s2, s14
 801b0ea:	eef0 1a67 	vmov.f32	s3, s15
 801b0ee:	69f8      	ldr	r0, [r7, #28]
 801b0f0:	f7f6 fe4a 	bl	8011d88 <nk_draw_text>
 801b0f4:	e002      	b.n	801b0fc <nk_widget_text+0x448>
    if (!o || !t) return;
 801b0f6:	bf00      	nop
 801b0f8:	e000      	b.n	801b0fc <nk_widget_text+0x448>
    } else return;
 801b0fa:	bf00      	nop
}
 801b0fc:	3738      	adds	r7, #56	; 0x38
 801b0fe:	46bd      	mov	sp, r7
 801b100:	bd80      	pop	{r7, pc}
 801b102:	bf00      	nop

0801b104 <nk_text_colored>:
    }
}
NK_API void
nk_text_colored(struct nk_context *ctx, const char *str, int len,
    nk_flags alignment, struct nk_color color)
{
 801b104:	b580      	push	{r7, lr}
 801b106:	b092      	sub	sp, #72	; 0x48
 801b108:	af02      	add	r7, sp, #8
 801b10a:	60f8      	str	r0, [r7, #12]
 801b10c:	60b9      	str	r1, [r7, #8]
 801b10e:	607a      	str	r2, [r7, #4]
 801b110:	603b      	str	r3, [r7, #0]

    struct nk_vec2 item_padding;
    struct nk_rect bounds;
    struct nk_text text;

    NK_ASSERT(ctx);
 801b112:	68fb      	ldr	r3, [r7, #12]
 801b114:	2b00      	cmp	r3, #0
 801b116:	d105      	bne.n	801b124 <nk_text_colored+0x20>
 801b118:	4b3e      	ldr	r3, [pc, #248]	; (801b214 <nk_text_colored+0x110>)
 801b11a:	4a3f      	ldr	r2, [pc, #252]	; (801b218 <nk_text_colored+0x114>)
 801b11c:	2168      	movs	r1, #104	; 0x68
 801b11e:	483f      	ldr	r0, [pc, #252]	; (801b21c <nk_text_colored+0x118>)
 801b120:	f002 fc7a 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 801b124:	68fb      	ldr	r3, [r7, #12]
 801b126:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801b12a:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801b12e:	2b00      	cmp	r3, #0
 801b130:	d105      	bne.n	801b13e <nk_text_colored+0x3a>
 801b132:	4b3b      	ldr	r3, [pc, #236]	; (801b220 <nk_text_colored+0x11c>)
 801b134:	4a38      	ldr	r2, [pc, #224]	; (801b218 <nk_text_colored+0x114>)
 801b136:	2169      	movs	r1, #105	; 0x69
 801b138:	4838      	ldr	r0, [pc, #224]	; (801b21c <nk_text_colored+0x118>)
 801b13a:	f002 fc6d 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 801b13e:	68fb      	ldr	r3, [r7, #12]
 801b140:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801b144:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801b148:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801b14c:	2b00      	cmp	r3, #0
 801b14e:	d105      	bne.n	801b15c <nk_text_colored+0x58>
 801b150:	4b34      	ldr	r3, [pc, #208]	; (801b224 <nk_text_colored+0x120>)
 801b152:	4a31      	ldr	r2, [pc, #196]	; (801b218 <nk_text_colored+0x114>)
 801b154:	216a      	movs	r1, #106	; 0x6a
 801b156:	4831      	ldr	r0, [pc, #196]	; (801b21c <nk_text_colored+0x118>)
 801b158:	f002 fc5e 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout) return;
 801b15c:	68fb      	ldr	r3, [r7, #12]
 801b15e:	2b00      	cmp	r3, #0
 801b160:	d053      	beq.n	801b20a <nk_text_colored+0x106>
 801b162:	68fb      	ldr	r3, [r7, #12]
 801b164:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801b168:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801b16c:	2b00      	cmp	r3, #0
 801b16e:	d04c      	beq.n	801b20a <nk_text_colored+0x106>
 801b170:	68fb      	ldr	r3, [r7, #12]
 801b172:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801b176:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801b17a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801b17e:	2b00      	cmp	r3, #0
 801b180:	d043      	beq.n	801b20a <nk_text_colored+0x106>

    win = ctx->current;
 801b182:	68fb      	ldr	r3, [r7, #12]
 801b184:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801b188:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801b18c:	63fb      	str	r3, [r7, #60]	; 0x3c
    style = &ctx->style;
 801b18e:	68fb      	ldr	r3, [r7, #12]
 801b190:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 801b194:	63bb      	str	r3, [r7, #56]	; 0x38
    nk_panel_alloc_space(&bounds, ctx);
 801b196:	f107 0320 	add.w	r3, r7, #32
 801b19a:	68f9      	ldr	r1, [r7, #12]
 801b19c:	4618      	mov	r0, r3
 801b19e:	f7f8 fa41 	bl	8013624 <nk_panel_alloc_space>
    item_padding = style->text.padding;
 801b1a2:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801b1a4:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801b1a8:	3230      	adds	r2, #48	; 0x30
 801b1aa:	e892 0003 	ldmia.w	r2, {r0, r1}
 801b1ae:	e883 0003 	stmia.w	r3, {r0, r1}

    text.padding.x = item_padding.x;
 801b1b2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b1b4:	613b      	str	r3, [r7, #16]
    text.padding.y = item_padding.y;
 801b1b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b1b8:	617b      	str	r3, [r7, #20]
    text.background = style->window.background;
 801b1ba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b1bc:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801b1c0:	f8d3 3874 	ldr.w	r3, [r3, #2164]	; 0x874
 801b1c4:	61bb      	str	r3, [r7, #24]
    text.text = color;
 801b1c6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801b1c8:	61fb      	str	r3, [r7, #28]
    nk_widget_text(&win->buffer, bounds, str, len, &text, alignment, style->font);
 801b1ca:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b1cc:	f103 0064 	add.w	r0, r3, #100	; 0x64
 801b1d0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b1d2:	681b      	ldr	r3, [r3, #0]
 801b1d4:	f107 0210 	add.w	r2, r7, #16
 801b1d8:	ed97 6a08 	vldr	s12, [r7, #32]
 801b1dc:	edd7 6a09 	vldr	s13, [r7, #36]	; 0x24
 801b1e0:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
 801b1e4:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
 801b1e8:	9301      	str	r3, [sp, #4]
 801b1ea:	683b      	ldr	r3, [r7, #0]
 801b1ec:	9300      	str	r3, [sp, #0]
 801b1ee:	4613      	mov	r3, r2
 801b1f0:	687a      	ldr	r2, [r7, #4]
 801b1f2:	68b9      	ldr	r1, [r7, #8]
 801b1f4:	eeb0 0a46 	vmov.f32	s0, s12
 801b1f8:	eef0 0a66 	vmov.f32	s1, s13
 801b1fc:	eeb0 1a47 	vmov.f32	s2, s14
 801b200:	eef0 1a67 	vmov.f32	s3, s15
 801b204:	f7ff fd56 	bl	801acb4 <nk_widget_text>
 801b208:	e000      	b.n	801b20c <nk_text_colored+0x108>
    if (!ctx || !ctx->current || !ctx->current->layout) return;
 801b20a:	bf00      	nop
}
 801b20c:	3740      	adds	r7, #64	; 0x40
 801b20e:	46bd      	mov	sp, r7
 801b210:	bd80      	pop	{r7, pc}
 801b212:	bf00      	nop
 801b214:	08021fb8 	.word	0x08021fb8
 801b218:	08023730 	.word	0x08023730
 801b21c:	08021f98 	.word	0x08021f98
 801b220:	08021fbc 	.word	0x08021fbc
 801b224:	08021fcc 	.word	0x08021fcc

0801b228 <nk_text>:
    nk_labelf(ctx, NK_TEXT_LEFT, "%s: %s", prefix, hex);
}
#endif
NK_API void
nk_text(struct nk_context *ctx, const char *str, int len, nk_flags alignment)
{
 801b228:	b580      	push	{r7, lr}
 801b22a:	b086      	sub	sp, #24
 801b22c:	af02      	add	r7, sp, #8
 801b22e:	60f8      	str	r0, [r7, #12]
 801b230:	60b9      	str	r1, [r7, #8]
 801b232:	607a      	str	r2, [r7, #4]
 801b234:	603b      	str	r3, [r7, #0]
    NK_ASSERT(ctx);
 801b236:	68fb      	ldr	r3, [r7, #12]
 801b238:	2b00      	cmp	r3, #0
 801b23a:	d106      	bne.n	801b24a <nk_text+0x22>
 801b23c:	4b0c      	ldr	r3, [pc, #48]	; (801b270 <nk_text+0x48>)
 801b23e:	4a0d      	ldr	r2, [pc, #52]	; (801b274 <nk_text+0x4c>)
 801b240:	f44f 7182 	mov.w	r1, #260	; 0x104
 801b244:	480c      	ldr	r0, [pc, #48]	; (801b278 <nk_text+0x50>)
 801b246:	f002 fbe7 	bl	801da18 <__assert_func>
    if (!ctx) return;
 801b24a:	68fb      	ldr	r3, [r7, #12]
 801b24c:	2b00      	cmp	r3, #0
 801b24e:	d00a      	beq.n	801b266 <nk_text+0x3e>
    nk_text_colored(ctx, str, len, alignment, ctx->style.text.color);
 801b250:	68fb      	ldr	r3, [r7, #12]
 801b252:	f8d3 3194 	ldr.w	r3, [r3, #404]	; 0x194
 801b256:	9300      	str	r3, [sp, #0]
 801b258:	683b      	ldr	r3, [r7, #0]
 801b25a:	687a      	ldr	r2, [r7, #4]
 801b25c:	68b9      	ldr	r1, [r7, #8]
 801b25e:	68f8      	ldr	r0, [r7, #12]
 801b260:	f7ff ff50 	bl	801b104 <nk_text_colored>
 801b264:	e000      	b.n	801b268 <nk_text+0x40>
    if (!ctx) return;
 801b266:	bf00      	nop
}
 801b268:	3710      	adds	r7, #16
 801b26a:	46bd      	mov	sp, r7
 801b26c:	bd80      	pop	{r7, pc}
 801b26e:	bf00      	nop
 801b270:	08021fb8 	.word	0x08021fb8
 801b274:	08023740 	.word	0x08023740
 801b278:	08021f98 	.word	0x08021f98

0801b27c <nk_label>:
    if (!ctx) return;
    nk_text_wrap_colored(ctx, str, len, ctx->style.text.color);
}
NK_API void
nk_label(struct nk_context *ctx, const char *str, nk_flags alignment)
{
 801b27c:	b580      	push	{r7, lr}
 801b27e:	b084      	sub	sp, #16
 801b280:	af00      	add	r7, sp, #0
 801b282:	60f8      	str	r0, [r7, #12]
 801b284:	60b9      	str	r1, [r7, #8]
 801b286:	607a      	str	r2, [r7, #4]
    nk_text(ctx, str, nk_strlen(str), alignment);
 801b288:	68b8      	ldr	r0, [r7, #8]
 801b28a:	f000 feeb 	bl	801c064 <nk_strlen>
 801b28e:	4602      	mov	r2, r0
 801b290:	687b      	ldr	r3, [r7, #4]
 801b292:	68b9      	ldr	r1, [r7, #8]
 801b294:	68f8      	ldr	r0, [r7, #12]
 801b296:	f7ff ffc7 	bl	801b228 <nk_text>
}
 801b29a:	bf00      	nop
 801b29c:	3710      	adds	r7, #16
 801b29e:	46bd      	mov	sp, r7
 801b2a0:	bd80      	pop	{r7, pc}
	...

0801b2a4 <nk_tree_state_base>:
 *
 * ===============================================================*/
NK_INTERN int
nk_tree_state_base(struct nk_context *ctx, enum nk_tree_type type,
    struct nk_image *img, const char *title, enum nk_collapse_states *state)
{
 801b2a4:	b580      	push	{r7, lr}
 801b2a6:	b0aa      	sub	sp, #168	; 0xa8
 801b2a8:	af04      	add	r7, sp, #16
 801b2aa:	60f8      	str	r0, [r7, #12]
 801b2ac:	607a      	str	r2, [r7, #4]
 801b2ae:	603b      	str	r3, [r7, #0]
 801b2b0:	460b      	mov	r3, r1
 801b2b2:	72fb      	strb	r3, [r7, #11]
    const struct nk_style_button *button;
    enum nk_symbol_type symbol;
    float row_height;

    struct nk_vec2 item_spacing;
    struct nk_rect header = {0,0,0,0};
 801b2b4:	f107 0348 	add.w	r3, r7, #72	; 0x48
 801b2b8:	2200      	movs	r2, #0
 801b2ba:	601a      	str	r2, [r3, #0]
 801b2bc:	605a      	str	r2, [r3, #4]
 801b2be:	609a      	str	r2, [r3, #8]
 801b2c0:	60da      	str	r2, [r3, #12]
    struct nk_rect sym = {0,0,0,0};
 801b2c2:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801b2c6:	2200      	movs	r2, #0
 801b2c8:	601a      	str	r2, [r3, #0]
 801b2ca:	605a      	str	r2, [r3, #4]
 801b2cc:	609a      	str	r2, [r3, #8]
 801b2ce:	60da      	str	r2, [r3, #12]
    struct nk_text text;

    nk_flags ws = 0;
 801b2d0:	2300      	movs	r3, #0
 801b2d2:	627b      	str	r3, [r7, #36]	; 0x24
    enum nk_widget_layout_states widget_state;

    NK_ASSERT(ctx);
 801b2d4:	68fb      	ldr	r3, [r7, #12]
 801b2d6:	2b00      	cmp	r3, #0
 801b2d8:	d105      	bne.n	801b2e6 <nk_tree_state_base+0x42>
 801b2da:	4bcd      	ldr	r3, [pc, #820]	; (801b610 <nk_tree_state_base+0x36c>)
 801b2dc:	4acd      	ldr	r2, [pc, #820]	; (801b614 <nk_tree_state_base+0x370>)
 801b2de:	211e      	movs	r1, #30
 801b2e0:	48cd      	ldr	r0, [pc, #820]	; (801b618 <nk_tree_state_base+0x374>)
 801b2e2:	f002 fb99 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 801b2e6:	68fb      	ldr	r3, [r7, #12]
 801b2e8:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801b2ec:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801b2f0:	2b00      	cmp	r3, #0
 801b2f2:	d105      	bne.n	801b300 <nk_tree_state_base+0x5c>
 801b2f4:	4bc9      	ldr	r3, [pc, #804]	; (801b61c <nk_tree_state_base+0x378>)
 801b2f6:	4ac7      	ldr	r2, [pc, #796]	; (801b614 <nk_tree_state_base+0x370>)
 801b2f8:	211f      	movs	r1, #31
 801b2fa:	48c7      	ldr	r0, [pc, #796]	; (801b618 <nk_tree_state_base+0x374>)
 801b2fc:	f002 fb8c 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 801b300:	68fb      	ldr	r3, [r7, #12]
 801b302:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801b306:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801b30a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801b30e:	2b00      	cmp	r3, #0
 801b310:	d105      	bne.n	801b31e <nk_tree_state_base+0x7a>
 801b312:	4bc3      	ldr	r3, [pc, #780]	; (801b620 <nk_tree_state_base+0x37c>)
 801b314:	4abf      	ldr	r2, [pc, #764]	; (801b614 <nk_tree_state_base+0x370>)
 801b316:	2120      	movs	r1, #32
 801b318:	48bf      	ldr	r0, [pc, #764]	; (801b618 <nk_tree_state_base+0x374>)
 801b31a:	f002 fb7d 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout)
 801b31e:	68fb      	ldr	r3, [r7, #12]
 801b320:	2b00      	cmp	r3, #0
 801b322:	d00f      	beq.n	801b344 <nk_tree_state_base+0xa0>
 801b324:	68fb      	ldr	r3, [r7, #12]
 801b326:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801b32a:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801b32e:	2b00      	cmp	r3, #0
 801b330:	d008      	beq.n	801b344 <nk_tree_state_base+0xa0>
 801b332:	68fb      	ldr	r3, [r7, #12]
 801b334:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801b338:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801b33c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801b340:	2b00      	cmp	r3, #0
 801b342:	d101      	bne.n	801b348 <nk_tree_state_base+0xa4>
        return 0;
 801b344:	2300      	movs	r3, #0
 801b346:	e2ee      	b.n	801b926 <nk_tree_state_base+0x682>

    /* cache some data */
    win = ctx->current;
 801b348:	68fb      	ldr	r3, [r7, #12]
 801b34a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801b34e:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801b352:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
    layout = win->layout;
 801b356:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 801b35a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801b35e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
    out = &win->buffer;
 801b362:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 801b366:	3364      	adds	r3, #100	; 0x64
 801b368:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
    style = &ctx->style;
 801b36c:	68fb      	ldr	r3, [r7, #12]
 801b36e:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 801b372:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
    item_spacing = style->window.spacing;
 801b376:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b37a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801b37e:	461a      	mov	r2, r3
 801b380:	f107 0358 	add.w	r3, r7, #88	; 0x58
 801b384:	f602 02d4 	addw	r2, r2, #2260	; 0x8d4
 801b388:	e892 0003 	ldmia.w	r2, {r0, r1}
 801b38c:	e883 0003 	stmia.w	r3, {r0, r1}

    /* calculate header bounds and draw background */
    row_height = style->font->height + 2 * style->tab.padding.y;
 801b390:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b394:	681b      	ldr	r3, [r3, #0]
 801b396:	ed93 7a01 	vldr	s14, [r3, #4]
 801b39a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b39e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801b3a2:	f203 5374 	addw	r3, r3, #1396	; 0x574
 801b3a6:	edd3 7a00 	vldr	s15, [r3]
 801b3aa:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801b3ae:	ee77 7a27 	vadd.f32	s15, s14, s15
 801b3b2:	edc7 7a1f 	vstr	s15, [r7, #124]	; 0x7c
    nk_layout_set_min_row_height(ctx, row_height);
 801b3b6:	ed97 0a1f 	vldr	s0, [r7, #124]	; 0x7c
 801b3ba:	68f8      	ldr	r0, [r7, #12]
 801b3bc:	f7f7 f9b8 	bl	8012730 <nk_layout_set_min_row_height>
    nk_layout_row_dynamic(ctx, row_height, 1);
 801b3c0:	2101      	movs	r1, #1
 801b3c2:	ed97 0a1f 	vldr	s0, [r7, #124]	; 0x7c
 801b3c6:	68f8      	ldr	r0, [r7, #12]
 801b3c8:	f7f7 fc5c 	bl	8012c84 <nk_layout_row_dynamic>
    nk_layout_reset_min_row_height(ctx);
 801b3cc:	68f8      	ldr	r0, [r7, #12]
 801b3ce:	f7f7 fa09 	bl	80127e4 <nk_layout_reset_min_row_height>

    widget_state = nk_widget(&header, ctx);
 801b3d2:	f107 0348 	add.w	r3, r7, #72	; 0x48
 801b3d6:	68f9      	ldr	r1, [r7, #12]
 801b3d8:	4618      	mov	r0, r3
 801b3da:	f001 f835 	bl	801c448 <nk_widget>
 801b3de:	4603      	mov	r3, r0
 801b3e0:	f887 307b 	strb.w	r3, [r7, #123]	; 0x7b
    if (type == NK_TREE_TAB) {
 801b3e4:	7afb      	ldrb	r3, [r7, #11]
 801b3e6:	2b01      	cmp	r3, #1
 801b3e8:	f040 80af 	bne.w	801b54a <nk_tree_state_base+0x2a6>
        const struct nk_style_item *background = &style->tab.background;
 801b3ec:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b3f0:	f503 5396 	add.w	r3, r3, #4800	; 0x12c0
 801b3f4:	331c      	adds	r3, #28
 801b3f6:	677b      	str	r3, [r7, #116]	; 0x74

        switch(background->type) {
 801b3f8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801b3fa:	781b      	ldrb	r3, [r3, #0]
 801b3fc:	2b02      	cmp	r3, #2
 801b3fe:	d021      	beq.n	801b444 <nk_tree_state_base+0x1a0>
 801b400:	2b02      	cmp	r3, #2
 801b402:	f300 80a9 	bgt.w	801b558 <nk_tree_state_base+0x2b4>
 801b406:	2b00      	cmp	r3, #0
 801b408:	d036      	beq.n	801b478 <nk_tree_state_base+0x1d4>
 801b40a:	2b01      	cmp	r3, #1
 801b40c:	f040 80a4 	bne.w	801b558 <nk_tree_state_base+0x2b4>
            case NK_STYLE_ITEM_IMAGE:
                nk_draw_image(out, header, &background->data.image, nk_white);
 801b410:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801b412:	3304      	adds	r3, #4
 801b414:	4a83      	ldr	r2, [pc, #524]	; (801b624 <nk_tree_state_base+0x380>)
 801b416:	ed97 6a12 	vldr	s12, [r7, #72]	; 0x48
 801b41a:	edd7 6a13 	vldr	s13, [r7, #76]	; 0x4c
 801b41e:	ed97 7a14 	vldr	s14, [r7, #80]	; 0x50
 801b422:	edd7 7a15 	vldr	s15, [r7, #84]	; 0x54
 801b426:	6812      	ldr	r2, [r2, #0]
 801b428:	4619      	mov	r1, r3
 801b42a:	eeb0 0a46 	vmov.f32	s0, s12
 801b42e:	eef0 0a66 	vmov.f32	s1, s13
 801b432:	eeb0 1a47 	vmov.f32	s2, s14
 801b436:	eef0 1a67 	vmov.f32	s3, s15
 801b43a:	f8d7 0084 	ldr.w	r0, [r7, #132]	; 0x84
 801b43e:	f7f5 ff87 	bl	8011350 <nk_draw_image>
                break;
 801b442:	e089      	b.n	801b558 <nk_tree_state_base+0x2b4>
            case NK_STYLE_ITEM_NINE_SLICE:
                nk_draw_nine_slice(out, header, &background->data.slice, nk_white);
 801b444:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801b446:	3304      	adds	r3, #4
 801b448:	4a76      	ldr	r2, [pc, #472]	; (801b624 <nk_tree_state_base+0x380>)
 801b44a:	ed97 6a12 	vldr	s12, [r7, #72]	; 0x48
 801b44e:	edd7 6a13 	vldr	s13, [r7, #76]	; 0x4c
 801b452:	ed97 7a14 	vldr	s14, [r7, #80]	; 0x50
 801b456:	edd7 7a15 	vldr	s15, [r7, #84]	; 0x54
 801b45a:	6812      	ldr	r2, [r2, #0]
 801b45c:	4619      	mov	r1, r3
 801b45e:	eeb0 0a46 	vmov.f32	s0, s12
 801b462:	eef0 0a66 	vmov.f32	s1, s13
 801b466:	eeb0 1a47 	vmov.f32	s2, s14
 801b46a:	eef0 1a67 	vmov.f32	s3, s15
 801b46e:	f8d7 0084 	ldr.w	r0, [r7, #132]	; 0x84
 801b472:	f7f6 f85f 	bl	8011534 <nk_draw_nine_slice>
                break;
 801b476:	e06f      	b.n	801b558 <nk_tree_state_base+0x2b4>
            case NK_STYLE_ITEM_COLOR:
                nk_fill_rect(out, header, 0, style->tab.border_color);
 801b478:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b47c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801b480:	ed97 6a12 	vldr	s12, [r7, #72]	; 0x48
 801b484:	edd7 6a13 	vldr	s13, [r7, #76]	; 0x4c
 801b488:	ed97 7a14 	vldr	s14, [r7, #80]	; 0x50
 801b48c:	edd7 7a15 	vldr	s15, [r7, #84]	; 0x54
 801b490:	f8d3 12f8 	ldr.w	r1, [r3, #760]	; 0x2f8
 801b494:	ed9f 2a64 	vldr	s4, [pc, #400]	; 801b628 <nk_tree_state_base+0x384>
 801b498:	eeb0 0a46 	vmov.f32	s0, s12
 801b49c:	eef0 0a66 	vmov.f32	s1, s13
 801b4a0:	eeb0 1a47 	vmov.f32	s2, s14
 801b4a4:	eef0 1a67 	vmov.f32	s3, s15
 801b4a8:	f8d7 0084 	ldr.w	r0, [r7, #132]	; 0x84
 801b4ac:	f7f5 fbf6 	bl	8010c9c <nk_fill_rect>
                nk_fill_rect(out, nk_shrink_rect(header, style->tab.border),
 801b4b0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b4b4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801b4b8:	f203 5364 	addw	r3, r3, #1380	; 0x564
 801b4bc:	edd3 5a00 	vldr	s11, [r3]
 801b4c0:	ed97 6a12 	vldr	s12, [r7, #72]	; 0x48
 801b4c4:	edd7 6a13 	vldr	s13, [r7, #76]	; 0x4c
 801b4c8:	ed97 7a14 	vldr	s14, [r7, #80]	; 0x50
 801b4cc:	edd7 7a15 	vldr	s15, [r7, #84]	; 0x54
 801b4d0:	eeb0 2a65 	vmov.f32	s4, s11
 801b4d4:	eeb0 0a46 	vmov.f32	s0, s12
 801b4d8:	eef0 0a66 	vmov.f32	s1, s13
 801b4dc:	eeb0 1a47 	vmov.f32	s2, s14
 801b4e0:	eef0 1a67 	vmov.f32	s3, s15
 801b4e4:	f7f8 f968 	bl	80137b8 <nk_shrink_rect>
 801b4e8:	eeb0 6a40 	vmov.f32	s12, s0
 801b4ec:	eef0 6a60 	vmov.f32	s13, s1
 801b4f0:	eeb0 7a41 	vmov.f32	s14, s2
 801b4f4:	eef0 7a61 	vmov.f32	s15, s3
 801b4f8:	ed87 6a18 	vstr	s12, [r7, #96]	; 0x60
 801b4fc:	edc7 6a19 	vstr	s13, [r7, #100]	; 0x64
 801b500:	ed87 7a1a 	vstr	s14, [r7, #104]	; 0x68
 801b504:	edc7 7a1b 	vstr	s15, [r7, #108]	; 0x6c
                    style->tab.rounding, background->data.color);
 801b508:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b50c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801b510:	f503 63ad 	add.w	r3, r3, #1384	; 0x568
 801b514:	edd3 5a00 	vldr	s11, [r3]
                nk_fill_rect(out, nk_shrink_rect(header, style->tab.border),
 801b518:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801b51a:	ed97 6a18 	vldr	s12, [r7, #96]	; 0x60
 801b51e:	edd7 6a19 	vldr	s13, [r7, #100]	; 0x64
 801b522:	ed97 7a1a 	vldr	s14, [r7, #104]	; 0x68
 801b526:	edd7 7a1b 	vldr	s15, [r7, #108]	; 0x6c
 801b52a:	6859      	ldr	r1, [r3, #4]
 801b52c:	eeb0 2a65 	vmov.f32	s4, s11
 801b530:	eeb0 0a46 	vmov.f32	s0, s12
 801b534:	eef0 0a66 	vmov.f32	s1, s13
 801b538:	eeb0 1a47 	vmov.f32	s2, s14
 801b53c:	eef0 1a67 	vmov.f32	s3, s15
 801b540:	f8d7 0084 	ldr.w	r0, [r7, #132]	; 0x84
 801b544:	f7f5 fbaa 	bl	8010c9c <nk_fill_rect>
                break;
 801b548:	e006      	b.n	801b558 <nk_tree_state_base+0x2b4>
        }
    } else text.background = style->window.background;
 801b54a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b54e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801b552:	f8d3 3874 	ldr.w	r3, [r3, #2164]	; 0x874
 801b556:	633b      	str	r3, [r7, #48]	; 0x30

    /* update node state */
    in = (!(layout->flags & NK_WINDOW_ROM)) ? &ctx->input: 0;
 801b558:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801b55c:	685b      	ldr	r3, [r3, #4]
 801b55e:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 801b562:	2b00      	cmp	r3, #0
 801b564:	d101      	bne.n	801b56a <nk_tree_state_base+0x2c6>
 801b566:	68fb      	ldr	r3, [r7, #12]
 801b568:	e000      	b.n	801b56c <nk_tree_state_base+0x2c8>
 801b56a:	2300      	movs	r3, #0
 801b56c:	673b      	str	r3, [r7, #112]	; 0x70
    in = (in && widget_state == NK_WIDGET_VALID) ? &ctx->input : 0;
 801b56e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801b570:	2b00      	cmp	r3, #0
 801b572:	d005      	beq.n	801b580 <nk_tree_state_base+0x2dc>
 801b574:	f897 307b 	ldrb.w	r3, [r7, #123]	; 0x7b
 801b578:	2b01      	cmp	r3, #1
 801b57a:	d101      	bne.n	801b580 <nk_tree_state_base+0x2dc>
 801b57c:	68fb      	ldr	r3, [r7, #12]
 801b57e:	e000      	b.n	801b582 <nk_tree_state_base+0x2de>
 801b580:	2300      	movs	r3, #0
 801b582:	673b      	str	r3, [r7, #112]	; 0x70
    if (nk_button_behavior(&ws, header, in, NK_BUTTON_DEFAULT))
 801b584:	ed97 6a12 	vldr	s12, [r7, #72]	; 0x48
 801b588:	edd7 6a13 	vldr	s13, [r7, #76]	; 0x4c
 801b58c:	ed97 7a14 	vldr	s14, [r7, #80]	; 0x50
 801b590:	edd7 7a15 	vldr	s15, [r7, #84]	; 0x54
 801b594:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801b598:	2200      	movs	r2, #0
 801b59a:	6f39      	ldr	r1, [r7, #112]	; 0x70
 801b59c:	eeb0 0a46 	vmov.f32	s0, s12
 801b5a0:	eef0 0a66 	vmov.f32	s1, s13
 801b5a4:	eeb0 1a47 	vmov.f32	s2, s14
 801b5a8:	eef0 1a67 	vmov.f32	s3, s15
 801b5ac:	4618      	mov	r0, r3
 801b5ae:	f7f2 fe4f 	bl	800e250 <nk_button_behavior>
 801b5b2:	4603      	mov	r3, r0
 801b5b4:	2b00      	cmp	r3, #0
 801b5b6:	d00b      	beq.n	801b5d0 <nk_tree_state_base+0x32c>
        *state = (*state == NK_MAXIMIZED) ? NK_MINIMIZED : NK_MAXIMIZED;
 801b5b8:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 801b5bc:	781b      	ldrb	r3, [r3, #0]
 801b5be:	2b01      	cmp	r3, #1
 801b5c0:	bf14      	ite	ne
 801b5c2:	2301      	movne	r3, #1
 801b5c4:	2300      	moveq	r3, #0
 801b5c6:	b2db      	uxtb	r3, r3
 801b5c8:	461a      	mov	r2, r3
 801b5ca:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 801b5ce:	701a      	strb	r2, [r3, #0]

    /* select correct button style */
    if (*state == NK_MAXIMIZED) {
 801b5d0:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 801b5d4:	781b      	ldrb	r3, [r3, #0]
 801b5d6:	2b01      	cmp	r3, #1
 801b5d8:	d128      	bne.n	801b62c <nk_tree_state_base+0x388>
        symbol = style->tab.sym_maximize;
 801b5da:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b5de:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801b5e2:	f893 3561 	ldrb.w	r3, [r3, #1377]	; 0x561
 801b5e6:	f887 3093 	strb.w	r3, [r7, #147]	; 0x93
        if (type == NK_TREE_TAB)
 801b5ea:	7afb      	ldrb	r3, [r7, #11]
 801b5ec:	2b01      	cmp	r3, #1
 801b5ee:	d106      	bne.n	801b5fe <nk_tree_state_base+0x35a>
            button = &style->tab.tab_maximize_button;
 801b5f0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b5f4:	f503 5398 	add.w	r3, r3, #4864	; 0x1300
 801b5f8:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 801b5fc:	e030      	b.n	801b660 <nk_tree_state_base+0x3bc>
        else button = &style->tab.node_maximize_button;
 801b5fe:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b602:	f503 53a1 	add.w	r3, r3, #5152	; 0x1420
 801b606:	3310      	adds	r3, #16
 801b608:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 801b60c:	e028      	b.n	801b660 <nk_tree_state_base+0x3bc>
 801b60e:	bf00      	nop
 801b610:	08022050 	.word	0x08022050
 801b614:	0802374c 	.word	0x0802374c
 801b618:	08022054 	.word	0x08022054
 801b61c:	08022070 	.word	0x08022070
 801b620:	08022080 	.word	0x08022080
 801b624:	08023748 	.word	0x08023748
 801b628:	00000000 	.word	0x00000000
    } else {
        symbol = style->tab.sym_minimize;
 801b62c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b630:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801b634:	f893 3560 	ldrb.w	r3, [r3, #1376]	; 0x560
 801b638:	f887 3093 	strb.w	r3, [r7, #147]	; 0x93
        if (type == NK_TREE_TAB)
 801b63c:	7afb      	ldrb	r3, [r7, #11]
 801b63e:	2b01      	cmp	r3, #1
 801b640:	d107      	bne.n	801b652 <nk_tree_state_base+0x3ae>
            button = &style->tab.tab_minimize_button;
 801b642:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b646:	f503 539c 	add.w	r3, r3, #4992	; 0x1380
 801b64a:	3318      	adds	r3, #24
 801b64c:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 801b650:	e006      	b.n	801b660 <nk_tree_state_base+0x3bc>
        else button = &style->tab.node_minimize_button;
 801b652:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b656:	f503 53a6 	add.w	r3, r3, #5312	; 0x14c0
 801b65a:	3308      	adds	r3, #8
 801b65c:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    }

    {/* draw triangle button */
    sym.w = sym.h = style->font->height;
 801b660:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b664:	681b      	ldr	r3, [r3, #0]
 801b666:	685b      	ldr	r3, [r3, #4]
 801b668:	647b      	str	r3, [r7, #68]	; 0x44
 801b66a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b66c:	643b      	str	r3, [r7, #64]	; 0x40
    sym.y = header.y + style->tab.padding.y;
 801b66e:	ed97 7a13 	vldr	s14, [r7, #76]	; 0x4c
 801b672:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b676:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801b67a:	f203 5374 	addw	r3, r3, #1396	; 0x574
 801b67e:	edd3 7a00 	vldr	s15, [r3]
 801b682:	ee77 7a27 	vadd.f32	s15, s14, s15
 801b686:	edc7 7a0f 	vstr	s15, [r7, #60]	; 0x3c
    sym.x = header.x + style->tab.padding.x;
 801b68a:	ed97 7a12 	vldr	s14, [r7, #72]	; 0x48
 801b68e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b692:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801b696:	f503 63ae 	add.w	r3, r3, #1392	; 0x570
 801b69a:	edd3 7a00 	vldr	s15, [r3]
 801b69e:	ee77 7a27 	vadd.f32	s15, s14, s15
 801b6a2:	edc7 7a0e 	vstr	s15, [r7, #56]	; 0x38
    nk_do_button_symbol(&ws, &win->buffer, sym, symbol, NK_BUTTON_DEFAULT,
 801b6a6:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 801b6aa:	f103 0164 	add.w	r1, r3, #100	; 0x64
        button, 0, style->font);
 801b6ae:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b6b2:	681b      	ldr	r3, [r3, #0]
    nk_do_button_symbol(&ws, &win->buffer, sym, symbol, NK_BUTTON_DEFAULT,
 801b6b4:	f897 2093 	ldrb.w	r2, [r7, #147]	; 0x93
 801b6b8:	ed97 6a0e 	vldr	s12, [r7, #56]	; 0x38
 801b6bc:	edd7 6a0f 	vldr	s13, [r7, #60]	; 0x3c
 801b6c0:	ed97 7a10 	vldr	s14, [r7, #64]	; 0x40
 801b6c4:	edd7 7a11 	vldr	s15, [r7, #68]	; 0x44
 801b6c8:	f107 0024 	add.w	r0, r7, #36	; 0x24
 801b6cc:	9302      	str	r3, [sp, #8]
 801b6ce:	2300      	movs	r3, #0
 801b6d0:	9301      	str	r3, [sp, #4]
 801b6d2:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 801b6d6:	9300      	str	r3, [sp, #0]
 801b6d8:	2300      	movs	r3, #0
 801b6da:	eeb0 0a46 	vmov.f32	s0, s12
 801b6de:	eef0 0a66 	vmov.f32	s1, s13
 801b6e2:	eeb0 1a47 	vmov.f32	s2, s14
 801b6e6:	eef0 1a67 	vmov.f32	s3, s15
 801b6ea:	f7f3 f943 	bl	800e974 <nk_do_button_symbol>

    if (img) {
 801b6ee:	687b      	ldr	r3, [r7, #4]
 801b6f0:	2b00      	cmp	r3, #0
 801b6f2:	d039      	beq.n	801b768 <nk_tree_state_base+0x4c4>
        /* draw optional image icon */
        sym.x = sym.x + sym.w + 4 * item_spacing.x;
 801b6f4:	ed97 7a0e 	vldr	s14, [r7, #56]	; 0x38
 801b6f8:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
 801b6fc:	ee37 7a27 	vadd.f32	s14, s14, s15
 801b700:	edd7 7a16 	vldr	s15, [r7, #88]	; 0x58
 801b704:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
 801b708:	ee67 7aa6 	vmul.f32	s15, s15, s13
 801b70c:	ee77 7a27 	vadd.f32	s15, s14, s15
 801b710:	edc7 7a0e 	vstr	s15, [r7, #56]	; 0x38
        nk_draw_image(&win->buffer, sym, img, nk_white);
 801b714:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 801b718:	3364      	adds	r3, #100	; 0x64
 801b71a:	4a85      	ldr	r2, [pc, #532]	; (801b930 <nk_tree_state_base+0x68c>)
 801b71c:	ed97 6a0e 	vldr	s12, [r7, #56]	; 0x38
 801b720:	edd7 6a0f 	vldr	s13, [r7, #60]	; 0x3c
 801b724:	ed97 7a10 	vldr	s14, [r7, #64]	; 0x40
 801b728:	edd7 7a11 	vldr	s15, [r7, #68]	; 0x44
 801b72c:	6812      	ldr	r2, [r2, #0]
 801b72e:	6879      	ldr	r1, [r7, #4]
 801b730:	eeb0 0a46 	vmov.f32	s0, s12
 801b734:	eef0 0a66 	vmov.f32	s1, s13
 801b738:	eeb0 1a47 	vmov.f32	s2, s14
 801b73c:	eef0 1a67 	vmov.f32	s3, s15
 801b740:	4618      	mov	r0, r3
 801b742:	f7f5 fe05 	bl	8011350 <nk_draw_image>
        sym.w = style->font->height + style->tab.spacing.x;}
 801b746:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b74a:	681b      	ldr	r3, [r3, #0]
 801b74c:	ed93 7a01 	vldr	s14, [r3, #4]
 801b750:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b754:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801b758:	f503 63af 	add.w	r3, r3, #1400	; 0x578
 801b75c:	edd3 7a00 	vldr	s15, [r3]
 801b760:	ee77 7a27 	vadd.f32	s15, s14, s15
 801b764:	edc7 7a10 	vstr	s15, [r7, #64]	; 0x40
    }

    {/* draw label */
    struct nk_rect label;
    header.w = NK_MAX(header.w, sym.w + item_spacing.x);
 801b768:	ed97 7a14 	vldr	s14, [r7, #80]	; 0x50
 801b76c:	edd7 6a10 	vldr	s13, [r7, #64]	; 0x40
 801b770:	edd7 7a16 	vldr	s15, [r7, #88]	; 0x58
 801b774:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801b778:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801b77c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b780:	d506      	bpl.n	801b790 <nk_tree_state_base+0x4ec>
 801b782:	ed97 7a10 	vldr	s14, [r7, #64]	; 0x40
 801b786:	edd7 7a16 	vldr	s15, [r7, #88]	; 0x58
 801b78a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801b78e:	e001      	b.n	801b794 <nk_tree_state_base+0x4f0>
 801b790:	edd7 7a14 	vldr	s15, [r7, #80]	; 0x50
 801b794:	edc7 7a14 	vstr	s15, [r7, #80]	; 0x50
    label.x = sym.x + sym.w + item_spacing.x;
 801b798:	ed97 7a0e 	vldr	s14, [r7, #56]	; 0x38
 801b79c:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
 801b7a0:	ee37 7a27 	vadd.f32	s14, s14, s15
 801b7a4:	edd7 7a16 	vldr	s15, [r7, #88]	; 0x58
 801b7a8:	ee77 7a27 	vadd.f32	s15, s14, s15
 801b7ac:	edc7 7a05 	vstr	s15, [r7, #20]
    label.y = sym.y;
 801b7b0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b7b2:	61bb      	str	r3, [r7, #24]
    label.w = header.w - (sym.w + item_spacing.y + style->tab.indent);
 801b7b4:	ed97 7a14 	vldr	s14, [r7, #80]	; 0x50
 801b7b8:	edd7 6a10 	vldr	s13, [r7, #64]	; 0x40
 801b7bc:	edd7 7a17 	vldr	s15, [r7, #92]	; 0x5c
 801b7c0:	ee76 6aa7 	vadd.f32	s13, s13, s15
 801b7c4:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b7c8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801b7cc:	f203 536c 	addw	r3, r3, #1388	; 0x56c
 801b7d0:	edd3 7a00 	vldr	s15, [r3]
 801b7d4:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801b7d8:	ee77 7a67 	vsub.f32	s15, s14, s15
 801b7dc:	edc7 7a07 	vstr	s15, [r7, #28]
    label.h = style->font->height;
 801b7e0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b7e4:	681b      	ldr	r3, [r3, #0]
 801b7e6:	685b      	ldr	r3, [r3, #4]
 801b7e8:	623b      	str	r3, [r7, #32]
    text.text = style->tab.text;
 801b7ea:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b7ee:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801b7f2:	f8d3 32fc 	ldr.w	r3, [r3, #764]	; 0x2fc
 801b7f6:	637b      	str	r3, [r7, #52]	; 0x34
    text.padding = nk_vec2(0,0);
 801b7f8:	eddf 0a4e 	vldr	s1, [pc, #312]	; 801b934 <nk_tree_state_base+0x690>
 801b7fc:	ed9f 0a4d 	vldr	s0, [pc, #308]	; 801b934 <nk_tree_state_base+0x690>
 801b800:	f7f8 f85a 	bl	80138b8 <nk_vec2>
 801b804:	eeb0 7a40 	vmov.f32	s14, s0
 801b808:	eef0 7a60 	vmov.f32	s15, s1
 801b80c:	ed87 7a0a 	vstr	s14, [r7, #40]	; 0x28
 801b810:	edc7 7a0b 	vstr	s15, [r7, #44]	; 0x2c
    nk_widget_text(out, label, title, nk_strlen(title), &text,
 801b814:	6838      	ldr	r0, [r7, #0]
 801b816:	f000 fc25 	bl	801c064 <nk_strlen>
 801b81a:	4601      	mov	r1, r0
        NK_TEXT_LEFT, style->font);}
 801b81c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b820:	681b      	ldr	r3, [r3, #0]
    nk_widget_text(out, label, title, nk_strlen(title), &text,
 801b822:	f107 0228 	add.w	r2, r7, #40	; 0x28
 801b826:	ed97 6a05 	vldr	s12, [r7, #20]
 801b82a:	edd7 6a06 	vldr	s13, [r7, #24]
 801b82e:	ed97 7a07 	vldr	s14, [r7, #28]
 801b832:	edd7 7a08 	vldr	s15, [r7, #32]
 801b836:	9301      	str	r3, [sp, #4]
 801b838:	2311      	movs	r3, #17
 801b83a:	9300      	str	r3, [sp, #0]
 801b83c:	4613      	mov	r3, r2
 801b83e:	460a      	mov	r2, r1
 801b840:	6839      	ldr	r1, [r7, #0]
 801b842:	eeb0 0a46 	vmov.f32	s0, s12
 801b846:	eef0 0a66 	vmov.f32	s1, s13
 801b84a:	eeb0 1a47 	vmov.f32	s2, s14
 801b84e:	eef0 1a67 	vmov.f32	s3, s15
 801b852:	f8d7 0084 	ldr.w	r0, [r7, #132]	; 0x84
 801b856:	f7ff fa2d 	bl	801acb4 <nk_widget_text>

    /* increase x-axis cursor widget position pointer */
    if (*state == NK_MAXIMIZED) {
 801b85a:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 801b85e:	781b      	ldrb	r3, [r3, #0]
 801b860:	2b01      	cmp	r3, #1
 801b862:	d15f      	bne.n	801b924 <nk_tree_state_base+0x680>
        layout->at_x = header.x + (float)*layout->offset_x + style->tab.indent;
 801b864:	ed97 7a12 	vldr	s14, [r7, #72]	; 0x48
 801b868:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801b86c:	699b      	ldr	r3, [r3, #24]
 801b86e:	681b      	ldr	r3, [r3, #0]
 801b870:	ee07 3a90 	vmov	s15, r3
 801b874:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801b878:	ee37 7a27 	vadd.f32	s14, s14, s15
 801b87c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b880:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801b884:	f203 536c 	addw	r3, r3, #1388	; 0x56c
 801b888:	edd3 7a00 	vldr	s15, [r3]
 801b88c:	ee77 7a27 	vadd.f32	s15, s14, s15
 801b890:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801b894:	edc3 7a08 	vstr	s15, [r3, #32]
        layout->bounds.w = NK_MAX(layout->bounds.w, style->tab.indent);
 801b898:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801b89c:	ed93 7a04 	vldr	s14, [r3, #16]
 801b8a0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b8a4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801b8a8:	f203 536c 	addw	r3, r3, #1388	; 0x56c
 801b8ac:	edd3 7a00 	vldr	s15, [r3]
 801b8b0:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801b8b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b8b8:	d507      	bpl.n	801b8ca <nk_tree_state_base+0x626>
 801b8ba:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b8be:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801b8c2:	f203 536c 	addw	r3, r3, #1388	; 0x56c
 801b8c6:	681b      	ldr	r3, [r3, #0]
 801b8c8:	e002      	b.n	801b8d0 <nk_tree_state_base+0x62c>
 801b8ca:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801b8ce:	691b      	ldr	r3, [r3, #16]
 801b8d0:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 801b8d4:	6113      	str	r3, [r2, #16]
        layout->bounds.w -= (style->tab.indent + style->window.padding.x);
 801b8d6:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801b8da:	ed93 7a04 	vldr	s14, [r3, #16]
 801b8de:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b8e2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801b8e6:	f203 536c 	addw	r3, r3, #1388	; 0x56c
 801b8ea:	edd3 6a00 	vldr	s13, [r3]
 801b8ee:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b8f2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801b8f6:	f603 03ec 	addw	r3, r3, #2284	; 0x8ec
 801b8fa:	edd3 7a00 	vldr	s15, [r3]
 801b8fe:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801b902:	ee77 7a67 	vsub.f32	s15, s14, s15
 801b906:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801b90a:	edc3 7a04 	vstr	s15, [r3, #16]
        layout->row.tree_depth++;
 801b90e:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801b912:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 801b916:	1c5a      	adds	r2, r3, #1
 801b918:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801b91c:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
        return nk_true;
 801b920:	2301      	movs	r3, #1
 801b922:	e000      	b.n	801b926 <nk_tree_state_base+0x682>
    } else return nk_false;
 801b924:	2300      	movs	r3, #0
}
 801b926:	4618      	mov	r0, r3
 801b928:	3798      	adds	r7, #152	; 0x98
 801b92a:	46bd      	mov	sp, r7
 801b92c:	bd80      	pop	{r7, pc}
 801b92e:	bf00      	nop
 801b930:	08023748 	.word	0x08023748
 801b934:	00000000 	.word	0x00000000

0801b938 <nk_tree_base>:
NK_INTERN int
nk_tree_base(struct nk_context *ctx, enum nk_tree_type type,
    struct nk_image *img, const char *title, enum nk_collapse_states initial_state,
    const char *hash, int len, int line)
{
 801b938:	b580      	push	{r7, lr}
 801b93a:	b08a      	sub	sp, #40	; 0x28
 801b93c:	af02      	add	r7, sp, #8
 801b93e:	60f8      	str	r0, [r7, #12]
 801b940:	607a      	str	r2, [r7, #4]
 801b942:	603b      	str	r3, [r7, #0]
 801b944:	460b      	mov	r3, r1
 801b946:	72fb      	strb	r3, [r7, #11]
    struct nk_window *win = ctx->current;
 801b948:	68fb      	ldr	r3, [r7, #12]
 801b94a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801b94e:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801b952:	617b      	str	r3, [r7, #20]
    int title_len = 0;
 801b954:	2300      	movs	r3, #0
 801b956:	613b      	str	r3, [r7, #16]
    nk_hash tree_hash = 0;
 801b958:	2300      	movs	r3, #0
 801b95a:	61fb      	str	r3, [r7, #28]
    nk_uint *state = 0;
 801b95c:	2300      	movs	r3, #0
 801b95e:	61bb      	str	r3, [r7, #24]

    /* retrieve tree state from internal widget state tables */
    if (!hash) {
 801b960:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801b962:	2b00      	cmp	r3, #0
 801b964:	d10b      	bne.n	801b97e <nk_tree_base+0x46>
        title_len = (int)nk_strlen(title);
 801b966:	6838      	ldr	r0, [r7, #0]
 801b968:	f000 fb7c 	bl	801c064 <nk_strlen>
 801b96c:	6138      	str	r0, [r7, #16]
        tree_hash = nk_murmur_hash(title, (int)title_len, (nk_hash)line);
 801b96e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b970:	461a      	mov	r2, r3
 801b972:	6939      	ldr	r1, [r7, #16]
 801b974:	6838      	ldr	r0, [r7, #0]
 801b976:	f000 fbf5 	bl	801c164 <nk_murmur_hash>
 801b97a:	61f8      	str	r0, [r7, #28]
 801b97c:	e006      	b.n	801b98c <nk_tree_base+0x54>
    } else tree_hash = nk_murmur_hash(hash, len, (nk_hash)line);
 801b97e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b980:	461a      	mov	r2, r3
 801b982:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801b984:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801b986:	f000 fbed 	bl	801c164 <nk_murmur_hash>
 801b98a:	61f8      	str	r0, [r7, #28]
    state = nk_find_value(win, tree_hash);
 801b98c:	69f9      	ldr	r1, [r7, #28]
 801b98e:	6978      	ldr	r0, [r7, #20]
 801b990:	f7ff f954 	bl	801ac3c <nk_find_value>
 801b994:	61b8      	str	r0, [r7, #24]
    if (!state) {
 801b996:	69bb      	ldr	r3, [r7, #24]
 801b998:	2b00      	cmp	r3, #0
 801b99a:	d10a      	bne.n	801b9b2 <nk_tree_base+0x7a>
        state = nk_add_value(ctx, win, tree_hash, 0);
 801b99c:	2300      	movs	r3, #0
 801b99e:	69fa      	ldr	r2, [r7, #28]
 801b9a0:	6979      	ldr	r1, [r7, #20]
 801b9a2:	68f8      	ldr	r0, [r7, #12]
 801b9a4:	f7ff f8d0 	bl	801ab48 <nk_add_value>
 801b9a8:	61b8      	str	r0, [r7, #24]
        *state = initial_state;
 801b9aa:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
 801b9ae:	69bb      	ldr	r3, [r7, #24]
 801b9b0:	601a      	str	r2, [r3, #0]
    }
    return nk_tree_state_base(ctx, type, img, title, (enum nk_collapse_states*)state);
 801b9b2:	7af9      	ldrb	r1, [r7, #11]
 801b9b4:	69bb      	ldr	r3, [r7, #24]
 801b9b6:	9300      	str	r3, [sp, #0]
 801b9b8:	683b      	ldr	r3, [r7, #0]
 801b9ba:	687a      	ldr	r2, [r7, #4]
 801b9bc:	68f8      	ldr	r0, [r7, #12]
 801b9be:	f7ff fc71 	bl	801b2a4 <nk_tree_state_base>
 801b9c2:	4603      	mov	r3, r0
}
 801b9c4:	4618      	mov	r0, r3
 801b9c6:	3720      	adds	r7, #32
 801b9c8:	46bd      	mov	sp, r7
 801b9ca:	bd80      	pop	{r7, pc}

0801b9cc <nk_tree_state_pop>:
{
    return nk_tree_state_base(ctx, type, &img, title, state);
}
NK_API void
nk_tree_state_pop(struct nk_context *ctx)
{
 801b9cc:	b580      	push	{r7, lr}
 801b9ce:	b084      	sub	sp, #16
 801b9d0:	af00      	add	r7, sp, #0
 801b9d2:	6078      	str	r0, [r7, #4]
    struct nk_window *win = 0;
 801b9d4:	2300      	movs	r3, #0
 801b9d6:	60fb      	str	r3, [r7, #12]
    struct nk_panel *layout = 0;
 801b9d8:	2300      	movs	r3, #0
 801b9da:	60bb      	str	r3, [r7, #8]

    NK_ASSERT(ctx);
 801b9dc:	687b      	ldr	r3, [r7, #4]
 801b9de:	2b00      	cmp	r3, #0
 801b9e0:	d105      	bne.n	801b9ee <nk_tree_state_pop+0x22>
 801b9e2:	4b43      	ldr	r3, [pc, #268]	; (801baf0 <nk_tree_state_pop+0x124>)
 801b9e4:	4a43      	ldr	r2, [pc, #268]	; (801baf4 <nk_tree_state_pop+0x128>)
 801b9e6:	21a2      	movs	r1, #162	; 0xa2
 801b9e8:	4843      	ldr	r0, [pc, #268]	; (801baf8 <nk_tree_state_pop+0x12c>)
 801b9ea:	f002 f815 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 801b9ee:	687b      	ldr	r3, [r7, #4]
 801b9f0:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801b9f4:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801b9f8:	2b00      	cmp	r3, #0
 801b9fa:	d105      	bne.n	801ba08 <nk_tree_state_pop+0x3c>
 801b9fc:	4b3f      	ldr	r3, [pc, #252]	; (801bafc <nk_tree_state_pop+0x130>)
 801b9fe:	4a3d      	ldr	r2, [pc, #244]	; (801baf4 <nk_tree_state_pop+0x128>)
 801ba00:	21a3      	movs	r1, #163	; 0xa3
 801ba02:	483d      	ldr	r0, [pc, #244]	; (801baf8 <nk_tree_state_pop+0x12c>)
 801ba04:	f002 f808 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 801ba08:	687b      	ldr	r3, [r7, #4]
 801ba0a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801ba0e:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801ba12:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801ba16:	2b00      	cmp	r3, #0
 801ba18:	d105      	bne.n	801ba26 <nk_tree_state_pop+0x5a>
 801ba1a:	4b39      	ldr	r3, [pc, #228]	; (801bb00 <nk_tree_state_pop+0x134>)
 801ba1c:	4a35      	ldr	r2, [pc, #212]	; (801baf4 <nk_tree_state_pop+0x128>)
 801ba1e:	21a4      	movs	r1, #164	; 0xa4
 801ba20:	4835      	ldr	r0, [pc, #212]	; (801baf8 <nk_tree_state_pop+0x12c>)
 801ba22:	f001 fff9 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout)
 801ba26:	687b      	ldr	r3, [r7, #4]
 801ba28:	2b00      	cmp	r3, #0
 801ba2a:	d05c      	beq.n	801bae6 <nk_tree_state_pop+0x11a>
 801ba2c:	687b      	ldr	r3, [r7, #4]
 801ba2e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801ba32:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801ba36:	2b00      	cmp	r3, #0
 801ba38:	d055      	beq.n	801bae6 <nk_tree_state_pop+0x11a>
 801ba3a:	687b      	ldr	r3, [r7, #4]
 801ba3c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801ba40:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801ba44:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801ba48:	2b00      	cmp	r3, #0
 801ba4a:	d04c      	beq.n	801bae6 <nk_tree_state_pop+0x11a>
        return;

    win = ctx->current;
 801ba4c:	687b      	ldr	r3, [r7, #4]
 801ba4e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801ba52:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801ba56:	60fb      	str	r3, [r7, #12]
    layout = win->layout;
 801ba58:	68fb      	ldr	r3, [r7, #12]
 801ba5a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801ba5e:	60bb      	str	r3, [r7, #8]
    layout->at_x -= ctx->style.tab.indent + (float)*layout->offset_x;
 801ba60:	68bb      	ldr	r3, [r7, #8]
 801ba62:	ed93 7a08 	vldr	s14, [r3, #32]
 801ba66:	687b      	ldr	r3, [r7, #4]
 801ba68:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801ba6c:	f203 63d4 	addw	r3, r3, #1748	; 0x6d4
 801ba70:	edd3 6a00 	vldr	s13, [r3]
 801ba74:	68bb      	ldr	r3, [r7, #8]
 801ba76:	699b      	ldr	r3, [r3, #24]
 801ba78:	681b      	ldr	r3, [r3, #0]
 801ba7a:	ee07 3a90 	vmov	s15, r3
 801ba7e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801ba82:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801ba86:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ba8a:	68bb      	ldr	r3, [r7, #8]
 801ba8c:	edc3 7a08 	vstr	s15, [r3, #32]
    layout->bounds.w += ctx->style.tab.indent + ctx->style.window.padding.x;
 801ba90:	68bb      	ldr	r3, [r7, #8]
 801ba92:	ed93 7a04 	vldr	s14, [r3, #16]
 801ba96:	687b      	ldr	r3, [r7, #4]
 801ba98:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801ba9c:	f203 63d4 	addw	r3, r3, #1748	; 0x6d4
 801baa0:	edd3 6a00 	vldr	s13, [r3]
 801baa4:	687b      	ldr	r3, [r7, #4]
 801baa6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801baaa:	f603 2354 	addw	r3, r3, #2644	; 0xa54
 801baae:	edd3 7a00 	vldr	s15, [r3]
 801bab2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801bab6:	ee77 7a27 	vadd.f32	s15, s14, s15
 801baba:	68bb      	ldr	r3, [r7, #8]
 801babc:	edc3 7a04 	vstr	s15, [r3, #16]
    NK_ASSERT(layout->row.tree_depth);
 801bac0:	68bb      	ldr	r3, [r7, #8]
 801bac2:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 801bac6:	2b00      	cmp	r3, #0
 801bac8:	d105      	bne.n	801bad6 <nk_tree_state_pop+0x10a>
 801baca:	4b0e      	ldr	r3, [pc, #56]	; (801bb04 <nk_tree_state_pop+0x138>)
 801bacc:	4a09      	ldr	r2, [pc, #36]	; (801baf4 <nk_tree_state_pop+0x128>)
 801bace:	21ac      	movs	r1, #172	; 0xac
 801bad0:	4809      	ldr	r0, [pc, #36]	; (801baf8 <nk_tree_state_pop+0x12c>)
 801bad2:	f001 ffa1 	bl	801da18 <__assert_func>
    layout->row.tree_depth--;
 801bad6:	68bb      	ldr	r3, [r7, #8]
 801bad8:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 801badc:	1e5a      	subs	r2, r3, #1
 801bade:	68bb      	ldr	r3, [r7, #8]
 801bae0:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
 801bae4:	e000      	b.n	801bae8 <nk_tree_state_pop+0x11c>
        return;
 801bae6:	bf00      	nop
}
 801bae8:	3710      	adds	r7, #16
 801baea:	46bd      	mov	sp, r7
 801baec:	bd80      	pop	{r7, pc}
 801baee:	bf00      	nop
 801baf0:	08022050 	.word	0x08022050
 801baf4:	08023760 	.word	0x08023760
 801baf8:	08022054 	.word	0x08022054
 801bafc:	08022070 	.word	0x08022070
 801bb00:	08022080 	.word	0x08022080
 801bb04:	08022098 	.word	0x08022098

0801bb08 <nk_tree_push_hashed>:
NK_API nk_bool
nk_tree_push_hashed(struct nk_context *ctx, enum nk_tree_type type,
    const char *title, enum nk_collapse_states initial_state,
    const char *hash, int len, int line)
{
 801bb08:	b580      	push	{r7, lr}
 801bb0a:	b088      	sub	sp, #32
 801bb0c:	af04      	add	r7, sp, #16
 801bb0e:	60f8      	str	r0, [r7, #12]
 801bb10:	607a      	str	r2, [r7, #4]
 801bb12:	461a      	mov	r2, r3
 801bb14:	460b      	mov	r3, r1
 801bb16:	72fb      	strb	r3, [r7, #11]
 801bb18:	4613      	mov	r3, r2
 801bb1a:	72bb      	strb	r3, [r7, #10]
    return nk_tree_base(ctx, type, 0, title, initial_state, hash, len, line);
 801bb1c:	7af9      	ldrb	r1, [r7, #11]
 801bb1e:	6a3b      	ldr	r3, [r7, #32]
 801bb20:	9303      	str	r3, [sp, #12]
 801bb22:	69fb      	ldr	r3, [r7, #28]
 801bb24:	9302      	str	r3, [sp, #8]
 801bb26:	69bb      	ldr	r3, [r7, #24]
 801bb28:	9301      	str	r3, [sp, #4]
 801bb2a:	7abb      	ldrb	r3, [r7, #10]
 801bb2c:	9300      	str	r3, [sp, #0]
 801bb2e:	687b      	ldr	r3, [r7, #4]
 801bb30:	2200      	movs	r2, #0
 801bb32:	68f8      	ldr	r0, [r7, #12]
 801bb34:	f7ff ff00 	bl	801b938 <nk_tree_base>
 801bb38:	4603      	mov	r3, r0
}
 801bb3a:	4618      	mov	r0, r3
 801bb3c:	3710      	adds	r7, #16
 801bb3e:	46bd      	mov	sp, r7
 801bb40:	bd80      	pop	{r7, pc}

0801bb42 <nk_tree_pop>:
{
    return nk_tree_base(ctx, type, &img, title, initial_state, hash, len, seed);
}
NK_API void
nk_tree_pop(struct nk_context *ctx)
{
 801bb42:	b580      	push	{r7, lr}
 801bb44:	b082      	sub	sp, #8
 801bb46:	af00      	add	r7, sp, #0
 801bb48:	6078      	str	r0, [r7, #4]
    nk_tree_state_pop(ctx);
 801bb4a:	6878      	ldr	r0, [r7, #4]
 801bb4c:	f7ff ff3e 	bl	801b9cc <nk_tree_state_pop>
}
 801bb50:	bf00      	nop
 801bb52:	3708      	adds	r7, #8
 801bb54:	46bd      	mov	sp, r7
 801bb56:	bd80      	pop	{r7, pc}

0801bb58 <nk_utf_validate>:
NK_GLOBAL const nk_uint nk_utfmin[NK_UTF_SIZE+1] = {0, 0, 0x80, 0x800, 0x10000};
NK_GLOBAL const nk_uint nk_utfmax[NK_UTF_SIZE+1] = {0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF};

NK_INTERN int
nk_utf_validate(nk_rune *u, int i)
{
 801bb58:	b580      	push	{r7, lr}
 801bb5a:	b082      	sub	sp, #8
 801bb5c:	af00      	add	r7, sp, #0
 801bb5e:	6078      	str	r0, [r7, #4]
 801bb60:	6039      	str	r1, [r7, #0]
    NK_ASSERT(u);
 801bb62:	687b      	ldr	r3, [r7, #4]
 801bb64:	2b00      	cmp	r3, #0
 801bb66:	d105      	bne.n	801bb74 <nk_utf_validate+0x1c>
 801bb68:	4b1e      	ldr	r3, [pc, #120]	; (801bbe4 <nk_utf_validate+0x8c>)
 801bb6a:	4a1f      	ldr	r2, [pc, #124]	; (801bbe8 <nk_utf_validate+0x90>)
 801bb6c:	2111      	movs	r1, #17
 801bb6e:	481f      	ldr	r0, [pc, #124]	; (801bbec <nk_utf_validate+0x94>)
 801bb70:	f001 ff52 	bl	801da18 <__assert_func>
    if (!u) return 0;
 801bb74:	687b      	ldr	r3, [r7, #4]
 801bb76:	2b00      	cmp	r3, #0
 801bb78:	d101      	bne.n	801bb7e <nk_utf_validate+0x26>
 801bb7a:	2300      	movs	r3, #0
 801bb7c:	e02d      	b.n	801bbda <nk_utf_validate+0x82>
    if (!NK_BETWEEN(*u, nk_utfmin[i], nk_utfmax[i]) ||
 801bb7e:	4a1c      	ldr	r2, [pc, #112]	; (801bbf0 <nk_utf_validate+0x98>)
 801bb80:	683b      	ldr	r3, [r7, #0]
 801bb82:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 801bb86:	687b      	ldr	r3, [r7, #4]
 801bb88:	681b      	ldr	r3, [r3, #0]
 801bb8a:	429a      	cmp	r2, r3
 801bb8c:	d812      	bhi.n	801bbb4 <nk_utf_validate+0x5c>
 801bb8e:	687b      	ldr	r3, [r7, #4]
 801bb90:	681a      	ldr	r2, [r3, #0]
 801bb92:	4918      	ldr	r1, [pc, #96]	; (801bbf4 <nk_utf_validate+0x9c>)
 801bb94:	683b      	ldr	r3, [r7, #0]
 801bb96:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801bb9a:	429a      	cmp	r2, r3
 801bb9c:	d20a      	bcs.n	801bbb4 <nk_utf_validate+0x5c>
         NK_BETWEEN(*u, 0xD800, 0xDFFF))
 801bb9e:	687b      	ldr	r3, [r7, #4]
 801bba0:	681b      	ldr	r3, [r3, #0]
    if (!NK_BETWEEN(*u, nk_utfmin[i], nk_utfmax[i]) ||
 801bba2:	f5b3 4f58 	cmp.w	r3, #55296	; 0xd800
 801bba6:	d309      	bcc.n	801bbbc <nk_utf_validate+0x64>
         NK_BETWEEN(*u, 0xD800, 0xDFFF))
 801bba8:	687b      	ldr	r3, [r7, #4]
 801bbaa:	681b      	ldr	r3, [r3, #0]
 801bbac:	f64d 72fe 	movw	r2, #57342	; 0xdffe
 801bbb0:	4293      	cmp	r3, r2
 801bbb2:	d803      	bhi.n	801bbbc <nk_utf_validate+0x64>
            *u = NK_UTF_INVALID;
 801bbb4:	687b      	ldr	r3, [r7, #4]
 801bbb6:	f64f 72fd 	movw	r2, #65533	; 0xfffd
 801bbba:	601a      	str	r2, [r3, #0]
    for (i = 1; *u > nk_utfmax[i]; ++i);
 801bbbc:	2301      	movs	r3, #1
 801bbbe:	603b      	str	r3, [r7, #0]
 801bbc0:	e002      	b.n	801bbc8 <nk_utf_validate+0x70>
 801bbc2:	683b      	ldr	r3, [r7, #0]
 801bbc4:	3301      	adds	r3, #1
 801bbc6:	603b      	str	r3, [r7, #0]
 801bbc8:	687b      	ldr	r3, [r7, #4]
 801bbca:	681a      	ldr	r2, [r3, #0]
 801bbcc:	4909      	ldr	r1, [pc, #36]	; (801bbf4 <nk_utf_validate+0x9c>)
 801bbce:	683b      	ldr	r3, [r7, #0]
 801bbd0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801bbd4:	429a      	cmp	r2, r3
 801bbd6:	d8f4      	bhi.n	801bbc2 <nk_utf_validate+0x6a>
    return i;
 801bbd8:	683b      	ldr	r3, [r7, #0]
}
 801bbda:	4618      	mov	r0, r3
 801bbdc:	3708      	adds	r7, #8
 801bbde:	46bd      	mov	sp, r7
 801bbe0:	bd80      	pop	{r7, pc}
 801bbe2:	bf00      	nop
 801bbe4:	080220b0 	.word	0x080220b0
 801bbe8:	080237ac 	.word	0x080237ac
 801bbec:	080220b4 	.word	0x080220b4
 801bbf0:	08023784 	.word	0x08023784
 801bbf4:	08023798 	.word	0x08023798

0801bbf8 <nk_utf_decode_byte>:
NK_INTERN nk_rune
nk_utf_decode_byte(char c, int *i)
{
 801bbf8:	b580      	push	{r7, lr}
 801bbfa:	b082      	sub	sp, #8
 801bbfc:	af00      	add	r7, sp, #0
 801bbfe:	4603      	mov	r3, r0
 801bc00:	6039      	str	r1, [r7, #0]
 801bc02:	71fb      	strb	r3, [r7, #7]
    NK_ASSERT(i);
 801bc04:	683b      	ldr	r3, [r7, #0]
 801bc06:	2b00      	cmp	r3, #0
 801bc08:	d105      	bne.n	801bc16 <nk_utf_decode_byte+0x1e>
 801bc0a:	4b1b      	ldr	r3, [pc, #108]	; (801bc78 <nk_utf_decode_byte+0x80>)
 801bc0c:	4a1b      	ldr	r2, [pc, #108]	; (801bc7c <nk_utf_decode_byte+0x84>)
 801bc0e:	211c      	movs	r1, #28
 801bc10:	481b      	ldr	r0, [pc, #108]	; (801bc80 <nk_utf_decode_byte+0x88>)
 801bc12:	f001 ff01 	bl	801da18 <__assert_func>
    if (!i) return 0;
 801bc16:	683b      	ldr	r3, [r7, #0]
 801bc18:	2b00      	cmp	r3, #0
 801bc1a:	d101      	bne.n	801bc20 <nk_utf_decode_byte+0x28>
 801bc1c:	2300      	movs	r3, #0
 801bc1e:	e027      	b.n	801bc70 <nk_utf_decode_byte+0x78>
    for(*i = 0; *i < (int)NK_LEN(nk_utfmask); ++(*i)) {
 801bc20:	683b      	ldr	r3, [r7, #0]
 801bc22:	2200      	movs	r2, #0
 801bc24:	601a      	str	r2, [r3, #0]
 801bc26:	e01e      	b.n	801bc66 <nk_utf_decode_byte+0x6e>
        if (((nk_byte)c & nk_utfmask[*i]) == nk_utfbyte[*i])
 801bc28:	683b      	ldr	r3, [r7, #0]
 801bc2a:	681b      	ldr	r3, [r3, #0]
 801bc2c:	4a15      	ldr	r2, [pc, #84]	; (801bc84 <nk_utf_decode_byte+0x8c>)
 801bc2e:	5cd2      	ldrb	r2, [r2, r3]
 801bc30:	79fb      	ldrb	r3, [r7, #7]
 801bc32:	4013      	ands	r3, r2
 801bc34:	b2da      	uxtb	r2, r3
 801bc36:	683b      	ldr	r3, [r7, #0]
 801bc38:	681b      	ldr	r3, [r3, #0]
 801bc3a:	4913      	ldr	r1, [pc, #76]	; (801bc88 <nk_utf_decode_byte+0x90>)
 801bc3c:	5ccb      	ldrb	r3, [r1, r3]
 801bc3e:	429a      	cmp	r2, r3
 801bc40:	d10c      	bne.n	801bc5c <nk_utf_decode_byte+0x64>
            return (nk_byte)(c & ~nk_utfmask[*i]);
 801bc42:	683b      	ldr	r3, [r7, #0]
 801bc44:	681b      	ldr	r3, [r3, #0]
 801bc46:	4a0f      	ldr	r2, [pc, #60]	; (801bc84 <nk_utf_decode_byte+0x8c>)
 801bc48:	5cd3      	ldrb	r3, [r2, r3]
 801bc4a:	b25b      	sxtb	r3, r3
 801bc4c:	43db      	mvns	r3, r3
 801bc4e:	b25a      	sxtb	r2, r3
 801bc50:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801bc54:	4013      	ands	r3, r2
 801bc56:	b25b      	sxtb	r3, r3
 801bc58:	b2db      	uxtb	r3, r3
 801bc5a:	e009      	b.n	801bc70 <nk_utf_decode_byte+0x78>
    for(*i = 0; *i < (int)NK_LEN(nk_utfmask); ++(*i)) {
 801bc5c:	683b      	ldr	r3, [r7, #0]
 801bc5e:	681b      	ldr	r3, [r3, #0]
 801bc60:	1c5a      	adds	r2, r3, #1
 801bc62:	683b      	ldr	r3, [r7, #0]
 801bc64:	601a      	str	r2, [r3, #0]
 801bc66:	683b      	ldr	r3, [r7, #0]
 801bc68:	681b      	ldr	r3, [r3, #0]
 801bc6a:	2b04      	cmp	r3, #4
 801bc6c:	dddc      	ble.n	801bc28 <nk_utf_decode_byte+0x30>
    }
    return 0;
 801bc6e:	2300      	movs	r3, #0
}
 801bc70:	4618      	mov	r0, r3
 801bc72:	3708      	adds	r7, #8
 801bc74:	46bd      	mov	sp, r7
 801bc76:	bd80      	pop	{r7, pc}
 801bc78:	080220d0 	.word	0x080220d0
 801bc7c:	080237bc 	.word	0x080237bc
 801bc80:	080220b4 	.word	0x080220b4
 801bc84:	0802377c 	.word	0x0802377c
 801bc88:	08023774 	.word	0x08023774

0801bc8c <nk_utf_decode>:
NK_API int
nk_utf_decode(const char *c, nk_rune *u, int clen)
{
 801bc8c:	b590      	push	{r4, r7, lr}
 801bc8e:	b08b      	sub	sp, #44	; 0x2c
 801bc90:	af00      	add	r7, sp, #0
 801bc92:	60f8      	str	r0, [r7, #12]
 801bc94:	60b9      	str	r1, [r7, #8]
 801bc96:	607a      	str	r2, [r7, #4]
    int i, j, len, type=0;
 801bc98:	2300      	movs	r3, #0
 801bc9a:	617b      	str	r3, [r7, #20]
    nk_rune udecoded;

    NK_ASSERT(c);
 801bc9c:	68fb      	ldr	r3, [r7, #12]
 801bc9e:	2b00      	cmp	r3, #0
 801bca0:	d105      	bne.n	801bcae <nk_utf_decode+0x22>
 801bca2:	4b35      	ldr	r3, [pc, #212]	; (801bd78 <nk_utf_decode+0xec>)
 801bca4:	4a35      	ldr	r2, [pc, #212]	; (801bd7c <nk_utf_decode+0xf0>)
 801bca6:	212a      	movs	r1, #42	; 0x2a
 801bca8:	4835      	ldr	r0, [pc, #212]	; (801bd80 <nk_utf_decode+0xf4>)
 801bcaa:	f001 feb5 	bl	801da18 <__assert_func>
    NK_ASSERT(u);
 801bcae:	68bb      	ldr	r3, [r7, #8]
 801bcb0:	2b00      	cmp	r3, #0
 801bcb2:	d105      	bne.n	801bcc0 <nk_utf_decode+0x34>
 801bcb4:	4b33      	ldr	r3, [pc, #204]	; (801bd84 <nk_utf_decode+0xf8>)
 801bcb6:	4a31      	ldr	r2, [pc, #196]	; (801bd7c <nk_utf_decode+0xf0>)
 801bcb8:	212b      	movs	r1, #43	; 0x2b
 801bcba:	4831      	ldr	r0, [pc, #196]	; (801bd80 <nk_utf_decode+0xf4>)
 801bcbc:	f001 feac 	bl	801da18 <__assert_func>

    if (!c || !u) return 0;
 801bcc0:	68fb      	ldr	r3, [r7, #12]
 801bcc2:	2b00      	cmp	r3, #0
 801bcc4:	d002      	beq.n	801bccc <nk_utf_decode+0x40>
 801bcc6:	68bb      	ldr	r3, [r7, #8]
 801bcc8:	2b00      	cmp	r3, #0
 801bcca:	d101      	bne.n	801bcd0 <nk_utf_decode+0x44>
 801bccc:	2300      	movs	r3, #0
 801bcce:	e04f      	b.n	801bd70 <nk_utf_decode+0xe4>
    if (!clen) return 0;
 801bcd0:	687b      	ldr	r3, [r7, #4]
 801bcd2:	2b00      	cmp	r3, #0
 801bcd4:	d101      	bne.n	801bcda <nk_utf_decode+0x4e>
 801bcd6:	2300      	movs	r3, #0
 801bcd8:	e04a      	b.n	801bd70 <nk_utf_decode+0xe4>
    *u = NK_UTF_INVALID;
 801bcda:	68bb      	ldr	r3, [r7, #8]
 801bcdc:	f64f 72fd 	movw	r2, #65533	; 0xfffd
 801bce0:	601a      	str	r2, [r3, #0]

    udecoded = nk_utf_decode_byte(c[0], &len);
 801bce2:	68fb      	ldr	r3, [r7, #12]
 801bce4:	781b      	ldrb	r3, [r3, #0]
 801bce6:	f107 0218 	add.w	r2, r7, #24
 801bcea:	4611      	mov	r1, r2
 801bcec:	4618      	mov	r0, r3
 801bcee:	f7ff ff83 	bl	801bbf8 <nk_utf_decode_byte>
 801bcf2:	61f8      	str	r0, [r7, #28]
    if (!NK_BETWEEN(len, 1, NK_UTF_SIZE))
 801bcf4:	69bb      	ldr	r3, [r7, #24]
 801bcf6:	2b00      	cmp	r3, #0
 801bcf8:	dd02      	ble.n	801bd00 <nk_utf_decode+0x74>
 801bcfa:	69bb      	ldr	r3, [r7, #24]
 801bcfc:	2b03      	cmp	r3, #3
 801bcfe:	dd01      	ble.n	801bd04 <nk_utf_decode+0x78>
        return 1;
 801bd00:	2301      	movs	r3, #1
 801bd02:	e035      	b.n	801bd70 <nk_utf_decode+0xe4>

    for (i = 1, j = 1; i < clen && j < len; ++i, ++j) {
 801bd04:	2301      	movs	r3, #1
 801bd06:	627b      	str	r3, [r7, #36]	; 0x24
 801bd08:	2301      	movs	r3, #1
 801bd0a:	623b      	str	r3, [r7, #32]
 801bd0c:	e019      	b.n	801bd42 <nk_utf_decode+0xb6>
        udecoded = (udecoded << 6) | nk_utf_decode_byte(c[i], &type);
 801bd0e:	69fb      	ldr	r3, [r7, #28]
 801bd10:	019c      	lsls	r4, r3, #6
 801bd12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801bd14:	68fa      	ldr	r2, [r7, #12]
 801bd16:	4413      	add	r3, r2
 801bd18:	781b      	ldrb	r3, [r3, #0]
 801bd1a:	f107 0214 	add.w	r2, r7, #20
 801bd1e:	4611      	mov	r1, r2
 801bd20:	4618      	mov	r0, r3
 801bd22:	f7ff ff69 	bl	801bbf8 <nk_utf_decode_byte>
 801bd26:	4603      	mov	r3, r0
 801bd28:	4323      	orrs	r3, r4
 801bd2a:	61fb      	str	r3, [r7, #28]
        if (type != 0)
 801bd2c:	697b      	ldr	r3, [r7, #20]
 801bd2e:	2b00      	cmp	r3, #0
 801bd30:	d001      	beq.n	801bd36 <nk_utf_decode+0xaa>
            return j;
 801bd32:	6a3b      	ldr	r3, [r7, #32]
 801bd34:	e01c      	b.n	801bd70 <nk_utf_decode+0xe4>
    for (i = 1, j = 1; i < clen && j < len; ++i, ++j) {
 801bd36:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801bd38:	3301      	adds	r3, #1
 801bd3a:	627b      	str	r3, [r7, #36]	; 0x24
 801bd3c:	6a3b      	ldr	r3, [r7, #32]
 801bd3e:	3301      	adds	r3, #1
 801bd40:	623b      	str	r3, [r7, #32]
 801bd42:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801bd44:	687b      	ldr	r3, [r7, #4]
 801bd46:	429a      	cmp	r2, r3
 801bd48:	da03      	bge.n	801bd52 <nk_utf_decode+0xc6>
 801bd4a:	69bb      	ldr	r3, [r7, #24]
 801bd4c:	6a3a      	ldr	r2, [r7, #32]
 801bd4e:	429a      	cmp	r2, r3
 801bd50:	dbdd      	blt.n	801bd0e <nk_utf_decode+0x82>
    }
    if (j < len)
 801bd52:	69bb      	ldr	r3, [r7, #24]
 801bd54:	6a3a      	ldr	r2, [r7, #32]
 801bd56:	429a      	cmp	r2, r3
 801bd58:	da01      	bge.n	801bd5e <nk_utf_decode+0xd2>
        return 0;
 801bd5a:	2300      	movs	r3, #0
 801bd5c:	e008      	b.n	801bd70 <nk_utf_decode+0xe4>
    *u = udecoded;
 801bd5e:	68bb      	ldr	r3, [r7, #8]
 801bd60:	69fa      	ldr	r2, [r7, #28]
 801bd62:	601a      	str	r2, [r3, #0]
    nk_utf_validate(u, len);
 801bd64:	69bb      	ldr	r3, [r7, #24]
 801bd66:	4619      	mov	r1, r3
 801bd68:	68b8      	ldr	r0, [r7, #8]
 801bd6a:	f7ff fef5 	bl	801bb58 <nk_utf_validate>
    return len;
 801bd6e:	69bb      	ldr	r3, [r7, #24]
}
 801bd70:	4618      	mov	r0, r3
 801bd72:	372c      	adds	r7, #44	; 0x2c
 801bd74:	46bd      	mov	sp, r7
 801bd76:	bd90      	pop	{r4, r7, pc}
 801bd78:	080220d4 	.word	0x080220d4
 801bd7c:	080237d0 	.word	0x080237d0
 801bd80:	080220b4 	.word	0x080220b4
 801bd84:	080220b0 	.word	0x080220b0

0801bd88 <nk_memcopy>:

//#ifndef NK_MEMCPY
//#define NK_MEMCPY nk_memcopy
NK_LIB void*
nk_memcopy(void *dst0, const void *src0, nk_size length)
{
 801bd88:	b480      	push	{r7}
 801bd8a:	b089      	sub	sp, #36	; 0x24
 801bd8c:	af00      	add	r7, sp, #0
 801bd8e:	60f8      	str	r0, [r7, #12]
 801bd90:	60b9      	str	r1, [r7, #8]
 801bd92:	607a      	str	r2, [r7, #4]
    nk_ptr t;
    char *dst = (char*)dst0;
 801bd94:	68fb      	ldr	r3, [r7, #12]
 801bd96:	61bb      	str	r3, [r7, #24]
    const char *src = (const char*)src0;
 801bd98:	68bb      	ldr	r3, [r7, #8]
 801bd9a:	617b      	str	r3, [r7, #20]
    if (length == 0 || dst == src)
 801bd9c:	687b      	ldr	r3, [r7, #4]
 801bd9e:	2b00      	cmp	r3, #0
 801bda0:	f000 80c7 	beq.w	801bf32 <nk_memcopy+0x1aa>
 801bda4:	69ba      	ldr	r2, [r7, #24]
 801bda6:	697b      	ldr	r3, [r7, #20]
 801bda8:	429a      	cmp	r2, r3
 801bdaa:	f000 80c2 	beq.w	801bf32 <nk_memcopy+0x1aa>
    #define nk_wsize sizeof(nk_word)
    #define nk_wmask (nk_wsize-1)
    #define NK_TLOOP(s) if (t) NK_TLOOP1(s)
    #define NK_TLOOP1(s) do { s; } while (--t)

    if (dst < src) {
 801bdae:	69ba      	ldr	r2, [r7, #24]
 801bdb0:	697b      	ldr	r3, [r7, #20]
 801bdb2:	429a      	cmp	r2, r3
 801bdb4:	d259      	bcs.n	801be6a <nk_memcopy+0xe2>
        t = (nk_ptr)src; /* only need low bits */
 801bdb6:	697b      	ldr	r3, [r7, #20]
 801bdb8:	61fb      	str	r3, [r7, #28]
        if ((t | (nk_ptr)dst) & nk_wmask) {
 801bdba:	69ba      	ldr	r2, [r7, #24]
 801bdbc:	69fb      	ldr	r3, [r7, #28]
 801bdbe:	4313      	orrs	r3, r2
 801bdc0:	f003 0303 	and.w	r3, r3, #3
 801bdc4:	2b00      	cmp	r3, #0
 801bdc6:	d024      	beq.n	801be12 <nk_memcopy+0x8a>
            if ((t ^ (nk_ptr)dst) & nk_wmask || length < nk_wsize)
 801bdc8:	69ba      	ldr	r2, [r7, #24]
 801bdca:	69fb      	ldr	r3, [r7, #28]
 801bdcc:	4053      	eors	r3, r2
 801bdce:	f003 0303 	and.w	r3, r3, #3
 801bdd2:	2b00      	cmp	r3, #0
 801bdd4:	d102      	bne.n	801bddc <nk_memcopy+0x54>
 801bdd6:	687b      	ldr	r3, [r7, #4]
 801bdd8:	2b03      	cmp	r3, #3
 801bdda:	d802      	bhi.n	801bde2 <nk_memcopy+0x5a>
                t = length;
 801bddc:	687b      	ldr	r3, [r7, #4]
 801bdde:	61fb      	str	r3, [r7, #28]
 801bde0:	e005      	b.n	801bdee <nk_memcopy+0x66>
            else
                t = nk_wsize - (t & nk_wmask);
 801bde2:	69fb      	ldr	r3, [r7, #28]
 801bde4:	f003 0303 	and.w	r3, r3, #3
 801bde8:	f1c3 0304 	rsb	r3, r3, #4
 801bdec:	61fb      	str	r3, [r7, #28]
            length -= t;
 801bdee:	687a      	ldr	r2, [r7, #4]
 801bdf0:	69fb      	ldr	r3, [r7, #28]
 801bdf2:	1ad3      	subs	r3, r2, r3
 801bdf4:	607b      	str	r3, [r7, #4]
            NK_TLOOP1(*dst++ = *src++);
 801bdf6:	697a      	ldr	r2, [r7, #20]
 801bdf8:	1c53      	adds	r3, r2, #1
 801bdfa:	617b      	str	r3, [r7, #20]
 801bdfc:	69bb      	ldr	r3, [r7, #24]
 801bdfe:	1c59      	adds	r1, r3, #1
 801be00:	61b9      	str	r1, [r7, #24]
 801be02:	7812      	ldrb	r2, [r2, #0]
 801be04:	701a      	strb	r2, [r3, #0]
 801be06:	69fb      	ldr	r3, [r7, #28]
 801be08:	3b01      	subs	r3, #1
 801be0a:	61fb      	str	r3, [r7, #28]
 801be0c:	69fb      	ldr	r3, [r7, #28]
 801be0e:	2b00      	cmp	r3, #0
 801be10:	d1f1      	bne.n	801bdf6 <nk_memcopy+0x6e>
        }
        t = length / nk_wsize;
 801be12:	687b      	ldr	r3, [r7, #4]
 801be14:	089b      	lsrs	r3, r3, #2
 801be16:	61fb      	str	r3, [r7, #28]
        NK_TLOOP(*(nk_word*)(void*)dst = *(const nk_word*)(const void*)src;
 801be18:	69fb      	ldr	r3, [r7, #28]
 801be1a:	2b00      	cmp	r3, #0
 801be1c:	d00f      	beq.n	801be3e <nk_memcopy+0xb6>
 801be1e:	697b      	ldr	r3, [r7, #20]
 801be20:	681a      	ldr	r2, [r3, #0]
 801be22:	69bb      	ldr	r3, [r7, #24]
 801be24:	601a      	str	r2, [r3, #0]
 801be26:	697b      	ldr	r3, [r7, #20]
 801be28:	3304      	adds	r3, #4
 801be2a:	617b      	str	r3, [r7, #20]
 801be2c:	69bb      	ldr	r3, [r7, #24]
 801be2e:	3304      	adds	r3, #4
 801be30:	61bb      	str	r3, [r7, #24]
 801be32:	69fb      	ldr	r3, [r7, #28]
 801be34:	3b01      	subs	r3, #1
 801be36:	61fb      	str	r3, [r7, #28]
 801be38:	69fb      	ldr	r3, [r7, #28]
 801be3a:	2b00      	cmp	r3, #0
 801be3c:	d1ef      	bne.n	801be1e <nk_memcopy+0x96>
            src += nk_wsize; dst += nk_wsize);
        t = length & nk_wmask;
 801be3e:	687b      	ldr	r3, [r7, #4]
 801be40:	f003 0303 	and.w	r3, r3, #3
 801be44:	61fb      	str	r3, [r7, #28]
        NK_TLOOP(*dst++ = *src++);
 801be46:	69fb      	ldr	r3, [r7, #28]
 801be48:	2b00      	cmp	r3, #0
 801be4a:	d075      	beq.n	801bf38 <nk_memcopy+0x1b0>
 801be4c:	697a      	ldr	r2, [r7, #20]
 801be4e:	1c53      	adds	r3, r2, #1
 801be50:	617b      	str	r3, [r7, #20]
 801be52:	69bb      	ldr	r3, [r7, #24]
 801be54:	1c59      	adds	r1, r3, #1
 801be56:	61b9      	str	r1, [r7, #24]
 801be58:	7812      	ldrb	r2, [r2, #0]
 801be5a:	701a      	strb	r2, [r3, #0]
 801be5c:	69fb      	ldr	r3, [r7, #28]
 801be5e:	3b01      	subs	r3, #1
 801be60:	61fb      	str	r3, [r7, #28]
 801be62:	69fb      	ldr	r3, [r7, #28]
 801be64:	2b00      	cmp	r3, #0
 801be66:	d1f1      	bne.n	801be4c <nk_memcopy+0xc4>
 801be68:	e066      	b.n	801bf38 <nk_memcopy+0x1b0>
    } else {
        src += length;
 801be6a:	697a      	ldr	r2, [r7, #20]
 801be6c:	687b      	ldr	r3, [r7, #4]
 801be6e:	4413      	add	r3, r2
 801be70:	617b      	str	r3, [r7, #20]
        dst += length;
 801be72:	69ba      	ldr	r2, [r7, #24]
 801be74:	687b      	ldr	r3, [r7, #4]
 801be76:	4413      	add	r3, r2
 801be78:	61bb      	str	r3, [r7, #24]
        t = (nk_ptr)src;
 801be7a:	697b      	ldr	r3, [r7, #20]
 801be7c:	61fb      	str	r3, [r7, #28]
        if ((t | (nk_ptr)dst) & nk_wmask) {
 801be7e:	69ba      	ldr	r2, [r7, #24]
 801be80:	69fb      	ldr	r3, [r7, #28]
 801be82:	4313      	orrs	r3, r2
 801be84:	f003 0303 	and.w	r3, r3, #3
 801be88:	2b00      	cmp	r3, #0
 801be8a:	d024      	beq.n	801bed6 <nk_memcopy+0x14e>
            if ((t ^ (nk_ptr)dst) & nk_wmask || length <= nk_wsize)
 801be8c:	69ba      	ldr	r2, [r7, #24]
 801be8e:	69fb      	ldr	r3, [r7, #28]
 801be90:	4053      	eors	r3, r2
 801be92:	f003 0303 	and.w	r3, r3, #3
 801be96:	2b00      	cmp	r3, #0
 801be98:	d102      	bne.n	801bea0 <nk_memcopy+0x118>
 801be9a:	687b      	ldr	r3, [r7, #4]
 801be9c:	2b04      	cmp	r3, #4
 801be9e:	d802      	bhi.n	801bea6 <nk_memcopy+0x11e>
                t = length;
 801bea0:	687b      	ldr	r3, [r7, #4]
 801bea2:	61fb      	str	r3, [r7, #28]
 801bea4:	e003      	b.n	801beae <nk_memcopy+0x126>
            else
                t &= nk_wmask;
 801bea6:	69fb      	ldr	r3, [r7, #28]
 801bea8:	f003 0303 	and.w	r3, r3, #3
 801beac:	61fb      	str	r3, [r7, #28]
            length -= t;
 801beae:	687a      	ldr	r2, [r7, #4]
 801beb0:	69fb      	ldr	r3, [r7, #28]
 801beb2:	1ad3      	subs	r3, r2, r3
 801beb4:	607b      	str	r3, [r7, #4]
            NK_TLOOP1(*--dst = *--src);
 801beb6:	697b      	ldr	r3, [r7, #20]
 801beb8:	3b01      	subs	r3, #1
 801beba:	617b      	str	r3, [r7, #20]
 801bebc:	69bb      	ldr	r3, [r7, #24]
 801bebe:	3b01      	subs	r3, #1
 801bec0:	61bb      	str	r3, [r7, #24]
 801bec2:	697b      	ldr	r3, [r7, #20]
 801bec4:	781a      	ldrb	r2, [r3, #0]
 801bec6:	69bb      	ldr	r3, [r7, #24]
 801bec8:	701a      	strb	r2, [r3, #0]
 801beca:	69fb      	ldr	r3, [r7, #28]
 801becc:	3b01      	subs	r3, #1
 801bece:	61fb      	str	r3, [r7, #28]
 801bed0:	69fb      	ldr	r3, [r7, #28]
 801bed2:	2b00      	cmp	r3, #0
 801bed4:	d1ef      	bne.n	801beb6 <nk_memcopy+0x12e>
        }
        t = length / nk_wsize;
 801bed6:	687b      	ldr	r3, [r7, #4]
 801bed8:	089b      	lsrs	r3, r3, #2
 801beda:	61fb      	str	r3, [r7, #28]
        NK_TLOOP(src -= nk_wsize; dst -= nk_wsize;
 801bedc:	69fb      	ldr	r3, [r7, #28]
 801bede:	2b00      	cmp	r3, #0
 801bee0:	d00f      	beq.n	801bf02 <nk_memcopy+0x17a>
 801bee2:	697b      	ldr	r3, [r7, #20]
 801bee4:	3b04      	subs	r3, #4
 801bee6:	617b      	str	r3, [r7, #20]
 801bee8:	69bb      	ldr	r3, [r7, #24]
 801beea:	3b04      	subs	r3, #4
 801beec:	61bb      	str	r3, [r7, #24]
 801beee:	697b      	ldr	r3, [r7, #20]
 801bef0:	681a      	ldr	r2, [r3, #0]
 801bef2:	69bb      	ldr	r3, [r7, #24]
 801bef4:	601a      	str	r2, [r3, #0]
 801bef6:	69fb      	ldr	r3, [r7, #28]
 801bef8:	3b01      	subs	r3, #1
 801befa:	61fb      	str	r3, [r7, #28]
 801befc:	69fb      	ldr	r3, [r7, #28]
 801befe:	2b00      	cmp	r3, #0
 801bf00:	d1ef      	bne.n	801bee2 <nk_memcopy+0x15a>
            *(nk_word*)(void*)dst = *(const nk_word*)(const void*)src);
        t = length & nk_wmask;
 801bf02:	687b      	ldr	r3, [r7, #4]
 801bf04:	f003 0303 	and.w	r3, r3, #3
 801bf08:	61fb      	str	r3, [r7, #28]
        NK_TLOOP(*--dst = *--src);
 801bf0a:	69fb      	ldr	r3, [r7, #28]
 801bf0c:	2b00      	cmp	r3, #0
 801bf0e:	d012      	beq.n	801bf36 <nk_memcopy+0x1ae>
 801bf10:	697b      	ldr	r3, [r7, #20]
 801bf12:	3b01      	subs	r3, #1
 801bf14:	617b      	str	r3, [r7, #20]
 801bf16:	69bb      	ldr	r3, [r7, #24]
 801bf18:	3b01      	subs	r3, #1
 801bf1a:	61bb      	str	r3, [r7, #24]
 801bf1c:	697b      	ldr	r3, [r7, #20]
 801bf1e:	781a      	ldrb	r2, [r3, #0]
 801bf20:	69bb      	ldr	r3, [r7, #24]
 801bf22:	701a      	strb	r2, [r3, #0]
 801bf24:	69fb      	ldr	r3, [r7, #28]
 801bf26:	3b01      	subs	r3, #1
 801bf28:	61fb      	str	r3, [r7, #28]
 801bf2a:	69fb      	ldr	r3, [r7, #28]
 801bf2c:	2b00      	cmp	r3, #0
 801bf2e:	d1ef      	bne.n	801bf10 <nk_memcopy+0x188>
    #undef nk_word
    #undef nk_wsize
    #undef nk_wmask
    #undef NK_TLOOP
    #undef NK_TLOOP1
done:
 801bf30:	e001      	b.n	801bf36 <nk_memcopy+0x1ae>
        goto done;
 801bf32:	bf00      	nop
 801bf34:	e000      	b.n	801bf38 <nk_memcopy+0x1b0>
done:
 801bf36:	bf00      	nop
    return (dst0);
 801bf38:	68fb      	ldr	r3, [r7, #12]
}
 801bf3a:	4618      	mov	r0, r3
 801bf3c:	3724      	adds	r7, #36	; 0x24
 801bf3e:	46bd      	mov	sp, r7
 801bf40:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bf44:	4770      	bx	lr

0801bf46 <nk_memset>:
//#endif
//#ifndef NK_MEMSET
//#define NK_MEMSET nk_memset
NK_LIB void
nk_memset(void *ptr, int c0, nk_size size)
{
 801bf46:	b480      	push	{r7}
 801bf48:	b089      	sub	sp, #36	; 0x24
 801bf4a:	af00      	add	r7, sp, #0
 801bf4c:	60f8      	str	r0, [r7, #12]
 801bf4e:	60b9      	str	r1, [r7, #8]
 801bf50:	607a      	str	r2, [r7, #4]
    #define nk_word unsigned
    #define nk_wsize sizeof(nk_word)
    #define nk_wmask (nk_wsize - 1)
    nk_byte *dst = (nk_byte*)ptr;
 801bf52:	68fb      	ldr	r3, [r7, #12]
 801bf54:	61fb      	str	r3, [r7, #28]
    unsigned c = 0;
 801bf56:	2300      	movs	r3, #0
 801bf58:	61bb      	str	r3, [r7, #24]
    nk_size t = 0;
 801bf5a:	2300      	movs	r3, #0
 801bf5c:	617b      	str	r3, [r7, #20]

    if ((c = (nk_byte)c0) != 0) {
 801bf5e:	68bb      	ldr	r3, [r7, #8]
 801bf60:	b2db      	uxtb	r3, r3
 801bf62:	61bb      	str	r3, [r7, #24]
 801bf64:	69bb      	ldr	r3, [r7, #24]
 801bf66:	2b00      	cmp	r3, #0
 801bf68:	d009      	beq.n	801bf7e <nk_memset+0x38>
        c = (c << 8) | c; /* at least 16-bits  */
 801bf6a:	69bb      	ldr	r3, [r7, #24]
 801bf6c:	021b      	lsls	r3, r3, #8
 801bf6e:	69ba      	ldr	r2, [r7, #24]
 801bf70:	4313      	orrs	r3, r2
 801bf72:	61bb      	str	r3, [r7, #24]
        if (sizeof(unsigned int) > 2)
            c = (c << 16) | c; /* at least 32-bits*/
 801bf74:	69bb      	ldr	r3, [r7, #24]
 801bf76:	041b      	lsls	r3, r3, #16
 801bf78:	69ba      	ldr	r2, [r7, #24]
 801bf7a:	4313      	orrs	r3, r2
 801bf7c:	61bb      	str	r3, [r7, #24]
    }

    /* too small of a word count */
    dst = (nk_byte*)ptr;
 801bf7e:	68fb      	ldr	r3, [r7, #12]
 801bf80:	61fb      	str	r3, [r7, #28]
    if (size < 3 * nk_wsize) {
 801bf82:	687b      	ldr	r3, [r7, #4]
 801bf84:	2b0b      	cmp	r3, #11
 801bf86:	d80c      	bhi.n	801bfa2 <nk_memset+0x5c>
        while (size--) *dst++ = (nk_byte)c0;
 801bf88:	e005      	b.n	801bf96 <nk_memset+0x50>
 801bf8a:	69fb      	ldr	r3, [r7, #28]
 801bf8c:	1c5a      	adds	r2, r3, #1
 801bf8e:	61fa      	str	r2, [r7, #28]
 801bf90:	68ba      	ldr	r2, [r7, #8]
 801bf92:	b2d2      	uxtb	r2, r2
 801bf94:	701a      	strb	r2, [r3, #0]
 801bf96:	687b      	ldr	r3, [r7, #4]
 801bf98:	1e5a      	subs	r2, r3, #1
 801bf9a:	607a      	str	r2, [r7, #4]
 801bf9c:	2b00      	cmp	r3, #0
 801bf9e:	d1f4      	bne.n	801bf8a <nk_memset+0x44>
        return;
 801bfa0:	e03c      	b.n	801c01c <nk_memset+0xd6>
    }

    /* align destination */
    if ((t = NK_PTR_TO_UINT(dst) & nk_wmask) != 0) {
 801bfa2:	69fb      	ldr	r3, [r7, #28]
 801bfa4:	f003 0303 	and.w	r3, r3, #3
 801bfa8:	617b      	str	r3, [r7, #20]
 801bfaa:	697b      	ldr	r3, [r7, #20]
 801bfac:	2b00      	cmp	r3, #0
 801bfae:	d013      	beq.n	801bfd8 <nk_memset+0x92>
        t = nk_wsize -t;
 801bfb0:	697b      	ldr	r3, [r7, #20]
 801bfb2:	f1c3 0304 	rsb	r3, r3, #4
 801bfb6:	617b      	str	r3, [r7, #20]
        size -= t;
 801bfb8:	687a      	ldr	r2, [r7, #4]
 801bfba:	697b      	ldr	r3, [r7, #20]
 801bfbc:	1ad3      	subs	r3, r2, r3
 801bfbe:	607b      	str	r3, [r7, #4]
        do {
            *dst++ = (nk_byte)c0;
 801bfc0:	69fb      	ldr	r3, [r7, #28]
 801bfc2:	1c5a      	adds	r2, r3, #1
 801bfc4:	61fa      	str	r2, [r7, #28]
 801bfc6:	68ba      	ldr	r2, [r7, #8]
 801bfc8:	b2d2      	uxtb	r2, r2
 801bfca:	701a      	strb	r2, [r3, #0]
        } while (--t != 0);
 801bfcc:	697b      	ldr	r3, [r7, #20]
 801bfce:	3b01      	subs	r3, #1
 801bfd0:	617b      	str	r3, [r7, #20]
 801bfd2:	697b      	ldr	r3, [r7, #20]
 801bfd4:	2b00      	cmp	r3, #0
 801bfd6:	d1f3      	bne.n	801bfc0 <nk_memset+0x7a>
    }

    /* fill word */
    t = size / nk_wsize;
 801bfd8:	687b      	ldr	r3, [r7, #4]
 801bfda:	089b      	lsrs	r3, r3, #2
 801bfdc:	617b      	str	r3, [r7, #20]
    do {
        *(nk_word*)((void*)dst) = c;
 801bfde:	69fb      	ldr	r3, [r7, #28]
 801bfe0:	69ba      	ldr	r2, [r7, #24]
 801bfe2:	601a      	str	r2, [r3, #0]
        dst += nk_wsize;
 801bfe4:	69fb      	ldr	r3, [r7, #28]
 801bfe6:	3304      	adds	r3, #4
 801bfe8:	61fb      	str	r3, [r7, #28]
    } while (--t != 0);
 801bfea:	697b      	ldr	r3, [r7, #20]
 801bfec:	3b01      	subs	r3, #1
 801bfee:	617b      	str	r3, [r7, #20]
 801bff0:	697b      	ldr	r3, [r7, #20]
 801bff2:	2b00      	cmp	r3, #0
 801bff4:	d1f3      	bne.n	801bfde <nk_memset+0x98>

    /* fill trailing bytes */
    t = (size & nk_wmask);
 801bff6:	687b      	ldr	r3, [r7, #4]
 801bff8:	f003 0303 	and.w	r3, r3, #3
 801bffc:	617b      	str	r3, [r7, #20]
    if (t != 0) {
 801bffe:	697b      	ldr	r3, [r7, #20]
 801c000:	2b00      	cmp	r3, #0
 801c002:	d00b      	beq.n	801c01c <nk_memset+0xd6>
        do {
            *dst++ = (nk_byte)c0;
 801c004:	69fb      	ldr	r3, [r7, #28]
 801c006:	1c5a      	adds	r2, r3, #1
 801c008:	61fa      	str	r2, [r7, #28]
 801c00a:	68ba      	ldr	r2, [r7, #8]
 801c00c:	b2d2      	uxtb	r2, r2
 801c00e:	701a      	strb	r2, [r3, #0]
        } while (--t != 0);
 801c010:	697b      	ldr	r3, [r7, #20]
 801c012:	3b01      	subs	r3, #1
 801c014:	617b      	str	r3, [r7, #20]
 801c016:	697b      	ldr	r3, [r7, #20]
 801c018:	2b00      	cmp	r3, #0
 801c01a:	d1f3      	bne.n	801c004 <nk_memset+0xbe>
    }

    #undef nk_word
    #undef nk_wsize
    #undef nk_wmask
}
 801c01c:	3724      	adds	r7, #36	; 0x24
 801c01e:	46bd      	mov	sp, r7
 801c020:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c024:	4770      	bx	lr
	...

0801c028 <nk_zero>:
//#endif
NK_LIB void
nk_zero(void *ptr, nk_size size)
{
 801c028:	b580      	push	{r7, lr}
 801c02a:	b082      	sub	sp, #8
 801c02c:	af00      	add	r7, sp, #0
 801c02e:	6078      	str	r0, [r7, #4]
 801c030:	6039      	str	r1, [r7, #0]
    NK_ASSERT(ptr);
 801c032:	687b      	ldr	r3, [r7, #4]
 801c034:	2b00      	cmp	r3, #0
 801c036:	d105      	bne.n	801c044 <nk_zero+0x1c>
 801c038:	4b07      	ldr	r3, [pc, #28]	; (801c058 <nk_zero+0x30>)
 801c03a:	4a08      	ldr	r2, [pc, #32]	; (801c05c <nk_zero+0x34>)
 801c03c:	2184      	movs	r1, #132	; 0x84
 801c03e:	4808      	ldr	r0, [pc, #32]	; (801c060 <nk_zero+0x38>)
 801c040:	f001 fcea 	bl	801da18 <__assert_func>
    NK_MEMSET(ptr, 0, size);
 801c044:	683a      	ldr	r2, [r7, #0]
 801c046:	2100      	movs	r1, #0
 801c048:	6878      	ldr	r0, [r7, #4]
 801c04a:	f7ff ff7c 	bl	801bf46 <nk_memset>
}
 801c04e:	bf00      	nop
 801c050:	3708      	adds	r7, #8
 801c052:	46bd      	mov	sp, r7
 801c054:	bd80      	pop	{r7, pc}
 801c056:	bf00      	nop
 801c058:	080220f0 	.word	0x080220f0
 801c05c:	080237e0 	.word	0x080237e0
 801c060:	080220f4 	.word	0x080220f4

0801c064 <nk_strlen>:
NK_API int
nk_strlen(const char *str)
{
 801c064:	b580      	push	{r7, lr}
 801c066:	b084      	sub	sp, #16
 801c068:	af00      	add	r7, sp, #0
 801c06a:	6078      	str	r0, [r7, #4]
    int siz = 0;
 801c06c:	2300      	movs	r3, #0
 801c06e:	60fb      	str	r3, [r7, #12]
    NK_ASSERT(str);
 801c070:	687b      	ldr	r3, [r7, #4]
 801c072:	2b00      	cmp	r3, #0
 801c074:	d108      	bne.n	801c088 <nk_strlen+0x24>
 801c076:	4b0b      	ldr	r3, [pc, #44]	; (801c0a4 <nk_strlen+0x40>)
 801c078:	4a0b      	ldr	r2, [pc, #44]	; (801c0a8 <nk_strlen+0x44>)
 801c07a:	218b      	movs	r1, #139	; 0x8b
 801c07c:	480b      	ldr	r0, [pc, #44]	; (801c0ac <nk_strlen+0x48>)
 801c07e:	f001 fccb 	bl	801da18 <__assert_func>
    while (str && *str++ != '\0') siz++;
 801c082:	68fb      	ldr	r3, [r7, #12]
 801c084:	3301      	adds	r3, #1
 801c086:	60fb      	str	r3, [r7, #12]
 801c088:	687b      	ldr	r3, [r7, #4]
 801c08a:	2b00      	cmp	r3, #0
 801c08c:	d005      	beq.n	801c09a <nk_strlen+0x36>
 801c08e:	687b      	ldr	r3, [r7, #4]
 801c090:	1c5a      	adds	r2, r3, #1
 801c092:	607a      	str	r2, [r7, #4]
 801c094:	781b      	ldrb	r3, [r3, #0]
 801c096:	2b00      	cmp	r3, #0
 801c098:	d1f3      	bne.n	801c082 <nk_strlen+0x1e>
    return siz;
 801c09a:	68fb      	ldr	r3, [r7, #12]
}
 801c09c:	4618      	mov	r0, r3
 801c09e:	3710      	adds	r7, #16
 801c0a0:	46bd      	mov	sp, r7
 801c0a2:	bd80      	pop	{r7, pc}
 801c0a4:	08022110 	.word	0x08022110
 801c0a8:	080237e8 	.word	0x080237e8
 801c0ac:	080220f4 	.word	0x080220f4

0801c0b0 <nk_stricmpn>:
    } while (c1);
    return 0;
}
NK_API int
nk_stricmpn(const char *s1, const char *s2, int n)
{
 801c0b0:	b580      	push	{r7, lr}
 801c0b2:	b088      	sub	sp, #32
 801c0b4:	af00      	add	r7, sp, #0
 801c0b6:	60f8      	str	r0, [r7, #12]
 801c0b8:	60b9      	str	r1, [r7, #8]
 801c0ba:	607a      	str	r2, [r7, #4]
    int c1,c2,d;
    NK_ASSERT(n >= 0);
 801c0bc:	687b      	ldr	r3, [r7, #4]
 801c0be:	2b00      	cmp	r3, #0
 801c0c0:	da06      	bge.n	801c0d0 <nk_stricmpn+0x20>
 801c0c2:	4b25      	ldr	r3, [pc, #148]	; (801c158 <nk_stricmpn+0xa8>)
 801c0c4:	4a25      	ldr	r2, [pc, #148]	; (801c15c <nk_stricmpn+0xac>)
 801c0c6:	f240 1103 	movw	r1, #259	; 0x103
 801c0ca:	4825      	ldr	r0, [pc, #148]	; (801c160 <nk_stricmpn+0xb0>)
 801c0cc:	f001 fca4 	bl	801da18 <__assert_func>
    do {
        c1 = *s1++;
 801c0d0:	68fb      	ldr	r3, [r7, #12]
 801c0d2:	1c5a      	adds	r2, r3, #1
 801c0d4:	60fa      	str	r2, [r7, #12]
 801c0d6:	781b      	ldrb	r3, [r3, #0]
 801c0d8:	61bb      	str	r3, [r7, #24]
        c2 = *s2++;
 801c0da:	68bb      	ldr	r3, [r7, #8]
 801c0dc:	1c5a      	adds	r2, r3, #1
 801c0de:	60ba      	str	r2, [r7, #8]
 801c0e0:	781b      	ldrb	r3, [r3, #0]
 801c0e2:	617b      	str	r3, [r7, #20]
        if (!n--) return 0;
 801c0e4:	687b      	ldr	r3, [r7, #4]
 801c0e6:	1e5a      	subs	r2, r3, #1
 801c0e8:	607a      	str	r2, [r7, #4]
 801c0ea:	2b00      	cmp	r3, #0
 801c0ec:	d101      	bne.n	801c0f2 <nk_stricmpn+0x42>
 801c0ee:	2300      	movs	r3, #0
 801c0f0:	e02e      	b.n	801c150 <nk_stricmpn+0xa0>

        d = c1 - c2;
 801c0f2:	69ba      	ldr	r2, [r7, #24]
 801c0f4:	697b      	ldr	r3, [r7, #20]
 801c0f6:	1ad3      	subs	r3, r2, r3
 801c0f8:	61fb      	str	r3, [r7, #28]
        while (d) {
 801c0fa:	bf00      	nop
 801c0fc:	69fb      	ldr	r3, [r7, #28]
 801c0fe:	2b00      	cmp	r3, #0
 801c100:	d022      	beq.n	801c148 <nk_stricmpn+0x98>
            if (c1 <= 'Z' && c1 >= 'A') {
 801c102:	69bb      	ldr	r3, [r7, #24]
 801c104:	2b5a      	cmp	r3, #90	; 0x5a
 801c106:	dc08      	bgt.n	801c11a <nk_stricmpn+0x6a>
 801c108:	69bb      	ldr	r3, [r7, #24]
 801c10a:	2b40      	cmp	r3, #64	; 0x40
 801c10c:	dd05      	ble.n	801c11a <nk_stricmpn+0x6a>
                d += ('a' - 'A');
 801c10e:	69fb      	ldr	r3, [r7, #28]
 801c110:	3320      	adds	r3, #32
 801c112:	61fb      	str	r3, [r7, #28]
                if (!d) break;
 801c114:	69fb      	ldr	r3, [r7, #28]
 801c116:	2b00      	cmp	r3, #0
 801c118:	d013      	beq.n	801c142 <nk_stricmpn+0x92>
            }
            if (c2 <= 'Z' && c2 >= 'A') {
 801c11a:	697b      	ldr	r3, [r7, #20]
 801c11c:	2b5a      	cmp	r3, #90	; 0x5a
 801c11e:	dc08      	bgt.n	801c132 <nk_stricmpn+0x82>
 801c120:	697b      	ldr	r3, [r7, #20]
 801c122:	2b40      	cmp	r3, #64	; 0x40
 801c124:	dd05      	ble.n	801c132 <nk_stricmpn+0x82>
                d -= ('a' - 'A');
 801c126:	69fb      	ldr	r3, [r7, #28]
 801c128:	3b20      	subs	r3, #32
 801c12a:	61fb      	str	r3, [r7, #28]
                if (!d) break;
 801c12c:	69fb      	ldr	r3, [r7, #28]
 801c12e:	2b00      	cmp	r3, #0
 801c130:	d009      	beq.n	801c146 <nk_stricmpn+0x96>
            }
            return ((d >= 0) << 1) - 1;
 801c132:	69fb      	ldr	r3, [r7, #28]
 801c134:	2b00      	cmp	r3, #0
 801c136:	db01      	blt.n	801c13c <nk_stricmpn+0x8c>
 801c138:	2301      	movs	r3, #1
 801c13a:	e009      	b.n	801c150 <nk_stricmpn+0xa0>
 801c13c:	f04f 33ff 	mov.w	r3, #4294967295
 801c140:	e006      	b.n	801c150 <nk_stricmpn+0xa0>
                if (!d) break;
 801c142:	bf00      	nop
 801c144:	e000      	b.n	801c148 <nk_stricmpn+0x98>
                if (!d) break;
 801c146:	bf00      	nop
        }
    } while (c1);
 801c148:	69bb      	ldr	r3, [r7, #24]
 801c14a:	2b00      	cmp	r3, #0
 801c14c:	d1c0      	bne.n	801c0d0 <nk_stricmpn+0x20>
    return 0;
 801c14e:	2300      	movs	r3, #0
}
 801c150:	4618      	mov	r0, r3
 801c152:	3720      	adds	r7, #32
 801c154:	46bd      	mov	sp, r7
 801c156:	bd80      	pop	{r7, pc}
 801c158:	08022114 	.word	0x08022114
 801c15c:	080237f4 	.word	0x080237f4
 801c160:	080220f4 	.word	0x080220f4

0801c164 <nk_murmur_hash>:
    return result;
}
#endif
NK_API nk_hash
nk_murmur_hash(const void * key, int len, nk_hash seed)
{
 801c164:	b480      	push	{r7}
 801c166:	b091      	sub	sp, #68	; 0x44
 801c168:	af00      	add	r7, sp, #0
 801c16a:	60f8      	str	r0, [r7, #12]
 801c16c:	60b9      	str	r1, [r7, #8]
 801c16e:	607a      	str	r2, [r7, #4]
    /* 32-Bit MurmurHash3: https://code.google.com/p/smhasher/wiki/MurmurHash3*/
    #define NK_ROTL(x,r) ((x) << (r) | ((x) >> (32 - r)))

    nk_uint h1 = seed;
 801c170:	687b      	ldr	r3, [r7, #4]
 801c172:	63fb      	str	r3, [r7, #60]	; 0x3c
    nk_uint k1;
    const nk_byte *data = (const nk_byte*)key;
 801c174:	68fb      	ldr	r3, [r7, #12]
 801c176:	633b      	str	r3, [r7, #48]	; 0x30
    const nk_byte *keyptr = data;
 801c178:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c17a:	63bb      	str	r3, [r7, #56]	; 0x38
    nk_byte *k1ptr;
    const int bsize = sizeof(k1);
 801c17c:	2304      	movs	r3, #4
 801c17e:	62fb      	str	r3, [r7, #44]	; 0x2c
    const int nblocks = len/4;
 801c180:	68bb      	ldr	r3, [r7, #8]
 801c182:	2b00      	cmp	r3, #0
 801c184:	da00      	bge.n	801c188 <nk_murmur_hash+0x24>
 801c186:	3303      	adds	r3, #3
 801c188:	109b      	asrs	r3, r3, #2
 801c18a:	62bb      	str	r3, [r7, #40]	; 0x28

    const nk_uint c1 = 0xcc9e2d51;
 801c18c:	4b57      	ldr	r3, [pc, #348]	; (801c2ec <nk_murmur_hash+0x188>)
 801c18e:	627b      	str	r3, [r7, #36]	; 0x24
    const nk_uint c2 = 0x1b873593;
 801c190:	4b57      	ldr	r3, [pc, #348]	; (801c2f0 <nk_murmur_hash+0x18c>)
 801c192:	623b      	str	r3, [r7, #32]
    const nk_byte *tail;
    int i;

    /* body */
    if (!key) return 0;
 801c194:	68fb      	ldr	r3, [r7, #12]
 801c196:	2b00      	cmp	r3, #0
 801c198:	d101      	bne.n	801c19e <nk_murmur_hash+0x3a>
 801c19a:	2300      	movs	r3, #0
 801c19c:	e09f      	b.n	801c2de <nk_murmur_hash+0x17a>
    for (i = 0; i < nblocks; ++i, keyptr += bsize) {
 801c19e:	2300      	movs	r3, #0
 801c1a0:	637b      	str	r3, [r7, #52]	; 0x34
 801c1a2:	e03c      	b.n	801c21e <nk_murmur_hash+0xba>
        k1ptr = (nk_byte*)&k1;
 801c1a4:	f107 0314 	add.w	r3, r7, #20
 801c1a8:	61bb      	str	r3, [r7, #24]
        k1ptr[0] = keyptr[0];
 801c1aa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c1ac:	781a      	ldrb	r2, [r3, #0]
 801c1ae:	69bb      	ldr	r3, [r7, #24]
 801c1b0:	701a      	strb	r2, [r3, #0]
        k1ptr[1] = keyptr[1];
 801c1b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c1b4:	1c5a      	adds	r2, r3, #1
 801c1b6:	69bb      	ldr	r3, [r7, #24]
 801c1b8:	3301      	adds	r3, #1
 801c1ba:	7812      	ldrb	r2, [r2, #0]
 801c1bc:	701a      	strb	r2, [r3, #0]
        k1ptr[2] = keyptr[2];
 801c1be:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c1c0:	1c9a      	adds	r2, r3, #2
 801c1c2:	69bb      	ldr	r3, [r7, #24]
 801c1c4:	3302      	adds	r3, #2
 801c1c6:	7812      	ldrb	r2, [r2, #0]
 801c1c8:	701a      	strb	r2, [r3, #0]
        k1ptr[3] = keyptr[3];
 801c1ca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c1cc:	1cda      	adds	r2, r3, #3
 801c1ce:	69bb      	ldr	r3, [r7, #24]
 801c1d0:	3303      	adds	r3, #3
 801c1d2:	7812      	ldrb	r2, [r2, #0]
 801c1d4:	701a      	strb	r2, [r3, #0]

        k1 *= c1;
 801c1d6:	697b      	ldr	r3, [r7, #20]
 801c1d8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801c1da:	fb02 f303 	mul.w	r3, r2, r3
 801c1de:	617b      	str	r3, [r7, #20]
        k1 = NK_ROTL(k1,15);
 801c1e0:	697b      	ldr	r3, [r7, #20]
 801c1e2:	ea4f 4373 	mov.w	r3, r3, ror #17
 801c1e6:	617b      	str	r3, [r7, #20]
        k1 *= c2;
 801c1e8:	697b      	ldr	r3, [r7, #20]
 801c1ea:	6a3a      	ldr	r2, [r7, #32]
 801c1ec:	fb02 f303 	mul.w	r3, r2, r3
 801c1f0:	617b      	str	r3, [r7, #20]

        h1 ^= k1;
 801c1f2:	697b      	ldr	r3, [r7, #20]
 801c1f4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801c1f6:	4053      	eors	r3, r2
 801c1f8:	63fb      	str	r3, [r7, #60]	; 0x3c
        h1 = NK_ROTL(h1,13);
 801c1fa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c1fc:	ea4f 43f3 	mov.w	r3, r3, ror #19
 801c200:	63fb      	str	r3, [r7, #60]	; 0x3c
        h1 = h1*5+0xe6546b64;
 801c202:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801c204:	4613      	mov	r3, r2
 801c206:	009b      	lsls	r3, r3, #2
 801c208:	441a      	add	r2, r3
 801c20a:	4b3a      	ldr	r3, [pc, #232]	; (801c2f4 <nk_murmur_hash+0x190>)
 801c20c:	4413      	add	r3, r2
 801c20e:	63fb      	str	r3, [r7, #60]	; 0x3c
    for (i = 0; i < nblocks; ++i, keyptr += bsize) {
 801c210:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c212:	3301      	adds	r3, #1
 801c214:	637b      	str	r3, [r7, #52]	; 0x34
 801c216:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c218:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801c21a:	4413      	add	r3, r2
 801c21c:	63bb      	str	r3, [r7, #56]	; 0x38
 801c21e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801c220:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c222:	429a      	cmp	r2, r3
 801c224:	dbbe      	blt.n	801c1a4 <nk_murmur_hash+0x40>
    }

    /* tail */
    tail = (const nk_byte*)(data + nblocks*4);
 801c226:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c228:	009b      	lsls	r3, r3, #2
 801c22a:	461a      	mov	r2, r3
 801c22c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c22e:	4413      	add	r3, r2
 801c230:	61fb      	str	r3, [r7, #28]
    k1 = 0;
 801c232:	2300      	movs	r3, #0
 801c234:	617b      	str	r3, [r7, #20]
    switch (len & 3) {
 801c236:	68bb      	ldr	r3, [r7, #8]
 801c238:	f003 0303 	and.w	r3, r3, #3
 801c23c:	2b03      	cmp	r3, #3
 801c23e:	d006      	beq.n	801c24e <nk_murmur_hash+0xea>
 801c240:	2b03      	cmp	r3, #3
 801c242:	dc2d      	bgt.n	801c2a0 <nk_murmur_hash+0x13c>
 801c244:	2b01      	cmp	r3, #1
 801c246:	d012      	beq.n	801c26e <nk_murmur_hash+0x10a>
 801c248:	2b02      	cmp	r3, #2
 801c24a:	d008      	beq.n	801c25e <nk_murmur_hash+0xfa>
            k1 *= c1;
            k1 = NK_ROTL(k1,15);
            k1 *= c2;
            h1 ^= k1;
            break;
        default: break;
 801c24c:	e028      	b.n	801c2a0 <nk_murmur_hash+0x13c>
        case 3: k1 ^= (nk_uint)(tail[2] << 16); /* fallthrough */
 801c24e:	69fb      	ldr	r3, [r7, #28]
 801c250:	3302      	adds	r3, #2
 801c252:	781b      	ldrb	r3, [r3, #0]
 801c254:	041b      	lsls	r3, r3, #16
 801c256:	461a      	mov	r2, r3
 801c258:	697b      	ldr	r3, [r7, #20]
 801c25a:	4053      	eors	r3, r2
 801c25c:	617b      	str	r3, [r7, #20]
        case 2: k1 ^= (nk_uint)(tail[1] << 8u); /* fallthrough */
 801c25e:	69fb      	ldr	r3, [r7, #28]
 801c260:	3301      	adds	r3, #1
 801c262:	781b      	ldrb	r3, [r3, #0]
 801c264:	021b      	lsls	r3, r3, #8
 801c266:	461a      	mov	r2, r3
 801c268:	697b      	ldr	r3, [r7, #20]
 801c26a:	4053      	eors	r3, r2
 801c26c:	617b      	str	r3, [r7, #20]
        case 1: k1 ^= tail[0];
 801c26e:	69fb      	ldr	r3, [r7, #28]
 801c270:	781b      	ldrb	r3, [r3, #0]
 801c272:	461a      	mov	r2, r3
 801c274:	697b      	ldr	r3, [r7, #20]
 801c276:	4053      	eors	r3, r2
 801c278:	617b      	str	r3, [r7, #20]
            k1 *= c1;
 801c27a:	697b      	ldr	r3, [r7, #20]
 801c27c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801c27e:	fb02 f303 	mul.w	r3, r2, r3
 801c282:	617b      	str	r3, [r7, #20]
            k1 = NK_ROTL(k1,15);
 801c284:	697b      	ldr	r3, [r7, #20]
 801c286:	ea4f 4373 	mov.w	r3, r3, ror #17
 801c28a:	617b      	str	r3, [r7, #20]
            k1 *= c2;
 801c28c:	697b      	ldr	r3, [r7, #20]
 801c28e:	6a3a      	ldr	r2, [r7, #32]
 801c290:	fb02 f303 	mul.w	r3, r2, r3
 801c294:	617b      	str	r3, [r7, #20]
            h1 ^= k1;
 801c296:	697b      	ldr	r3, [r7, #20]
 801c298:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801c29a:	4053      	eors	r3, r2
 801c29c:	63fb      	str	r3, [r7, #60]	; 0x3c
            break;
 801c29e:	e000      	b.n	801c2a2 <nk_murmur_hash+0x13e>
        default: break;
 801c2a0:	bf00      	nop
    }

    /* finalization */
    h1 ^= (nk_uint)len;
 801c2a2:	68bb      	ldr	r3, [r7, #8]
 801c2a4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801c2a6:	4053      	eors	r3, r2
 801c2a8:	63fb      	str	r3, [r7, #60]	; 0x3c
    /* fmix32 */
    h1 ^= h1 >> 16;
 801c2aa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c2ac:	0c1b      	lsrs	r3, r3, #16
 801c2ae:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801c2b0:	4053      	eors	r3, r2
 801c2b2:	63fb      	str	r3, [r7, #60]	; 0x3c
    h1 *= 0x85ebca6b;
 801c2b4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c2b6:	4a10      	ldr	r2, [pc, #64]	; (801c2f8 <nk_murmur_hash+0x194>)
 801c2b8:	fb02 f303 	mul.w	r3, r2, r3
 801c2bc:	63fb      	str	r3, [r7, #60]	; 0x3c
    h1 ^= h1 >> 13;
 801c2be:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c2c0:	0b5b      	lsrs	r3, r3, #13
 801c2c2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801c2c4:	4053      	eors	r3, r2
 801c2c6:	63fb      	str	r3, [r7, #60]	; 0x3c
    h1 *= 0xc2b2ae35;
 801c2c8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c2ca:	4a0c      	ldr	r2, [pc, #48]	; (801c2fc <nk_murmur_hash+0x198>)
 801c2cc:	fb02 f303 	mul.w	r3, r2, r3
 801c2d0:	63fb      	str	r3, [r7, #60]	; 0x3c
    h1 ^= h1 >> 16;
 801c2d2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c2d4:	0c1b      	lsrs	r3, r3, #16
 801c2d6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801c2d8:	4053      	eors	r3, r2
 801c2da:	63fb      	str	r3, [r7, #60]	; 0x3c

    #undef NK_ROTL
    return h1;
 801c2dc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
 801c2de:	4618      	mov	r0, r3
 801c2e0:	3744      	adds	r7, #68	; 0x44
 801c2e2:	46bd      	mov	sp, r7
 801c2e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c2e8:	4770      	bx	lr
 801c2ea:	bf00      	nop
 801c2ec:	cc9e2d51 	.word	0xcc9e2d51
 801c2f0:	1b873593 	.word	0x1b873593
 801c2f4:	e6546b64 	.word	0xe6546b64
 801c2f8:	85ebca6b 	.word	0x85ebca6b
 801c2fc:	c2b2ae35 	.word	0xc2b2ae35

0801c300 <nk_text_clamp>:
#endif
NK_LIB int
nk_text_clamp(const struct nk_user_font *font, const char *text,
    int text_len, float space, int *glyphs, float *text_width,
    nk_rune *sep_list, int sep_count)
{
 801c300:	b580      	push	{r7, lr}
 801c302:	b092      	sub	sp, #72	; 0x48
 801c304:	af00      	add	r7, sp, #0
 801c306:	6178      	str	r0, [r7, #20]
 801c308:	6139      	str	r1, [r7, #16]
 801c30a:	60fa      	str	r2, [r7, #12]
 801c30c:	ed87 0a02 	vstr	s0, [r7, #8]
 801c310:	607b      	str	r3, [r7, #4]
    int i = 0;
 801c312:	2300      	movs	r3, #0
 801c314:	647b      	str	r3, [r7, #68]	; 0x44
    int glyph_len = 0;
 801c316:	2300      	movs	r3, #0
 801c318:	643b      	str	r3, [r7, #64]	; 0x40
    float last_width = 0;
 801c31a:	f04f 0300 	mov.w	r3, #0
 801c31e:	63fb      	str	r3, [r7, #60]	; 0x3c
    nk_rune unicode = 0;
 801c320:	2300      	movs	r3, #0
 801c322:	61fb      	str	r3, [r7, #28]
    float width = 0;
 801c324:	f04f 0300 	mov.w	r3, #0
 801c328:	63bb      	str	r3, [r7, #56]	; 0x38
    int len = 0;
 801c32a:	2300      	movs	r3, #0
 801c32c:	637b      	str	r3, [r7, #52]	; 0x34
    int g = 0;
 801c32e:	2300      	movs	r3, #0
 801c330:	633b      	str	r3, [r7, #48]	; 0x30
    float s;

    int sep_len = 0;
 801c332:	2300      	movs	r3, #0
 801c334:	62fb      	str	r3, [r7, #44]	; 0x2c
    int sep_g = 0;
 801c336:	2300      	movs	r3, #0
 801c338:	62bb      	str	r3, [r7, #40]	; 0x28
    float sep_width = 0;
 801c33a:	f04f 0300 	mov.w	r3, #0
 801c33e:	627b      	str	r3, [r7, #36]	; 0x24
    sep_count = NK_MAX(sep_count,0);
 801c340:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801c342:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 801c346:	65bb      	str	r3, [r7, #88]	; 0x58

    glyph_len = nk_utf_decode(text, &unicode, text_len);
 801c348:	f107 031c 	add.w	r3, r7, #28
 801c34c:	68fa      	ldr	r2, [r7, #12]
 801c34e:	4619      	mov	r1, r3
 801c350:	6938      	ldr	r0, [r7, #16]
 801c352:	f7ff fc9b 	bl	801bc8c <nk_utf_decode>
 801c356:	6438      	str	r0, [r7, #64]	; 0x40
    while (glyph_len && (width < space) && (len < text_len)) {
 801c358:	e04a      	b.n	801c3f0 <nk_text_clamp+0xf0>
        len += glyph_len;
 801c35a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801c35c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c35e:	4413      	add	r3, r2
 801c360:	637b      	str	r3, [r7, #52]	; 0x34
        s = font->width(font->userdata, font->height, text, len);
 801c362:	697b      	ldr	r3, [r7, #20]
 801c364:	689b      	ldr	r3, [r3, #8]
 801c366:	697a      	ldr	r2, [r7, #20]
 801c368:	edd2 7a01 	vldr	s15, [r2, #4]
 801c36c:	6978      	ldr	r0, [r7, #20]
 801c36e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801c370:	6939      	ldr	r1, [r7, #16]
 801c372:	eeb0 0a67 	vmov.f32	s0, s15
 801c376:	6800      	ldr	r0, [r0, #0]
 801c378:	4798      	blx	r3
 801c37a:	ed87 0a08 	vstr	s0, [r7, #32]
        for (i = 0; i < sep_count; ++i) {
 801c37e:	2300      	movs	r3, #0
 801c380:	647b      	str	r3, [r7, #68]	; 0x44
 801c382:	e015      	b.n	801c3b0 <nk_text_clamp+0xb0>
            if (unicode != sep_list[i]) continue;
 801c384:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c386:	009b      	lsls	r3, r3, #2
 801c388:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801c38a:	4413      	add	r3, r2
 801c38c:	681a      	ldr	r2, [r3, #0]
 801c38e:	69fb      	ldr	r3, [r7, #28]
 801c390:	429a      	cmp	r2, r3
 801c392:	d109      	bne.n	801c3a8 <nk_text_clamp+0xa8>
            sep_width = last_width = width;
 801c394:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c396:	63fb      	str	r3, [r7, #60]	; 0x3c
 801c398:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c39a:	627b      	str	r3, [r7, #36]	; 0x24
            sep_g = g+1;
 801c39c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c39e:	3301      	adds	r3, #1
 801c3a0:	62bb      	str	r3, [r7, #40]	; 0x28
            sep_len = len;
 801c3a2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c3a4:	62fb      	str	r3, [r7, #44]	; 0x2c
            break;
 801c3a6:	e007      	b.n	801c3b8 <nk_text_clamp+0xb8>
            if (unicode != sep_list[i]) continue;
 801c3a8:	bf00      	nop
        for (i = 0; i < sep_count; ++i) {
 801c3aa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c3ac:	3301      	adds	r3, #1
 801c3ae:	647b      	str	r3, [r7, #68]	; 0x44
 801c3b0:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801c3b2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801c3b4:	429a      	cmp	r2, r3
 801c3b6:	dbe5      	blt.n	801c384 <nk_text_clamp+0x84>
        }
        if (i == sep_count){
 801c3b8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801c3ba:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801c3bc:	429a      	cmp	r2, r3
 801c3be:	d106      	bne.n	801c3ce <nk_text_clamp+0xce>
            last_width = sep_width = width;
 801c3c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c3c2:	627b      	str	r3, [r7, #36]	; 0x24
 801c3c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c3c6:	63fb      	str	r3, [r7, #60]	; 0x3c
            sep_g = g+1;
 801c3c8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c3ca:	3301      	adds	r3, #1
 801c3cc:	62bb      	str	r3, [r7, #40]	; 0x28
        }
        width = s;
 801c3ce:	6a3b      	ldr	r3, [r7, #32]
 801c3d0:	63bb      	str	r3, [r7, #56]	; 0x38
        glyph_len = nk_utf_decode(&text[len], &unicode, text_len - len);
 801c3d2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c3d4:	693a      	ldr	r2, [r7, #16]
 801c3d6:	18d0      	adds	r0, r2, r3
 801c3d8:	68fa      	ldr	r2, [r7, #12]
 801c3da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c3dc:	1ad2      	subs	r2, r2, r3
 801c3de:	f107 031c 	add.w	r3, r7, #28
 801c3e2:	4619      	mov	r1, r3
 801c3e4:	f7ff fc52 	bl	801bc8c <nk_utf_decode>
 801c3e8:	6438      	str	r0, [r7, #64]	; 0x40
        g++;
 801c3ea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c3ec:	3301      	adds	r3, #1
 801c3ee:	633b      	str	r3, [r7, #48]	; 0x30
    while (glyph_len && (width < space) && (len < text_len)) {
 801c3f0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c3f2:	2b00      	cmp	r3, #0
 801c3f4:	d00c      	beq.n	801c410 <nk_text_clamp+0x110>
 801c3f6:	ed97 7a0e 	vldr	s14, [r7, #56]	; 0x38
 801c3fa:	edd7 7a02 	vldr	s15, [r7, #8]
 801c3fe:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801c402:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c406:	d503      	bpl.n	801c410 <nk_text_clamp+0x110>
 801c408:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801c40a:	68fb      	ldr	r3, [r7, #12]
 801c40c:	429a      	cmp	r2, r3
 801c40e:	dba4      	blt.n	801c35a <nk_text_clamp+0x5a>
    }
    if (len >= text_len) {
 801c410:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801c412:	68fb      	ldr	r3, [r7, #12]
 801c414:	429a      	cmp	r2, r3
 801c416:	db07      	blt.n	801c428 <nk_text_clamp+0x128>
        *glyphs = g;
 801c418:	687b      	ldr	r3, [r7, #4]
 801c41a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801c41c:	601a      	str	r2, [r3, #0]
        *text_width = last_width;
 801c41e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801c420:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801c422:	601a      	str	r2, [r3, #0]
        return len;
 801c424:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c426:	e00b      	b.n	801c440 <nk_text_clamp+0x140>
    } else {
        *glyphs = sep_g;
 801c428:	687b      	ldr	r3, [r7, #4]
 801c42a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801c42c:	601a      	str	r2, [r3, #0]
        *text_width = sep_width;
 801c42e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801c430:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801c432:	601a      	str	r2, [r3, #0]
        return (!sep_len) ? len: sep_len;
 801c434:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c436:	2b00      	cmp	r3, #0
 801c438:	d101      	bne.n	801c43e <nk_text_clamp+0x13e>
 801c43a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c43c:	e000      	b.n	801c440 <nk_text_clamp+0x140>
 801c43e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    }
}
 801c440:	4618      	mov	r0, r3
 801c442:	3748      	adds	r7, #72	; 0x48
 801c444:	46bd      	mov	sp, r7
 801c446:	bd80      	pop	{r7, pc}

0801c448 <nk_widget>:
        return 0;
    return nk_input_has_mouse_click_down_in_rect(&ctx->input, btn, bounds, down);
}
NK_API enum nk_widget_layout_states
nk_widget(struct nk_rect *bounds, const struct nk_context *ctx)
{
 801c448:	b590      	push	{r4, r7, lr}
 801c44a:	b08f      	sub	sp, #60	; 0x3c
 801c44c:	af00      	add	r7, sp, #0
 801c44e:	6078      	str	r0, [r7, #4]
 801c450:	6039      	str	r1, [r7, #0]
    struct nk_rect c, v;
    struct nk_window *win;
    struct nk_panel *layout;
    const struct nk_input *in;

    NK_ASSERT(ctx);
 801c452:	683b      	ldr	r3, [r7, #0]
 801c454:	2b00      	cmp	r3, #0
 801c456:	d105      	bne.n	801c464 <nk_widget+0x1c>
 801c458:	4b9d      	ldr	r3, [pc, #628]	; (801c6d0 <nk_widget+0x288>)
 801c45a:	4a9e      	ldr	r2, [pc, #632]	; (801c6d4 <nk_widget+0x28c>)
 801c45c:	218e      	movs	r1, #142	; 0x8e
 801c45e:	489e      	ldr	r0, [pc, #632]	; (801c6d8 <nk_widget+0x290>)
 801c460:	f001 fada 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 801c464:	683b      	ldr	r3, [r7, #0]
 801c466:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801c46a:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801c46e:	2b00      	cmp	r3, #0
 801c470:	d105      	bne.n	801c47e <nk_widget+0x36>
 801c472:	4b9a      	ldr	r3, [pc, #616]	; (801c6dc <nk_widget+0x294>)
 801c474:	4a97      	ldr	r2, [pc, #604]	; (801c6d4 <nk_widget+0x28c>)
 801c476:	218f      	movs	r1, #143	; 0x8f
 801c478:	4897      	ldr	r0, [pc, #604]	; (801c6d8 <nk_widget+0x290>)
 801c47a:	f001 facd 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 801c47e:	683b      	ldr	r3, [r7, #0]
 801c480:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801c484:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801c488:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801c48c:	2b00      	cmp	r3, #0
 801c48e:	d105      	bne.n	801c49c <nk_widget+0x54>
 801c490:	4b93      	ldr	r3, [pc, #588]	; (801c6e0 <nk_widget+0x298>)
 801c492:	4a90      	ldr	r2, [pc, #576]	; (801c6d4 <nk_widget+0x28c>)
 801c494:	2190      	movs	r1, #144	; 0x90
 801c496:	4890      	ldr	r0, [pc, #576]	; (801c6d8 <nk_widget+0x290>)
 801c498:	f001 fabe 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout)
 801c49c:	683b      	ldr	r3, [r7, #0]
 801c49e:	2b00      	cmp	r3, #0
 801c4a0:	d00f      	beq.n	801c4c2 <nk_widget+0x7a>
 801c4a2:	683b      	ldr	r3, [r7, #0]
 801c4a4:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801c4a8:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801c4ac:	2b00      	cmp	r3, #0
 801c4ae:	d008      	beq.n	801c4c2 <nk_widget+0x7a>
 801c4b0:	683b      	ldr	r3, [r7, #0]
 801c4b2:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801c4b6:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801c4ba:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801c4be:	2b00      	cmp	r3, #0
 801c4c0:	d101      	bne.n	801c4c6 <nk_widget+0x7e>
        return NK_WIDGET_INVALID;
 801c4c2:	2300      	movs	r3, #0
 801c4c4:	e167      	b.n	801c796 <nk_widget+0x34e>

    /* allocate space and check if the widget needs to be updated and drawn */
    nk_panel_alloc_space(bounds, ctx);
 801c4c6:	6839      	ldr	r1, [r7, #0]
 801c4c8:	6878      	ldr	r0, [r7, #4]
 801c4ca:	f7f7 f8ab 	bl	8013624 <nk_panel_alloc_space>
    win = ctx->current;
 801c4ce:	683b      	ldr	r3, [r7, #0]
 801c4d0:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801c4d4:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801c4d8:	637b      	str	r3, [r7, #52]	; 0x34
    layout = win->layout;
 801c4da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c4dc:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801c4e0:	633b      	str	r3, [r7, #48]	; 0x30
    in = &ctx->input;
 801c4e2:	683b      	ldr	r3, [r7, #0]
 801c4e4:	62fb      	str	r3, [r7, #44]	; 0x2c
    c = layout->clip;
 801c4e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c4e8:	f107 041c 	add.w	r4, r7, #28
 801c4ec:	333c      	adds	r3, #60	; 0x3c
 801c4ee:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801c4f0:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    /*  if one of these triggers you forgot to add an `if` condition around either
        a window, group, popup, combobox or contextual menu `begin` and `end` block.
        Example:
            if (nk_begin(...) {...} nk_end(...); or
            if (nk_group_begin(...) { nk_group_end(...);} */
    NK_ASSERT(!(layout->flags & NK_WINDOW_MINIMIZED));
 801c4f4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c4f6:	685b      	ldr	r3, [r3, #4]
 801c4f8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 801c4fc:	2b00      	cmp	r3, #0
 801c4fe:	d005      	beq.n	801c50c <nk_widget+0xc4>
 801c500:	4b78      	ldr	r3, [pc, #480]	; (801c6e4 <nk_widget+0x29c>)
 801c502:	4a74      	ldr	r2, [pc, #464]	; (801c6d4 <nk_widget+0x28c>)
 801c504:	21a0      	movs	r1, #160	; 0xa0
 801c506:	4874      	ldr	r0, [pc, #464]	; (801c6d8 <nk_widget+0x290>)
 801c508:	f001 fa86 	bl	801da18 <__assert_func>
    NK_ASSERT(!(layout->flags & NK_WINDOW_HIDDEN));
 801c50c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c50e:	685b      	ldr	r3, [r3, #4]
 801c510:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801c514:	2b00      	cmp	r3, #0
 801c516:	d005      	beq.n	801c524 <nk_widget+0xdc>
 801c518:	4b73      	ldr	r3, [pc, #460]	; (801c6e8 <nk_widget+0x2a0>)
 801c51a:	4a6e      	ldr	r2, [pc, #440]	; (801c6d4 <nk_widget+0x28c>)
 801c51c:	21a1      	movs	r1, #161	; 0xa1
 801c51e:	486e      	ldr	r0, [pc, #440]	; (801c6d8 <nk_widget+0x290>)
 801c520:	f001 fa7a 	bl	801da18 <__assert_func>
    NK_ASSERT(!(layout->flags & NK_WINDOW_CLOSED));
 801c524:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c526:	685b      	ldr	r3, [r3, #4]
 801c528:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 801c52c:	2b00      	cmp	r3, #0
 801c52e:	d005      	beq.n	801c53c <nk_widget+0xf4>
 801c530:	4b6e      	ldr	r3, [pc, #440]	; (801c6ec <nk_widget+0x2a4>)
 801c532:	4a68      	ldr	r2, [pc, #416]	; (801c6d4 <nk_widget+0x28c>)
 801c534:	21a2      	movs	r1, #162	; 0xa2
 801c536:	4868      	ldr	r0, [pc, #416]	; (801c6d8 <nk_widget+0x290>)
 801c538:	f001 fa6e 	bl	801da18 <__assert_func>

    /* need to convert to int here to remove floating point errors */
    bounds->x = (float)((int)bounds->x);
 801c53c:	687b      	ldr	r3, [r7, #4]
 801c53e:	edd3 7a00 	vldr	s15, [r3]
 801c542:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c546:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801c54a:	687b      	ldr	r3, [r7, #4]
 801c54c:	edc3 7a00 	vstr	s15, [r3]
    bounds->y = (float)((int)bounds->y);
 801c550:	687b      	ldr	r3, [r7, #4]
 801c552:	edd3 7a01 	vldr	s15, [r3, #4]
 801c556:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c55a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801c55e:	687b      	ldr	r3, [r7, #4]
 801c560:	edc3 7a01 	vstr	s15, [r3, #4]
    bounds->w = (float)((int)bounds->w);
 801c564:	687b      	ldr	r3, [r7, #4]
 801c566:	edd3 7a02 	vldr	s15, [r3, #8]
 801c56a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c56e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801c572:	687b      	ldr	r3, [r7, #4]
 801c574:	edc3 7a02 	vstr	s15, [r3, #8]
    bounds->h = (float)((int)bounds->h);
 801c578:	687b      	ldr	r3, [r7, #4]
 801c57a:	edd3 7a03 	vldr	s15, [r3, #12]
 801c57e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c582:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801c586:	687b      	ldr	r3, [r7, #4]
 801c588:	edc3 7a03 	vstr	s15, [r3, #12]

    c.x = (float)((int)c.x);
 801c58c:	edd7 7a07 	vldr	s15, [r7, #28]
 801c590:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c594:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801c598:	edc7 7a07 	vstr	s15, [r7, #28]
    c.y = (float)((int)c.y);
 801c59c:	edd7 7a08 	vldr	s15, [r7, #32]
 801c5a0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c5a4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801c5a8:	edc7 7a08 	vstr	s15, [r7, #32]
    c.w = (float)((int)c.w);
 801c5ac:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 801c5b0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c5b4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801c5b8:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
    c.h = (float)((int)c.h);
 801c5bc:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
 801c5c0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c5c4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801c5c8:	edc7 7a0a 	vstr	s15, [r7, #40]	; 0x28

    nk_unify(&v, &c, bounds->x, bounds->y, bounds->x + bounds->w, bounds->y + bounds->h);
 801c5cc:	687b      	ldr	r3, [r7, #4]
 801c5ce:	edd3 6a00 	vldr	s13, [r3]
 801c5d2:	687b      	ldr	r3, [r7, #4]
 801c5d4:	ed93 6a01 	vldr	s12, [r3, #4]
 801c5d8:	687b      	ldr	r3, [r7, #4]
 801c5da:	ed93 7a00 	vldr	s14, [r3]
 801c5de:	687b      	ldr	r3, [r7, #4]
 801c5e0:	edd3 7a02 	vldr	s15, [r3, #8]
 801c5e4:	ee77 5a27 	vadd.f32	s11, s14, s15
 801c5e8:	687b      	ldr	r3, [r7, #4]
 801c5ea:	ed93 7a01 	vldr	s14, [r3, #4]
 801c5ee:	687b      	ldr	r3, [r7, #4]
 801c5f0:	edd3 7a03 	vldr	s15, [r3, #12]
 801c5f4:	ee77 7a27 	vadd.f32	s15, s14, s15
 801c5f8:	f107 021c 	add.w	r2, r7, #28
 801c5fc:	f107 030c 	add.w	r3, r7, #12
 801c600:	eef0 1a67 	vmov.f32	s3, s15
 801c604:	eeb0 1a65 	vmov.f32	s2, s11
 801c608:	eef0 0a46 	vmov.f32	s1, s12
 801c60c:	eeb0 0a66 	vmov.f32	s0, s13
 801c610:	4611      	mov	r1, r2
 801c612:	4618      	mov	r0, r3
 801c614:	f7f7 f972 	bl	80138fc <nk_unify>
    if (!NK_INTERSECT(c.x, c.y, c.w, c.h, bounds->x, bounds->y, bounds->w, bounds->h))
 801c618:	687b      	ldr	r3, [r7, #4]
 801c61a:	ed93 7a00 	vldr	s14, [r3]
 801c61e:	edd7 6a07 	vldr	s13, [r7, #28]
 801c622:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 801c626:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801c62a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801c62e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c632:	bf4c      	ite	mi
 801c634:	2301      	movmi	r3, #1
 801c636:	2300      	movpl	r3, #0
 801c638:	b2db      	uxtb	r3, r3
 801c63a:	f083 0301 	eor.w	r3, r3, #1
 801c63e:	b2db      	uxtb	r3, r3
 801c640:	2b00      	cmp	r3, #0
 801c642:	d143      	bne.n	801c6cc <nk_widget+0x284>
 801c644:	ed97 7a07 	vldr	s14, [r7, #28]
 801c648:	687b      	ldr	r3, [r7, #4]
 801c64a:	edd3 6a00 	vldr	s13, [r3]
 801c64e:	687b      	ldr	r3, [r7, #4]
 801c650:	edd3 7a02 	vldr	s15, [r3, #8]
 801c654:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801c658:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801c65c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c660:	bf4c      	ite	mi
 801c662:	2301      	movmi	r3, #1
 801c664:	2300      	movpl	r3, #0
 801c666:	b2db      	uxtb	r3, r3
 801c668:	f083 0301 	eor.w	r3, r3, #1
 801c66c:	b2db      	uxtb	r3, r3
 801c66e:	2b00      	cmp	r3, #0
 801c670:	d12c      	bne.n	801c6cc <nk_widget+0x284>
 801c672:	687b      	ldr	r3, [r7, #4]
 801c674:	ed93 7a01 	vldr	s14, [r3, #4]
 801c678:	edd7 6a08 	vldr	s13, [r7, #32]
 801c67c:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
 801c680:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801c684:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801c688:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c68c:	bf4c      	ite	mi
 801c68e:	2301      	movmi	r3, #1
 801c690:	2300      	movpl	r3, #0
 801c692:	b2db      	uxtb	r3, r3
 801c694:	f083 0301 	eor.w	r3, r3, #1
 801c698:	b2db      	uxtb	r3, r3
 801c69a:	2b00      	cmp	r3, #0
 801c69c:	d116      	bne.n	801c6cc <nk_widget+0x284>
 801c69e:	ed97 7a08 	vldr	s14, [r7, #32]
 801c6a2:	687b      	ldr	r3, [r7, #4]
 801c6a4:	edd3 6a01 	vldr	s13, [r3, #4]
 801c6a8:	687b      	ldr	r3, [r7, #4]
 801c6aa:	edd3 7a03 	vldr	s15, [r3, #12]
 801c6ae:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801c6b2:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801c6b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c6ba:	bf4c      	ite	mi
 801c6bc:	2301      	movmi	r3, #1
 801c6be:	2300      	movpl	r3, #0
 801c6c0:	b2db      	uxtb	r3, r3
 801c6c2:	f083 0301 	eor.w	r3, r3, #1
 801c6c6:	b2db      	uxtb	r3, r3
 801c6c8:	2b00      	cmp	r3, #0
 801c6ca:	d011      	beq.n	801c6f0 <nk_widget+0x2a8>
        return NK_WIDGET_INVALID;
 801c6cc:	2300      	movs	r3, #0
 801c6ce:	e062      	b.n	801c796 <nk_widget+0x34e>
 801c6d0:	08022208 	.word	0x08022208
 801c6d4:	08023800 	.word	0x08023800
 801c6d8:	0802220c 	.word	0x0802220c
 801c6dc:	08022228 	.word	0x08022228
 801c6e0:	08022238 	.word	0x08022238
 801c6e4:	08022250 	.word	0x08022250
 801c6e8:	08022278 	.word	0x08022278
 801c6ec:	0802229c 	.word	0x0802229c
    if (!NK_INBOX(in->mouse.pos.x, in->mouse.pos.y, v.x, v.y, v.w, v.h))
 801c6f0:	ed97 7a03 	vldr	s14, [r7, #12]
 801c6f4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c6f6:	edd3 7a51 	vldr	s15, [r3, #324]	; 0x144
 801c6fa:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801c6fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c702:	bf94      	ite	ls
 801c704:	2301      	movls	r3, #1
 801c706:	2300      	movhi	r3, #0
 801c708:	b2db      	uxtb	r3, r3
 801c70a:	f083 0301 	eor.w	r3, r3, #1
 801c70e:	b2db      	uxtb	r3, r3
 801c710:	2b00      	cmp	r3, #0
 801c712:	d13d      	bne.n	801c790 <nk_widget+0x348>
 801c714:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c716:	ed93 7a51 	vldr	s14, [r3, #324]	; 0x144
 801c71a:	edd7 6a03 	vldr	s13, [r7, #12]
 801c71e:	edd7 7a05 	vldr	s15, [r7, #20]
 801c722:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801c726:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801c72a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c72e:	bf4c      	ite	mi
 801c730:	2301      	movmi	r3, #1
 801c732:	2300      	movpl	r3, #0
 801c734:	b2db      	uxtb	r3, r3
 801c736:	f083 0301 	eor.w	r3, r3, #1
 801c73a:	b2db      	uxtb	r3, r3
 801c73c:	2b00      	cmp	r3, #0
 801c73e:	d127      	bne.n	801c790 <nk_widget+0x348>
 801c740:	ed97 7a04 	vldr	s14, [r7, #16]
 801c744:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c746:	edd3 7a52 	vldr	s15, [r3, #328]	; 0x148
 801c74a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801c74e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c752:	bf94      	ite	ls
 801c754:	2301      	movls	r3, #1
 801c756:	2300      	movhi	r3, #0
 801c758:	b2db      	uxtb	r3, r3
 801c75a:	f083 0301 	eor.w	r3, r3, #1
 801c75e:	b2db      	uxtb	r3, r3
 801c760:	2b00      	cmp	r3, #0
 801c762:	d115      	bne.n	801c790 <nk_widget+0x348>
 801c764:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c766:	ed93 7a52 	vldr	s14, [r3, #328]	; 0x148
 801c76a:	edd7 6a04 	vldr	s13, [r7, #16]
 801c76e:	edd7 7a06 	vldr	s15, [r7, #24]
 801c772:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801c776:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801c77a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c77e:	bf4c      	ite	mi
 801c780:	2301      	movmi	r3, #1
 801c782:	2300      	movpl	r3, #0
 801c784:	b2db      	uxtb	r3, r3
 801c786:	f083 0301 	eor.w	r3, r3, #1
 801c78a:	b2db      	uxtb	r3, r3
 801c78c:	2b00      	cmp	r3, #0
 801c78e:	d001      	beq.n	801c794 <nk_widget+0x34c>
        return NK_WIDGET_ROM;
 801c790:	2302      	movs	r3, #2
 801c792:	e000      	b.n	801c796 <nk_widget+0x34e>
    return NK_WIDGET_VALID;
 801c794:	2301      	movs	r3, #1
}
 801c796:	4618      	mov	r0, r3
 801c798:	373c      	adds	r7, #60	; 0x3c
 801c79a:	46bd      	mov	sp, r7
 801c79c:	bd90      	pop	{r4, r7, pc}
 801c79e:	bf00      	nop

0801c7a0 <nk_widget_fitting>:
NK_API enum nk_widget_layout_states
nk_widget_fitting(struct nk_rect *bounds, struct nk_context *ctx,
    struct nk_vec2 item_padding)
{
 801c7a0:	b580      	push	{r7, lr}
 801c7a2:	b086      	sub	sp, #24
 801c7a4:	af00      	add	r7, sp, #0
 801c7a6:	60f8      	str	r0, [r7, #12]
 801c7a8:	60b9      	str	r1, [r7, #8]
 801c7aa:	eeb0 7a40 	vmov.f32	s14, s0
 801c7ae:	eef0 7a60 	vmov.f32	s15, s1
 801c7b2:	ed87 7a00 	vstr	s14, [r7]
 801c7b6:	edc7 7a01 	vstr	s15, [r7, #4]
    /* update the bounds to stand without padding  */
    enum nk_widget_layout_states state;
    NK_UNUSED(item_padding);

    NK_ASSERT(ctx);
 801c7ba:	68bb      	ldr	r3, [r7, #8]
 801c7bc:	2b00      	cmp	r3, #0
 801c7be:	d105      	bne.n	801c7cc <nk_widget_fitting+0x2c>
 801c7c0:	4b20      	ldr	r3, [pc, #128]	; (801c844 <nk_widget_fitting+0xa4>)
 801c7c2:	4a21      	ldr	r2, [pc, #132]	; (801c848 <nk_widget_fitting+0xa8>)
 801c7c4:	21be      	movs	r1, #190	; 0xbe
 801c7c6:	4821      	ldr	r0, [pc, #132]	; (801c84c <nk_widget_fitting+0xac>)
 801c7c8:	f001 f926 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 801c7cc:	68bb      	ldr	r3, [r7, #8]
 801c7ce:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801c7d2:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801c7d6:	2b00      	cmp	r3, #0
 801c7d8:	d105      	bne.n	801c7e6 <nk_widget_fitting+0x46>
 801c7da:	4b1d      	ldr	r3, [pc, #116]	; (801c850 <nk_widget_fitting+0xb0>)
 801c7dc:	4a1a      	ldr	r2, [pc, #104]	; (801c848 <nk_widget_fitting+0xa8>)
 801c7de:	21bf      	movs	r1, #191	; 0xbf
 801c7e0:	481a      	ldr	r0, [pc, #104]	; (801c84c <nk_widget_fitting+0xac>)
 801c7e2:	f001 f919 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current->layout);
 801c7e6:	68bb      	ldr	r3, [r7, #8]
 801c7e8:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801c7ec:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801c7f0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801c7f4:	2b00      	cmp	r3, #0
 801c7f6:	d105      	bne.n	801c804 <nk_widget_fitting+0x64>
 801c7f8:	4b16      	ldr	r3, [pc, #88]	; (801c854 <nk_widget_fitting+0xb4>)
 801c7fa:	4a13      	ldr	r2, [pc, #76]	; (801c848 <nk_widget_fitting+0xa8>)
 801c7fc:	21c0      	movs	r1, #192	; 0xc0
 801c7fe:	4813      	ldr	r0, [pc, #76]	; (801c84c <nk_widget_fitting+0xac>)
 801c800:	f001 f90a 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || !ctx->current->layout)
 801c804:	68bb      	ldr	r3, [r7, #8]
 801c806:	2b00      	cmp	r3, #0
 801c808:	d00f      	beq.n	801c82a <nk_widget_fitting+0x8a>
 801c80a:	68bb      	ldr	r3, [r7, #8]
 801c80c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801c810:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801c814:	2b00      	cmp	r3, #0
 801c816:	d008      	beq.n	801c82a <nk_widget_fitting+0x8a>
 801c818:	68bb      	ldr	r3, [r7, #8]
 801c81a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801c81e:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801c822:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801c826:	2b00      	cmp	r3, #0
 801c828:	d101      	bne.n	801c82e <nk_widget_fitting+0x8e>
        return NK_WIDGET_INVALID;
 801c82a:	2300      	movs	r3, #0
 801c82c:	e006      	b.n	801c83c <nk_widget_fitting+0x9c>

    state = nk_widget(bounds, ctx);
 801c82e:	68b9      	ldr	r1, [r7, #8]
 801c830:	68f8      	ldr	r0, [r7, #12]
 801c832:	f7ff fe09 	bl	801c448 <nk_widget>
 801c836:	4603      	mov	r3, r0
 801c838:	75fb      	strb	r3, [r7, #23]
    return state;
 801c83a:	7dfb      	ldrb	r3, [r7, #23]
}
 801c83c:	4618      	mov	r0, r3
 801c83e:	3718      	adds	r7, #24
 801c840:	46bd      	mov	sp, r7
 801c842:	bd80      	pop	{r7, pc}
 801c844:	08022208 	.word	0x08022208
 801c848:	0802380c 	.word	0x0802380c
 801c84c:	0802220c 	.word	0x0802220c
 801c850:	08022228 	.word	0x08022228
 801c854:	08022238 	.word	0x08022238

0801c858 <nk_create_window>:
 *                              WINDOW
 *
 * ===============================================================*/
NK_LIB void*
nk_create_window(struct nk_context *ctx)
{
 801c858:	b580      	push	{r7, lr}
 801c85a:	b084      	sub	sp, #16
 801c85c:	af00      	add	r7, sp, #0
 801c85e:	6078      	str	r0, [r7, #4]
    struct nk_page_element *elem;
    elem = nk_create_page_element(ctx);
 801c860:	6878      	ldr	r0, [r7, #4]
 801c862:	f7f7 fabd 	bl	8013de0 <nk_create_page_element>
 801c866:	60f8      	str	r0, [r7, #12]
    if (!elem) return 0;
 801c868:	68fb      	ldr	r3, [r7, #12]
 801c86a:	2b00      	cmp	r3, #0
 801c86c:	d101      	bne.n	801c872 <nk_create_window+0x1a>
 801c86e:	2300      	movs	r3, #0
 801c870:	e007      	b.n	801c882 <nk_create_window+0x2a>
    elem->data.win.seq = ctx->seq;
 801c872:	687b      	ldr	r3, [r7, #4]
 801c874:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801c878:	f8d3 2664 	ldr.w	r2, [r3, #1636]	; 0x664
 801c87c:	68fb      	ldr	r3, [r7, #12]
 801c87e:	601a      	str	r2, [r3, #0]
    return &elem->data.win;
 801c880:	68fb      	ldr	r3, [r7, #12]
}
 801c882:	4618      	mov	r0, r3
 801c884:	3710      	adds	r7, #16
 801c886:	46bd      	mov	sp, r7
 801c888:	bd80      	pop	{r7, pc}

0801c88a <nk_free_window>:
NK_LIB void
nk_free_window(struct nk_context *ctx, struct nk_window *win)
{
 801c88a:	b580      	push	{r7, lr}
 801c88c:	b086      	sub	sp, #24
 801c88e:	af00      	add	r7, sp, #0
 801c890:	6078      	str	r0, [r7, #4]
 801c892:	6039      	str	r1, [r7, #0]
    /* unlink windows from list */
    struct nk_table *it = win->tables;
 801c894:	683b      	ldr	r3, [r7, #0]
 801c896:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
 801c89a:	617b      	str	r3, [r7, #20]
    if (win->popup.win) {
 801c89c:	683b      	ldr	r3, [r7, #0]
 801c89e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801c8a2:	2b00      	cmp	r3, #0
 801c8a4:	d00a      	beq.n	801c8bc <nk_free_window+0x32>
        nk_free_window(ctx, win->popup.win);
 801c8a6:	683b      	ldr	r3, [r7, #0]
 801c8a8:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801c8ac:	4619      	mov	r1, r3
 801c8ae:	6878      	ldr	r0, [r7, #4]
 801c8b0:	f7ff ffeb 	bl	801c88a <nk_free_window>
        win->popup.win = 0;
 801c8b4:	683b      	ldr	r3, [r7, #0]
 801c8b6:	2200      	movs	r2, #0
 801c8b8:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
    }
    win->next = 0;
 801c8bc:	683b      	ldr	r3, [r7, #0]
 801c8be:	2200      	movs	r2, #0
 801c8c0:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
    win->prev = 0;
 801c8c4:	683b      	ldr	r3, [r7, #0]
 801c8c6:	2200      	movs	r2, #0
 801c8c8:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c

    while (it) {
 801c8cc:	e017      	b.n	801c8fe <nk_free_window+0x74>
        /*free window state tables */
        struct nk_table *n = it->next;
 801c8ce:	697b      	ldr	r3, [r7, #20]
 801c8d0:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 801c8d4:	60bb      	str	r3, [r7, #8]
        nk_remove_table(win, it);
 801c8d6:	6979      	ldr	r1, [r7, #20]
 801c8d8:	6838      	ldr	r0, [r7, #0]
 801c8da:	f7fe f8fc 	bl	801aad6 <nk_remove_table>
        nk_free_table(ctx, it);
 801c8de:	6979      	ldr	r1, [r7, #20]
 801c8e0:	6878      	ldr	r0, [r7, #4]
 801c8e2:	f7fe f8a6 	bl	801aa32 <nk_free_table>
        if (it == win->tables)
 801c8e6:	683b      	ldr	r3, [r7, #0]
 801c8e8:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
 801c8ec:	697a      	ldr	r2, [r7, #20]
 801c8ee:	429a      	cmp	r2, r3
 801c8f0:	d103      	bne.n	801c8fa <nk_free_window+0x70>
            win->tables = n;
 801c8f2:	683b      	ldr	r3, [r7, #0]
 801c8f4:	68ba      	ldr	r2, [r7, #8]
 801c8f6:	f8c3 2170 	str.w	r2, [r3, #368]	; 0x170
        it = n;
 801c8fa:	68bb      	ldr	r3, [r7, #8]
 801c8fc:	617b      	str	r3, [r7, #20]
    while (it) {
 801c8fe:	697b      	ldr	r3, [r7, #20]
 801c900:	2b00      	cmp	r3, #0
 801c902:	d1e4      	bne.n	801c8ce <nk_free_window+0x44>
    }

    /* link windows into freelist */
    {union nk_page_data *pd = NK_CONTAINER_OF(win, union nk_page_data, win);
 801c904:	683b      	ldr	r3, [r7, #0]
 801c906:	613b      	str	r3, [r7, #16]
    struct nk_page_element *pe = NK_CONTAINER_OF(pd, struct nk_page_element, data);
 801c908:	693b      	ldr	r3, [r7, #16]
 801c90a:	60fb      	str	r3, [r7, #12]
    nk_free_page_element(ctx, pe);}
 801c90c:	68f9      	ldr	r1, [r7, #12]
 801c90e:	6878      	ldr	r0, [r7, #4]
 801c910:	f7f7 fafd 	bl	8013f0e <nk_free_page_element>
}
 801c914:	bf00      	nop
 801c916:	3718      	adds	r7, #24
 801c918:	46bd      	mov	sp, r7
 801c91a:	bd80      	pop	{r7, pc}

0801c91c <nk_find_window>:
NK_LIB struct nk_window*
nk_find_window(struct nk_context *ctx, nk_hash hash, const char *name)
{
 801c91c:	b580      	push	{r7, lr}
 801c91e:	b086      	sub	sp, #24
 801c920:	af00      	add	r7, sp, #0
 801c922:	60f8      	str	r0, [r7, #12]
 801c924:	60b9      	str	r1, [r7, #8]
 801c926:	607a      	str	r2, [r7, #4]
    struct nk_window *iter;
    iter = ctx->begin;
 801c928:	68fb      	ldr	r3, [r7, #12]
 801c92a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801c92e:	f8d3 364c 	ldr.w	r3, [r3, #1612]	; 0x64c
 801c932:	617b      	str	r3, [r7, #20]
    while (iter) {
 801c934:	e026      	b.n	801c984 <nk_find_window+0x68>
        NK_ASSERT(iter != iter->next);
 801c936:	697b      	ldr	r3, [r7, #20]
 801c938:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 801c93c:	697a      	ldr	r2, [r7, #20]
 801c93e:	429a      	cmp	r2, r3
 801c940:	d105      	bne.n	801c94e <nk_find_window+0x32>
 801c942:	4b14      	ldr	r3, [pc, #80]	; (801c994 <nk_find_window+0x78>)
 801c944:	4a14      	ldr	r2, [pc, #80]	; (801c998 <nk_find_window+0x7c>)
 801c946:	2133      	movs	r1, #51	; 0x33
 801c948:	4814      	ldr	r0, [pc, #80]	; (801c99c <nk_find_window+0x80>)
 801c94a:	f001 f865 	bl	801da18 <__assert_func>
        if (iter->name == hash) {
 801c94e:	697b      	ldr	r3, [r7, #20]
 801c950:	685b      	ldr	r3, [r3, #4]
 801c952:	68ba      	ldr	r2, [r7, #8]
 801c954:	429a      	cmp	r2, r3
 801c956:	d111      	bne.n	801c97c <nk_find_window+0x60>
            int max_len = nk_strlen(iter->name_string);
 801c958:	697b      	ldr	r3, [r7, #20]
 801c95a:	3308      	adds	r3, #8
 801c95c:	4618      	mov	r0, r3
 801c95e:	f7ff fb81 	bl	801c064 <nk_strlen>
 801c962:	6138      	str	r0, [r7, #16]
            if (!nk_stricmpn(iter->name_string, name, max_len))
 801c964:	697b      	ldr	r3, [r7, #20]
 801c966:	3308      	adds	r3, #8
 801c968:	693a      	ldr	r2, [r7, #16]
 801c96a:	6879      	ldr	r1, [r7, #4]
 801c96c:	4618      	mov	r0, r3
 801c96e:	f7ff fb9f 	bl	801c0b0 <nk_stricmpn>
 801c972:	4603      	mov	r3, r0
 801c974:	2b00      	cmp	r3, #0
 801c976:	d101      	bne.n	801c97c <nk_find_window+0x60>
                return iter;
 801c978:	697b      	ldr	r3, [r7, #20]
 801c97a:	e007      	b.n	801c98c <nk_find_window+0x70>
        }
        iter = iter->next;
 801c97c:	697b      	ldr	r3, [r7, #20]
 801c97e:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 801c982:	617b      	str	r3, [r7, #20]
    while (iter) {
 801c984:	697b      	ldr	r3, [r7, #20]
 801c986:	2b00      	cmp	r3, #0
 801c988:	d1d5      	bne.n	801c936 <nk_find_window+0x1a>
    }
    return 0;
 801c98a:	2300      	movs	r3, #0
}
 801c98c:	4618      	mov	r0, r3
 801c98e:	3718      	adds	r7, #24
 801c990:	46bd      	mov	sp, r7
 801c992:	bd80      	pop	{r7, pc}
 801c994:	080222c0 	.word	0x080222c0
 801c998:	08023820 	.word	0x08023820
 801c99c:	080222d4 	.word	0x080222d4

0801c9a0 <nk_insert_window>:
NK_LIB void
nk_insert_window(struct nk_context *ctx, struct nk_window *win,
    enum nk_window_insert_location loc)
{
 801c9a0:	b580      	push	{r7, lr}
 801c9a2:	b086      	sub	sp, #24
 801c9a4:	af00      	add	r7, sp, #0
 801c9a6:	60f8      	str	r0, [r7, #12]
 801c9a8:	60b9      	str	r1, [r7, #8]
 801c9aa:	4613      	mov	r3, r2
 801c9ac:	71fb      	strb	r3, [r7, #7]
    const struct nk_window *iter;
    NK_ASSERT(ctx);
 801c9ae:	68fb      	ldr	r3, [r7, #12]
 801c9b0:	2b00      	cmp	r3, #0
 801c9b2:	d105      	bne.n	801c9c0 <nk_insert_window+0x20>
 801c9b4:	4b6f      	ldr	r3, [pc, #444]	; (801cb74 <nk_insert_window+0x1d4>)
 801c9b6:	4a70      	ldr	r2, [pc, #448]	; (801cb78 <nk_insert_window+0x1d8>)
 801c9b8:	2142      	movs	r1, #66	; 0x42
 801c9ba:	4870      	ldr	r0, [pc, #448]	; (801cb7c <nk_insert_window+0x1dc>)
 801c9bc:	f001 f82c 	bl	801da18 <__assert_func>
    NK_ASSERT(win);
 801c9c0:	68bb      	ldr	r3, [r7, #8]
 801c9c2:	2b00      	cmp	r3, #0
 801c9c4:	d105      	bne.n	801c9d2 <nk_insert_window+0x32>
 801c9c6:	4b6e      	ldr	r3, [pc, #440]	; (801cb80 <nk_insert_window+0x1e0>)
 801c9c8:	4a6b      	ldr	r2, [pc, #428]	; (801cb78 <nk_insert_window+0x1d8>)
 801c9ca:	2143      	movs	r1, #67	; 0x43
 801c9cc:	486b      	ldr	r0, [pc, #428]	; (801cb7c <nk_insert_window+0x1dc>)
 801c9ce:	f001 f823 	bl	801da18 <__assert_func>
    if (!win || !ctx) return;
 801c9d2:	68bb      	ldr	r3, [r7, #8]
 801c9d4:	2b00      	cmp	r3, #0
 801c9d6:	f000 80c6 	beq.w	801cb66 <nk_insert_window+0x1c6>
 801c9da:	68fb      	ldr	r3, [r7, #12]
 801c9dc:	2b00      	cmp	r3, #0
 801c9de:	f000 80c2 	beq.w	801cb66 <nk_insert_window+0x1c6>

    iter = ctx->begin;
 801c9e2:	68fb      	ldr	r3, [r7, #12]
 801c9e4:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801c9e8:	f8d3 364c 	ldr.w	r3, [r3, #1612]	; 0x64c
 801c9ec:	617b      	str	r3, [r7, #20]
    while (iter) {
 801c9ee:	e01e      	b.n	801ca2e <nk_insert_window+0x8e>
        NK_ASSERT(iter != iter->next);
 801c9f0:	697b      	ldr	r3, [r7, #20]
 801c9f2:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 801c9f6:	697a      	ldr	r2, [r7, #20]
 801c9f8:	429a      	cmp	r2, r3
 801c9fa:	d105      	bne.n	801ca08 <nk_insert_window+0x68>
 801c9fc:	4b61      	ldr	r3, [pc, #388]	; (801cb84 <nk_insert_window+0x1e4>)
 801c9fe:	4a5e      	ldr	r2, [pc, #376]	; (801cb78 <nk_insert_window+0x1d8>)
 801ca00:	2148      	movs	r1, #72	; 0x48
 801ca02:	485e      	ldr	r0, [pc, #376]	; (801cb7c <nk_insert_window+0x1dc>)
 801ca04:	f001 f808 	bl	801da18 <__assert_func>
        NK_ASSERT(iter != win);
 801ca08:	697a      	ldr	r2, [r7, #20]
 801ca0a:	68bb      	ldr	r3, [r7, #8]
 801ca0c:	429a      	cmp	r2, r3
 801ca0e:	d105      	bne.n	801ca1c <nk_insert_window+0x7c>
 801ca10:	4b5d      	ldr	r3, [pc, #372]	; (801cb88 <nk_insert_window+0x1e8>)
 801ca12:	4a59      	ldr	r2, [pc, #356]	; (801cb78 <nk_insert_window+0x1d8>)
 801ca14:	2149      	movs	r1, #73	; 0x49
 801ca16:	4859      	ldr	r0, [pc, #356]	; (801cb7c <nk_insert_window+0x1dc>)
 801ca18:	f000 fffe 	bl	801da18 <__assert_func>
        if (iter == win) return;
 801ca1c:	697a      	ldr	r2, [r7, #20]
 801ca1e:	68bb      	ldr	r3, [r7, #8]
 801ca20:	429a      	cmp	r2, r3
 801ca22:	f000 80a2 	beq.w	801cb6a <nk_insert_window+0x1ca>
        iter = iter->next;
 801ca26:	697b      	ldr	r3, [r7, #20]
 801ca28:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 801ca2c:	617b      	str	r3, [r7, #20]
    while (iter) {
 801ca2e:	697b      	ldr	r3, [r7, #20]
 801ca30:	2b00      	cmp	r3, #0
 801ca32:	d1dd      	bne.n	801c9f0 <nk_insert_window+0x50>
    }

    if (!ctx->begin) {
 801ca34:	68fb      	ldr	r3, [r7, #12]
 801ca36:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801ca3a:	f8d3 364c 	ldr.w	r3, [r3, #1612]	; 0x64c
 801ca3e:	2b00      	cmp	r3, #0
 801ca40:	d11d      	bne.n	801ca7e <nk_insert_window+0xde>
        win->next = 0;
 801ca42:	68bb      	ldr	r3, [r7, #8]
 801ca44:	2200      	movs	r2, #0
 801ca46:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
        win->prev = 0;
 801ca4a:	68bb      	ldr	r3, [r7, #8]
 801ca4c:	2200      	movs	r2, #0
 801ca4e:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
        ctx->begin = win;
 801ca52:	68fb      	ldr	r3, [r7, #12]
 801ca54:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801ca58:	461a      	mov	r2, r3
 801ca5a:	68bb      	ldr	r3, [r7, #8]
 801ca5c:	f8c2 364c 	str.w	r3, [r2, #1612]	; 0x64c
        ctx->end = win;
 801ca60:	68fb      	ldr	r3, [r7, #12]
 801ca62:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801ca66:	461a      	mov	r2, r3
 801ca68:	68bb      	ldr	r3, [r7, #8]
 801ca6a:	f8c2 3650 	str.w	r3, [r2, #1616]	; 0x650
        ctx->count = 1;
 801ca6e:	68fb      	ldr	r3, [r7, #12]
 801ca70:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801ca74:	461a      	mov	r2, r3
 801ca76:	2301      	movs	r3, #1
 801ca78:	f8c2 3660 	str.w	r3, [r2, #1632]	; 0x660
        return;
 801ca7c:	e076      	b.n	801cb6c <nk_insert_window+0x1cc>
    }
    if (loc == NK_INSERT_BACK) {
 801ca7e:	79fb      	ldrb	r3, [r7, #7]
 801ca80:	2b00      	cmp	r3, #0
 801ca82:	d13b      	bne.n	801cafc <nk_insert_window+0x15c>
        struct nk_window *end;
        end = ctx->end;
 801ca84:	68fb      	ldr	r3, [r7, #12]
 801ca86:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801ca8a:	f8d3 3650 	ldr.w	r3, [r3, #1616]	; 0x650
 801ca8e:	613b      	str	r3, [r7, #16]
        end->flags |= NK_WINDOW_ROM;
 801ca90:	693b      	ldr	r3, [r7, #16]
 801ca92:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801ca94:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
 801ca98:	693b      	ldr	r3, [r7, #16]
 801ca9a:	649a      	str	r2, [r3, #72]	; 0x48
        end->next = win;
 801ca9c:	693b      	ldr	r3, [r7, #16]
 801ca9e:	68ba      	ldr	r2, [r7, #8]
 801caa0:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
        win->prev = ctx->end;
 801caa4:	68fb      	ldr	r3, [r7, #12]
 801caa6:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801caaa:	f8d3 2650 	ldr.w	r2, [r3, #1616]	; 0x650
 801caae:	68bb      	ldr	r3, [r7, #8]
 801cab0:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
        win->next = 0;
 801cab4:	68bb      	ldr	r3, [r7, #8]
 801cab6:	2200      	movs	r2, #0
 801cab8:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
        ctx->end = win;
 801cabc:	68fb      	ldr	r3, [r7, #12]
 801cabe:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cac2:	461a      	mov	r2, r3
 801cac4:	68bb      	ldr	r3, [r7, #8]
 801cac6:	f8c2 3650 	str.w	r3, [r2, #1616]	; 0x650
        ctx->active = ctx->end;
 801caca:	68fb      	ldr	r3, [r7, #12]
 801cacc:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cad0:	f8d3 3650 	ldr.w	r3, [r3, #1616]	; 0x650
 801cad4:	68fa      	ldr	r2, [r7, #12]
 801cad6:	f502 5240 	add.w	r2, r2, #12288	; 0x3000
 801cada:	f8c2 3654 	str.w	r3, [r2, #1620]	; 0x654
        ctx->end->flags &= ~(nk_flags)NK_WINDOW_ROM;
 801cade:	68fb      	ldr	r3, [r7, #12]
 801cae0:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cae4:	f8d3 3650 	ldr.w	r3, [r3, #1616]	; 0x650
 801cae8:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 801caea:	68fb      	ldr	r3, [r7, #12]
 801caec:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801caf0:	f8d3 3650 	ldr.w	r3, [r3, #1616]	; 0x650
 801caf4:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 801caf8:	649a      	str	r2, [r3, #72]	; 0x48
 801cafa:	e028      	b.n	801cb4e <nk_insert_window+0x1ae>
    } else {
        /*ctx->end->flags |= NK_WINDOW_ROM;*/
        ctx->begin->prev = win;
 801cafc:	68fb      	ldr	r3, [r7, #12]
 801cafe:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cb02:	f8d3 364c 	ldr.w	r3, [r3, #1612]	; 0x64c
 801cb06:	68ba      	ldr	r2, [r7, #8]
 801cb08:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
        win->next = ctx->begin;
 801cb0c:	68fb      	ldr	r3, [r7, #12]
 801cb0e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cb12:	f8d3 264c 	ldr.w	r2, [r3, #1612]	; 0x64c
 801cb16:	68bb      	ldr	r3, [r7, #8]
 801cb18:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
        win->prev = 0;
 801cb1c:	68bb      	ldr	r3, [r7, #8]
 801cb1e:	2200      	movs	r2, #0
 801cb20:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
        ctx->begin = win;
 801cb24:	68fb      	ldr	r3, [r7, #12]
 801cb26:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cb2a:	461a      	mov	r2, r3
 801cb2c:	68bb      	ldr	r3, [r7, #8]
 801cb2e:	f8c2 364c 	str.w	r3, [r2, #1612]	; 0x64c
        ctx->begin->flags &= ~(nk_flags)NK_WINDOW_ROM;
 801cb32:	68fb      	ldr	r3, [r7, #12]
 801cb34:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cb38:	f8d3 364c 	ldr.w	r3, [r3, #1612]	; 0x64c
 801cb3c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 801cb3e:	68fb      	ldr	r3, [r7, #12]
 801cb40:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cb44:	f8d3 364c 	ldr.w	r3, [r3, #1612]	; 0x64c
 801cb48:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 801cb4c:	649a      	str	r2, [r3, #72]	; 0x48
    }
    ctx->count++;
 801cb4e:	68fb      	ldr	r3, [r7, #12]
 801cb50:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cb54:	f8d3 3660 	ldr.w	r3, [r3, #1632]	; 0x660
 801cb58:	3301      	adds	r3, #1
 801cb5a:	68fa      	ldr	r2, [r7, #12]
 801cb5c:	f502 5240 	add.w	r2, r2, #12288	; 0x3000
 801cb60:	f8c2 3660 	str.w	r3, [r2, #1632]	; 0x660
 801cb64:	e002      	b.n	801cb6c <nk_insert_window+0x1cc>
    if (!win || !ctx) return;
 801cb66:	bf00      	nop
 801cb68:	e000      	b.n	801cb6c <nk_insert_window+0x1cc>
        if (iter == win) return;
 801cb6a:	bf00      	nop
}
 801cb6c:	3718      	adds	r7, #24
 801cb6e:	46bd      	mov	sp, r7
 801cb70:	bd80      	pop	{r7, pc}
 801cb72:	bf00      	nop
 801cb74:	080222f0 	.word	0x080222f0
 801cb78:	08023830 	.word	0x08023830
 801cb7c:	080222d4 	.word	0x080222d4
 801cb80:	080222f4 	.word	0x080222f4
 801cb84:	080222c0 	.word	0x080222c0
 801cb88:	080222f8 	.word	0x080222f8

0801cb8c <nk_remove_window>:
NK_LIB void
nk_remove_window(struct nk_context *ctx, struct nk_window *win)
{
 801cb8c:	b480      	push	{r7}
 801cb8e:	b083      	sub	sp, #12
 801cb90:	af00      	add	r7, sp, #0
 801cb92:	6078      	str	r0, [r7, #4]
 801cb94:	6039      	str	r1, [r7, #0]
    if (win == ctx->begin || win == ctx->end) {
 801cb96:	687b      	ldr	r3, [r7, #4]
 801cb98:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cb9c:	f8d3 364c 	ldr.w	r3, [r3, #1612]	; 0x64c
 801cba0:	683a      	ldr	r2, [r7, #0]
 801cba2:	429a      	cmp	r2, r3
 801cba4:	d007      	beq.n	801cbb6 <nk_remove_window+0x2a>
 801cba6:	687b      	ldr	r3, [r7, #4]
 801cba8:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cbac:	f8d3 3650 	ldr.w	r3, [r3, #1616]	; 0x650
 801cbb0:	683a      	ldr	r2, [r7, #0]
 801cbb2:	429a      	cmp	r2, r3
 801cbb4:	d136      	bne.n	801cc24 <nk_remove_window+0x98>
        if (win == ctx->begin) {
 801cbb6:	687b      	ldr	r3, [r7, #4]
 801cbb8:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cbbc:	f8d3 364c 	ldr.w	r3, [r3, #1612]	; 0x64c
 801cbc0:	683a      	ldr	r2, [r7, #0]
 801cbc2:	429a      	cmp	r2, r3
 801cbc4:	d112      	bne.n	801cbec <nk_remove_window+0x60>
            ctx->begin = win->next;
 801cbc6:	683b      	ldr	r3, [r7, #0]
 801cbc8:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 801cbcc:	687a      	ldr	r2, [r7, #4]
 801cbce:	f502 5240 	add.w	r2, r2, #12288	; 0x3000
 801cbd2:	f8c2 364c 	str.w	r3, [r2, #1612]	; 0x64c
            if (win->next)
 801cbd6:	683b      	ldr	r3, [r7, #0]
 801cbd8:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 801cbdc:	2b00      	cmp	r3, #0
 801cbde:	d005      	beq.n	801cbec <nk_remove_window+0x60>
                win->next->prev = 0;
 801cbe0:	683b      	ldr	r3, [r7, #0]
 801cbe2:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 801cbe6:	2200      	movs	r2, #0
 801cbe8:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
        }
        if (win == ctx->end) {
 801cbec:	687b      	ldr	r3, [r7, #4]
 801cbee:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cbf2:	f8d3 3650 	ldr.w	r3, [r3, #1616]	; 0x650
 801cbf6:	683a      	ldr	r2, [r7, #0]
 801cbf8:	429a      	cmp	r2, r3
 801cbfa:	d12e      	bne.n	801cc5a <nk_remove_window+0xce>
            ctx->end = win->prev;
 801cbfc:	683b      	ldr	r3, [r7, #0]
 801cbfe:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
 801cc02:	687a      	ldr	r2, [r7, #4]
 801cc04:	f502 5240 	add.w	r2, r2, #12288	; 0x3000
 801cc08:	f8c2 3650 	str.w	r3, [r2, #1616]	; 0x650
            if (win->prev)
 801cc0c:	683b      	ldr	r3, [r7, #0]
 801cc0e:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
 801cc12:	2b00      	cmp	r3, #0
 801cc14:	d021      	beq.n	801cc5a <nk_remove_window+0xce>
                win->prev->next = 0;
 801cc16:	683b      	ldr	r3, [r7, #0]
 801cc18:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
 801cc1c:	2200      	movs	r2, #0
 801cc1e:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
        if (win == ctx->end) {
 801cc22:	e01a      	b.n	801cc5a <nk_remove_window+0xce>
        }
    } else {
        if (win->next)
 801cc24:	683b      	ldr	r3, [r7, #0]
 801cc26:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 801cc2a:	2b00      	cmp	r3, #0
 801cc2c:	d007      	beq.n	801cc3e <nk_remove_window+0xb2>
            win->next->prev = win->prev;
 801cc2e:	683b      	ldr	r3, [r7, #0]
 801cc30:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 801cc34:	683a      	ldr	r2, [r7, #0]
 801cc36:	f8d2 217c 	ldr.w	r2, [r2, #380]	; 0x17c
 801cc3a:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
        if (win->prev)
 801cc3e:	683b      	ldr	r3, [r7, #0]
 801cc40:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
 801cc44:	2b00      	cmp	r3, #0
 801cc46:	d009      	beq.n	801cc5c <nk_remove_window+0xd0>
            win->prev->next = win->next;
 801cc48:	683b      	ldr	r3, [r7, #0]
 801cc4a:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
 801cc4e:	683a      	ldr	r2, [r7, #0]
 801cc50:	f8d2 2178 	ldr.w	r2, [r2, #376]	; 0x178
 801cc54:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
 801cc58:	e000      	b.n	801cc5c <nk_remove_window+0xd0>
        if (win == ctx->end) {
 801cc5a:	bf00      	nop
    }
    if (win == ctx->active || !ctx->active) {
 801cc5c:	687b      	ldr	r3, [r7, #4]
 801cc5e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cc62:	f8d3 3654 	ldr.w	r3, [r3, #1620]	; 0x654
 801cc66:	683a      	ldr	r2, [r7, #0]
 801cc68:	429a      	cmp	r2, r3
 801cc6a:	d006      	beq.n	801cc7a <nk_remove_window+0xee>
 801cc6c:	687b      	ldr	r3, [r7, #4]
 801cc6e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cc72:	f8d3 3654 	ldr.w	r3, [r3, #1620]	; 0x654
 801cc76:	2b00      	cmp	r3, #0
 801cc78:	d11e      	bne.n	801ccb8 <nk_remove_window+0x12c>
        ctx->active = ctx->end;
 801cc7a:	687b      	ldr	r3, [r7, #4]
 801cc7c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cc80:	f8d3 3650 	ldr.w	r3, [r3, #1616]	; 0x650
 801cc84:	687a      	ldr	r2, [r7, #4]
 801cc86:	f502 5240 	add.w	r2, r2, #12288	; 0x3000
 801cc8a:	f8c2 3654 	str.w	r3, [r2, #1620]	; 0x654
        if (ctx->end)
 801cc8e:	687b      	ldr	r3, [r7, #4]
 801cc90:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cc94:	f8d3 3650 	ldr.w	r3, [r3, #1616]	; 0x650
 801cc98:	2b00      	cmp	r3, #0
 801cc9a:	d00d      	beq.n	801ccb8 <nk_remove_window+0x12c>
            ctx->end->flags &= ~(nk_flags)NK_WINDOW_ROM;
 801cc9c:	687b      	ldr	r3, [r7, #4]
 801cc9e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cca2:	f8d3 3650 	ldr.w	r3, [r3, #1616]	; 0x650
 801cca6:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 801cca8:	687b      	ldr	r3, [r7, #4]
 801ccaa:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801ccae:	f8d3 3650 	ldr.w	r3, [r3, #1616]	; 0x650
 801ccb2:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 801ccb6:	649a      	str	r2, [r3, #72]	; 0x48
    }
    win->next = 0;
 801ccb8:	683b      	ldr	r3, [r7, #0]
 801ccba:	2200      	movs	r2, #0
 801ccbc:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
    win->prev = 0;
 801ccc0:	683b      	ldr	r3, [r7, #0]
 801ccc2:	2200      	movs	r2, #0
 801ccc4:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
    ctx->count--;
 801ccc8:	687b      	ldr	r3, [r7, #4]
 801ccca:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801ccce:	f8d3 3660 	ldr.w	r3, [r3, #1632]	; 0x660
 801ccd2:	3b01      	subs	r3, #1
 801ccd4:	687a      	ldr	r2, [r7, #4]
 801ccd6:	f502 5240 	add.w	r2, r2, #12288	; 0x3000
 801ccda:	f8c2 3660 	str.w	r3, [r2, #1632]	; 0x660
}
 801ccde:	bf00      	nop
 801cce0:	370c      	adds	r7, #12
 801cce2:	46bd      	mov	sp, r7
 801cce4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cce8:	4770      	bx	lr

0801ccea <nk_begin>:
NK_API nk_bool
nk_begin(struct nk_context *ctx, const char *title,
    struct nk_rect bounds, nk_flags flags)
{
 801ccea:	b580      	push	{r7, lr}
 801ccec:	b088      	sub	sp, #32
 801ccee:	af00      	add	r7, sp, #0
 801ccf0:	61f8      	str	r0, [r7, #28]
 801ccf2:	61b9      	str	r1, [r7, #24]
 801ccf4:	eeb0 6a40 	vmov.f32	s12, s0
 801ccf8:	eef0 6a60 	vmov.f32	s13, s1
 801ccfc:	eeb0 7a41 	vmov.f32	s14, s2
 801cd00:	eef0 7a61 	vmov.f32	s15, s3
 801cd04:	607a      	str	r2, [r7, #4]
 801cd06:	ed87 6a02 	vstr	s12, [r7, #8]
 801cd0a:	edc7 6a03 	vstr	s13, [r7, #12]
 801cd0e:	ed87 7a04 	vstr	s14, [r7, #16]
 801cd12:	edc7 7a05 	vstr	s15, [r7, #20]
    return nk_begin_titled(ctx, title, title, bounds, flags);
 801cd16:	ed97 6a02 	vldr	s12, [r7, #8]
 801cd1a:	edd7 6a03 	vldr	s13, [r7, #12]
 801cd1e:	ed97 7a04 	vldr	s14, [r7, #16]
 801cd22:	edd7 7a05 	vldr	s15, [r7, #20]
 801cd26:	687b      	ldr	r3, [r7, #4]
 801cd28:	eeb0 0a46 	vmov.f32	s0, s12
 801cd2c:	eef0 0a66 	vmov.f32	s1, s13
 801cd30:	eeb0 1a47 	vmov.f32	s2, s14
 801cd34:	eef0 1a67 	vmov.f32	s3, s15
 801cd38:	69ba      	ldr	r2, [r7, #24]
 801cd3a:	69b9      	ldr	r1, [r7, #24]
 801cd3c:	69f8      	ldr	r0, [r7, #28]
 801cd3e:	f000 f805 	bl	801cd4c <nk_begin_titled>
 801cd42:	4603      	mov	r3, r0
}
 801cd44:	4618      	mov	r0, r3
 801cd46:	3720      	adds	r7, #32
 801cd48:	46bd      	mov	sp, r7
 801cd4a:	bd80      	pop	{r7, pc}

0801cd4c <nk_begin_titled>:
NK_API nk_bool
nk_begin_titled(struct nk_context *ctx, const char *name, const char *title,
    struct nk_rect bounds, nk_flags flags)
{
 801cd4c:	b590      	push	{r4, r7, lr}
 801cd4e:	b09f      	sub	sp, #124	; 0x7c
 801cd50:	af00      	add	r7, sp, #0
 801cd52:	61f8      	str	r0, [r7, #28]
 801cd54:	61b9      	str	r1, [r7, #24]
 801cd56:	617a      	str	r2, [r7, #20]
 801cd58:	eeb0 6a40 	vmov.f32	s12, s0
 801cd5c:	eef0 6a60 	vmov.f32	s13, s1
 801cd60:	eeb0 7a41 	vmov.f32	s14, s2
 801cd64:	eef0 7a61 	vmov.f32	s15, s3
 801cd68:	603b      	str	r3, [r7, #0]
 801cd6a:	ed87 6a01 	vstr	s12, [r7, #4]
 801cd6e:	edc7 6a02 	vstr	s13, [r7, #8]
 801cd72:	ed87 7a03 	vstr	s14, [r7, #12]
 801cd76:	edc7 7a04 	vstr	s15, [r7, #16]
    struct nk_window *win;
    struct nk_style *style;
    nk_hash name_hash;
    int name_len;
    int ret = 0;
 801cd7a:	2300      	movs	r3, #0
 801cd7c:	66fb      	str	r3, [r7, #108]	; 0x6c

    NK_ASSERT(ctx);
 801cd7e:	69fb      	ldr	r3, [r7, #28]
 801cd80:	2b00      	cmp	r3, #0
 801cd82:	d105      	bne.n	801cd90 <nk_begin_titled+0x44>
 801cd84:	4b8f      	ldr	r3, [pc, #572]	; (801cfc4 <nk_begin_titled+0x278>)
 801cd86:	4a90      	ldr	r2, [pc, #576]	; (801cfc8 <nk_begin_titled+0x27c>)
 801cd88:	2197      	movs	r1, #151	; 0x97
 801cd8a:	4890      	ldr	r0, [pc, #576]	; (801cfcc <nk_begin_titled+0x280>)
 801cd8c:	f000 fe44 	bl	801da18 <__assert_func>
    NK_ASSERT(name);
 801cd90:	69bb      	ldr	r3, [r7, #24]
 801cd92:	2b00      	cmp	r3, #0
 801cd94:	d105      	bne.n	801cda2 <nk_begin_titled+0x56>
 801cd96:	4b8e      	ldr	r3, [pc, #568]	; (801cfd0 <nk_begin_titled+0x284>)
 801cd98:	4a8b      	ldr	r2, [pc, #556]	; (801cfc8 <nk_begin_titled+0x27c>)
 801cd9a:	2198      	movs	r1, #152	; 0x98
 801cd9c:	488b      	ldr	r0, [pc, #556]	; (801cfcc <nk_begin_titled+0x280>)
 801cd9e:	f000 fe3b 	bl	801da18 <__assert_func>
    NK_ASSERT(title);
 801cda2:	697b      	ldr	r3, [r7, #20]
 801cda4:	2b00      	cmp	r3, #0
 801cda6:	d105      	bne.n	801cdb4 <nk_begin_titled+0x68>
 801cda8:	4b8a      	ldr	r3, [pc, #552]	; (801cfd4 <nk_begin_titled+0x288>)
 801cdaa:	4a87      	ldr	r2, [pc, #540]	; (801cfc8 <nk_begin_titled+0x27c>)
 801cdac:	2199      	movs	r1, #153	; 0x99
 801cdae:	4887      	ldr	r0, [pc, #540]	; (801cfcc <nk_begin_titled+0x280>)
 801cdb0:	f000 fe32 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->style.font && ctx->style.font->width && "if this triggers you forgot to add a font");
 801cdb4:	69fb      	ldr	r3, [r7, #28]
 801cdb6:	f8d3 3168 	ldr.w	r3, [r3, #360]	; 0x168
 801cdba:	2b00      	cmp	r3, #0
 801cdbc:	d005      	beq.n	801cdca <nk_begin_titled+0x7e>
 801cdbe:	69fb      	ldr	r3, [r7, #28]
 801cdc0:	f8d3 3168 	ldr.w	r3, [r3, #360]	; 0x168
 801cdc4:	689b      	ldr	r3, [r3, #8]
 801cdc6:	2b00      	cmp	r3, #0
 801cdc8:	d105      	bne.n	801cdd6 <nk_begin_titled+0x8a>
 801cdca:	4b83      	ldr	r3, [pc, #524]	; (801cfd8 <nk_begin_titled+0x28c>)
 801cdcc:	4a7e      	ldr	r2, [pc, #504]	; (801cfc8 <nk_begin_titled+0x27c>)
 801cdce:	219a      	movs	r1, #154	; 0x9a
 801cdd0:	487e      	ldr	r0, [pc, #504]	; (801cfcc <nk_begin_titled+0x280>)
 801cdd2:	f000 fe21 	bl	801da18 <__assert_func>
    NK_ASSERT(!ctx->current && "if this triggers you missed a `nk_end` call");
 801cdd6:	69fb      	ldr	r3, [r7, #28]
 801cdd8:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cddc:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801cde0:	2b00      	cmp	r3, #0
 801cde2:	d005      	beq.n	801cdf0 <nk_begin_titled+0xa4>
 801cde4:	4b7d      	ldr	r3, [pc, #500]	; (801cfdc <nk_begin_titled+0x290>)
 801cde6:	4a78      	ldr	r2, [pc, #480]	; (801cfc8 <nk_begin_titled+0x27c>)
 801cde8:	219b      	movs	r1, #155	; 0x9b
 801cdea:	4878      	ldr	r0, [pc, #480]	; (801cfcc <nk_begin_titled+0x280>)
 801cdec:	f000 fe14 	bl	801da18 <__assert_func>
    if (!ctx || ctx->current || !title || !name)
 801cdf0:	69fb      	ldr	r3, [r7, #28]
 801cdf2:	2b00      	cmp	r3, #0
 801cdf4:	d00c      	beq.n	801ce10 <nk_begin_titled+0xc4>
 801cdf6:	69fb      	ldr	r3, [r7, #28]
 801cdf8:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cdfc:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801ce00:	2b00      	cmp	r3, #0
 801ce02:	d105      	bne.n	801ce10 <nk_begin_titled+0xc4>
 801ce04:	697b      	ldr	r3, [r7, #20]
 801ce06:	2b00      	cmp	r3, #0
 801ce08:	d002      	beq.n	801ce10 <nk_begin_titled+0xc4>
 801ce0a:	69bb      	ldr	r3, [r7, #24]
 801ce0c:	2b00      	cmp	r3, #0
 801ce0e:	d101      	bne.n	801ce14 <nk_begin_titled+0xc8>
        return 0;
 801ce10:	2300      	movs	r3, #0
 801ce12:	e3d7      	b.n	801d5c4 <nk_begin_titled+0x878>

    /* find or create window */
    style = &ctx->style;
 801ce14:	69fb      	ldr	r3, [r7, #28]
 801ce16:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 801ce1a:	66bb      	str	r3, [r7, #104]	; 0x68
    name_len = (int)nk_strlen(name);
 801ce1c:	69b8      	ldr	r0, [r7, #24]
 801ce1e:	f7ff f921 	bl	801c064 <nk_strlen>
 801ce22:	6678      	str	r0, [r7, #100]	; 0x64
    name_hash = nk_murmur_hash(name, (int)name_len, NK_WINDOW_TITLE);
 801ce24:	2240      	movs	r2, #64	; 0x40
 801ce26:	6e79      	ldr	r1, [r7, #100]	; 0x64
 801ce28:	69b8      	ldr	r0, [r7, #24]
 801ce2a:	f7ff f99b 	bl	801c164 <nk_murmur_hash>
 801ce2e:	6638      	str	r0, [r7, #96]	; 0x60
    win = nk_find_window(ctx, name_hash, name);
 801ce30:	69ba      	ldr	r2, [r7, #24]
 801ce32:	6e39      	ldr	r1, [r7, #96]	; 0x60
 801ce34:	69f8      	ldr	r0, [r7, #28]
 801ce36:	f7ff fd71 	bl	801c91c <nk_find_window>
 801ce3a:	6778      	str	r0, [r7, #116]	; 0x74
    if (!win) {
 801ce3c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801ce3e:	2b00      	cmp	r3, #0
 801ce40:	d160      	bne.n	801cf04 <nk_begin_titled+0x1b8>
        /* create new window */
        nk_size name_length = (nk_size)name_len;
 801ce42:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801ce44:	65fb      	str	r3, [r7, #92]	; 0x5c
        win = (struct nk_window*)nk_create_window(ctx);
 801ce46:	69f8      	ldr	r0, [r7, #28]
 801ce48:	f7ff fd06 	bl	801c858 <nk_create_window>
 801ce4c:	6778      	str	r0, [r7, #116]	; 0x74
        NK_ASSERT(win);
 801ce4e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801ce50:	2b00      	cmp	r3, #0
 801ce52:	d105      	bne.n	801ce60 <nk_begin_titled+0x114>
 801ce54:	4b62      	ldr	r3, [pc, #392]	; (801cfe0 <nk_begin_titled+0x294>)
 801ce56:	4a5c      	ldr	r2, [pc, #368]	; (801cfc8 <nk_begin_titled+0x27c>)
 801ce58:	21a8      	movs	r1, #168	; 0xa8
 801ce5a:	485c      	ldr	r0, [pc, #368]	; (801cfcc <nk_begin_titled+0x280>)
 801ce5c:	f000 fddc 	bl	801da18 <__assert_func>
        if (!win) return 0;
 801ce60:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801ce62:	2b00      	cmp	r3, #0
 801ce64:	d101      	bne.n	801ce6a <nk_begin_titled+0x11e>
 801ce66:	2300      	movs	r3, #0
 801ce68:	e3ac      	b.n	801d5c4 <nk_begin_titled+0x878>

        if (flags & NK_WINDOW_BACKGROUND)
 801ce6a:	683b      	ldr	r3, [r7, #0]
 801ce6c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801ce70:	2b00      	cmp	r3, #0
 801ce72:	d005      	beq.n	801ce80 <nk_begin_titled+0x134>
            nk_insert_window(ctx, win, NK_INSERT_FRONT);
 801ce74:	2201      	movs	r2, #1
 801ce76:	6f79      	ldr	r1, [r7, #116]	; 0x74
 801ce78:	69f8      	ldr	r0, [r7, #28]
 801ce7a:	f7ff fd91 	bl	801c9a0 <nk_insert_window>
 801ce7e:	e004      	b.n	801ce8a <nk_begin_titled+0x13e>
        else nk_insert_window(ctx, win, NK_INSERT_BACK);
 801ce80:	2200      	movs	r2, #0
 801ce82:	6f79      	ldr	r1, [r7, #116]	; 0x74
 801ce84:	69f8      	ldr	r0, [r7, #28]
 801ce86:	f7ff fd8b 	bl	801c9a0 <nk_insert_window>
        nk_command_buffer_init(&win->buffer, &ctx->memory, NK_CLIPPING_ON);
 801ce8a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801ce8c:	f103 0064 	add.w	r0, r3, #100	; 0x64
 801ce90:	69fb      	ldr	r3, [r7, #28]
 801ce92:	f503 53d4 	add.w	r3, r3, #6784	; 0x1a80
 801ce96:	330c      	adds	r3, #12
 801ce98:	2201      	movs	r2, #1
 801ce9a:	4619      	mov	r1, r3
 801ce9c:	f7f3 fcac 	bl	80107f8 <nk_command_buffer_init>

        win->flags = flags;
 801cea0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801cea2:	683a      	ldr	r2, [r7, #0]
 801cea4:	649a      	str	r2, [r3, #72]	; 0x48
        win->bounds = bounds;
 801cea6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801cea8:	f103 044c 	add.w	r4, r3, #76	; 0x4c
 801ceac:	1d3b      	adds	r3, r7, #4
 801ceae:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801ceb0:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        win->name = name_hash;
 801ceb4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801ceb6:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 801ceb8:	605a      	str	r2, [r3, #4]
        name_length = NK_MIN(name_length, NK_WINDOW_MAX_NAME-1);
 801ceba:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801cebc:	2b3f      	cmp	r3, #63	; 0x3f
 801cebe:	bf28      	it	cs
 801cec0:	233f      	movcs	r3, #63	; 0x3f
 801cec2:	65fb      	str	r3, [r7, #92]	; 0x5c
        NK_MEMCPY(win->name_string, name, name_length);
 801cec4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801cec6:	3308      	adds	r3, #8
 801cec8:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801ceca:	69b9      	ldr	r1, [r7, #24]
 801cecc:	4618      	mov	r0, r3
 801cece:	f7fe ff5b 	bl	801bd88 <nk_memcopy>
        win->name_string[name_length] = 0;
 801ced2:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 801ced4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801ced6:	4413      	add	r3, r2
 801ced8:	3308      	adds	r3, #8
 801ceda:	2200      	movs	r2, #0
 801cedc:	701a      	strb	r2, [r3, #0]
        win->popup.win = 0;
 801cede:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801cee0:	2200      	movs	r2, #0
 801cee2:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
        if (!ctx->active)
 801cee6:	69fb      	ldr	r3, [r7, #28]
 801cee8:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801ceec:	f8d3 3654 	ldr.w	r3, [r3, #1620]	; 0x654
 801cef0:	2b00      	cmp	r3, #0
 801cef2:	d153      	bne.n	801cf9c <nk_begin_titled+0x250>
            ctx->active = win;
 801cef4:	69fb      	ldr	r3, [r7, #28]
 801cef6:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cefa:	461a      	mov	r2, r3
 801cefc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801cefe:	f8c2 3654 	str.w	r3, [r2, #1620]	; 0x654
 801cf02:	e04b      	b.n	801cf9c <nk_begin_titled+0x250>
    } else {
        /* update window */
        win->flags &= ~(nk_flags)(NK_WINDOW_PRIVATE-1);
 801cf04:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801cf06:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801cf08:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 801cf0c:	f023 0307 	bic.w	r3, r3, #7
 801cf10:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 801cf12:	6493      	str	r3, [r2, #72]	; 0x48
        win->flags |= flags;
 801cf14:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801cf16:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 801cf18:	683b      	ldr	r3, [r7, #0]
 801cf1a:	431a      	orrs	r2, r3
 801cf1c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801cf1e:	649a      	str	r2, [r3, #72]	; 0x48
        if (!(win->flags & (NK_WINDOW_MOVABLE | NK_WINDOW_SCALABLE)))
 801cf20:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801cf22:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801cf24:	f003 0306 	and.w	r3, r3, #6
 801cf28:	2b00      	cmp	r3, #0
 801cf2a:	d106      	bne.n	801cf3a <nk_begin_titled+0x1ee>
            win->bounds = bounds;
 801cf2c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801cf2e:	f103 044c 	add.w	r4, r3, #76	; 0x4c
 801cf32:	1d3b      	adds	r3, r7, #4
 801cf34:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801cf36:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
         * I.) Have more than one window with the same name or
         * II.) You forgot to actually draw the window.
         *      More specific you did not call `nk_clear` (nk_clear will be
         *      automatically called for you if you are using one of the
         *      provided demo backends). */
        NK_ASSERT(win->seq != ctx->seq);
 801cf3a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801cf3c:	681a      	ldr	r2, [r3, #0]
 801cf3e:	69fb      	ldr	r3, [r7, #28]
 801cf40:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cf44:	f8d3 3664 	ldr.w	r3, [r3, #1636]	; 0x664
 801cf48:	429a      	cmp	r2, r3
 801cf4a:	d105      	bne.n	801cf58 <nk_begin_titled+0x20c>
 801cf4c:	4b25      	ldr	r3, [pc, #148]	; (801cfe4 <nk_begin_titled+0x298>)
 801cf4e:	4a1e      	ldr	r2, [pc, #120]	; (801cfc8 <nk_begin_titled+0x27c>)
 801cf50:	21c6      	movs	r1, #198	; 0xc6
 801cf52:	481e      	ldr	r0, [pc, #120]	; (801cfcc <nk_begin_titled+0x280>)
 801cf54:	f000 fd60 	bl	801da18 <__assert_func>
        win->seq = ctx->seq;
 801cf58:	69fb      	ldr	r3, [r7, #28]
 801cf5a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cf5e:	f8d3 2664 	ldr.w	r2, [r3, #1636]	; 0x664
 801cf62:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801cf64:	601a      	str	r2, [r3, #0]
        if (!ctx->active && !(win->flags & NK_WINDOW_HIDDEN)) {
 801cf66:	69fb      	ldr	r3, [r7, #28]
 801cf68:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cf6c:	f8d3 3654 	ldr.w	r3, [r3, #1620]	; 0x654
 801cf70:	2b00      	cmp	r3, #0
 801cf72:	d113      	bne.n	801cf9c <nk_begin_titled+0x250>
 801cf74:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801cf76:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801cf78:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801cf7c:	2b00      	cmp	r3, #0
 801cf7e:	d10d      	bne.n	801cf9c <nk_begin_titled+0x250>
            ctx->active = win;
 801cf80:	69fb      	ldr	r3, [r7, #28]
 801cf82:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cf86:	461a      	mov	r2, r3
 801cf88:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801cf8a:	f8c2 3654 	str.w	r3, [r2, #1620]	; 0x654
            ctx->end = win;
 801cf8e:	69fb      	ldr	r3, [r7, #28]
 801cf90:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cf94:	461a      	mov	r2, r3
 801cf96:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801cf98:	f8c2 3650 	str.w	r3, [r2, #1616]	; 0x650
        }
    }
    if (win->flags & NK_WINDOW_HIDDEN) {
 801cf9c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801cf9e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801cfa0:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801cfa4:	2b00      	cmp	r3, #0
 801cfa6:	d01f      	beq.n	801cfe8 <nk_begin_titled+0x29c>
        ctx->current = win;
 801cfa8:	69fb      	ldr	r3, [r7, #28]
 801cfaa:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801cfae:	461a      	mov	r2, r3
 801cfb0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801cfb2:	f8c2 3658 	str.w	r3, [r2, #1624]	; 0x658
        win->layout = 0;
 801cfb6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801cfb8:	2200      	movs	r2, #0
 801cfba:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        return 0;
 801cfbe:	2300      	movs	r3, #0
 801cfc0:	e300      	b.n	801d5c4 <nk_begin_titled+0x878>
 801cfc2:	bf00      	nop
 801cfc4:	080222f0 	.word	0x080222f0
 801cfc8:	08023844 	.word	0x08023844
 801cfcc:	080222d4 	.word	0x080222d4
 801cfd0:	08022304 	.word	0x08022304
 801cfd4:	0802230c 	.word	0x0802230c
 801cfd8:	08022314 	.word	0x08022314
 801cfdc:	08022370 	.word	0x08022370
 801cfe0:	080222f4 	.word	0x080222f4
 801cfe4:	080223b0 	.word	0x080223b0
    } else nk_start(ctx, win);
 801cfe8:	6f79      	ldr	r1, [r7, #116]	; 0x74
 801cfea:	69f8      	ldr	r0, [r7, #28]
 801cfec:	f7f2 ff1a 	bl	800fe24 <nk_start>

    /* window overlapping */
    if (!(win->flags & NK_WINDOW_HIDDEN) && !(win->flags & NK_WINDOW_NO_INPUT))
 801cff0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801cff2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801cff4:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801cff8:	2b00      	cmp	r3, #0
 801cffa:	f040 82c2 	bne.w	801d582 <nk_begin_titled+0x836>
 801cffe:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d000:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d002:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801d006:	2b00      	cmp	r3, #0
 801d008:	f040 82bb 	bne.w	801d582 <nk_begin_titled+0x836>
    {
        int inpanel, ishovered;
        struct nk_window *iter = win;
 801d00c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d00e:	673b      	str	r3, [r7, #112]	; 0x70
        float h = ctx->style.font->height + 2.0f * style->window.header.padding.y +
 801d010:	69fb      	ldr	r3, [r7, #28]
 801d012:	f8d3 3168 	ldr.w	r3, [r3, #360]	; 0x168
 801d016:	ed93 7a01 	vldr	s14, [r3, #4]
 801d01a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801d01c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801d020:	f603 0344 	addw	r3, r3, #2116	; 0x844
 801d024:	edd3 7a00 	vldr	s15, [r3]
 801d028:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801d02c:	ee37 7a27 	vadd.f32	s14, s14, s15
            (2.0f * style->window.header.label_padding.y);
 801d030:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801d032:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801d036:	f603 034c 	addw	r3, r3, #2124	; 0x84c
 801d03a:	edd3 7a00 	vldr	s15, [r3]
 801d03e:	ee77 7aa7 	vadd.f32	s15, s15, s15
        float h = ctx->style.font->height + 2.0f * style->window.header.padding.y +
 801d042:	ee77 7a27 	vadd.f32	s15, s14, s15
 801d046:	edc7 7a16 	vstr	s15, [r7, #88]	; 0x58
        struct nk_rect win_bounds = (!(win->flags & NK_WINDOW_MINIMIZED))?
 801d04a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d04c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d04e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 801d052:	2b00      	cmp	r3, #0
 801d054:	d107      	bne.n	801d066 <nk_begin_titled+0x31a>
 801d056:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d058:	f107 0440 	add.w	r4, r7, #64	; 0x40
 801d05c:	334c      	adds	r3, #76	; 0x4c
 801d05e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d060:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 801d064:	e022      	b.n	801d0ac <nk_begin_titled+0x360>
            win->bounds: nk_rect(win->bounds.x, win->bounds.y, win->bounds.w, h);
 801d066:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d068:	edd3 7a13 	vldr	s15, [r3, #76]	; 0x4c
 801d06c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d06e:	ed93 7a14 	vldr	s14, [r3, #80]	; 0x50
 801d072:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d074:	edd3 6a15 	vldr	s13, [r3, #84]	; 0x54
 801d078:	edd7 1a16 	vldr	s3, [r7, #88]	; 0x58
 801d07c:	eeb0 1a66 	vmov.f32	s2, s13
 801d080:	eef0 0a47 	vmov.f32	s1, s14
 801d084:	eeb0 0a67 	vmov.f32	s0, s15
 801d088:	f7f6 fb64 	bl	8013754 <nk_rect>
 801d08c:	eeb0 6a40 	vmov.f32	s12, s0
 801d090:	eef0 6a60 	vmov.f32	s13, s1
 801d094:	eeb0 7a41 	vmov.f32	s14, s2
 801d098:	eef0 7a61 	vmov.f32	s15, s3
 801d09c:	ed87 6a10 	vstr	s12, [r7, #64]	; 0x40
 801d0a0:	edc7 6a11 	vstr	s13, [r7, #68]	; 0x44
 801d0a4:	ed87 7a12 	vstr	s14, [r7, #72]	; 0x48
 801d0a8:	edc7 7a13 	vstr	s15, [r7, #76]	; 0x4c

        /* activate window if hovered and no other window is overlapping this window */
        inpanel = nk_input_has_mouse_click_down_in_rect(&ctx->input, NK_BUTTON_LEFT, win_bounds, nk_true);
 801d0ac:	69fb      	ldr	r3, [r7, #28]
 801d0ae:	ed97 6a10 	vldr	s12, [r7, #64]	; 0x40
 801d0b2:	edd7 6a11 	vldr	s13, [r7, #68]	; 0x44
 801d0b6:	ed97 7a12 	vldr	s14, [r7, #72]	; 0x48
 801d0ba:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
 801d0be:	2201      	movs	r2, #1
 801d0c0:	eeb0 0a46 	vmov.f32	s0, s12
 801d0c4:	eef0 0a66 	vmov.f32	s1, s13
 801d0c8:	eeb0 1a47 	vmov.f32	s2, s14
 801d0cc:	eef0 1a67 	vmov.f32	s3, s15
 801d0d0:	2100      	movs	r1, #0
 801d0d2:	4618      	mov	r0, r3
 801d0d4:	f7f5 f9dc 	bl	8012490 <nk_input_has_mouse_click_down_in_rect>
 801d0d8:	6578      	str	r0, [r7, #84]	; 0x54
        inpanel = inpanel && ctx->input.mouse.buttons[NK_BUTTON_LEFT].clicked;
 801d0da:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801d0dc:	2b00      	cmp	r3, #0
 801d0de:	d006      	beq.n	801d0ee <nk_begin_titled+0x3a2>
 801d0e0:	69fb      	ldr	r3, [r7, #28]
 801d0e2:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 801d0e6:	2b00      	cmp	r3, #0
 801d0e8:	d001      	beq.n	801d0ee <nk_begin_titled+0x3a2>
 801d0ea:	2301      	movs	r3, #1
 801d0ec:	e000      	b.n	801d0f0 <nk_begin_titled+0x3a4>
 801d0ee:	2300      	movs	r3, #0
 801d0f0:	657b      	str	r3, [r7, #84]	; 0x54
        ishovered = nk_input_is_mouse_hovering_rect(&ctx->input, win_bounds);
 801d0f2:	69fb      	ldr	r3, [r7, #28]
 801d0f4:	ed97 6a10 	vldr	s12, [r7, #64]	; 0x40
 801d0f8:	edd7 6a11 	vldr	s13, [r7, #68]	; 0x44
 801d0fc:	ed97 7a12 	vldr	s14, [r7, #72]	; 0x48
 801d100:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
 801d104:	eeb0 0a46 	vmov.f32	s0, s12
 801d108:	eef0 0a66 	vmov.f32	s1, s13
 801d10c:	eeb0 1a47 	vmov.f32	s2, s14
 801d110:	eef0 1a67 	vmov.f32	s3, s15
 801d114:	4618      	mov	r0, r3
 801d116:	f7f5 fa02 	bl	801251e <nk_input_is_mouse_hovering_rect>
 801d11a:	6538      	str	r0, [r7, #80]	; 0x50
        if ((win != ctx->active) && ishovered && !ctx->input.mouse.buttons[NK_BUTTON_LEFT].down) {
 801d11c:	69fb      	ldr	r3, [r7, #28]
 801d11e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d122:	f8d3 3654 	ldr.w	r3, [r3, #1620]	; 0x654
 801d126:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 801d128:	429a      	cmp	r2, r3
 801d12a:	f000 80de 	beq.w	801d2ea <nk_begin_titled+0x59e>
 801d12e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801d130:	2b00      	cmp	r3, #0
 801d132:	f000 80da 	beq.w	801d2ea <nk_begin_titled+0x59e>
 801d136:	69fb      	ldr	r3, [r7, #28]
 801d138:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 801d13c:	2b00      	cmp	r3, #0
 801d13e:	f040 80d4 	bne.w	801d2ea <nk_begin_titled+0x59e>
            iter = win->next;
 801d142:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d144:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 801d148:	673b      	str	r3, [r7, #112]	; 0x70
            while (iter) {
 801d14a:	e0c6      	b.n	801d2da <nk_begin_titled+0x58e>
                struct nk_rect iter_bounds = (!(iter->flags & NK_WINDOW_MINIMIZED))?
 801d14c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d14e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d150:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 801d154:	2b00      	cmp	r3, #0
 801d156:	d107      	bne.n	801d168 <nk_begin_titled+0x41c>
 801d158:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d15a:	f107 0430 	add.w	r4, r7, #48	; 0x30
 801d15e:	334c      	adds	r3, #76	; 0x4c
 801d160:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d162:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 801d166:	e022      	b.n	801d1ae <nk_begin_titled+0x462>
                    iter->bounds: nk_rect(iter->bounds.x, iter->bounds.y, iter->bounds.w, h);
 801d168:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d16a:	edd3 7a13 	vldr	s15, [r3, #76]	; 0x4c
 801d16e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d170:	ed93 7a14 	vldr	s14, [r3, #80]	; 0x50
 801d174:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d176:	edd3 6a15 	vldr	s13, [r3, #84]	; 0x54
 801d17a:	edd7 1a16 	vldr	s3, [r7, #88]	; 0x58
 801d17e:	eeb0 1a66 	vmov.f32	s2, s13
 801d182:	eef0 0a47 	vmov.f32	s1, s14
 801d186:	eeb0 0a67 	vmov.f32	s0, s15
 801d18a:	f7f6 fae3 	bl	8013754 <nk_rect>
 801d18e:	eeb0 6a40 	vmov.f32	s12, s0
 801d192:	eef0 6a60 	vmov.f32	s13, s1
 801d196:	eeb0 7a41 	vmov.f32	s14, s2
 801d19a:	eef0 7a61 	vmov.f32	s15, s3
 801d19e:	ed87 6a0c 	vstr	s12, [r7, #48]	; 0x30
 801d1a2:	edc7 6a0d 	vstr	s13, [r7, #52]	; 0x34
 801d1a6:	ed87 7a0e 	vstr	s14, [r7, #56]	; 0x38
 801d1aa:	edc7 7a0f 	vstr	s15, [r7, #60]	; 0x3c
                if (NK_INTERSECT(win_bounds.x, win_bounds.y, win_bounds.w, win_bounds.h,
 801d1ae:	ed97 7a0c 	vldr	s14, [r7, #48]	; 0x30
 801d1b2:	edd7 6a10 	vldr	s13, [r7, #64]	; 0x40
 801d1b6:	edd7 7a12 	vldr	s15, [r7, #72]	; 0x48
 801d1ba:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801d1be:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801d1c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d1c6:	d52c      	bpl.n	801d222 <nk_begin_titled+0x4d6>
 801d1c8:	ed97 7a10 	vldr	s14, [r7, #64]	; 0x40
 801d1cc:	edd7 6a0c 	vldr	s13, [r7, #48]	; 0x30
 801d1d0:	edd7 7a0e 	vldr	s15, [r7, #56]	; 0x38
 801d1d4:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801d1d8:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801d1dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d1e0:	d51f      	bpl.n	801d222 <nk_begin_titled+0x4d6>
 801d1e2:	ed97 7a0d 	vldr	s14, [r7, #52]	; 0x34
 801d1e6:	edd7 6a11 	vldr	s13, [r7, #68]	; 0x44
 801d1ea:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
 801d1ee:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801d1f2:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801d1f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d1fa:	d512      	bpl.n	801d222 <nk_begin_titled+0x4d6>
 801d1fc:	ed97 7a11 	vldr	s14, [r7, #68]	; 0x44
 801d200:	edd7 6a0d 	vldr	s13, [r7, #52]	; 0x34
 801d204:	edd7 7a0f 	vldr	s15, [r7, #60]	; 0x3c
 801d208:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801d20c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801d210:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d214:	d505      	bpl.n	801d222 <nk_begin_titled+0x4d6>
                    iter_bounds.x, iter_bounds.y, iter_bounds.w, iter_bounds.h) &&
                    (!(iter->flags & NK_WINDOW_HIDDEN)))
 801d216:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d218:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d21a:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
                    iter_bounds.x, iter_bounds.y, iter_bounds.w, iter_bounds.h) &&
 801d21e:	2b00      	cmp	r3, #0
 801d220:	d060      	beq.n	801d2e4 <nk_begin_titled+0x598>
                    break;

                if (iter->popup.win && iter->popup.active && !(iter->flags & NK_WINDOW_HIDDEN) &&
 801d222:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d224:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801d228:	2b00      	cmp	r3, #0
 801d22a:	d052      	beq.n	801d2d2 <nk_begin_titled+0x586>
 801d22c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d22e:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 801d232:	2b00      	cmp	r3, #0
 801d234:	d04d      	beq.n	801d2d2 <nk_begin_titled+0x586>
 801d236:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d238:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d23a:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801d23e:	2b00      	cmp	r3, #0
 801d240:	d147      	bne.n	801d2d2 <nk_begin_titled+0x586>
                    NK_INTERSECT(win->bounds.x, win_bounds.y, win_bounds.w, win_bounds.h,
 801d242:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d244:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801d248:	ed93 7a13 	vldr	s14, [r3, #76]	; 0x4c
 801d24c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d24e:	edd3 6a13 	vldr	s13, [r3, #76]	; 0x4c
 801d252:	edd7 7a12 	vldr	s15, [r7, #72]	; 0x48
 801d256:	ee76 7aa7 	vadd.f32	s15, s13, s15
                if (iter->popup.win && iter->popup.active && !(iter->flags & NK_WINDOW_HIDDEN) &&
 801d25a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801d25e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d262:	d536      	bpl.n	801d2d2 <nk_begin_titled+0x586>
                    NK_INTERSECT(win->bounds.x, win_bounds.y, win_bounds.w, win_bounds.h,
 801d264:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d266:	ed93 7a13 	vldr	s14, [r3, #76]	; 0x4c
 801d26a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d26c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801d270:	edd3 6a13 	vldr	s13, [r3, #76]	; 0x4c
 801d274:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d276:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801d27a:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 801d27e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801d282:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801d286:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d28a:	d522      	bpl.n	801d2d2 <nk_begin_titled+0x586>
 801d28c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d28e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801d292:	ed93 7a14 	vldr	s14, [r3, #80]	; 0x50
 801d296:	edd7 6a11 	vldr	s13, [r7, #68]	; 0x44
 801d29a:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
 801d29e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801d2a2:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801d2a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d2aa:	d512      	bpl.n	801d2d2 <nk_begin_titled+0x586>
 801d2ac:	ed97 7a11 	vldr	s14, [r7, #68]	; 0x44
 801d2b0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d2b2:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801d2b6:	edd3 6a14 	vldr	s13, [r3, #80]	; 0x50
 801d2ba:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d2bc:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801d2c0:	edd3 7a16 	vldr	s15, [r3, #88]	; 0x58
 801d2c4:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801d2c8:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801d2cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d2d0:	d40a      	bmi.n	801d2e8 <nk_begin_titled+0x59c>
                    iter->popup.win->bounds.x, iter->popup.win->bounds.y,
                    iter->popup.win->bounds.w, iter->popup.win->bounds.h))
                    break;
                iter = iter->next;
 801d2d2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d2d4:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 801d2d8:	673b      	str	r3, [r7, #112]	; 0x70
            while (iter) {
 801d2da:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d2dc:	2b00      	cmp	r3, #0
 801d2de:	f47f af35 	bne.w	801d14c <nk_begin_titled+0x400>
 801d2e2:	e002      	b.n	801d2ea <nk_begin_titled+0x59e>
                    break;
 801d2e4:	bf00      	nop
 801d2e6:	e000      	b.n	801d2ea <nk_begin_titled+0x59e>
                    break;
 801d2e8:	bf00      	nop
            }
        }

        /* activate window if clicked */
        if (iter && inpanel && (win != ctx->end)) {
 801d2ea:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d2ec:	2b00      	cmp	r3, #0
 801d2ee:	f000 80db 	beq.w	801d4a8 <nk_begin_titled+0x75c>
 801d2f2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801d2f4:	2b00      	cmp	r3, #0
 801d2f6:	f000 80d7 	beq.w	801d4a8 <nk_begin_titled+0x75c>
 801d2fa:	69fb      	ldr	r3, [r7, #28]
 801d2fc:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d300:	f8d3 3650 	ldr.w	r3, [r3, #1616]	; 0x650
 801d304:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 801d306:	429a      	cmp	r2, r3
 801d308:	f000 80ce 	beq.w	801d4a8 <nk_begin_titled+0x75c>
            iter = win->next;
 801d30c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d30e:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 801d312:	673b      	str	r3, [r7, #112]	; 0x70
            while (iter) {
 801d314:	e0c0      	b.n	801d498 <nk_begin_titled+0x74c>
                /* try to find a panel with higher priority in the same position */
                struct nk_rect iter_bounds = (!(iter->flags & NK_WINDOW_MINIMIZED))?
 801d316:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d318:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d31a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 801d31e:	2b00      	cmp	r3, #0
 801d320:	d107      	bne.n	801d332 <nk_begin_titled+0x5e6>
 801d322:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d324:	f107 0420 	add.w	r4, r7, #32
 801d328:	334c      	adds	r3, #76	; 0x4c
 801d32a:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d32c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 801d330:	e022      	b.n	801d378 <nk_begin_titled+0x62c>
                iter->bounds: nk_rect(iter->bounds.x, iter->bounds.y, iter->bounds.w, h);
 801d332:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d334:	edd3 7a13 	vldr	s15, [r3, #76]	; 0x4c
 801d338:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d33a:	ed93 7a14 	vldr	s14, [r3, #80]	; 0x50
 801d33e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d340:	edd3 6a15 	vldr	s13, [r3, #84]	; 0x54
 801d344:	edd7 1a16 	vldr	s3, [r7, #88]	; 0x58
 801d348:	eeb0 1a66 	vmov.f32	s2, s13
 801d34c:	eef0 0a47 	vmov.f32	s1, s14
 801d350:	eeb0 0a67 	vmov.f32	s0, s15
 801d354:	f7f6 f9fe 	bl	8013754 <nk_rect>
 801d358:	eeb0 6a40 	vmov.f32	s12, s0
 801d35c:	eef0 6a60 	vmov.f32	s13, s1
 801d360:	eeb0 7a41 	vmov.f32	s14, s2
 801d364:	eef0 7a61 	vmov.f32	s15, s3
 801d368:	ed87 6a08 	vstr	s12, [r7, #32]
 801d36c:	edc7 6a09 	vstr	s13, [r7, #36]	; 0x24
 801d370:	ed87 7a0a 	vstr	s14, [r7, #40]	; 0x28
 801d374:	edc7 7a0b 	vstr	s15, [r7, #44]	; 0x2c
                if (NK_INBOX(ctx->input.mouse.pos.x, ctx->input.mouse.pos.y,
 801d378:	ed97 7a08 	vldr	s14, [r7, #32]
 801d37c:	69fb      	ldr	r3, [r7, #28]
 801d37e:	edd3 7a51 	vldr	s15, [r3, #324]	; 0x144
 801d382:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801d386:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d38a:	d82b      	bhi.n	801d3e4 <nk_begin_titled+0x698>
 801d38c:	69fb      	ldr	r3, [r7, #28]
 801d38e:	ed93 7a51 	vldr	s14, [r3, #324]	; 0x144
 801d392:	edd7 6a08 	vldr	s13, [r7, #32]
 801d396:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
 801d39a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801d39e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801d3a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d3a6:	d51d      	bpl.n	801d3e4 <nk_begin_titled+0x698>
 801d3a8:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 801d3ac:	69fb      	ldr	r3, [r7, #28]
 801d3ae:	edd3 7a52 	vldr	s15, [r3, #328]	; 0x148
 801d3b2:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801d3b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d3ba:	d813      	bhi.n	801d3e4 <nk_begin_titled+0x698>
 801d3bc:	69fb      	ldr	r3, [r7, #28]
 801d3be:	ed93 7a52 	vldr	s14, [r3, #328]	; 0x148
 801d3c2:	edd7 6a09 	vldr	s13, [r7, #36]	; 0x24
 801d3c6:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
 801d3ca:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801d3ce:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801d3d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d3d6:	d505      	bpl.n	801d3e4 <nk_begin_titled+0x698>
                    iter_bounds.x, iter_bounds.y, iter_bounds.w, iter_bounds.h) &&
                    !(iter->flags & NK_WINDOW_HIDDEN))
 801d3d8:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d3da:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d3dc:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
                    iter_bounds.x, iter_bounds.y, iter_bounds.w, iter_bounds.h) &&
 801d3e0:	2b00      	cmp	r3, #0
 801d3e2:	d05e      	beq.n	801d4a2 <nk_begin_titled+0x756>
                    break;
                if (iter->popup.win && iter->popup.active && !(iter->flags & NK_WINDOW_HIDDEN) &&
 801d3e4:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d3e6:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801d3ea:	2b00      	cmp	r3, #0
 801d3ec:	d050      	beq.n	801d490 <nk_begin_titled+0x744>
 801d3ee:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d3f0:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 801d3f4:	2b00      	cmp	r3, #0
 801d3f6:	d04b      	beq.n	801d490 <nk_begin_titled+0x744>
 801d3f8:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d3fa:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d3fc:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801d400:	2b00      	cmp	r3, #0
 801d402:	d145      	bne.n	801d490 <nk_begin_titled+0x744>
                    NK_INTERSECT(win_bounds.x, win_bounds.y, win_bounds.w, win_bounds.h,
 801d404:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d406:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801d40a:	ed93 7a13 	vldr	s14, [r3, #76]	; 0x4c
 801d40e:	edd7 6a10 	vldr	s13, [r7, #64]	; 0x40
 801d412:	edd7 7a12 	vldr	s15, [r7, #72]	; 0x48
 801d416:	ee76 7aa7 	vadd.f32	s15, s13, s15
                if (iter->popup.win && iter->popup.active && !(iter->flags & NK_WINDOW_HIDDEN) &&
 801d41a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801d41e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d422:	d535      	bpl.n	801d490 <nk_begin_titled+0x744>
                    NK_INTERSECT(win_bounds.x, win_bounds.y, win_bounds.w, win_bounds.h,
 801d424:	ed97 7a10 	vldr	s14, [r7, #64]	; 0x40
 801d428:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d42a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801d42e:	edd3 6a13 	vldr	s13, [r3, #76]	; 0x4c
 801d432:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d434:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801d438:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 801d43c:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801d440:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801d444:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d448:	d522      	bpl.n	801d490 <nk_begin_titled+0x744>
 801d44a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d44c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801d450:	ed93 7a14 	vldr	s14, [r3, #80]	; 0x50
 801d454:	edd7 6a11 	vldr	s13, [r7, #68]	; 0x44
 801d458:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
 801d45c:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801d460:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801d464:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d468:	d512      	bpl.n	801d490 <nk_begin_titled+0x744>
 801d46a:	ed97 7a11 	vldr	s14, [r7, #68]	; 0x44
 801d46e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d470:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801d474:	edd3 6a14 	vldr	s13, [r3, #80]	; 0x50
 801d478:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d47a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801d47e:	edd3 7a16 	vldr	s15, [r3, #88]	; 0x58
 801d482:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801d486:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801d48a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d48e:	d40a      	bmi.n	801d4a6 <nk_begin_titled+0x75a>
                    iter->popup.win->bounds.x, iter->popup.win->bounds.y,
                    iter->popup.win->bounds.w, iter->popup.win->bounds.h))
                    break;
                iter = iter->next;
 801d490:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d492:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 801d496:	673b      	str	r3, [r7, #112]	; 0x70
            while (iter) {
 801d498:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d49a:	2b00      	cmp	r3, #0
 801d49c:	f47f af3b 	bne.w	801d316 <nk_begin_titled+0x5ca>
 801d4a0:	e002      	b.n	801d4a8 <nk_begin_titled+0x75c>
                    break;
 801d4a2:	bf00      	nop
 801d4a4:	e000      	b.n	801d4a8 <nk_begin_titled+0x75c>
                    break;
 801d4a6:	bf00      	nop
            }
        }
        if (iter && !(win->flags & NK_WINDOW_ROM) && (win->flags & NK_WINDOW_BACKGROUND)) {
 801d4a8:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d4aa:	2b00      	cmp	r3, #0
 801d4ac:	d02e      	beq.n	801d50c <nk_begin_titled+0x7c0>
 801d4ae:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d4b0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d4b2:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 801d4b6:	2b00      	cmp	r3, #0
 801d4b8:	d128      	bne.n	801d50c <nk_begin_titled+0x7c0>
 801d4ba:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d4bc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d4be:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801d4c2:	2b00      	cmp	r3, #0
 801d4c4:	d022      	beq.n	801d50c <nk_begin_titled+0x7c0>
            win->flags |= (nk_flags)NK_WINDOW_ROM;
 801d4c6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d4c8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d4ca:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
 801d4ce:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d4d0:	649a      	str	r2, [r3, #72]	; 0x48
            iter->flags &= ~(nk_flags)NK_WINDOW_ROM;
 801d4d2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d4d4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d4d6:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 801d4da:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d4dc:	649a      	str	r2, [r3, #72]	; 0x48
            ctx->active = iter;
 801d4de:	69fb      	ldr	r3, [r7, #28]
 801d4e0:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d4e4:	461a      	mov	r2, r3
 801d4e6:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d4e8:	f8c2 3654 	str.w	r3, [r2, #1620]	; 0x654
            if (!(iter->flags & NK_WINDOW_BACKGROUND)) {
 801d4ec:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d4ee:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d4f0:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801d4f4:	2b00      	cmp	r3, #0
 801d4f6:	d144      	bne.n	801d582 <nk_begin_titled+0x836>
                /* current window is active in that position so transfer to top
                 * at the highest priority in stack */
                nk_remove_window(ctx, iter);
 801d4f8:	6f39      	ldr	r1, [r7, #112]	; 0x70
 801d4fa:	69f8      	ldr	r0, [r7, #28]
 801d4fc:	f7ff fb46 	bl	801cb8c <nk_remove_window>
                nk_insert_window(ctx, iter, NK_INSERT_BACK);
 801d500:	2200      	movs	r2, #0
 801d502:	6f39      	ldr	r1, [r7, #112]	; 0x70
 801d504:	69f8      	ldr	r0, [r7, #28]
 801d506:	f7ff fa4b 	bl	801c9a0 <nk_insert_window>
            if (!(iter->flags & NK_WINDOW_BACKGROUND)) {
 801d50a:	e03a      	b.n	801d582 <nk_begin_titled+0x836>
            }
        } else {
            if (!iter && ctx->end != win) {
 801d50c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801d50e:	2b00      	cmp	r3, #0
 801d510:	d123      	bne.n	801d55a <nk_begin_titled+0x80e>
 801d512:	69fb      	ldr	r3, [r7, #28]
 801d514:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d518:	f8d3 3650 	ldr.w	r3, [r3, #1616]	; 0x650
 801d51c:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 801d51e:	429a      	cmp	r2, r3
 801d520:	d01b      	beq.n	801d55a <nk_begin_titled+0x80e>
                if (!(win->flags & NK_WINDOW_BACKGROUND)) {
 801d522:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d524:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d526:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801d52a:	2b00      	cmp	r3, #0
 801d52c:	d108      	bne.n	801d540 <nk_begin_titled+0x7f4>
                    /* current window is active in that position so transfer to top
                     * at the highest priority in stack */
                    nk_remove_window(ctx, win);
 801d52e:	6f79      	ldr	r1, [r7, #116]	; 0x74
 801d530:	69f8      	ldr	r0, [r7, #28]
 801d532:	f7ff fb2b 	bl	801cb8c <nk_remove_window>
                    nk_insert_window(ctx, win, NK_INSERT_BACK);
 801d536:	2200      	movs	r2, #0
 801d538:	6f79      	ldr	r1, [r7, #116]	; 0x74
 801d53a:	69f8      	ldr	r0, [r7, #28]
 801d53c:	f7ff fa30 	bl	801c9a0 <nk_insert_window>
                }
                win->flags &= ~(nk_flags)NK_WINDOW_ROM;
 801d540:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d542:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d544:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 801d548:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d54a:	649a      	str	r2, [r3, #72]	; 0x48
                ctx->active = win;
 801d54c:	69fb      	ldr	r3, [r7, #28]
 801d54e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d552:	461a      	mov	r2, r3
 801d554:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d556:	f8c2 3654 	str.w	r3, [r2, #1620]	; 0x654
            }
            if (ctx->end != win && !(win->flags & NK_WINDOW_BACKGROUND))
 801d55a:	69fb      	ldr	r3, [r7, #28]
 801d55c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d560:	f8d3 3650 	ldr.w	r3, [r3, #1616]	; 0x650
 801d564:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 801d566:	429a      	cmp	r2, r3
 801d568:	d00b      	beq.n	801d582 <nk_begin_titled+0x836>
 801d56a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d56c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d56e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801d572:	2b00      	cmp	r3, #0
 801d574:	d105      	bne.n	801d582 <nk_begin_titled+0x836>
                win->flags |= NK_WINDOW_ROM;
 801d576:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d578:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d57a:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
 801d57e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d580:	649a      	str	r2, [r3, #72]	; 0x48
        }
    }
    win->layout = (struct nk_panel*)nk_create_panel(ctx);
 801d582:	69f8      	ldr	r0, [r7, #28]
 801d584:	f7f6 fcfc 	bl	8013f80 <nk_create_panel>
 801d588:	4602      	mov	r2, r0
 801d58a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d58c:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    ctx->current = win;
 801d590:	69fb      	ldr	r3, [r7, #28]
 801d592:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d596:	461a      	mov	r2, r3
 801d598:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d59a:	f8c2 3658 	str.w	r3, [r2, #1624]	; 0x658
    ret = nk_panel_begin(ctx, title, NK_PANEL_WINDOW);
 801d59e:	2201      	movs	r2, #1
 801d5a0:	6979      	ldr	r1, [r7, #20]
 801d5a2:	69f8      	ldr	r0, [r7, #28]
 801d5a4:	f7f6 ff5a 	bl	801445c <nk_panel_begin>
 801d5a8:	66f8      	str	r0, [r7, #108]	; 0x6c
    win->layout->offset_x = &win->scrollbar.x;
 801d5aa:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d5ac:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801d5b0:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 801d5b2:	325c      	adds	r2, #92	; 0x5c
 801d5b4:	619a      	str	r2, [r3, #24]
    win->layout->offset_y = &win->scrollbar.y;
 801d5b6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801d5b8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801d5bc:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 801d5be:	3260      	adds	r2, #96	; 0x60
 801d5c0:	61da      	str	r2, [r3, #28]
    return ret;
 801d5c2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
}
 801d5c4:	4618      	mov	r0, r3
 801d5c6:	377c      	adds	r7, #124	; 0x7c
 801d5c8:	46bd      	mov	sp, r7
 801d5ca:	bd90      	pop	{r4, r7, pc}

0801d5cc <nk_end>:
NK_API void
nk_end(struct nk_context *ctx)
{
 801d5cc:	b580      	push	{r7, lr}
 801d5ce:	b084      	sub	sp, #16
 801d5d0:	af00      	add	r7, sp, #0
 801d5d2:	6078      	str	r0, [r7, #4]
    struct nk_panel *layout;
    NK_ASSERT(ctx);
 801d5d4:	687b      	ldr	r3, [r7, #4]
 801d5d6:	2b00      	cmp	r3, #0
 801d5d8:	d106      	bne.n	801d5e8 <nk_end+0x1c>
 801d5da:	4b2d      	ldr	r3, [pc, #180]	; (801d690 <nk_end+0xc4>)
 801d5dc:	4a2d      	ldr	r2, [pc, #180]	; (801d694 <nk_end+0xc8>)
 801d5de:	f240 112b 	movw	r1, #299	; 0x12b
 801d5e2:	482d      	ldr	r0, [pc, #180]	; (801d698 <nk_end+0xcc>)
 801d5e4:	f000 fa18 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current && "if this triggers you forgot to call `nk_begin`");
 801d5e8:	687b      	ldr	r3, [r7, #4]
 801d5ea:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d5ee:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801d5f2:	2b00      	cmp	r3, #0
 801d5f4:	d106      	bne.n	801d604 <nk_end+0x38>
 801d5f6:	4b29      	ldr	r3, [pc, #164]	; (801d69c <nk_end+0xd0>)
 801d5f8:	4a26      	ldr	r2, [pc, #152]	; (801d694 <nk_end+0xc8>)
 801d5fa:	f44f 7196 	mov.w	r1, #300	; 0x12c
 801d5fe:	4826      	ldr	r0, [pc, #152]	; (801d698 <nk_end+0xcc>)
 801d600:	f000 fa0a 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current)
 801d604:	687b      	ldr	r3, [r7, #4]
 801d606:	2b00      	cmp	r3, #0
 801d608:	d03d      	beq.n	801d686 <nk_end+0xba>
 801d60a:	687b      	ldr	r3, [r7, #4]
 801d60c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d610:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801d614:	2b00      	cmp	r3, #0
 801d616:	d036      	beq.n	801d686 <nk_end+0xba>
        return;

    layout = ctx->current->layout;
 801d618:	687b      	ldr	r3, [r7, #4]
 801d61a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d61e:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801d622:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801d626:	60fb      	str	r3, [r7, #12]
    if (!layout || (layout->type == NK_PANEL_WINDOW && (ctx->current->flags & NK_WINDOW_HIDDEN))) {
 801d628:	68fb      	ldr	r3, [r7, #12]
 801d62a:	2b00      	cmp	r3, #0
 801d62c:	d00d      	beq.n	801d64a <nk_end+0x7e>
 801d62e:	68fb      	ldr	r3, [r7, #12]
 801d630:	781b      	ldrb	r3, [r3, #0]
 801d632:	2b01      	cmp	r3, #1
 801d634:	d111      	bne.n	801d65a <nk_end+0x8e>
 801d636:	687b      	ldr	r3, [r7, #4]
 801d638:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d63c:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801d640:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d642:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801d646:	2b00      	cmp	r3, #0
 801d648:	d007      	beq.n	801d65a <nk_end+0x8e>
        ctx->current = 0;
 801d64a:	687b      	ldr	r3, [r7, #4]
 801d64c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d650:	461a      	mov	r2, r3
 801d652:	2300      	movs	r3, #0
 801d654:	f8c2 3658 	str.w	r3, [r2, #1624]	; 0x658
        return;
 801d658:	e016      	b.n	801d688 <nk_end+0xbc>
    }
    nk_panel_end(ctx);
 801d65a:	6878      	ldr	r0, [r7, #4]
 801d65c:	f7f7 fe40 	bl	80152e0 <nk_panel_end>
    nk_free_panel(ctx, ctx->current->layout);
 801d660:	687b      	ldr	r3, [r7, #4]
 801d662:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d666:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801d66a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801d66e:	4619      	mov	r1, r3
 801d670:	6878      	ldr	r0, [r7, #4]
 801d672:	f7f6 fc9c 	bl	8013fae <nk_free_panel>
    ctx->current = 0;
 801d676:	687b      	ldr	r3, [r7, #4]
 801d678:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d67c:	461a      	mov	r2, r3
 801d67e:	2300      	movs	r3, #0
 801d680:	f8c2 3658 	str.w	r3, [r2, #1624]	; 0x658
 801d684:	e000      	b.n	801d688 <nk_end+0xbc>
        return;
 801d686:	bf00      	nop
}
 801d688:	3710      	adds	r7, #16
 801d68a:	46bd      	mov	sp, r7
 801d68c:	bd80      	pop	{r7, pc}
 801d68e:	bf00      	nop
 801d690:	080222f0 	.word	0x080222f0
 801d694:	08023854 	.word	0x08023854
 801d698:	080222d4 	.word	0x080222d4
 801d69c:	080223c8 	.word	0x080223c8

0801d6a0 <nk_window_is_hovered>:
    if (!ctx || !ctx->current) return 0;
    return ctx->current == ctx->active;
}
NK_API nk_bool
nk_window_is_hovered(struct nk_context *ctx)
{
 801d6a0:	b590      	push	{r4, r7, lr}
 801d6a2:	b087      	sub	sp, #28
 801d6a4:	af00      	add	r7, sp, #0
 801d6a6:	6078      	str	r0, [r7, #4]
    NK_ASSERT(ctx);
 801d6a8:	687b      	ldr	r3, [r7, #4]
 801d6aa:	2b00      	cmp	r3, #0
 801d6ac:	d106      	bne.n	801d6bc <nk_window_is_hovered+0x1c>
 801d6ae:	4b31      	ldr	r3, [pc, #196]	; (801d774 <nk_window_is_hovered+0xd4>)
 801d6b0:	4a31      	ldr	r2, [pc, #196]	; (801d778 <nk_window_is_hovered+0xd8>)
 801d6b2:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 801d6b6:	4831      	ldr	r0, [pc, #196]	; (801d77c <nk_window_is_hovered+0xdc>)
 801d6b8:	f000 f9ae 	bl	801da18 <__assert_func>
    NK_ASSERT(ctx->current);
 801d6bc:	687b      	ldr	r3, [r7, #4]
 801d6be:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d6c2:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801d6c6:	2b00      	cmp	r3, #0
 801d6c8:	d106      	bne.n	801d6d8 <nk_window_is_hovered+0x38>
 801d6ca:	4b2d      	ldr	r3, [pc, #180]	; (801d780 <nk_window_is_hovered+0xe0>)
 801d6cc:	4a2a      	ldr	r2, [pc, #168]	; (801d778 <nk_window_is_hovered+0xd8>)
 801d6ce:	f240 11b1 	movw	r1, #433	; 0x1b1
 801d6d2:	482a      	ldr	r0, [pc, #168]	; (801d77c <nk_window_is_hovered+0xdc>)
 801d6d4:	f000 f9a0 	bl	801da18 <__assert_func>
    if (!ctx || !ctx->current || (ctx->current->flags & NK_WINDOW_HIDDEN))
 801d6d8:	687b      	ldr	r3, [r7, #4]
 801d6da:	2b00      	cmp	r3, #0
 801d6dc:	d010      	beq.n	801d700 <nk_window_is_hovered+0x60>
 801d6de:	687b      	ldr	r3, [r7, #4]
 801d6e0:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d6e4:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801d6e8:	2b00      	cmp	r3, #0
 801d6ea:	d009      	beq.n	801d700 <nk_window_is_hovered+0x60>
 801d6ec:	687b      	ldr	r3, [r7, #4]
 801d6ee:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d6f2:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801d6f6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d6f8:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801d6fc:	2b00      	cmp	r3, #0
 801d6fe:	d001      	beq.n	801d704 <nk_window_is_hovered+0x64>
        return 0;
 801d700:	2300      	movs	r3, #0
 801d702:	e032      	b.n	801d76a <nk_window_is_hovered+0xca>
    else {
        struct nk_rect actual_bounds = ctx->current->bounds;
 801d704:	687b      	ldr	r3, [r7, #4]
 801d706:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d70a:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801d70e:	f107 0408 	add.w	r4, r7, #8
 801d712:	334c      	adds	r3, #76	; 0x4c
 801d714:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d716:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        if (ctx->begin->flags & NK_WINDOW_MINIMIZED) {
 801d71a:	687b      	ldr	r3, [r7, #4]
 801d71c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d720:	f8d3 364c 	ldr.w	r3, [r3, #1612]	; 0x64c
 801d724:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d726:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 801d72a:	2b00      	cmp	r3, #0
 801d72c:	d008      	beq.n	801d740 <nk_window_is_hovered+0xa0>
            actual_bounds.h = ctx->current->layout->header_height;
 801d72e:	687b      	ldr	r3, [r7, #4]
 801d730:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801d734:	f8d3 3658 	ldr.w	r3, [r3, #1624]	; 0x658
 801d738:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801d73c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801d73e:	617b      	str	r3, [r7, #20]
        }
        return nk_input_is_mouse_hovering_rect(&ctx->input, actual_bounds);
 801d740:	687b      	ldr	r3, [r7, #4]
 801d742:	ed97 6a02 	vldr	s12, [r7, #8]
 801d746:	edd7 6a03 	vldr	s13, [r7, #12]
 801d74a:	ed97 7a04 	vldr	s14, [r7, #16]
 801d74e:	edd7 7a05 	vldr	s15, [r7, #20]
 801d752:	eeb0 0a46 	vmov.f32	s0, s12
 801d756:	eef0 0a66 	vmov.f32	s1, s13
 801d75a:	eeb0 1a47 	vmov.f32	s2, s14
 801d75e:	eef0 1a67 	vmov.f32	s3, s15
 801d762:	4618      	mov	r0, r3
 801d764:	f7f4 fedb 	bl	801251e <nk_input_is_mouse_hovering_rect>
 801d768:	4603      	mov	r3, r0
    }
}
 801d76a:	4618      	mov	r0, r3
 801d76c:	371c      	adds	r7, #28
 801d76e:	46bd      	mov	sp, r7
 801d770:	bd90      	pop	{r4, r7, pc}
 801d772:	bf00      	nop
 801d774:	080222f0 	.word	0x080222f0
 801d778:	0802385c 	.word	0x0802385c
 801d77c:	080222d4 	.word	0x080222d4
 801d780:	0802240c 	.word	0x0802240c

0801d784 <nk_window_is_collapsed>:
    int any_active = (ctx->last_widget_state & NK_WIDGET_STATE_MODIFIED);
    return any_hovered || any_active;
}
NK_API nk_bool
nk_window_is_collapsed(struct nk_context *ctx, const char *name)
{
 801d784:	b580      	push	{r7, lr}
 801d786:	b086      	sub	sp, #24
 801d788:	af00      	add	r7, sp, #0
 801d78a:	6078      	str	r0, [r7, #4]
 801d78c:	6039      	str	r1, [r7, #0]
    int title_len;
    nk_hash title_hash;
    struct nk_window *win;
    NK_ASSERT(ctx);
 801d78e:	687b      	ldr	r3, [r7, #4]
 801d790:	2b00      	cmp	r3, #0
 801d792:	d106      	bne.n	801d7a2 <nk_window_is_collapsed+0x1e>
 801d794:	4b14      	ldr	r3, [pc, #80]	; (801d7e8 <nk_window_is_collapsed+0x64>)
 801d796:	4a15      	ldr	r2, [pc, #84]	; (801d7ec <nk_window_is_collapsed+0x68>)
 801d798:	f44f 71f2 	mov.w	r1, #484	; 0x1e4
 801d79c:	4814      	ldr	r0, [pc, #80]	; (801d7f0 <nk_window_is_collapsed+0x6c>)
 801d79e:	f000 f93b 	bl	801da18 <__assert_func>
    if (!ctx) return 0;
 801d7a2:	687b      	ldr	r3, [r7, #4]
 801d7a4:	2b00      	cmp	r3, #0
 801d7a6:	d101      	bne.n	801d7ac <nk_window_is_collapsed+0x28>
 801d7a8:	2300      	movs	r3, #0
 801d7aa:	e018      	b.n	801d7de <nk_window_is_collapsed+0x5a>

    title_len = (int)nk_strlen(name);
 801d7ac:	6838      	ldr	r0, [r7, #0]
 801d7ae:	f7fe fc59 	bl	801c064 <nk_strlen>
 801d7b2:	6178      	str	r0, [r7, #20]
    title_hash = nk_murmur_hash(name, (int)title_len, NK_WINDOW_TITLE);
 801d7b4:	2240      	movs	r2, #64	; 0x40
 801d7b6:	6979      	ldr	r1, [r7, #20]
 801d7b8:	6838      	ldr	r0, [r7, #0]
 801d7ba:	f7fe fcd3 	bl	801c164 <nk_murmur_hash>
 801d7be:	6138      	str	r0, [r7, #16]
    win = nk_find_window(ctx, title_hash, name);
 801d7c0:	683a      	ldr	r2, [r7, #0]
 801d7c2:	6939      	ldr	r1, [r7, #16]
 801d7c4:	6878      	ldr	r0, [r7, #4]
 801d7c6:	f7ff f8a9 	bl	801c91c <nk_find_window>
 801d7ca:	60f8      	str	r0, [r7, #12]
    if (!win) return 0;
 801d7cc:	68fb      	ldr	r3, [r7, #12]
 801d7ce:	2b00      	cmp	r3, #0
 801d7d0:	d101      	bne.n	801d7d6 <nk_window_is_collapsed+0x52>
 801d7d2:	2300      	movs	r3, #0
 801d7d4:	e003      	b.n	801d7de <nk_window_is_collapsed+0x5a>
    return win->flags & NK_WINDOW_MINIMIZED;
 801d7d6:	68fb      	ldr	r3, [r7, #12]
 801d7d8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d7da:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
}
 801d7de:	4618      	mov	r0, r3
 801d7e0:	3718      	adds	r7, #24
 801d7e2:	46bd      	mov	sp, r7
 801d7e4:	bd80      	pop	{r7, pc}
 801d7e6:	bf00      	nop
 801d7e8:	080222f0 	.word	0x080222f0
 801d7ec:	08023874 	.word	0x08023874
 801d7f0:	080222d4 	.word	0x080222d4

0801d7f4 <tsc2046_init>:
#include <stdint.h>
#include "tsc2046.h"


void tsc2046_init(tTsc2046* tsc, SPI_HandleTypeDef* spi, GPIO_TypeDef* cs_port, uint16_t cs_pin, float ax, float bx, float ay, float by, int avg )
{
 801d7f4:	b580      	push	{r7, lr}
 801d7f6:	b088      	sub	sp, #32
 801d7f8:	af00      	add	r7, sp, #0
 801d7fa:	61f8      	str	r0, [r7, #28]
 801d7fc:	61b9      	str	r1, [r7, #24]
 801d7fe:	617a      	str	r2, [r7, #20]
 801d800:	ed87 0a03 	vstr	s0, [r7, #12]
 801d804:	edc7 0a02 	vstr	s1, [r7, #8]
 801d808:	ed87 1a01 	vstr	s2, [r7, #4]
 801d80c:	edc7 1a00 	vstr	s3, [r7]
 801d810:	827b      	strh	r3, [r7, #18]
	tsc->spi = spi;
 801d812:	69fb      	ldr	r3, [r7, #28]
 801d814:	69ba      	ldr	r2, [r7, #24]
 801d816:	601a      	str	r2, [r3, #0]
	tsc->cs_port = cs_port;
 801d818:	69fb      	ldr	r3, [r7, #28]
 801d81a:	697a      	ldr	r2, [r7, #20]
 801d81c:	605a      	str	r2, [r3, #4]
	tsc->cs_pin = cs_pin;
 801d81e:	69fb      	ldr	r3, [r7, #28]
 801d820:	8a7a      	ldrh	r2, [r7, #18]
 801d822:	811a      	strh	r2, [r3, #8]
	tsc->ax = ax;
 801d824:	69fb      	ldr	r3, [r7, #28]
 801d826:	68fa      	ldr	r2, [r7, #12]
 801d828:	60da      	str	r2, [r3, #12]
	tsc->bx = bx;
 801d82a:	69fb      	ldr	r3, [r7, #28]
 801d82c:	68ba      	ldr	r2, [r7, #8]
 801d82e:	611a      	str	r2, [r3, #16]
	tsc->ay = ay;
 801d830:	69fb      	ldr	r3, [r7, #28]
 801d832:	687a      	ldr	r2, [r7, #4]
 801d834:	615a      	str	r2, [r3, #20]
	tsc->by = by;
 801d836:	69fb      	ldr	r3, [r7, #28]
 801d838:	683a      	ldr	r2, [r7, #0]
 801d83a:	619a      	str	r2, [r3, #24]
	tsc->avg = avg;
 801d83c:	69fb      	ldr	r3, [r7, #28]
 801d83e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801d840:	61da      	str	r2, [r3, #28]
    HAL_GPIO_WritePin(tsc->cs_port, tsc->cs_pin, GPIO_PIN_SET);
 801d842:	69fb      	ldr	r3, [r7, #28]
 801d844:	6858      	ldr	r0, [r3, #4]
 801d846:	69fb      	ldr	r3, [r7, #28]
 801d848:	891b      	ldrh	r3, [r3, #8]
 801d84a:	2201      	movs	r2, #1
 801d84c:	4619      	mov	r1, r3
 801d84e:	f7eb ff5f 	bl	8009710 <HAL_GPIO_WritePin>
}
 801d852:	bf00      	nop
 801d854:	3720      	adds	r7, #32
 801d856:	46bd      	mov	sp, r7
 801d858:	bd80      	pop	{r7, pc}
	...

0801d85c <tsc2046_read_ll>:

void tsc2046_read_ll( tTsc2046* tsc, uint16_t* x, uint16_t* y) {
 801d85c:	b580      	push	{r7, lr}
 801d85e:	b088      	sub	sp, #32
 801d860:	af02      	add	r7, sp, #8
 801d862:	60f8      	str	r0, [r7, #12]
 801d864:	60b9      	str	r1, [r7, #8]
 801d866:	607a      	str	r2, [r7, #4]
	uint8_t buf_tx[3] = {0};
 801d868:	4b2d      	ldr	r3, [pc, #180]	; (801d920 <tsc2046_read_ll+0xc4>)
 801d86a:	881b      	ldrh	r3, [r3, #0]
 801d86c:	82bb      	strh	r3, [r7, #20]
 801d86e:	2300      	movs	r3, #0
 801d870:	75bb      	strb	r3, [r7, #22]
	uint8_t buf_rx[3] = {0};
 801d872:	4b2b      	ldr	r3, [pc, #172]	; (801d920 <tsc2046_read_ll+0xc4>)
 801d874:	881b      	ldrh	r3, [r3, #0]
 801d876:	823b      	strh	r3, [r7, #16]
 801d878:	2300      	movs	r3, #0
 801d87a:	74bb      	strb	r3, [r7, #18]

    HAL_GPIO_WritePin(tsc->cs_port, tsc->cs_pin, GPIO_PIN_RESET);
 801d87c:	68fb      	ldr	r3, [r7, #12]
 801d87e:	6858      	ldr	r0, [r3, #4]
 801d880:	68fb      	ldr	r3, [r7, #12]
 801d882:	891b      	ldrh	r3, [r3, #8]
 801d884:	2200      	movs	r2, #0
 801d886:	4619      	mov	r1, r3
 801d888:	f7eb ff42 	bl	8009710 <HAL_GPIO_WritePin>

    buf_tx[0] = TSC2046_CHANNEL_X;
 801d88c:	2390      	movs	r3, #144	; 0x90
 801d88e:	753b      	strb	r3, [r7, #20]
    HAL_SPI_TransmitReceive(tsc->spi, buf_tx, buf_rx, 3, HAL_MAX_DELAY);
 801d890:	68fb      	ldr	r3, [r7, #12]
 801d892:	6818      	ldr	r0, [r3, #0]
 801d894:	f107 0210 	add.w	r2, r7, #16
 801d898:	f107 0114 	add.w	r1, r7, #20
 801d89c:	f04f 33ff 	mov.w	r3, #4294967295
 801d8a0:	9300      	str	r3, [sp, #0]
 801d8a2:	2303      	movs	r3, #3
 801d8a4:	f7ed fbdd 	bl	800b062 <HAL_SPI_TransmitReceive>
    *x = (buf_rx[1] << 4) | (buf_rx[2] >> 4);
 801d8a8:	7c7b      	ldrb	r3, [r7, #17]
 801d8aa:	011b      	lsls	r3, r3, #4
 801d8ac:	b21a      	sxth	r2, r3
 801d8ae:	7cbb      	ldrb	r3, [r7, #18]
 801d8b0:	091b      	lsrs	r3, r3, #4
 801d8b2:	b2db      	uxtb	r3, r3
 801d8b4:	b21b      	sxth	r3, r3
 801d8b6:	4313      	orrs	r3, r2
 801d8b8:	b21b      	sxth	r3, r3
 801d8ba:	b29a      	uxth	r2, r3
 801d8bc:	68bb      	ldr	r3, [r7, #8]
 801d8be:	801a      	strh	r2, [r3, #0]

    buf_tx[0] = TSC2046_CHANNEL_Y;
 801d8c0:	23d0      	movs	r3, #208	; 0xd0
 801d8c2:	753b      	strb	r3, [r7, #20]
    HAL_SPI_TransmitReceive(tsc->spi, buf_tx, buf_rx, 3, HAL_MAX_DELAY);
 801d8c4:	68fb      	ldr	r3, [r7, #12]
 801d8c6:	6818      	ldr	r0, [r3, #0]
 801d8c8:	f107 0210 	add.w	r2, r7, #16
 801d8cc:	f107 0114 	add.w	r1, r7, #20
 801d8d0:	f04f 33ff 	mov.w	r3, #4294967295
 801d8d4:	9300      	str	r3, [sp, #0]
 801d8d6:	2303      	movs	r3, #3
 801d8d8:	f7ed fbc3 	bl	800b062 <HAL_SPI_TransmitReceive>
    *y = (buf_rx[1] << 4) | (buf_rx[2] >> 4);
 801d8dc:	7c7b      	ldrb	r3, [r7, #17]
 801d8de:	011b      	lsls	r3, r3, #4
 801d8e0:	b21a      	sxth	r2, r3
 801d8e2:	7cbb      	ldrb	r3, [r7, #18]
 801d8e4:	091b      	lsrs	r3, r3, #4
 801d8e6:	b2db      	uxtb	r3, r3
 801d8e8:	b21b      	sxth	r3, r3
 801d8ea:	4313      	orrs	r3, r2
 801d8ec:	b21b      	sxth	r3, r3
 801d8ee:	b29a      	uxth	r2, r3
 801d8f0:	687b      	ldr	r3, [r7, #4]
 801d8f2:	801a      	strh	r2, [r3, #0]

    HAL_GPIO_WritePin(tsc->cs_port, tsc->cs_pin, GPIO_PIN_SET);
 801d8f4:	68fb      	ldr	r3, [r7, #12]
 801d8f6:	6858      	ldr	r0, [r3, #4]
 801d8f8:	68fb      	ldr	r3, [r7, #12]
 801d8fa:	891b      	ldrh	r3, [r3, #8]
 801d8fc:	2201      	movs	r2, #1
 801d8fe:	4619      	mov	r1, r3
 801d900:	f7eb ff06 	bl	8009710 <HAL_GPIO_WritePin>

    if (*x == 2047) {
 801d904:	68bb      	ldr	r3, [r7, #8]
 801d906:	881b      	ldrh	r3, [r3, #0]
 801d908:	f240 72ff 	movw	r2, #2047	; 0x7ff
 801d90c:	4293      	cmp	r3, r2
 801d90e:	d102      	bne.n	801d916 <tsc2046_read_ll+0xba>
        *x = 0;
 801d910:	68bb      	ldr	r3, [r7, #8]
 801d912:	2200      	movs	r2, #0
 801d914:	801a      	strh	r2, [r3, #0]
    }
}
 801d916:	bf00      	nop
 801d918:	3718      	adds	r7, #24
 801d91a:	46bd      	mov	sp, r7
 801d91c:	bd80      	pop	{r7, pc}
 801d91e:	bf00      	nop
 801d920:	080224c4 	.word	0x080224c4

0801d924 <tsc2046_read>:

void tsc2046_read( tTsc2046* tsc, uint16_t* x, uint16_t* y) {
 801d924:	b580      	push	{r7, lr}
 801d926:	b088      	sub	sp, #32
 801d928:	af00      	add	r7, sp, #0
 801d92a:	60f8      	str	r0, [r7, #12]
 801d92c:	60b9      	str	r1, [r7, #8]
 801d92e:	607a      	str	r2, [r7, #4]
    int32_t x_acc = 0;
 801d930:	2300      	movs	r3, #0
 801d932:	61fb      	str	r3, [r7, #28]
    int32_t y_acc = 0;
 801d934:	2300      	movs	r3, #0
 801d936:	61bb      	str	r3, [r7, #24]

    for (int i = 0; i < tsc->avg; i++) {
 801d938:	2300      	movs	r3, #0
 801d93a:	617b      	str	r3, [r7, #20]
 801d93c:	e026      	b.n	801d98c <tsc2046_read+0x68>
    	tsc2046_read_ll(tsc, x, y);
 801d93e:	687a      	ldr	r2, [r7, #4]
 801d940:	68b9      	ldr	r1, [r7, #8]
 801d942:	68f8      	ldr	r0, [r7, #12]
 801d944:	f7ff ff8a 	bl	801d85c <tsc2046_read_ll>
        if (*x && *y) {
 801d948:	68bb      	ldr	r3, [r7, #8]
 801d94a:	881b      	ldrh	r3, [r3, #0]
 801d94c:	2b00      	cmp	r3, #0
 801d94e:	d016      	beq.n	801d97e <tsc2046_read+0x5a>
 801d950:	687b      	ldr	r3, [r7, #4]
 801d952:	881b      	ldrh	r3, [r3, #0]
 801d954:	2b00      	cmp	r3, #0
 801d956:	d012      	beq.n	801d97e <tsc2046_read+0x5a>
            x_acc += *x;
 801d958:	68bb      	ldr	r3, [r7, #8]
 801d95a:	881b      	ldrh	r3, [r3, #0]
 801d95c:	461a      	mov	r2, r3
 801d95e:	69fb      	ldr	r3, [r7, #28]
 801d960:	4413      	add	r3, r2
 801d962:	61fb      	str	r3, [r7, #28]
            y_acc += *y;
 801d964:	687b      	ldr	r3, [r7, #4]
 801d966:	881b      	ldrh	r3, [r3, #0]
 801d968:	461a      	mov	r2, r3
 801d96a:	69bb      	ldr	r3, [r7, #24]
 801d96c:	4413      	add	r3, r2
 801d96e:	61bb      	str	r3, [r7, #24]
        } else {
            *x = 0;
            *y = 0;
            return;
        }
        HAL_Delay(1);
 801d970:	2001      	movs	r0, #1
 801d972:	f7e8 f9fb 	bl	8005d6c <HAL_Delay>
    for (int i = 0; i < tsc->avg; i++) {
 801d976:	697b      	ldr	r3, [r7, #20]
 801d978:	3301      	adds	r3, #1
 801d97a:	617b      	str	r3, [r7, #20]
 801d97c:	e006      	b.n	801d98c <tsc2046_read+0x68>
            *x = 0;
 801d97e:	68bb      	ldr	r3, [r7, #8]
 801d980:	2200      	movs	r2, #0
 801d982:	801a      	strh	r2, [r3, #0]
            *y = 0;
 801d984:	687b      	ldr	r3, [r7, #4]
 801d986:	2200      	movs	r2, #0
 801d988:	801a      	strh	r2, [r3, #0]
            return;
 801d98a:	e042      	b.n	801da12 <tsc2046_read+0xee>
    for (int i = 0; i < tsc->avg; i++) {
 801d98c:	68fb      	ldr	r3, [r7, #12]
 801d98e:	69db      	ldr	r3, [r3, #28]
 801d990:	697a      	ldr	r2, [r7, #20]
 801d992:	429a      	cmp	r2, r3
 801d994:	dbd3      	blt.n	801d93e <tsc2046_read+0x1a>
    }
    *x = x_acc / tsc->avg;
 801d996:	68fb      	ldr	r3, [r7, #12]
 801d998:	69db      	ldr	r3, [r3, #28]
 801d99a:	69fa      	ldr	r2, [r7, #28]
 801d99c:	fb92 f3f3 	sdiv	r3, r2, r3
 801d9a0:	b29a      	uxth	r2, r3
 801d9a2:	68bb      	ldr	r3, [r7, #8]
 801d9a4:	801a      	strh	r2, [r3, #0]
    *y = y_acc / tsc->avg;
 801d9a6:	68fb      	ldr	r3, [r7, #12]
 801d9a8:	69db      	ldr	r3, [r3, #28]
 801d9aa:	69ba      	ldr	r2, [r7, #24]
 801d9ac:	fb92 f3f3 	sdiv	r3, r2, r3
 801d9b0:	b29a      	uxth	r2, r3
 801d9b2:	687b      	ldr	r3, [r7, #4]
 801d9b4:	801a      	strh	r2, [r3, #0]
    *x = tsc->ax * *x + tsc->bx;
 801d9b6:	68fb      	ldr	r3, [r7, #12]
 801d9b8:	ed93 7a03 	vldr	s14, [r3, #12]
 801d9bc:	68bb      	ldr	r3, [r7, #8]
 801d9be:	881b      	ldrh	r3, [r3, #0]
 801d9c0:	ee07 3a90 	vmov	s15, r3
 801d9c4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801d9c8:	ee27 7a27 	vmul.f32	s14, s14, s15
 801d9cc:	68fb      	ldr	r3, [r7, #12]
 801d9ce:	edd3 7a04 	vldr	s15, [r3, #16]
 801d9d2:	ee77 7a27 	vadd.f32	s15, s14, s15
 801d9d6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801d9da:	ee17 3a90 	vmov	r3, s15
 801d9de:	b29a      	uxth	r2, r3
 801d9e0:	68bb      	ldr	r3, [r7, #8]
 801d9e2:	801a      	strh	r2, [r3, #0]
    *y = tsc->ay * *y + tsc->by;
 801d9e4:	68fb      	ldr	r3, [r7, #12]
 801d9e6:	ed93 7a05 	vldr	s14, [r3, #20]
 801d9ea:	687b      	ldr	r3, [r7, #4]
 801d9ec:	881b      	ldrh	r3, [r3, #0]
 801d9ee:	ee07 3a90 	vmov	s15, r3
 801d9f2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801d9f6:	ee27 7a27 	vmul.f32	s14, s14, s15
 801d9fa:	68fb      	ldr	r3, [r7, #12]
 801d9fc:	edd3 7a06 	vldr	s15, [r3, #24]
 801da00:	ee77 7a27 	vadd.f32	s15, s14, s15
 801da04:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801da08:	ee17 3a90 	vmov	r3, s15
 801da0c:	b29a      	uxth	r2, r3
 801da0e:	687b      	ldr	r3, [r7, #4]
 801da10:	801a      	strh	r2, [r3, #0]
}
 801da12:	3720      	adds	r7, #32
 801da14:	46bd      	mov	sp, r7
 801da16:	bd80      	pop	{r7, pc}

0801da18 <__assert_func>:
 801da18:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 801da1a:	4614      	mov	r4, r2
 801da1c:	461a      	mov	r2, r3
 801da1e:	4b09      	ldr	r3, [pc, #36]	; (801da44 <__assert_func+0x2c>)
 801da20:	681b      	ldr	r3, [r3, #0]
 801da22:	4605      	mov	r5, r0
 801da24:	68d8      	ldr	r0, [r3, #12]
 801da26:	b14c      	cbz	r4, 801da3c <__assert_func+0x24>
 801da28:	4b07      	ldr	r3, [pc, #28]	; (801da48 <__assert_func+0x30>)
 801da2a:	9100      	str	r1, [sp, #0]
 801da2c:	e9cd 3401 	strd	r3, r4, [sp, #4]
 801da30:	4906      	ldr	r1, [pc, #24]	; (801da4c <__assert_func+0x34>)
 801da32:	462b      	mov	r3, r5
 801da34:	f000 fd06 	bl	801e444 <fiprintf>
 801da38:	f000 fe24 	bl	801e684 <abort>
 801da3c:	4b04      	ldr	r3, [pc, #16]	; (801da50 <__assert_func+0x38>)
 801da3e:	461c      	mov	r4, r3
 801da40:	e7f3      	b.n	801da2a <__assert_func+0x12>
 801da42:	bf00      	nop
 801da44:	200001e8 	.word	0x200001e8
 801da48:	0802388b 	.word	0x0802388b
 801da4c:	08023898 	.word	0x08023898
 801da50:	080238c6 	.word	0x080238c6

0801da54 <__cvt>:
 801da54:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 801da58:	ec55 4b10 	vmov	r4, r5, d0
 801da5c:	2d00      	cmp	r5, #0
 801da5e:	460e      	mov	r6, r1
 801da60:	4619      	mov	r1, r3
 801da62:	462b      	mov	r3, r5
 801da64:	bfbb      	ittet	lt
 801da66:	f105 4300 	addlt.w	r3, r5, #2147483648	; 0x80000000
 801da6a:	461d      	movlt	r5, r3
 801da6c:	2300      	movge	r3, #0
 801da6e:	232d      	movlt	r3, #45	; 0x2d
 801da70:	700b      	strb	r3, [r1, #0]
 801da72:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801da74:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
 801da78:	4691      	mov	r9, r2
 801da7a:	f023 0820 	bic.w	r8, r3, #32
 801da7e:	bfbc      	itt	lt
 801da80:	4622      	movlt	r2, r4
 801da82:	4614      	movlt	r4, r2
 801da84:	f1b8 0f46 	cmp.w	r8, #70	; 0x46
 801da88:	d005      	beq.n	801da96 <__cvt+0x42>
 801da8a:	f1b8 0f45 	cmp.w	r8, #69	; 0x45
 801da8e:	d100      	bne.n	801da92 <__cvt+0x3e>
 801da90:	3601      	adds	r6, #1
 801da92:	2102      	movs	r1, #2
 801da94:	e000      	b.n	801da98 <__cvt+0x44>
 801da96:	2103      	movs	r1, #3
 801da98:	ab03      	add	r3, sp, #12
 801da9a:	9301      	str	r3, [sp, #4]
 801da9c:	ab02      	add	r3, sp, #8
 801da9e:	9300      	str	r3, [sp, #0]
 801daa0:	ec45 4b10 	vmov	d0, r4, r5
 801daa4:	4653      	mov	r3, sl
 801daa6:	4632      	mov	r2, r6
 801daa8:	f000 fe7e 	bl	801e7a8 <_dtoa_r>
 801daac:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
 801dab0:	4607      	mov	r7, r0
 801dab2:	d102      	bne.n	801daba <__cvt+0x66>
 801dab4:	f019 0f01 	tst.w	r9, #1
 801dab8:	d022      	beq.n	801db00 <__cvt+0xac>
 801daba:	f1b8 0f46 	cmp.w	r8, #70	; 0x46
 801dabe:	eb07 0906 	add.w	r9, r7, r6
 801dac2:	d110      	bne.n	801dae6 <__cvt+0x92>
 801dac4:	783b      	ldrb	r3, [r7, #0]
 801dac6:	2b30      	cmp	r3, #48	; 0x30
 801dac8:	d10a      	bne.n	801dae0 <__cvt+0x8c>
 801daca:	2200      	movs	r2, #0
 801dacc:	2300      	movs	r3, #0
 801dace:	4620      	mov	r0, r4
 801dad0:	4629      	mov	r1, r5
 801dad2:	f7e3 f821 	bl	8000b18 <__aeabi_dcmpeq>
 801dad6:	b918      	cbnz	r0, 801dae0 <__cvt+0x8c>
 801dad8:	f1c6 0601 	rsb	r6, r6, #1
 801dadc:	f8ca 6000 	str.w	r6, [sl]
 801dae0:	f8da 3000 	ldr.w	r3, [sl]
 801dae4:	4499      	add	r9, r3
 801dae6:	2200      	movs	r2, #0
 801dae8:	2300      	movs	r3, #0
 801daea:	4620      	mov	r0, r4
 801daec:	4629      	mov	r1, r5
 801daee:	f7e3 f813 	bl	8000b18 <__aeabi_dcmpeq>
 801daf2:	b108      	cbz	r0, 801daf8 <__cvt+0xa4>
 801daf4:	f8cd 900c 	str.w	r9, [sp, #12]
 801daf8:	2230      	movs	r2, #48	; 0x30
 801dafa:	9b03      	ldr	r3, [sp, #12]
 801dafc:	454b      	cmp	r3, r9
 801dafe:	d307      	bcc.n	801db10 <__cvt+0xbc>
 801db00:	9b03      	ldr	r3, [sp, #12]
 801db02:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801db04:	1bdb      	subs	r3, r3, r7
 801db06:	4638      	mov	r0, r7
 801db08:	6013      	str	r3, [r2, #0]
 801db0a:	b004      	add	sp, #16
 801db0c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801db10:	1c59      	adds	r1, r3, #1
 801db12:	9103      	str	r1, [sp, #12]
 801db14:	701a      	strb	r2, [r3, #0]
 801db16:	e7f0      	b.n	801dafa <__cvt+0xa6>

0801db18 <__exponent>:
 801db18:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801db1a:	4603      	mov	r3, r0
 801db1c:	2900      	cmp	r1, #0
 801db1e:	bfb8      	it	lt
 801db20:	4249      	neglt	r1, r1
 801db22:	f803 2b02 	strb.w	r2, [r3], #2
 801db26:	bfb4      	ite	lt
 801db28:	222d      	movlt	r2, #45	; 0x2d
 801db2a:	222b      	movge	r2, #43	; 0x2b
 801db2c:	2909      	cmp	r1, #9
 801db2e:	7042      	strb	r2, [r0, #1]
 801db30:	dd2a      	ble.n	801db88 <__exponent+0x70>
 801db32:	f10d 0207 	add.w	r2, sp, #7
 801db36:	4617      	mov	r7, r2
 801db38:	260a      	movs	r6, #10
 801db3a:	4694      	mov	ip, r2
 801db3c:	fb91 f5f6 	sdiv	r5, r1, r6
 801db40:	fb06 1415 	mls	r4, r6, r5, r1
 801db44:	3430      	adds	r4, #48	; 0x30
 801db46:	f80c 4c01 	strb.w	r4, [ip, #-1]
 801db4a:	460c      	mov	r4, r1
 801db4c:	2c63      	cmp	r4, #99	; 0x63
 801db4e:	f102 32ff 	add.w	r2, r2, #4294967295
 801db52:	4629      	mov	r1, r5
 801db54:	dcf1      	bgt.n	801db3a <__exponent+0x22>
 801db56:	3130      	adds	r1, #48	; 0x30
 801db58:	f1ac 0402 	sub.w	r4, ip, #2
 801db5c:	f802 1c01 	strb.w	r1, [r2, #-1]
 801db60:	1c41      	adds	r1, r0, #1
 801db62:	4622      	mov	r2, r4
 801db64:	42ba      	cmp	r2, r7
 801db66:	d30a      	bcc.n	801db7e <__exponent+0x66>
 801db68:	f10d 0209 	add.w	r2, sp, #9
 801db6c:	eba2 020c 	sub.w	r2, r2, ip
 801db70:	42bc      	cmp	r4, r7
 801db72:	bf88      	it	hi
 801db74:	2200      	movhi	r2, #0
 801db76:	4413      	add	r3, r2
 801db78:	1a18      	subs	r0, r3, r0
 801db7a:	b003      	add	sp, #12
 801db7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801db7e:	f812 5b01 	ldrb.w	r5, [r2], #1
 801db82:	f801 5f01 	strb.w	r5, [r1, #1]!
 801db86:	e7ed      	b.n	801db64 <__exponent+0x4c>
 801db88:	2330      	movs	r3, #48	; 0x30
 801db8a:	3130      	adds	r1, #48	; 0x30
 801db8c:	7083      	strb	r3, [r0, #2]
 801db8e:	70c1      	strb	r1, [r0, #3]
 801db90:	1d03      	adds	r3, r0, #4
 801db92:	e7f1      	b.n	801db78 <__exponent+0x60>

0801db94 <_printf_float>:
 801db94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801db98:	ed2d 8b02 	vpush	{d8}
 801db9c:	b08d      	sub	sp, #52	; 0x34
 801db9e:	460c      	mov	r4, r1
 801dba0:	f8dd 8060 	ldr.w	r8, [sp, #96]	; 0x60
 801dba4:	4616      	mov	r6, r2
 801dba6:	461f      	mov	r7, r3
 801dba8:	4605      	mov	r5, r0
 801dbaa:	f000 fce7 	bl	801e57c <_localeconv_r>
 801dbae:	f8d0 a000 	ldr.w	sl, [r0]
 801dbb2:	4650      	mov	r0, sl
 801dbb4:	f7e2 fb84 	bl	80002c0 <strlen>
 801dbb8:	2300      	movs	r3, #0
 801dbba:	930a      	str	r3, [sp, #40]	; 0x28
 801dbbc:	6823      	ldr	r3, [r4, #0]
 801dbbe:	9305      	str	r3, [sp, #20]
 801dbc0:	f8d8 3000 	ldr.w	r3, [r8]
 801dbc4:	f894 b018 	ldrb.w	fp, [r4, #24]
 801dbc8:	3307      	adds	r3, #7
 801dbca:	f023 0307 	bic.w	r3, r3, #7
 801dbce:	f103 0208 	add.w	r2, r3, #8
 801dbd2:	f8c8 2000 	str.w	r2, [r8]
 801dbd6:	e9d3 8900 	ldrd	r8, r9, [r3]
 801dbda:	f029 4300 	bic.w	r3, r9, #2147483648	; 0x80000000
 801dbde:	9307      	str	r3, [sp, #28]
 801dbe0:	f8cd 8018 	str.w	r8, [sp, #24]
 801dbe4:	ee08 0a10 	vmov	s16, r0
 801dbe8:	e9c4 8912 	strd	r8, r9, [r4, #72]	; 0x48
 801dbec:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 801dbf0:	4b9e      	ldr	r3, [pc, #632]	; (801de6c <_printf_float+0x2d8>)
 801dbf2:	f04f 32ff 	mov.w	r2, #4294967295
 801dbf6:	f7e2 ffc1 	bl	8000b7c <__aeabi_dcmpun>
 801dbfa:	bb88      	cbnz	r0, 801dc60 <_printf_float+0xcc>
 801dbfc:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 801dc00:	4b9a      	ldr	r3, [pc, #616]	; (801de6c <_printf_float+0x2d8>)
 801dc02:	f04f 32ff 	mov.w	r2, #4294967295
 801dc06:	f7e2 ff9b 	bl	8000b40 <__aeabi_dcmple>
 801dc0a:	bb48      	cbnz	r0, 801dc60 <_printf_float+0xcc>
 801dc0c:	2200      	movs	r2, #0
 801dc0e:	2300      	movs	r3, #0
 801dc10:	4640      	mov	r0, r8
 801dc12:	4649      	mov	r1, r9
 801dc14:	f7e2 ff8a 	bl	8000b2c <__aeabi_dcmplt>
 801dc18:	b110      	cbz	r0, 801dc20 <_printf_float+0x8c>
 801dc1a:	232d      	movs	r3, #45	; 0x2d
 801dc1c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 801dc20:	4a93      	ldr	r2, [pc, #588]	; (801de70 <_printf_float+0x2dc>)
 801dc22:	4b94      	ldr	r3, [pc, #592]	; (801de74 <_printf_float+0x2e0>)
 801dc24:	f1bb 0f47 	cmp.w	fp, #71	; 0x47
 801dc28:	bf94      	ite	ls
 801dc2a:	4690      	movls	r8, r2
 801dc2c:	4698      	movhi	r8, r3
 801dc2e:	2303      	movs	r3, #3
 801dc30:	6123      	str	r3, [r4, #16]
 801dc32:	9b05      	ldr	r3, [sp, #20]
 801dc34:	f023 0304 	bic.w	r3, r3, #4
 801dc38:	6023      	str	r3, [r4, #0]
 801dc3a:	f04f 0900 	mov.w	r9, #0
 801dc3e:	9700      	str	r7, [sp, #0]
 801dc40:	4633      	mov	r3, r6
 801dc42:	aa0b      	add	r2, sp, #44	; 0x2c
 801dc44:	4621      	mov	r1, r4
 801dc46:	4628      	mov	r0, r5
 801dc48:	f000 f9da 	bl	801e000 <_printf_common>
 801dc4c:	3001      	adds	r0, #1
 801dc4e:	f040 8090 	bne.w	801dd72 <_printf_float+0x1de>
 801dc52:	f04f 30ff 	mov.w	r0, #4294967295
 801dc56:	b00d      	add	sp, #52	; 0x34
 801dc58:	ecbd 8b02 	vpop	{d8}
 801dc5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801dc60:	4642      	mov	r2, r8
 801dc62:	464b      	mov	r3, r9
 801dc64:	4640      	mov	r0, r8
 801dc66:	4649      	mov	r1, r9
 801dc68:	f7e2 ff88 	bl	8000b7c <__aeabi_dcmpun>
 801dc6c:	b140      	cbz	r0, 801dc80 <_printf_float+0xec>
 801dc6e:	464b      	mov	r3, r9
 801dc70:	2b00      	cmp	r3, #0
 801dc72:	bfbc      	itt	lt
 801dc74:	232d      	movlt	r3, #45	; 0x2d
 801dc76:	f884 3043 	strblt.w	r3, [r4, #67]	; 0x43
 801dc7a:	4a7f      	ldr	r2, [pc, #508]	; (801de78 <_printf_float+0x2e4>)
 801dc7c:	4b7f      	ldr	r3, [pc, #508]	; (801de7c <_printf_float+0x2e8>)
 801dc7e:	e7d1      	b.n	801dc24 <_printf_float+0x90>
 801dc80:	6863      	ldr	r3, [r4, #4]
 801dc82:	f00b 02df 	and.w	r2, fp, #223	; 0xdf
 801dc86:	9206      	str	r2, [sp, #24]
 801dc88:	1c5a      	adds	r2, r3, #1
 801dc8a:	d13f      	bne.n	801dd0c <_printf_float+0x178>
 801dc8c:	2306      	movs	r3, #6
 801dc8e:	6063      	str	r3, [r4, #4]
 801dc90:	9b05      	ldr	r3, [sp, #20]
 801dc92:	6861      	ldr	r1, [r4, #4]
 801dc94:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
 801dc98:	2300      	movs	r3, #0
 801dc9a:	9303      	str	r3, [sp, #12]
 801dc9c:	ab0a      	add	r3, sp, #40	; 0x28
 801dc9e:	e9cd b301 	strd	fp, r3, [sp, #4]
 801dca2:	ab09      	add	r3, sp, #36	; 0x24
 801dca4:	ec49 8b10 	vmov	d0, r8, r9
 801dca8:	9300      	str	r3, [sp, #0]
 801dcaa:	6022      	str	r2, [r4, #0]
 801dcac:	f10d 0323 	add.w	r3, sp, #35	; 0x23
 801dcb0:	4628      	mov	r0, r5
 801dcb2:	f7ff fecf 	bl	801da54 <__cvt>
 801dcb6:	9b06      	ldr	r3, [sp, #24]
 801dcb8:	9909      	ldr	r1, [sp, #36]	; 0x24
 801dcba:	2b47      	cmp	r3, #71	; 0x47
 801dcbc:	4680      	mov	r8, r0
 801dcbe:	d108      	bne.n	801dcd2 <_printf_float+0x13e>
 801dcc0:	1cc8      	adds	r0, r1, #3
 801dcc2:	db02      	blt.n	801dcca <_printf_float+0x136>
 801dcc4:	6863      	ldr	r3, [r4, #4]
 801dcc6:	4299      	cmp	r1, r3
 801dcc8:	dd41      	ble.n	801dd4e <_printf_float+0x1ba>
 801dcca:	f1ab 0302 	sub.w	r3, fp, #2
 801dcce:	fa5f fb83 	uxtb.w	fp, r3
 801dcd2:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 801dcd6:	d820      	bhi.n	801dd1a <_printf_float+0x186>
 801dcd8:	3901      	subs	r1, #1
 801dcda:	465a      	mov	r2, fp
 801dcdc:	f104 0050 	add.w	r0, r4, #80	; 0x50
 801dce0:	9109      	str	r1, [sp, #36]	; 0x24
 801dce2:	f7ff ff19 	bl	801db18 <__exponent>
 801dce6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801dce8:	1813      	adds	r3, r2, r0
 801dcea:	2a01      	cmp	r2, #1
 801dcec:	4681      	mov	r9, r0
 801dcee:	6123      	str	r3, [r4, #16]
 801dcf0:	dc02      	bgt.n	801dcf8 <_printf_float+0x164>
 801dcf2:	6822      	ldr	r2, [r4, #0]
 801dcf4:	07d2      	lsls	r2, r2, #31
 801dcf6:	d501      	bpl.n	801dcfc <_printf_float+0x168>
 801dcf8:	3301      	adds	r3, #1
 801dcfa:	6123      	str	r3, [r4, #16]
 801dcfc:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 801dd00:	2b00      	cmp	r3, #0
 801dd02:	d09c      	beq.n	801dc3e <_printf_float+0xaa>
 801dd04:	232d      	movs	r3, #45	; 0x2d
 801dd06:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 801dd0a:	e798      	b.n	801dc3e <_printf_float+0xaa>
 801dd0c:	9a06      	ldr	r2, [sp, #24]
 801dd0e:	2a47      	cmp	r2, #71	; 0x47
 801dd10:	d1be      	bne.n	801dc90 <_printf_float+0xfc>
 801dd12:	2b00      	cmp	r3, #0
 801dd14:	d1bc      	bne.n	801dc90 <_printf_float+0xfc>
 801dd16:	2301      	movs	r3, #1
 801dd18:	e7b9      	b.n	801dc8e <_printf_float+0xfa>
 801dd1a:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 801dd1e:	d118      	bne.n	801dd52 <_printf_float+0x1be>
 801dd20:	2900      	cmp	r1, #0
 801dd22:	6863      	ldr	r3, [r4, #4]
 801dd24:	dd0b      	ble.n	801dd3e <_printf_float+0x1aa>
 801dd26:	6121      	str	r1, [r4, #16]
 801dd28:	b913      	cbnz	r3, 801dd30 <_printf_float+0x19c>
 801dd2a:	6822      	ldr	r2, [r4, #0]
 801dd2c:	07d0      	lsls	r0, r2, #31
 801dd2e:	d502      	bpl.n	801dd36 <_printf_float+0x1a2>
 801dd30:	3301      	adds	r3, #1
 801dd32:	440b      	add	r3, r1
 801dd34:	6123      	str	r3, [r4, #16]
 801dd36:	65a1      	str	r1, [r4, #88]	; 0x58
 801dd38:	f04f 0900 	mov.w	r9, #0
 801dd3c:	e7de      	b.n	801dcfc <_printf_float+0x168>
 801dd3e:	b913      	cbnz	r3, 801dd46 <_printf_float+0x1b2>
 801dd40:	6822      	ldr	r2, [r4, #0]
 801dd42:	07d2      	lsls	r2, r2, #31
 801dd44:	d501      	bpl.n	801dd4a <_printf_float+0x1b6>
 801dd46:	3302      	adds	r3, #2
 801dd48:	e7f4      	b.n	801dd34 <_printf_float+0x1a0>
 801dd4a:	2301      	movs	r3, #1
 801dd4c:	e7f2      	b.n	801dd34 <_printf_float+0x1a0>
 801dd4e:	f04f 0b67 	mov.w	fp, #103	; 0x67
 801dd52:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801dd54:	4299      	cmp	r1, r3
 801dd56:	db05      	blt.n	801dd64 <_printf_float+0x1d0>
 801dd58:	6823      	ldr	r3, [r4, #0]
 801dd5a:	6121      	str	r1, [r4, #16]
 801dd5c:	07d8      	lsls	r0, r3, #31
 801dd5e:	d5ea      	bpl.n	801dd36 <_printf_float+0x1a2>
 801dd60:	1c4b      	adds	r3, r1, #1
 801dd62:	e7e7      	b.n	801dd34 <_printf_float+0x1a0>
 801dd64:	2900      	cmp	r1, #0
 801dd66:	bfd4      	ite	le
 801dd68:	f1c1 0202 	rsble	r2, r1, #2
 801dd6c:	2201      	movgt	r2, #1
 801dd6e:	4413      	add	r3, r2
 801dd70:	e7e0      	b.n	801dd34 <_printf_float+0x1a0>
 801dd72:	6823      	ldr	r3, [r4, #0]
 801dd74:	055a      	lsls	r2, r3, #21
 801dd76:	d407      	bmi.n	801dd88 <_printf_float+0x1f4>
 801dd78:	6923      	ldr	r3, [r4, #16]
 801dd7a:	4642      	mov	r2, r8
 801dd7c:	4631      	mov	r1, r6
 801dd7e:	4628      	mov	r0, r5
 801dd80:	47b8      	blx	r7
 801dd82:	3001      	adds	r0, #1
 801dd84:	d12c      	bne.n	801dde0 <_printf_float+0x24c>
 801dd86:	e764      	b.n	801dc52 <_printf_float+0xbe>
 801dd88:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 801dd8c:	f240 80e0 	bls.w	801df50 <_printf_float+0x3bc>
 801dd90:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
 801dd94:	2200      	movs	r2, #0
 801dd96:	2300      	movs	r3, #0
 801dd98:	f7e2 febe 	bl	8000b18 <__aeabi_dcmpeq>
 801dd9c:	2800      	cmp	r0, #0
 801dd9e:	d034      	beq.n	801de0a <_printf_float+0x276>
 801dda0:	4a37      	ldr	r2, [pc, #220]	; (801de80 <_printf_float+0x2ec>)
 801dda2:	2301      	movs	r3, #1
 801dda4:	4631      	mov	r1, r6
 801dda6:	4628      	mov	r0, r5
 801dda8:	47b8      	blx	r7
 801ddaa:	3001      	adds	r0, #1
 801ddac:	f43f af51 	beq.w	801dc52 <_printf_float+0xbe>
 801ddb0:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
 801ddb4:	429a      	cmp	r2, r3
 801ddb6:	db02      	blt.n	801ddbe <_printf_float+0x22a>
 801ddb8:	6823      	ldr	r3, [r4, #0]
 801ddba:	07d8      	lsls	r0, r3, #31
 801ddbc:	d510      	bpl.n	801dde0 <_printf_float+0x24c>
 801ddbe:	ee18 3a10 	vmov	r3, s16
 801ddc2:	4652      	mov	r2, sl
 801ddc4:	4631      	mov	r1, r6
 801ddc6:	4628      	mov	r0, r5
 801ddc8:	47b8      	blx	r7
 801ddca:	3001      	adds	r0, #1
 801ddcc:	f43f af41 	beq.w	801dc52 <_printf_float+0xbe>
 801ddd0:	f04f 0800 	mov.w	r8, #0
 801ddd4:	f104 091a 	add.w	r9, r4, #26
 801ddd8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801ddda:	3b01      	subs	r3, #1
 801dddc:	4543      	cmp	r3, r8
 801ddde:	dc09      	bgt.n	801ddf4 <_printf_float+0x260>
 801dde0:	6823      	ldr	r3, [r4, #0]
 801dde2:	079b      	lsls	r3, r3, #30
 801dde4:	f100 8107 	bmi.w	801dff6 <_printf_float+0x462>
 801dde8:	68e0      	ldr	r0, [r4, #12]
 801ddea:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801ddec:	4298      	cmp	r0, r3
 801ddee:	bfb8      	it	lt
 801ddf0:	4618      	movlt	r0, r3
 801ddf2:	e730      	b.n	801dc56 <_printf_float+0xc2>
 801ddf4:	2301      	movs	r3, #1
 801ddf6:	464a      	mov	r2, r9
 801ddf8:	4631      	mov	r1, r6
 801ddfa:	4628      	mov	r0, r5
 801ddfc:	47b8      	blx	r7
 801ddfe:	3001      	adds	r0, #1
 801de00:	f43f af27 	beq.w	801dc52 <_printf_float+0xbe>
 801de04:	f108 0801 	add.w	r8, r8, #1
 801de08:	e7e6      	b.n	801ddd8 <_printf_float+0x244>
 801de0a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801de0c:	2b00      	cmp	r3, #0
 801de0e:	dc39      	bgt.n	801de84 <_printf_float+0x2f0>
 801de10:	4a1b      	ldr	r2, [pc, #108]	; (801de80 <_printf_float+0x2ec>)
 801de12:	2301      	movs	r3, #1
 801de14:	4631      	mov	r1, r6
 801de16:	4628      	mov	r0, r5
 801de18:	47b8      	blx	r7
 801de1a:	3001      	adds	r0, #1
 801de1c:	f43f af19 	beq.w	801dc52 <_printf_float+0xbe>
 801de20:	e9dd 3209 	ldrd	r3, r2, [sp, #36]	; 0x24
 801de24:	4313      	orrs	r3, r2
 801de26:	d102      	bne.n	801de2e <_printf_float+0x29a>
 801de28:	6823      	ldr	r3, [r4, #0]
 801de2a:	07d9      	lsls	r1, r3, #31
 801de2c:	d5d8      	bpl.n	801dde0 <_printf_float+0x24c>
 801de2e:	ee18 3a10 	vmov	r3, s16
 801de32:	4652      	mov	r2, sl
 801de34:	4631      	mov	r1, r6
 801de36:	4628      	mov	r0, r5
 801de38:	47b8      	blx	r7
 801de3a:	3001      	adds	r0, #1
 801de3c:	f43f af09 	beq.w	801dc52 <_printf_float+0xbe>
 801de40:	f04f 0900 	mov.w	r9, #0
 801de44:	f104 0a1a 	add.w	sl, r4, #26
 801de48:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801de4a:	425b      	negs	r3, r3
 801de4c:	454b      	cmp	r3, r9
 801de4e:	dc01      	bgt.n	801de54 <_printf_float+0x2c0>
 801de50:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801de52:	e792      	b.n	801dd7a <_printf_float+0x1e6>
 801de54:	2301      	movs	r3, #1
 801de56:	4652      	mov	r2, sl
 801de58:	4631      	mov	r1, r6
 801de5a:	4628      	mov	r0, r5
 801de5c:	47b8      	blx	r7
 801de5e:	3001      	adds	r0, #1
 801de60:	f43f aef7 	beq.w	801dc52 <_printf_float+0xbe>
 801de64:	f109 0901 	add.w	r9, r9, #1
 801de68:	e7ee      	b.n	801de48 <_printf_float+0x2b4>
 801de6a:	bf00      	nop
 801de6c:	7fefffff 	.word	0x7fefffff
 801de70:	080238c7 	.word	0x080238c7
 801de74:	080238cb 	.word	0x080238cb
 801de78:	080238cf 	.word	0x080238cf
 801de7c:	080238d3 	.word	0x080238d3
 801de80:	080238d7 	.word	0x080238d7
 801de84:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801de86:	6da3      	ldr	r3, [r4, #88]	; 0x58
 801de88:	429a      	cmp	r2, r3
 801de8a:	bfa8      	it	ge
 801de8c:	461a      	movge	r2, r3
 801de8e:	2a00      	cmp	r2, #0
 801de90:	4691      	mov	r9, r2
 801de92:	dc37      	bgt.n	801df04 <_printf_float+0x370>
 801de94:	f04f 0b00 	mov.w	fp, #0
 801de98:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
 801de9c:	f104 021a 	add.w	r2, r4, #26
 801dea0:	6da3      	ldr	r3, [r4, #88]	; 0x58
 801dea2:	9305      	str	r3, [sp, #20]
 801dea4:	eba3 0309 	sub.w	r3, r3, r9
 801dea8:	455b      	cmp	r3, fp
 801deaa:	dc33      	bgt.n	801df14 <_printf_float+0x380>
 801deac:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
 801deb0:	429a      	cmp	r2, r3
 801deb2:	db3b      	blt.n	801df2c <_printf_float+0x398>
 801deb4:	6823      	ldr	r3, [r4, #0]
 801deb6:	07da      	lsls	r2, r3, #31
 801deb8:	d438      	bmi.n	801df2c <_printf_float+0x398>
 801deba:	e9dd 3209 	ldrd	r3, r2, [sp, #36]	; 0x24
 801debe:	eba2 0903 	sub.w	r9, r2, r3
 801dec2:	9b05      	ldr	r3, [sp, #20]
 801dec4:	1ad2      	subs	r2, r2, r3
 801dec6:	4591      	cmp	r9, r2
 801dec8:	bfa8      	it	ge
 801deca:	4691      	movge	r9, r2
 801decc:	f1b9 0f00 	cmp.w	r9, #0
 801ded0:	dc35      	bgt.n	801df3e <_printf_float+0x3aa>
 801ded2:	f04f 0800 	mov.w	r8, #0
 801ded6:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
 801deda:	f104 0a1a 	add.w	sl, r4, #26
 801dede:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
 801dee2:	1a9b      	subs	r3, r3, r2
 801dee4:	eba3 0309 	sub.w	r3, r3, r9
 801dee8:	4543      	cmp	r3, r8
 801deea:	f77f af79 	ble.w	801dde0 <_printf_float+0x24c>
 801deee:	2301      	movs	r3, #1
 801def0:	4652      	mov	r2, sl
 801def2:	4631      	mov	r1, r6
 801def4:	4628      	mov	r0, r5
 801def6:	47b8      	blx	r7
 801def8:	3001      	adds	r0, #1
 801defa:	f43f aeaa 	beq.w	801dc52 <_printf_float+0xbe>
 801defe:	f108 0801 	add.w	r8, r8, #1
 801df02:	e7ec      	b.n	801dede <_printf_float+0x34a>
 801df04:	4613      	mov	r3, r2
 801df06:	4631      	mov	r1, r6
 801df08:	4642      	mov	r2, r8
 801df0a:	4628      	mov	r0, r5
 801df0c:	47b8      	blx	r7
 801df0e:	3001      	adds	r0, #1
 801df10:	d1c0      	bne.n	801de94 <_printf_float+0x300>
 801df12:	e69e      	b.n	801dc52 <_printf_float+0xbe>
 801df14:	2301      	movs	r3, #1
 801df16:	4631      	mov	r1, r6
 801df18:	4628      	mov	r0, r5
 801df1a:	9205      	str	r2, [sp, #20]
 801df1c:	47b8      	blx	r7
 801df1e:	3001      	adds	r0, #1
 801df20:	f43f ae97 	beq.w	801dc52 <_printf_float+0xbe>
 801df24:	9a05      	ldr	r2, [sp, #20]
 801df26:	f10b 0b01 	add.w	fp, fp, #1
 801df2a:	e7b9      	b.n	801dea0 <_printf_float+0x30c>
 801df2c:	ee18 3a10 	vmov	r3, s16
 801df30:	4652      	mov	r2, sl
 801df32:	4631      	mov	r1, r6
 801df34:	4628      	mov	r0, r5
 801df36:	47b8      	blx	r7
 801df38:	3001      	adds	r0, #1
 801df3a:	d1be      	bne.n	801deba <_printf_float+0x326>
 801df3c:	e689      	b.n	801dc52 <_printf_float+0xbe>
 801df3e:	9a05      	ldr	r2, [sp, #20]
 801df40:	464b      	mov	r3, r9
 801df42:	4442      	add	r2, r8
 801df44:	4631      	mov	r1, r6
 801df46:	4628      	mov	r0, r5
 801df48:	47b8      	blx	r7
 801df4a:	3001      	adds	r0, #1
 801df4c:	d1c1      	bne.n	801ded2 <_printf_float+0x33e>
 801df4e:	e680      	b.n	801dc52 <_printf_float+0xbe>
 801df50:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801df52:	2a01      	cmp	r2, #1
 801df54:	dc01      	bgt.n	801df5a <_printf_float+0x3c6>
 801df56:	07db      	lsls	r3, r3, #31
 801df58:	d53a      	bpl.n	801dfd0 <_printf_float+0x43c>
 801df5a:	2301      	movs	r3, #1
 801df5c:	4642      	mov	r2, r8
 801df5e:	4631      	mov	r1, r6
 801df60:	4628      	mov	r0, r5
 801df62:	47b8      	blx	r7
 801df64:	3001      	adds	r0, #1
 801df66:	f43f ae74 	beq.w	801dc52 <_printf_float+0xbe>
 801df6a:	ee18 3a10 	vmov	r3, s16
 801df6e:	4652      	mov	r2, sl
 801df70:	4631      	mov	r1, r6
 801df72:	4628      	mov	r0, r5
 801df74:	47b8      	blx	r7
 801df76:	3001      	adds	r0, #1
 801df78:	f43f ae6b 	beq.w	801dc52 <_printf_float+0xbe>
 801df7c:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
 801df80:	2200      	movs	r2, #0
 801df82:	2300      	movs	r3, #0
 801df84:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 801df88:	f7e2 fdc6 	bl	8000b18 <__aeabi_dcmpeq>
 801df8c:	b9d8      	cbnz	r0, 801dfc6 <_printf_float+0x432>
 801df8e:	f10a 33ff 	add.w	r3, sl, #4294967295
 801df92:	f108 0201 	add.w	r2, r8, #1
 801df96:	4631      	mov	r1, r6
 801df98:	4628      	mov	r0, r5
 801df9a:	47b8      	blx	r7
 801df9c:	3001      	adds	r0, #1
 801df9e:	d10e      	bne.n	801dfbe <_printf_float+0x42a>
 801dfa0:	e657      	b.n	801dc52 <_printf_float+0xbe>
 801dfa2:	2301      	movs	r3, #1
 801dfa4:	4652      	mov	r2, sl
 801dfa6:	4631      	mov	r1, r6
 801dfa8:	4628      	mov	r0, r5
 801dfaa:	47b8      	blx	r7
 801dfac:	3001      	adds	r0, #1
 801dfae:	f43f ae50 	beq.w	801dc52 <_printf_float+0xbe>
 801dfb2:	f108 0801 	add.w	r8, r8, #1
 801dfb6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801dfb8:	3b01      	subs	r3, #1
 801dfba:	4543      	cmp	r3, r8
 801dfbc:	dcf1      	bgt.n	801dfa2 <_printf_float+0x40e>
 801dfbe:	464b      	mov	r3, r9
 801dfc0:	f104 0250 	add.w	r2, r4, #80	; 0x50
 801dfc4:	e6da      	b.n	801dd7c <_printf_float+0x1e8>
 801dfc6:	f04f 0800 	mov.w	r8, #0
 801dfca:	f104 0a1a 	add.w	sl, r4, #26
 801dfce:	e7f2      	b.n	801dfb6 <_printf_float+0x422>
 801dfd0:	2301      	movs	r3, #1
 801dfd2:	4642      	mov	r2, r8
 801dfd4:	e7df      	b.n	801df96 <_printf_float+0x402>
 801dfd6:	2301      	movs	r3, #1
 801dfd8:	464a      	mov	r2, r9
 801dfda:	4631      	mov	r1, r6
 801dfdc:	4628      	mov	r0, r5
 801dfde:	47b8      	blx	r7
 801dfe0:	3001      	adds	r0, #1
 801dfe2:	f43f ae36 	beq.w	801dc52 <_printf_float+0xbe>
 801dfe6:	f108 0801 	add.w	r8, r8, #1
 801dfea:	68e3      	ldr	r3, [r4, #12]
 801dfec:	990b      	ldr	r1, [sp, #44]	; 0x2c
 801dfee:	1a5b      	subs	r3, r3, r1
 801dff0:	4543      	cmp	r3, r8
 801dff2:	dcf0      	bgt.n	801dfd6 <_printf_float+0x442>
 801dff4:	e6f8      	b.n	801dde8 <_printf_float+0x254>
 801dff6:	f04f 0800 	mov.w	r8, #0
 801dffa:	f104 0919 	add.w	r9, r4, #25
 801dffe:	e7f4      	b.n	801dfea <_printf_float+0x456>

0801e000 <_printf_common>:
 801e000:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801e004:	4616      	mov	r6, r2
 801e006:	4699      	mov	r9, r3
 801e008:	688a      	ldr	r2, [r1, #8]
 801e00a:	690b      	ldr	r3, [r1, #16]
 801e00c:	f8dd 8020 	ldr.w	r8, [sp, #32]
 801e010:	4293      	cmp	r3, r2
 801e012:	bfb8      	it	lt
 801e014:	4613      	movlt	r3, r2
 801e016:	6033      	str	r3, [r6, #0]
 801e018:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 801e01c:	4607      	mov	r7, r0
 801e01e:	460c      	mov	r4, r1
 801e020:	b10a      	cbz	r2, 801e026 <_printf_common+0x26>
 801e022:	3301      	adds	r3, #1
 801e024:	6033      	str	r3, [r6, #0]
 801e026:	6823      	ldr	r3, [r4, #0]
 801e028:	0699      	lsls	r1, r3, #26
 801e02a:	bf42      	ittt	mi
 801e02c:	6833      	ldrmi	r3, [r6, #0]
 801e02e:	3302      	addmi	r3, #2
 801e030:	6033      	strmi	r3, [r6, #0]
 801e032:	6825      	ldr	r5, [r4, #0]
 801e034:	f015 0506 	ands.w	r5, r5, #6
 801e038:	d106      	bne.n	801e048 <_printf_common+0x48>
 801e03a:	f104 0a19 	add.w	sl, r4, #25
 801e03e:	68e3      	ldr	r3, [r4, #12]
 801e040:	6832      	ldr	r2, [r6, #0]
 801e042:	1a9b      	subs	r3, r3, r2
 801e044:	42ab      	cmp	r3, r5
 801e046:	dc26      	bgt.n	801e096 <_printf_common+0x96>
 801e048:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 801e04c:	1e13      	subs	r3, r2, #0
 801e04e:	6822      	ldr	r2, [r4, #0]
 801e050:	bf18      	it	ne
 801e052:	2301      	movne	r3, #1
 801e054:	0692      	lsls	r2, r2, #26
 801e056:	d42b      	bmi.n	801e0b0 <_printf_common+0xb0>
 801e058:	f104 0243 	add.w	r2, r4, #67	; 0x43
 801e05c:	4649      	mov	r1, r9
 801e05e:	4638      	mov	r0, r7
 801e060:	47c0      	blx	r8
 801e062:	3001      	adds	r0, #1
 801e064:	d01e      	beq.n	801e0a4 <_printf_common+0xa4>
 801e066:	6823      	ldr	r3, [r4, #0]
 801e068:	6922      	ldr	r2, [r4, #16]
 801e06a:	f003 0306 	and.w	r3, r3, #6
 801e06e:	2b04      	cmp	r3, #4
 801e070:	bf02      	ittt	eq
 801e072:	68e5      	ldreq	r5, [r4, #12]
 801e074:	6833      	ldreq	r3, [r6, #0]
 801e076:	1aed      	subeq	r5, r5, r3
 801e078:	68a3      	ldr	r3, [r4, #8]
 801e07a:	bf0c      	ite	eq
 801e07c:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 801e080:	2500      	movne	r5, #0
 801e082:	4293      	cmp	r3, r2
 801e084:	bfc4      	itt	gt
 801e086:	1a9b      	subgt	r3, r3, r2
 801e088:	18ed      	addgt	r5, r5, r3
 801e08a:	2600      	movs	r6, #0
 801e08c:	341a      	adds	r4, #26
 801e08e:	42b5      	cmp	r5, r6
 801e090:	d11a      	bne.n	801e0c8 <_printf_common+0xc8>
 801e092:	2000      	movs	r0, #0
 801e094:	e008      	b.n	801e0a8 <_printf_common+0xa8>
 801e096:	2301      	movs	r3, #1
 801e098:	4652      	mov	r2, sl
 801e09a:	4649      	mov	r1, r9
 801e09c:	4638      	mov	r0, r7
 801e09e:	47c0      	blx	r8
 801e0a0:	3001      	adds	r0, #1
 801e0a2:	d103      	bne.n	801e0ac <_printf_common+0xac>
 801e0a4:	f04f 30ff 	mov.w	r0, #4294967295
 801e0a8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801e0ac:	3501      	adds	r5, #1
 801e0ae:	e7c6      	b.n	801e03e <_printf_common+0x3e>
 801e0b0:	18e1      	adds	r1, r4, r3
 801e0b2:	1c5a      	adds	r2, r3, #1
 801e0b4:	2030      	movs	r0, #48	; 0x30
 801e0b6:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 801e0ba:	4422      	add	r2, r4
 801e0bc:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 801e0c0:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 801e0c4:	3302      	adds	r3, #2
 801e0c6:	e7c7      	b.n	801e058 <_printf_common+0x58>
 801e0c8:	2301      	movs	r3, #1
 801e0ca:	4622      	mov	r2, r4
 801e0cc:	4649      	mov	r1, r9
 801e0ce:	4638      	mov	r0, r7
 801e0d0:	47c0      	blx	r8
 801e0d2:	3001      	adds	r0, #1
 801e0d4:	d0e6      	beq.n	801e0a4 <_printf_common+0xa4>
 801e0d6:	3601      	adds	r6, #1
 801e0d8:	e7d9      	b.n	801e08e <_printf_common+0x8e>
	...

0801e0dc <_printf_i>:
 801e0dc:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 801e0e0:	7e0f      	ldrb	r7, [r1, #24]
 801e0e2:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801e0e4:	2f78      	cmp	r7, #120	; 0x78
 801e0e6:	4691      	mov	r9, r2
 801e0e8:	4680      	mov	r8, r0
 801e0ea:	460c      	mov	r4, r1
 801e0ec:	469a      	mov	sl, r3
 801e0ee:	f101 0243 	add.w	r2, r1, #67	; 0x43
 801e0f2:	d807      	bhi.n	801e104 <_printf_i+0x28>
 801e0f4:	2f62      	cmp	r7, #98	; 0x62
 801e0f6:	d80a      	bhi.n	801e10e <_printf_i+0x32>
 801e0f8:	2f00      	cmp	r7, #0
 801e0fa:	f000 80d4 	beq.w	801e2a6 <_printf_i+0x1ca>
 801e0fe:	2f58      	cmp	r7, #88	; 0x58
 801e100:	f000 80c0 	beq.w	801e284 <_printf_i+0x1a8>
 801e104:	f104 0542 	add.w	r5, r4, #66	; 0x42
 801e108:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 801e10c:	e03a      	b.n	801e184 <_printf_i+0xa8>
 801e10e:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 801e112:	2b15      	cmp	r3, #21
 801e114:	d8f6      	bhi.n	801e104 <_printf_i+0x28>
 801e116:	a101      	add	r1, pc, #4	; (adr r1, 801e11c <_printf_i+0x40>)
 801e118:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 801e11c:	0801e175 	.word	0x0801e175
 801e120:	0801e189 	.word	0x0801e189
 801e124:	0801e105 	.word	0x0801e105
 801e128:	0801e105 	.word	0x0801e105
 801e12c:	0801e105 	.word	0x0801e105
 801e130:	0801e105 	.word	0x0801e105
 801e134:	0801e189 	.word	0x0801e189
 801e138:	0801e105 	.word	0x0801e105
 801e13c:	0801e105 	.word	0x0801e105
 801e140:	0801e105 	.word	0x0801e105
 801e144:	0801e105 	.word	0x0801e105
 801e148:	0801e28d 	.word	0x0801e28d
 801e14c:	0801e1b5 	.word	0x0801e1b5
 801e150:	0801e247 	.word	0x0801e247
 801e154:	0801e105 	.word	0x0801e105
 801e158:	0801e105 	.word	0x0801e105
 801e15c:	0801e2af 	.word	0x0801e2af
 801e160:	0801e105 	.word	0x0801e105
 801e164:	0801e1b5 	.word	0x0801e1b5
 801e168:	0801e105 	.word	0x0801e105
 801e16c:	0801e105 	.word	0x0801e105
 801e170:	0801e24f 	.word	0x0801e24f
 801e174:	682b      	ldr	r3, [r5, #0]
 801e176:	1d1a      	adds	r2, r3, #4
 801e178:	681b      	ldr	r3, [r3, #0]
 801e17a:	602a      	str	r2, [r5, #0]
 801e17c:	f104 0542 	add.w	r5, r4, #66	; 0x42
 801e180:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 801e184:	2301      	movs	r3, #1
 801e186:	e09f      	b.n	801e2c8 <_printf_i+0x1ec>
 801e188:	6820      	ldr	r0, [r4, #0]
 801e18a:	682b      	ldr	r3, [r5, #0]
 801e18c:	0607      	lsls	r7, r0, #24
 801e18e:	f103 0104 	add.w	r1, r3, #4
 801e192:	6029      	str	r1, [r5, #0]
 801e194:	d501      	bpl.n	801e19a <_printf_i+0xbe>
 801e196:	681e      	ldr	r6, [r3, #0]
 801e198:	e003      	b.n	801e1a2 <_printf_i+0xc6>
 801e19a:	0646      	lsls	r6, r0, #25
 801e19c:	d5fb      	bpl.n	801e196 <_printf_i+0xba>
 801e19e:	f9b3 6000 	ldrsh.w	r6, [r3]
 801e1a2:	2e00      	cmp	r6, #0
 801e1a4:	da03      	bge.n	801e1ae <_printf_i+0xd2>
 801e1a6:	232d      	movs	r3, #45	; 0x2d
 801e1a8:	4276      	negs	r6, r6
 801e1aa:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 801e1ae:	485a      	ldr	r0, [pc, #360]	; (801e318 <_printf_i+0x23c>)
 801e1b0:	230a      	movs	r3, #10
 801e1b2:	e012      	b.n	801e1da <_printf_i+0xfe>
 801e1b4:	682b      	ldr	r3, [r5, #0]
 801e1b6:	6820      	ldr	r0, [r4, #0]
 801e1b8:	1d19      	adds	r1, r3, #4
 801e1ba:	6029      	str	r1, [r5, #0]
 801e1bc:	0605      	lsls	r5, r0, #24
 801e1be:	d501      	bpl.n	801e1c4 <_printf_i+0xe8>
 801e1c0:	681e      	ldr	r6, [r3, #0]
 801e1c2:	e002      	b.n	801e1ca <_printf_i+0xee>
 801e1c4:	0641      	lsls	r1, r0, #25
 801e1c6:	d5fb      	bpl.n	801e1c0 <_printf_i+0xe4>
 801e1c8:	881e      	ldrh	r6, [r3, #0]
 801e1ca:	4853      	ldr	r0, [pc, #332]	; (801e318 <_printf_i+0x23c>)
 801e1cc:	2f6f      	cmp	r7, #111	; 0x6f
 801e1ce:	bf0c      	ite	eq
 801e1d0:	2308      	moveq	r3, #8
 801e1d2:	230a      	movne	r3, #10
 801e1d4:	2100      	movs	r1, #0
 801e1d6:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 801e1da:	6865      	ldr	r5, [r4, #4]
 801e1dc:	60a5      	str	r5, [r4, #8]
 801e1de:	2d00      	cmp	r5, #0
 801e1e0:	bfa2      	ittt	ge
 801e1e2:	6821      	ldrge	r1, [r4, #0]
 801e1e4:	f021 0104 	bicge.w	r1, r1, #4
 801e1e8:	6021      	strge	r1, [r4, #0]
 801e1ea:	b90e      	cbnz	r6, 801e1f0 <_printf_i+0x114>
 801e1ec:	2d00      	cmp	r5, #0
 801e1ee:	d04b      	beq.n	801e288 <_printf_i+0x1ac>
 801e1f0:	4615      	mov	r5, r2
 801e1f2:	fbb6 f1f3 	udiv	r1, r6, r3
 801e1f6:	fb03 6711 	mls	r7, r3, r1, r6
 801e1fa:	5dc7      	ldrb	r7, [r0, r7]
 801e1fc:	f805 7d01 	strb.w	r7, [r5, #-1]!
 801e200:	4637      	mov	r7, r6
 801e202:	42bb      	cmp	r3, r7
 801e204:	460e      	mov	r6, r1
 801e206:	d9f4      	bls.n	801e1f2 <_printf_i+0x116>
 801e208:	2b08      	cmp	r3, #8
 801e20a:	d10b      	bne.n	801e224 <_printf_i+0x148>
 801e20c:	6823      	ldr	r3, [r4, #0]
 801e20e:	07de      	lsls	r6, r3, #31
 801e210:	d508      	bpl.n	801e224 <_printf_i+0x148>
 801e212:	6923      	ldr	r3, [r4, #16]
 801e214:	6861      	ldr	r1, [r4, #4]
 801e216:	4299      	cmp	r1, r3
 801e218:	bfde      	ittt	le
 801e21a:	2330      	movle	r3, #48	; 0x30
 801e21c:	f805 3c01 	strble.w	r3, [r5, #-1]
 801e220:	f105 35ff 	addle.w	r5, r5, #4294967295
 801e224:	1b52      	subs	r2, r2, r5
 801e226:	6122      	str	r2, [r4, #16]
 801e228:	f8cd a000 	str.w	sl, [sp]
 801e22c:	464b      	mov	r3, r9
 801e22e:	aa03      	add	r2, sp, #12
 801e230:	4621      	mov	r1, r4
 801e232:	4640      	mov	r0, r8
 801e234:	f7ff fee4 	bl	801e000 <_printf_common>
 801e238:	3001      	adds	r0, #1
 801e23a:	d14a      	bne.n	801e2d2 <_printf_i+0x1f6>
 801e23c:	f04f 30ff 	mov.w	r0, #4294967295
 801e240:	b004      	add	sp, #16
 801e242:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801e246:	6823      	ldr	r3, [r4, #0]
 801e248:	f043 0320 	orr.w	r3, r3, #32
 801e24c:	6023      	str	r3, [r4, #0]
 801e24e:	4833      	ldr	r0, [pc, #204]	; (801e31c <_printf_i+0x240>)
 801e250:	2778      	movs	r7, #120	; 0x78
 801e252:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
 801e256:	6823      	ldr	r3, [r4, #0]
 801e258:	6829      	ldr	r1, [r5, #0]
 801e25a:	061f      	lsls	r7, r3, #24
 801e25c:	f851 6b04 	ldr.w	r6, [r1], #4
 801e260:	d402      	bmi.n	801e268 <_printf_i+0x18c>
 801e262:	065f      	lsls	r7, r3, #25
 801e264:	bf48      	it	mi
 801e266:	b2b6      	uxthmi	r6, r6
 801e268:	07df      	lsls	r7, r3, #31
 801e26a:	bf48      	it	mi
 801e26c:	f043 0320 	orrmi.w	r3, r3, #32
 801e270:	6029      	str	r1, [r5, #0]
 801e272:	bf48      	it	mi
 801e274:	6023      	strmi	r3, [r4, #0]
 801e276:	b91e      	cbnz	r6, 801e280 <_printf_i+0x1a4>
 801e278:	6823      	ldr	r3, [r4, #0]
 801e27a:	f023 0320 	bic.w	r3, r3, #32
 801e27e:	6023      	str	r3, [r4, #0]
 801e280:	2310      	movs	r3, #16
 801e282:	e7a7      	b.n	801e1d4 <_printf_i+0xf8>
 801e284:	4824      	ldr	r0, [pc, #144]	; (801e318 <_printf_i+0x23c>)
 801e286:	e7e4      	b.n	801e252 <_printf_i+0x176>
 801e288:	4615      	mov	r5, r2
 801e28a:	e7bd      	b.n	801e208 <_printf_i+0x12c>
 801e28c:	682b      	ldr	r3, [r5, #0]
 801e28e:	6826      	ldr	r6, [r4, #0]
 801e290:	6961      	ldr	r1, [r4, #20]
 801e292:	1d18      	adds	r0, r3, #4
 801e294:	6028      	str	r0, [r5, #0]
 801e296:	0635      	lsls	r5, r6, #24
 801e298:	681b      	ldr	r3, [r3, #0]
 801e29a:	d501      	bpl.n	801e2a0 <_printf_i+0x1c4>
 801e29c:	6019      	str	r1, [r3, #0]
 801e29e:	e002      	b.n	801e2a6 <_printf_i+0x1ca>
 801e2a0:	0670      	lsls	r0, r6, #25
 801e2a2:	d5fb      	bpl.n	801e29c <_printf_i+0x1c0>
 801e2a4:	8019      	strh	r1, [r3, #0]
 801e2a6:	2300      	movs	r3, #0
 801e2a8:	6123      	str	r3, [r4, #16]
 801e2aa:	4615      	mov	r5, r2
 801e2ac:	e7bc      	b.n	801e228 <_printf_i+0x14c>
 801e2ae:	682b      	ldr	r3, [r5, #0]
 801e2b0:	1d1a      	adds	r2, r3, #4
 801e2b2:	602a      	str	r2, [r5, #0]
 801e2b4:	681d      	ldr	r5, [r3, #0]
 801e2b6:	6862      	ldr	r2, [r4, #4]
 801e2b8:	2100      	movs	r1, #0
 801e2ba:	4628      	mov	r0, r5
 801e2bc:	f7e1 ffb0 	bl	8000220 <memchr>
 801e2c0:	b108      	cbz	r0, 801e2c6 <_printf_i+0x1ea>
 801e2c2:	1b40      	subs	r0, r0, r5
 801e2c4:	6060      	str	r0, [r4, #4]
 801e2c6:	6863      	ldr	r3, [r4, #4]
 801e2c8:	6123      	str	r3, [r4, #16]
 801e2ca:	2300      	movs	r3, #0
 801e2cc:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 801e2d0:	e7aa      	b.n	801e228 <_printf_i+0x14c>
 801e2d2:	6923      	ldr	r3, [r4, #16]
 801e2d4:	462a      	mov	r2, r5
 801e2d6:	4649      	mov	r1, r9
 801e2d8:	4640      	mov	r0, r8
 801e2da:	47d0      	blx	sl
 801e2dc:	3001      	adds	r0, #1
 801e2de:	d0ad      	beq.n	801e23c <_printf_i+0x160>
 801e2e0:	6823      	ldr	r3, [r4, #0]
 801e2e2:	079b      	lsls	r3, r3, #30
 801e2e4:	d413      	bmi.n	801e30e <_printf_i+0x232>
 801e2e6:	68e0      	ldr	r0, [r4, #12]
 801e2e8:	9b03      	ldr	r3, [sp, #12]
 801e2ea:	4298      	cmp	r0, r3
 801e2ec:	bfb8      	it	lt
 801e2ee:	4618      	movlt	r0, r3
 801e2f0:	e7a6      	b.n	801e240 <_printf_i+0x164>
 801e2f2:	2301      	movs	r3, #1
 801e2f4:	4632      	mov	r2, r6
 801e2f6:	4649      	mov	r1, r9
 801e2f8:	4640      	mov	r0, r8
 801e2fa:	47d0      	blx	sl
 801e2fc:	3001      	adds	r0, #1
 801e2fe:	d09d      	beq.n	801e23c <_printf_i+0x160>
 801e300:	3501      	adds	r5, #1
 801e302:	68e3      	ldr	r3, [r4, #12]
 801e304:	9903      	ldr	r1, [sp, #12]
 801e306:	1a5b      	subs	r3, r3, r1
 801e308:	42ab      	cmp	r3, r5
 801e30a:	dcf2      	bgt.n	801e2f2 <_printf_i+0x216>
 801e30c:	e7eb      	b.n	801e2e6 <_printf_i+0x20a>
 801e30e:	2500      	movs	r5, #0
 801e310:	f104 0619 	add.w	r6, r4, #25
 801e314:	e7f5      	b.n	801e302 <_printf_i+0x226>
 801e316:	bf00      	nop
 801e318:	080238d9 	.word	0x080238d9
 801e31c:	080238ea 	.word	0x080238ea

0801e320 <std>:
 801e320:	2300      	movs	r3, #0
 801e322:	b510      	push	{r4, lr}
 801e324:	4604      	mov	r4, r0
 801e326:	e9c0 3300 	strd	r3, r3, [r0]
 801e32a:	e9c0 3304 	strd	r3, r3, [r0, #16]
 801e32e:	6083      	str	r3, [r0, #8]
 801e330:	8181      	strh	r1, [r0, #12]
 801e332:	6643      	str	r3, [r0, #100]	; 0x64
 801e334:	81c2      	strh	r2, [r0, #14]
 801e336:	6183      	str	r3, [r0, #24]
 801e338:	4619      	mov	r1, r3
 801e33a:	2208      	movs	r2, #8
 801e33c:	305c      	adds	r0, #92	; 0x5c
 801e33e:	f000 f914 	bl	801e56a <memset>
 801e342:	4b05      	ldr	r3, [pc, #20]	; (801e358 <std+0x38>)
 801e344:	6263      	str	r3, [r4, #36]	; 0x24
 801e346:	4b05      	ldr	r3, [pc, #20]	; (801e35c <std+0x3c>)
 801e348:	62a3      	str	r3, [r4, #40]	; 0x28
 801e34a:	4b05      	ldr	r3, [pc, #20]	; (801e360 <std+0x40>)
 801e34c:	62e3      	str	r3, [r4, #44]	; 0x2c
 801e34e:	4b05      	ldr	r3, [pc, #20]	; (801e364 <std+0x44>)
 801e350:	6224      	str	r4, [r4, #32]
 801e352:	6323      	str	r3, [r4, #48]	; 0x30
 801e354:	bd10      	pop	{r4, pc}
 801e356:	bf00      	nop
 801e358:	0801e4e5 	.word	0x0801e4e5
 801e35c:	0801e507 	.word	0x0801e507
 801e360:	0801e53f 	.word	0x0801e53f
 801e364:	0801e563 	.word	0x0801e563

0801e368 <stdio_exit_handler>:
 801e368:	4a02      	ldr	r2, [pc, #8]	; (801e374 <stdio_exit_handler+0xc>)
 801e36a:	4903      	ldr	r1, [pc, #12]	; (801e378 <stdio_exit_handler+0x10>)
 801e36c:	4803      	ldr	r0, [pc, #12]	; (801e37c <stdio_exit_handler+0x14>)
 801e36e:	f000 b87b 	b.w	801e468 <_fwalk_sglue>
 801e372:	bf00      	nop
 801e374:	20000190 	.word	0x20000190
 801e378:	080202c9 	.word	0x080202c9
 801e37c:	2000019c 	.word	0x2000019c

0801e380 <cleanup_stdio>:
 801e380:	6841      	ldr	r1, [r0, #4]
 801e382:	4b0c      	ldr	r3, [pc, #48]	; (801e3b4 <cleanup_stdio+0x34>)
 801e384:	4299      	cmp	r1, r3
 801e386:	b510      	push	{r4, lr}
 801e388:	4604      	mov	r4, r0
 801e38a:	d001      	beq.n	801e390 <cleanup_stdio+0x10>
 801e38c:	f001 ff9c 	bl	80202c8 <_fflush_r>
 801e390:	68a1      	ldr	r1, [r4, #8]
 801e392:	4b09      	ldr	r3, [pc, #36]	; (801e3b8 <cleanup_stdio+0x38>)
 801e394:	4299      	cmp	r1, r3
 801e396:	d002      	beq.n	801e39e <cleanup_stdio+0x1e>
 801e398:	4620      	mov	r0, r4
 801e39a:	f001 ff95 	bl	80202c8 <_fflush_r>
 801e39e:	68e1      	ldr	r1, [r4, #12]
 801e3a0:	4b06      	ldr	r3, [pc, #24]	; (801e3bc <cleanup_stdio+0x3c>)
 801e3a2:	4299      	cmp	r1, r3
 801e3a4:	d004      	beq.n	801e3b0 <cleanup_stdio+0x30>
 801e3a6:	4620      	mov	r0, r4
 801e3a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801e3ac:	f001 bf8c 	b.w	80202c8 <_fflush_r>
 801e3b0:	bd10      	pop	{r4, pc}
 801e3b2:	bf00      	nop
 801e3b4:	2001692c 	.word	0x2001692c
 801e3b8:	20016994 	.word	0x20016994
 801e3bc:	200169fc 	.word	0x200169fc

0801e3c0 <global_stdio_init.part.0>:
 801e3c0:	b510      	push	{r4, lr}
 801e3c2:	4b0b      	ldr	r3, [pc, #44]	; (801e3f0 <global_stdio_init.part.0+0x30>)
 801e3c4:	4c0b      	ldr	r4, [pc, #44]	; (801e3f4 <global_stdio_init.part.0+0x34>)
 801e3c6:	4a0c      	ldr	r2, [pc, #48]	; (801e3f8 <global_stdio_init.part.0+0x38>)
 801e3c8:	601a      	str	r2, [r3, #0]
 801e3ca:	4620      	mov	r0, r4
 801e3cc:	2200      	movs	r2, #0
 801e3ce:	2104      	movs	r1, #4
 801e3d0:	f7ff ffa6 	bl	801e320 <std>
 801e3d4:	f104 0068 	add.w	r0, r4, #104	; 0x68
 801e3d8:	2201      	movs	r2, #1
 801e3da:	2109      	movs	r1, #9
 801e3dc:	f7ff ffa0 	bl	801e320 <std>
 801e3e0:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 801e3e4:	2202      	movs	r2, #2
 801e3e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801e3ea:	2112      	movs	r1, #18
 801e3ec:	f7ff bf98 	b.w	801e320 <std>
 801e3f0:	20016a64 	.word	0x20016a64
 801e3f4:	2001692c 	.word	0x2001692c
 801e3f8:	0801e369 	.word	0x0801e369

0801e3fc <__sfp_lock_acquire>:
 801e3fc:	4801      	ldr	r0, [pc, #4]	; (801e404 <__sfp_lock_acquire+0x8>)
 801e3fe:	f000 b931 	b.w	801e664 <__retarget_lock_acquire_recursive>
 801e402:	bf00      	nop
 801e404:	20016a6d 	.word	0x20016a6d

0801e408 <__sfp_lock_release>:
 801e408:	4801      	ldr	r0, [pc, #4]	; (801e410 <__sfp_lock_release+0x8>)
 801e40a:	f000 b92c 	b.w	801e666 <__retarget_lock_release_recursive>
 801e40e:	bf00      	nop
 801e410:	20016a6d 	.word	0x20016a6d

0801e414 <__sinit>:
 801e414:	b510      	push	{r4, lr}
 801e416:	4604      	mov	r4, r0
 801e418:	f7ff fff0 	bl	801e3fc <__sfp_lock_acquire>
 801e41c:	6a23      	ldr	r3, [r4, #32]
 801e41e:	b11b      	cbz	r3, 801e428 <__sinit+0x14>
 801e420:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801e424:	f7ff bff0 	b.w	801e408 <__sfp_lock_release>
 801e428:	4b04      	ldr	r3, [pc, #16]	; (801e43c <__sinit+0x28>)
 801e42a:	6223      	str	r3, [r4, #32]
 801e42c:	4b04      	ldr	r3, [pc, #16]	; (801e440 <__sinit+0x2c>)
 801e42e:	681b      	ldr	r3, [r3, #0]
 801e430:	2b00      	cmp	r3, #0
 801e432:	d1f5      	bne.n	801e420 <__sinit+0xc>
 801e434:	f7ff ffc4 	bl	801e3c0 <global_stdio_init.part.0>
 801e438:	e7f2      	b.n	801e420 <__sinit+0xc>
 801e43a:	bf00      	nop
 801e43c:	0801e381 	.word	0x0801e381
 801e440:	20016a64 	.word	0x20016a64

0801e444 <fiprintf>:
 801e444:	b40e      	push	{r1, r2, r3}
 801e446:	b503      	push	{r0, r1, lr}
 801e448:	4601      	mov	r1, r0
 801e44a:	ab03      	add	r3, sp, #12
 801e44c:	4805      	ldr	r0, [pc, #20]	; (801e464 <fiprintf+0x20>)
 801e44e:	f853 2b04 	ldr.w	r2, [r3], #4
 801e452:	6800      	ldr	r0, [r0, #0]
 801e454:	9301      	str	r3, [sp, #4]
 801e456:	f001 fd97 	bl	801ff88 <_vfiprintf_r>
 801e45a:	b002      	add	sp, #8
 801e45c:	f85d eb04 	ldr.w	lr, [sp], #4
 801e460:	b003      	add	sp, #12
 801e462:	4770      	bx	lr
 801e464:	200001e8 	.word	0x200001e8

0801e468 <_fwalk_sglue>:
 801e468:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801e46c:	4607      	mov	r7, r0
 801e46e:	4688      	mov	r8, r1
 801e470:	4614      	mov	r4, r2
 801e472:	2600      	movs	r6, #0
 801e474:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 801e478:	f1b9 0901 	subs.w	r9, r9, #1
 801e47c:	d505      	bpl.n	801e48a <_fwalk_sglue+0x22>
 801e47e:	6824      	ldr	r4, [r4, #0]
 801e480:	2c00      	cmp	r4, #0
 801e482:	d1f7      	bne.n	801e474 <_fwalk_sglue+0xc>
 801e484:	4630      	mov	r0, r6
 801e486:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801e48a:	89ab      	ldrh	r3, [r5, #12]
 801e48c:	2b01      	cmp	r3, #1
 801e48e:	d907      	bls.n	801e4a0 <_fwalk_sglue+0x38>
 801e490:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 801e494:	3301      	adds	r3, #1
 801e496:	d003      	beq.n	801e4a0 <_fwalk_sglue+0x38>
 801e498:	4629      	mov	r1, r5
 801e49a:	4638      	mov	r0, r7
 801e49c:	47c0      	blx	r8
 801e49e:	4306      	orrs	r6, r0
 801e4a0:	3568      	adds	r5, #104	; 0x68
 801e4a2:	e7e9      	b.n	801e478 <_fwalk_sglue+0x10>

0801e4a4 <siprintf>:
 801e4a4:	b40e      	push	{r1, r2, r3}
 801e4a6:	b500      	push	{lr}
 801e4a8:	b09c      	sub	sp, #112	; 0x70
 801e4aa:	ab1d      	add	r3, sp, #116	; 0x74
 801e4ac:	9002      	str	r0, [sp, #8]
 801e4ae:	9006      	str	r0, [sp, #24]
 801e4b0:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 801e4b4:	4809      	ldr	r0, [pc, #36]	; (801e4dc <siprintf+0x38>)
 801e4b6:	9107      	str	r1, [sp, #28]
 801e4b8:	9104      	str	r1, [sp, #16]
 801e4ba:	4909      	ldr	r1, [pc, #36]	; (801e4e0 <siprintf+0x3c>)
 801e4bc:	f853 2b04 	ldr.w	r2, [r3], #4
 801e4c0:	9105      	str	r1, [sp, #20]
 801e4c2:	6800      	ldr	r0, [r0, #0]
 801e4c4:	9301      	str	r3, [sp, #4]
 801e4c6:	a902      	add	r1, sp, #8
 801e4c8:	f001 fc36 	bl	801fd38 <_svfiprintf_r>
 801e4cc:	9b02      	ldr	r3, [sp, #8]
 801e4ce:	2200      	movs	r2, #0
 801e4d0:	701a      	strb	r2, [r3, #0]
 801e4d2:	b01c      	add	sp, #112	; 0x70
 801e4d4:	f85d eb04 	ldr.w	lr, [sp], #4
 801e4d8:	b003      	add	sp, #12
 801e4da:	4770      	bx	lr
 801e4dc:	200001e8 	.word	0x200001e8
 801e4e0:	ffff0208 	.word	0xffff0208

0801e4e4 <__sread>:
 801e4e4:	b510      	push	{r4, lr}
 801e4e6:	460c      	mov	r4, r1
 801e4e8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801e4ec:	f000 f86c 	bl	801e5c8 <_read_r>
 801e4f0:	2800      	cmp	r0, #0
 801e4f2:	bfab      	itete	ge
 801e4f4:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 801e4f6:	89a3      	ldrhlt	r3, [r4, #12]
 801e4f8:	181b      	addge	r3, r3, r0
 801e4fa:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 801e4fe:	bfac      	ite	ge
 801e500:	6563      	strge	r3, [r4, #84]	; 0x54
 801e502:	81a3      	strhlt	r3, [r4, #12]
 801e504:	bd10      	pop	{r4, pc}

0801e506 <__swrite>:
 801e506:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801e50a:	461f      	mov	r7, r3
 801e50c:	898b      	ldrh	r3, [r1, #12]
 801e50e:	05db      	lsls	r3, r3, #23
 801e510:	4605      	mov	r5, r0
 801e512:	460c      	mov	r4, r1
 801e514:	4616      	mov	r6, r2
 801e516:	d505      	bpl.n	801e524 <__swrite+0x1e>
 801e518:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801e51c:	2302      	movs	r3, #2
 801e51e:	2200      	movs	r2, #0
 801e520:	f000 f840 	bl	801e5a4 <_lseek_r>
 801e524:	89a3      	ldrh	r3, [r4, #12]
 801e526:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 801e52a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 801e52e:	81a3      	strh	r3, [r4, #12]
 801e530:	4632      	mov	r2, r6
 801e532:	463b      	mov	r3, r7
 801e534:	4628      	mov	r0, r5
 801e536:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 801e53a:	f000 b857 	b.w	801e5ec <_write_r>

0801e53e <__sseek>:
 801e53e:	b510      	push	{r4, lr}
 801e540:	460c      	mov	r4, r1
 801e542:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801e546:	f000 f82d 	bl	801e5a4 <_lseek_r>
 801e54a:	1c43      	adds	r3, r0, #1
 801e54c:	89a3      	ldrh	r3, [r4, #12]
 801e54e:	bf15      	itete	ne
 801e550:	6560      	strne	r0, [r4, #84]	; 0x54
 801e552:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 801e556:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 801e55a:	81a3      	strheq	r3, [r4, #12]
 801e55c:	bf18      	it	ne
 801e55e:	81a3      	strhne	r3, [r4, #12]
 801e560:	bd10      	pop	{r4, pc}

0801e562 <__sclose>:
 801e562:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801e566:	f000 b80d 	b.w	801e584 <_close_r>

0801e56a <memset>:
 801e56a:	4402      	add	r2, r0
 801e56c:	4603      	mov	r3, r0
 801e56e:	4293      	cmp	r3, r2
 801e570:	d100      	bne.n	801e574 <memset+0xa>
 801e572:	4770      	bx	lr
 801e574:	f803 1b01 	strb.w	r1, [r3], #1
 801e578:	e7f9      	b.n	801e56e <memset+0x4>
	...

0801e57c <_localeconv_r>:
 801e57c:	4800      	ldr	r0, [pc, #0]	; (801e580 <_localeconv_r+0x4>)
 801e57e:	4770      	bx	lr
 801e580:	200002dc 	.word	0x200002dc

0801e584 <_close_r>:
 801e584:	b538      	push	{r3, r4, r5, lr}
 801e586:	4d06      	ldr	r5, [pc, #24]	; (801e5a0 <_close_r+0x1c>)
 801e588:	2300      	movs	r3, #0
 801e58a:	4604      	mov	r4, r0
 801e58c:	4608      	mov	r0, r1
 801e58e:	602b      	str	r3, [r5, #0]
 801e590:	f7e7 f975 	bl	800587e <_close>
 801e594:	1c43      	adds	r3, r0, #1
 801e596:	d102      	bne.n	801e59e <_close_r+0x1a>
 801e598:	682b      	ldr	r3, [r5, #0]
 801e59a:	b103      	cbz	r3, 801e59e <_close_r+0x1a>
 801e59c:	6023      	str	r3, [r4, #0]
 801e59e:	bd38      	pop	{r3, r4, r5, pc}
 801e5a0:	20016a68 	.word	0x20016a68

0801e5a4 <_lseek_r>:
 801e5a4:	b538      	push	{r3, r4, r5, lr}
 801e5a6:	4d07      	ldr	r5, [pc, #28]	; (801e5c4 <_lseek_r+0x20>)
 801e5a8:	4604      	mov	r4, r0
 801e5aa:	4608      	mov	r0, r1
 801e5ac:	4611      	mov	r1, r2
 801e5ae:	2200      	movs	r2, #0
 801e5b0:	602a      	str	r2, [r5, #0]
 801e5b2:	461a      	mov	r2, r3
 801e5b4:	f7e7 f98a 	bl	80058cc <_lseek>
 801e5b8:	1c43      	adds	r3, r0, #1
 801e5ba:	d102      	bne.n	801e5c2 <_lseek_r+0x1e>
 801e5bc:	682b      	ldr	r3, [r5, #0]
 801e5be:	b103      	cbz	r3, 801e5c2 <_lseek_r+0x1e>
 801e5c0:	6023      	str	r3, [r4, #0]
 801e5c2:	bd38      	pop	{r3, r4, r5, pc}
 801e5c4:	20016a68 	.word	0x20016a68

0801e5c8 <_read_r>:
 801e5c8:	b538      	push	{r3, r4, r5, lr}
 801e5ca:	4d07      	ldr	r5, [pc, #28]	; (801e5e8 <_read_r+0x20>)
 801e5cc:	4604      	mov	r4, r0
 801e5ce:	4608      	mov	r0, r1
 801e5d0:	4611      	mov	r1, r2
 801e5d2:	2200      	movs	r2, #0
 801e5d4:	602a      	str	r2, [r5, #0]
 801e5d6:	461a      	mov	r2, r3
 801e5d8:	f7e7 f934 	bl	8005844 <_read>
 801e5dc:	1c43      	adds	r3, r0, #1
 801e5de:	d102      	bne.n	801e5e6 <_read_r+0x1e>
 801e5e0:	682b      	ldr	r3, [r5, #0]
 801e5e2:	b103      	cbz	r3, 801e5e6 <_read_r+0x1e>
 801e5e4:	6023      	str	r3, [r4, #0]
 801e5e6:	bd38      	pop	{r3, r4, r5, pc}
 801e5e8:	20016a68 	.word	0x20016a68

0801e5ec <_write_r>:
 801e5ec:	b538      	push	{r3, r4, r5, lr}
 801e5ee:	4d07      	ldr	r5, [pc, #28]	; (801e60c <_write_r+0x20>)
 801e5f0:	4604      	mov	r4, r0
 801e5f2:	4608      	mov	r0, r1
 801e5f4:	4611      	mov	r1, r2
 801e5f6:	2200      	movs	r2, #0
 801e5f8:	602a      	str	r2, [r5, #0]
 801e5fa:	461a      	mov	r2, r3
 801e5fc:	f7e3 f9fd 	bl	80019fa <_write>
 801e600:	1c43      	adds	r3, r0, #1
 801e602:	d102      	bne.n	801e60a <_write_r+0x1e>
 801e604:	682b      	ldr	r3, [r5, #0]
 801e606:	b103      	cbz	r3, 801e60a <_write_r+0x1e>
 801e608:	6023      	str	r3, [r4, #0]
 801e60a:	bd38      	pop	{r3, r4, r5, pc}
 801e60c:	20016a68 	.word	0x20016a68

0801e610 <__errno>:
 801e610:	4b01      	ldr	r3, [pc, #4]	; (801e618 <__errno+0x8>)
 801e612:	6818      	ldr	r0, [r3, #0]
 801e614:	4770      	bx	lr
 801e616:	bf00      	nop
 801e618:	200001e8 	.word	0x200001e8

0801e61c <__libc_init_array>:
 801e61c:	b570      	push	{r4, r5, r6, lr}
 801e61e:	4d0d      	ldr	r5, [pc, #52]	; (801e654 <__libc_init_array+0x38>)
 801e620:	4c0d      	ldr	r4, [pc, #52]	; (801e658 <__libc_init_array+0x3c>)
 801e622:	1b64      	subs	r4, r4, r5
 801e624:	10a4      	asrs	r4, r4, #2
 801e626:	2600      	movs	r6, #0
 801e628:	42a6      	cmp	r6, r4
 801e62a:	d109      	bne.n	801e640 <__libc_init_array+0x24>
 801e62c:	4d0b      	ldr	r5, [pc, #44]	; (801e65c <__libc_init_array+0x40>)
 801e62e:	4c0c      	ldr	r4, [pc, #48]	; (801e660 <__libc_init_array+0x44>)
 801e630:	f002 fda0 	bl	8021174 <_init>
 801e634:	1b64      	subs	r4, r4, r5
 801e636:	10a4      	asrs	r4, r4, #2
 801e638:	2600      	movs	r6, #0
 801e63a:	42a6      	cmp	r6, r4
 801e63c:	d105      	bne.n	801e64a <__libc_init_array+0x2e>
 801e63e:	bd70      	pop	{r4, r5, r6, pc}
 801e640:	f855 3b04 	ldr.w	r3, [r5], #4
 801e644:	4798      	blx	r3
 801e646:	3601      	adds	r6, #1
 801e648:	e7ee      	b.n	801e628 <__libc_init_array+0xc>
 801e64a:	f855 3b04 	ldr.w	r3, [r5], #4
 801e64e:	4798      	blx	r3
 801e650:	3601      	adds	r6, #1
 801e652:	e7f2      	b.n	801e63a <__libc_init_array+0x1e>
 801e654:	08023fd0 	.word	0x08023fd0
 801e658:	08023fd0 	.word	0x08023fd0
 801e65c:	08023fd0 	.word	0x08023fd0
 801e660:	08023fd4 	.word	0x08023fd4

0801e664 <__retarget_lock_acquire_recursive>:
 801e664:	4770      	bx	lr

0801e666 <__retarget_lock_release_recursive>:
 801e666:	4770      	bx	lr

0801e668 <memcpy>:
 801e668:	440a      	add	r2, r1
 801e66a:	4291      	cmp	r1, r2
 801e66c:	f100 33ff 	add.w	r3, r0, #4294967295
 801e670:	d100      	bne.n	801e674 <memcpy+0xc>
 801e672:	4770      	bx	lr
 801e674:	b510      	push	{r4, lr}
 801e676:	f811 4b01 	ldrb.w	r4, [r1], #1
 801e67a:	f803 4f01 	strb.w	r4, [r3, #1]!
 801e67e:	4291      	cmp	r1, r2
 801e680:	d1f9      	bne.n	801e676 <memcpy+0xe>
 801e682:	bd10      	pop	{r4, pc}

0801e684 <abort>:
 801e684:	b508      	push	{r3, lr}
 801e686:	2006      	movs	r0, #6
 801e688:	f001 ff1e 	bl	80204c8 <raise>
 801e68c:	2001      	movs	r0, #1
 801e68e:	f7e7 f8cf 	bl	8005830 <_exit>

0801e692 <quorem>:
 801e692:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e696:	6903      	ldr	r3, [r0, #16]
 801e698:	690c      	ldr	r4, [r1, #16]
 801e69a:	42a3      	cmp	r3, r4
 801e69c:	4607      	mov	r7, r0
 801e69e:	db7e      	blt.n	801e79e <quorem+0x10c>
 801e6a0:	3c01      	subs	r4, #1
 801e6a2:	f101 0814 	add.w	r8, r1, #20
 801e6a6:	f100 0514 	add.w	r5, r0, #20
 801e6aa:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 801e6ae:	9301      	str	r3, [sp, #4]
 801e6b0:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
 801e6b4:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 801e6b8:	3301      	adds	r3, #1
 801e6ba:	429a      	cmp	r2, r3
 801e6bc:	ea4f 0b84 	mov.w	fp, r4, lsl #2
 801e6c0:	eb08 0984 	add.w	r9, r8, r4, lsl #2
 801e6c4:	fbb2 f6f3 	udiv	r6, r2, r3
 801e6c8:	d331      	bcc.n	801e72e <quorem+0x9c>
 801e6ca:	f04f 0e00 	mov.w	lr, #0
 801e6ce:	4640      	mov	r0, r8
 801e6d0:	46ac      	mov	ip, r5
 801e6d2:	46f2      	mov	sl, lr
 801e6d4:	f850 2b04 	ldr.w	r2, [r0], #4
 801e6d8:	b293      	uxth	r3, r2
 801e6da:	fb06 e303 	mla	r3, r6, r3, lr
 801e6de:	ea4f 4e12 	mov.w	lr, r2, lsr #16
 801e6e2:	0c1a      	lsrs	r2, r3, #16
 801e6e4:	b29b      	uxth	r3, r3
 801e6e6:	ebaa 0303 	sub.w	r3, sl, r3
 801e6ea:	f8dc a000 	ldr.w	sl, [ip]
 801e6ee:	fa13 f38a 	uxtah	r3, r3, sl
 801e6f2:	fb06 220e 	mla	r2, r6, lr, r2
 801e6f6:	9300      	str	r3, [sp, #0]
 801e6f8:	9b00      	ldr	r3, [sp, #0]
 801e6fa:	ea4f 4e12 	mov.w	lr, r2, lsr #16
 801e6fe:	b292      	uxth	r2, r2
 801e700:	ebc2 421a 	rsb	r2, r2, sl, lsr #16
 801e704:	eb02 4223 	add.w	r2, r2, r3, asr #16
 801e708:	f8bd 3000 	ldrh.w	r3, [sp]
 801e70c:	4581      	cmp	r9, r0
 801e70e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 801e712:	f84c 3b04 	str.w	r3, [ip], #4
 801e716:	ea4f 4a22 	mov.w	sl, r2, asr #16
 801e71a:	d2db      	bcs.n	801e6d4 <quorem+0x42>
 801e71c:	f855 300b 	ldr.w	r3, [r5, fp]
 801e720:	b92b      	cbnz	r3, 801e72e <quorem+0x9c>
 801e722:	9b01      	ldr	r3, [sp, #4]
 801e724:	3b04      	subs	r3, #4
 801e726:	429d      	cmp	r5, r3
 801e728:	461a      	mov	r2, r3
 801e72a:	d32c      	bcc.n	801e786 <quorem+0xf4>
 801e72c:	613c      	str	r4, [r7, #16]
 801e72e:	4638      	mov	r0, r7
 801e730:	f001 f9a8 	bl	801fa84 <__mcmp>
 801e734:	2800      	cmp	r0, #0
 801e736:	db22      	blt.n	801e77e <quorem+0xec>
 801e738:	3601      	adds	r6, #1
 801e73a:	4629      	mov	r1, r5
 801e73c:	2000      	movs	r0, #0
 801e73e:	f858 2b04 	ldr.w	r2, [r8], #4
 801e742:	f8d1 c000 	ldr.w	ip, [r1]
 801e746:	b293      	uxth	r3, r2
 801e748:	1ac3      	subs	r3, r0, r3
 801e74a:	0c12      	lsrs	r2, r2, #16
 801e74c:	fa13 f38c 	uxtah	r3, r3, ip
 801e750:	ebc2 421c 	rsb	r2, r2, ip, lsr #16
 801e754:	eb02 4223 	add.w	r2, r2, r3, asr #16
 801e758:	b29b      	uxth	r3, r3
 801e75a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 801e75e:	45c1      	cmp	r9, r8
 801e760:	f841 3b04 	str.w	r3, [r1], #4
 801e764:	ea4f 4022 	mov.w	r0, r2, asr #16
 801e768:	d2e9      	bcs.n	801e73e <quorem+0xac>
 801e76a:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 801e76e:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 801e772:	b922      	cbnz	r2, 801e77e <quorem+0xec>
 801e774:	3b04      	subs	r3, #4
 801e776:	429d      	cmp	r5, r3
 801e778:	461a      	mov	r2, r3
 801e77a:	d30a      	bcc.n	801e792 <quorem+0x100>
 801e77c:	613c      	str	r4, [r7, #16]
 801e77e:	4630      	mov	r0, r6
 801e780:	b003      	add	sp, #12
 801e782:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801e786:	6812      	ldr	r2, [r2, #0]
 801e788:	3b04      	subs	r3, #4
 801e78a:	2a00      	cmp	r2, #0
 801e78c:	d1ce      	bne.n	801e72c <quorem+0x9a>
 801e78e:	3c01      	subs	r4, #1
 801e790:	e7c9      	b.n	801e726 <quorem+0x94>
 801e792:	6812      	ldr	r2, [r2, #0]
 801e794:	3b04      	subs	r3, #4
 801e796:	2a00      	cmp	r2, #0
 801e798:	d1f0      	bne.n	801e77c <quorem+0xea>
 801e79a:	3c01      	subs	r4, #1
 801e79c:	e7eb      	b.n	801e776 <quorem+0xe4>
 801e79e:	2000      	movs	r0, #0
 801e7a0:	e7ee      	b.n	801e780 <quorem+0xee>
 801e7a2:	0000      	movs	r0, r0
 801e7a4:	0000      	movs	r0, r0
	...

0801e7a8 <_dtoa_r>:
 801e7a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e7ac:	ed2d 8b04 	vpush	{d8-d9}
 801e7b0:	69c5      	ldr	r5, [r0, #28]
 801e7b2:	b093      	sub	sp, #76	; 0x4c
 801e7b4:	ed8d 0b02 	vstr	d0, [sp, #8]
 801e7b8:	ec57 6b10 	vmov	r6, r7, d0
 801e7bc:	f8dd 8080 	ldr.w	r8, [sp, #128]	; 0x80
 801e7c0:	9107      	str	r1, [sp, #28]
 801e7c2:	4604      	mov	r4, r0
 801e7c4:	920a      	str	r2, [sp, #40]	; 0x28
 801e7c6:	930d      	str	r3, [sp, #52]	; 0x34
 801e7c8:	b975      	cbnz	r5, 801e7e8 <_dtoa_r+0x40>
 801e7ca:	2010      	movs	r0, #16
 801e7cc:	f000 fe2a 	bl	801f424 <malloc>
 801e7d0:	4602      	mov	r2, r0
 801e7d2:	61e0      	str	r0, [r4, #28]
 801e7d4:	b920      	cbnz	r0, 801e7e0 <_dtoa_r+0x38>
 801e7d6:	4bae      	ldr	r3, [pc, #696]	; (801ea90 <_dtoa_r+0x2e8>)
 801e7d8:	21ef      	movs	r1, #239	; 0xef
 801e7da:	48ae      	ldr	r0, [pc, #696]	; (801ea94 <_dtoa_r+0x2ec>)
 801e7dc:	f7ff f91c 	bl	801da18 <__assert_func>
 801e7e0:	e9c0 5501 	strd	r5, r5, [r0, #4]
 801e7e4:	6005      	str	r5, [r0, #0]
 801e7e6:	60c5      	str	r5, [r0, #12]
 801e7e8:	69e3      	ldr	r3, [r4, #28]
 801e7ea:	6819      	ldr	r1, [r3, #0]
 801e7ec:	b151      	cbz	r1, 801e804 <_dtoa_r+0x5c>
 801e7ee:	685a      	ldr	r2, [r3, #4]
 801e7f0:	604a      	str	r2, [r1, #4]
 801e7f2:	2301      	movs	r3, #1
 801e7f4:	4093      	lsls	r3, r2
 801e7f6:	608b      	str	r3, [r1, #8]
 801e7f8:	4620      	mov	r0, r4
 801e7fa:	f000 ff07 	bl	801f60c <_Bfree>
 801e7fe:	69e3      	ldr	r3, [r4, #28]
 801e800:	2200      	movs	r2, #0
 801e802:	601a      	str	r2, [r3, #0]
 801e804:	1e3b      	subs	r3, r7, #0
 801e806:	bfbb      	ittet	lt
 801e808:	f023 4300 	biclt.w	r3, r3, #2147483648	; 0x80000000
 801e80c:	9303      	strlt	r3, [sp, #12]
 801e80e:	2300      	movge	r3, #0
 801e810:	2201      	movlt	r2, #1
 801e812:	bfac      	ite	ge
 801e814:	f8c8 3000 	strge.w	r3, [r8]
 801e818:	f8c8 2000 	strlt.w	r2, [r8]
 801e81c:	4b9e      	ldr	r3, [pc, #632]	; (801ea98 <_dtoa_r+0x2f0>)
 801e81e:	f8dd 800c 	ldr.w	r8, [sp, #12]
 801e822:	ea33 0308 	bics.w	r3, r3, r8
 801e826:	d11b      	bne.n	801e860 <_dtoa_r+0xb8>
 801e828:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801e82a:	f242 730f 	movw	r3, #9999	; 0x270f
 801e82e:	6013      	str	r3, [r2, #0]
 801e830:	f3c8 0313 	ubfx	r3, r8, #0, #20
 801e834:	4333      	orrs	r3, r6
 801e836:	f000 8593 	beq.w	801f360 <_dtoa_r+0xbb8>
 801e83a:	9b21      	ldr	r3, [sp, #132]	; 0x84
 801e83c:	b963      	cbnz	r3, 801e858 <_dtoa_r+0xb0>
 801e83e:	4b97      	ldr	r3, [pc, #604]	; (801ea9c <_dtoa_r+0x2f4>)
 801e840:	e027      	b.n	801e892 <_dtoa_r+0xea>
 801e842:	4b97      	ldr	r3, [pc, #604]	; (801eaa0 <_dtoa_r+0x2f8>)
 801e844:	9300      	str	r3, [sp, #0]
 801e846:	3308      	adds	r3, #8
 801e848:	9a21      	ldr	r2, [sp, #132]	; 0x84
 801e84a:	6013      	str	r3, [r2, #0]
 801e84c:	9800      	ldr	r0, [sp, #0]
 801e84e:	b013      	add	sp, #76	; 0x4c
 801e850:	ecbd 8b04 	vpop	{d8-d9}
 801e854:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801e858:	4b90      	ldr	r3, [pc, #576]	; (801ea9c <_dtoa_r+0x2f4>)
 801e85a:	9300      	str	r3, [sp, #0]
 801e85c:	3303      	adds	r3, #3
 801e85e:	e7f3      	b.n	801e848 <_dtoa_r+0xa0>
 801e860:	ed9d 7b02 	vldr	d7, [sp, #8]
 801e864:	2200      	movs	r2, #0
 801e866:	ec51 0b17 	vmov	r0, r1, d7
 801e86a:	eeb0 8a47 	vmov.f32	s16, s14
 801e86e:	eef0 8a67 	vmov.f32	s17, s15
 801e872:	2300      	movs	r3, #0
 801e874:	f7e2 f950 	bl	8000b18 <__aeabi_dcmpeq>
 801e878:	4681      	mov	r9, r0
 801e87a:	b160      	cbz	r0, 801e896 <_dtoa_r+0xee>
 801e87c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801e87e:	2301      	movs	r3, #1
 801e880:	6013      	str	r3, [r2, #0]
 801e882:	9b21      	ldr	r3, [sp, #132]	; 0x84
 801e884:	2b00      	cmp	r3, #0
 801e886:	f000 8568 	beq.w	801f35a <_dtoa_r+0xbb2>
 801e88a:	4b86      	ldr	r3, [pc, #536]	; (801eaa4 <_dtoa_r+0x2fc>)
 801e88c:	9a21      	ldr	r2, [sp, #132]	; 0x84
 801e88e:	6013      	str	r3, [r2, #0]
 801e890:	3b01      	subs	r3, #1
 801e892:	9300      	str	r3, [sp, #0]
 801e894:	e7da      	b.n	801e84c <_dtoa_r+0xa4>
 801e896:	aa10      	add	r2, sp, #64	; 0x40
 801e898:	a911      	add	r1, sp, #68	; 0x44
 801e89a:	4620      	mov	r0, r4
 801e89c:	eeb0 0a48 	vmov.f32	s0, s16
 801e8a0:	eef0 0a68 	vmov.f32	s1, s17
 801e8a4:	f001 f994 	bl	801fbd0 <__d2b>
 801e8a8:	f3c8 550a 	ubfx	r5, r8, #20, #11
 801e8ac:	4682      	mov	sl, r0
 801e8ae:	2d00      	cmp	r5, #0
 801e8b0:	d07f      	beq.n	801e9b2 <_dtoa_r+0x20a>
 801e8b2:	ee18 3a90 	vmov	r3, s17
 801e8b6:	f3c3 0313 	ubfx	r3, r3, #0, #20
 801e8ba:	f043 537f 	orr.w	r3, r3, #1069547520	; 0x3fc00000
 801e8be:	ec51 0b18 	vmov	r0, r1, d8
 801e8c2:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
 801e8c6:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
 801e8ca:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
 801e8ce:	4619      	mov	r1, r3
 801e8d0:	2200      	movs	r2, #0
 801e8d2:	4b75      	ldr	r3, [pc, #468]	; (801eaa8 <_dtoa_r+0x300>)
 801e8d4:	f7e1 fd00 	bl	80002d8 <__aeabi_dsub>
 801e8d8:	a367      	add	r3, pc, #412	; (adr r3, 801ea78 <_dtoa_r+0x2d0>)
 801e8da:	e9d3 2300 	ldrd	r2, r3, [r3]
 801e8de:	f7e1 feb3 	bl	8000648 <__aeabi_dmul>
 801e8e2:	a367      	add	r3, pc, #412	; (adr r3, 801ea80 <_dtoa_r+0x2d8>)
 801e8e4:	e9d3 2300 	ldrd	r2, r3, [r3]
 801e8e8:	f7e1 fcf8 	bl	80002dc <__adddf3>
 801e8ec:	4606      	mov	r6, r0
 801e8ee:	4628      	mov	r0, r5
 801e8f0:	460f      	mov	r7, r1
 801e8f2:	f7e1 fe3f 	bl	8000574 <__aeabi_i2d>
 801e8f6:	a364      	add	r3, pc, #400	; (adr r3, 801ea88 <_dtoa_r+0x2e0>)
 801e8f8:	e9d3 2300 	ldrd	r2, r3, [r3]
 801e8fc:	f7e1 fea4 	bl	8000648 <__aeabi_dmul>
 801e900:	4602      	mov	r2, r0
 801e902:	460b      	mov	r3, r1
 801e904:	4630      	mov	r0, r6
 801e906:	4639      	mov	r1, r7
 801e908:	f7e1 fce8 	bl	80002dc <__adddf3>
 801e90c:	4606      	mov	r6, r0
 801e90e:	460f      	mov	r7, r1
 801e910:	f7e2 f94a 	bl	8000ba8 <__aeabi_d2iz>
 801e914:	2200      	movs	r2, #0
 801e916:	4683      	mov	fp, r0
 801e918:	2300      	movs	r3, #0
 801e91a:	4630      	mov	r0, r6
 801e91c:	4639      	mov	r1, r7
 801e91e:	f7e2 f905 	bl	8000b2c <__aeabi_dcmplt>
 801e922:	b148      	cbz	r0, 801e938 <_dtoa_r+0x190>
 801e924:	4658      	mov	r0, fp
 801e926:	f7e1 fe25 	bl	8000574 <__aeabi_i2d>
 801e92a:	4632      	mov	r2, r6
 801e92c:	463b      	mov	r3, r7
 801e92e:	f7e2 f8f3 	bl	8000b18 <__aeabi_dcmpeq>
 801e932:	b908      	cbnz	r0, 801e938 <_dtoa_r+0x190>
 801e934:	f10b 3bff 	add.w	fp, fp, #4294967295
 801e938:	f1bb 0f16 	cmp.w	fp, #22
 801e93c:	d857      	bhi.n	801e9ee <_dtoa_r+0x246>
 801e93e:	4b5b      	ldr	r3, [pc, #364]	; (801eaac <_dtoa_r+0x304>)
 801e940:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 801e944:	e9d3 2300 	ldrd	r2, r3, [r3]
 801e948:	ec51 0b18 	vmov	r0, r1, d8
 801e94c:	f7e2 f8ee 	bl	8000b2c <__aeabi_dcmplt>
 801e950:	2800      	cmp	r0, #0
 801e952:	d04e      	beq.n	801e9f2 <_dtoa_r+0x24a>
 801e954:	f10b 3bff 	add.w	fp, fp, #4294967295
 801e958:	2300      	movs	r3, #0
 801e95a:	930c      	str	r3, [sp, #48]	; 0x30
 801e95c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801e95e:	1b5b      	subs	r3, r3, r5
 801e960:	1e5a      	subs	r2, r3, #1
 801e962:	bf45      	ittet	mi
 801e964:	f1c3 0301 	rsbmi	r3, r3, #1
 801e968:	9305      	strmi	r3, [sp, #20]
 801e96a:	2300      	movpl	r3, #0
 801e96c:	2300      	movmi	r3, #0
 801e96e:	9206      	str	r2, [sp, #24]
 801e970:	bf54      	ite	pl
 801e972:	9305      	strpl	r3, [sp, #20]
 801e974:	9306      	strmi	r3, [sp, #24]
 801e976:	f1bb 0f00 	cmp.w	fp, #0
 801e97a:	db3c      	blt.n	801e9f6 <_dtoa_r+0x24e>
 801e97c:	9b06      	ldr	r3, [sp, #24]
 801e97e:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
 801e982:	445b      	add	r3, fp
 801e984:	9306      	str	r3, [sp, #24]
 801e986:	2300      	movs	r3, #0
 801e988:	9308      	str	r3, [sp, #32]
 801e98a:	9b07      	ldr	r3, [sp, #28]
 801e98c:	2b09      	cmp	r3, #9
 801e98e:	d868      	bhi.n	801ea62 <_dtoa_r+0x2ba>
 801e990:	2b05      	cmp	r3, #5
 801e992:	bfc4      	itt	gt
 801e994:	3b04      	subgt	r3, #4
 801e996:	9307      	strgt	r3, [sp, #28]
 801e998:	9b07      	ldr	r3, [sp, #28]
 801e99a:	f1a3 0302 	sub.w	r3, r3, #2
 801e99e:	bfcc      	ite	gt
 801e9a0:	2500      	movgt	r5, #0
 801e9a2:	2501      	movle	r5, #1
 801e9a4:	2b03      	cmp	r3, #3
 801e9a6:	f200 8085 	bhi.w	801eab4 <_dtoa_r+0x30c>
 801e9aa:	e8df f003 	tbb	[pc, r3]
 801e9ae:	3b2e      	.short	0x3b2e
 801e9b0:	5839      	.short	0x5839
 801e9b2:	e9dd 5310 	ldrd	r5, r3, [sp, #64]	; 0x40
 801e9b6:	441d      	add	r5, r3
 801e9b8:	f205 4332 	addw	r3, r5, #1074	; 0x432
 801e9bc:	2b20      	cmp	r3, #32
 801e9be:	bfc1      	itttt	gt
 801e9c0:	f1c3 0340 	rsbgt	r3, r3, #64	; 0x40
 801e9c4:	fa08 f803 	lslgt.w	r8, r8, r3
 801e9c8:	f205 4312 	addwgt	r3, r5, #1042	; 0x412
 801e9cc:	fa26 f303 	lsrgt.w	r3, r6, r3
 801e9d0:	bfd6      	itet	le
 801e9d2:	f1c3 0320 	rsble	r3, r3, #32
 801e9d6:	ea48 0003 	orrgt.w	r0, r8, r3
 801e9da:	fa06 f003 	lslle.w	r0, r6, r3
 801e9de:	f7e1 fdb9 	bl	8000554 <__aeabi_ui2d>
 801e9e2:	2201      	movs	r2, #1
 801e9e4:	f1a1 73f8 	sub.w	r3, r1, #32505856	; 0x1f00000
 801e9e8:	3d01      	subs	r5, #1
 801e9ea:	920e      	str	r2, [sp, #56]	; 0x38
 801e9ec:	e76f      	b.n	801e8ce <_dtoa_r+0x126>
 801e9ee:	2301      	movs	r3, #1
 801e9f0:	e7b3      	b.n	801e95a <_dtoa_r+0x1b2>
 801e9f2:	900c      	str	r0, [sp, #48]	; 0x30
 801e9f4:	e7b2      	b.n	801e95c <_dtoa_r+0x1b4>
 801e9f6:	9b05      	ldr	r3, [sp, #20]
 801e9f8:	eba3 030b 	sub.w	r3, r3, fp
 801e9fc:	9305      	str	r3, [sp, #20]
 801e9fe:	f1cb 0300 	rsb	r3, fp, #0
 801ea02:	9308      	str	r3, [sp, #32]
 801ea04:	2300      	movs	r3, #0
 801ea06:	930b      	str	r3, [sp, #44]	; 0x2c
 801ea08:	e7bf      	b.n	801e98a <_dtoa_r+0x1e2>
 801ea0a:	2300      	movs	r3, #0
 801ea0c:	9309      	str	r3, [sp, #36]	; 0x24
 801ea0e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801ea10:	2b00      	cmp	r3, #0
 801ea12:	dc52      	bgt.n	801eaba <_dtoa_r+0x312>
 801ea14:	2301      	movs	r3, #1
 801ea16:	9301      	str	r3, [sp, #4]
 801ea18:	9304      	str	r3, [sp, #16]
 801ea1a:	461a      	mov	r2, r3
 801ea1c:	920a      	str	r2, [sp, #40]	; 0x28
 801ea1e:	e00b      	b.n	801ea38 <_dtoa_r+0x290>
 801ea20:	2301      	movs	r3, #1
 801ea22:	e7f3      	b.n	801ea0c <_dtoa_r+0x264>
 801ea24:	2300      	movs	r3, #0
 801ea26:	9309      	str	r3, [sp, #36]	; 0x24
 801ea28:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801ea2a:	445b      	add	r3, fp
 801ea2c:	9301      	str	r3, [sp, #4]
 801ea2e:	3301      	adds	r3, #1
 801ea30:	2b01      	cmp	r3, #1
 801ea32:	9304      	str	r3, [sp, #16]
 801ea34:	bfb8      	it	lt
 801ea36:	2301      	movlt	r3, #1
 801ea38:	69e0      	ldr	r0, [r4, #28]
 801ea3a:	2100      	movs	r1, #0
 801ea3c:	2204      	movs	r2, #4
 801ea3e:	f102 0614 	add.w	r6, r2, #20
 801ea42:	429e      	cmp	r6, r3
 801ea44:	d93d      	bls.n	801eac2 <_dtoa_r+0x31a>
 801ea46:	6041      	str	r1, [r0, #4]
 801ea48:	4620      	mov	r0, r4
 801ea4a:	f000 fd9f 	bl	801f58c <_Balloc>
 801ea4e:	9000      	str	r0, [sp, #0]
 801ea50:	2800      	cmp	r0, #0
 801ea52:	d139      	bne.n	801eac8 <_dtoa_r+0x320>
 801ea54:	4b16      	ldr	r3, [pc, #88]	; (801eab0 <_dtoa_r+0x308>)
 801ea56:	4602      	mov	r2, r0
 801ea58:	f240 11af 	movw	r1, #431	; 0x1af
 801ea5c:	e6bd      	b.n	801e7da <_dtoa_r+0x32>
 801ea5e:	2301      	movs	r3, #1
 801ea60:	e7e1      	b.n	801ea26 <_dtoa_r+0x27e>
 801ea62:	2501      	movs	r5, #1
 801ea64:	2300      	movs	r3, #0
 801ea66:	9307      	str	r3, [sp, #28]
 801ea68:	9509      	str	r5, [sp, #36]	; 0x24
 801ea6a:	f04f 33ff 	mov.w	r3, #4294967295
 801ea6e:	9301      	str	r3, [sp, #4]
 801ea70:	9304      	str	r3, [sp, #16]
 801ea72:	2200      	movs	r2, #0
 801ea74:	2312      	movs	r3, #18
 801ea76:	e7d1      	b.n	801ea1c <_dtoa_r+0x274>
 801ea78:	636f4361 	.word	0x636f4361
 801ea7c:	3fd287a7 	.word	0x3fd287a7
 801ea80:	8b60c8b3 	.word	0x8b60c8b3
 801ea84:	3fc68a28 	.word	0x3fc68a28
 801ea88:	509f79fb 	.word	0x509f79fb
 801ea8c:	3fd34413 	.word	0x3fd34413
 801ea90:	08023908 	.word	0x08023908
 801ea94:	0802391f 	.word	0x0802391f
 801ea98:	7ff00000 	.word	0x7ff00000
 801ea9c:	08023904 	.word	0x08023904
 801eaa0:	080238fb 	.word	0x080238fb
 801eaa4:	080238d8 	.word	0x080238d8
 801eaa8:	3ff80000 	.word	0x3ff80000
 801eaac:	08023a10 	.word	0x08023a10
 801eab0:	08023977 	.word	0x08023977
 801eab4:	2301      	movs	r3, #1
 801eab6:	9309      	str	r3, [sp, #36]	; 0x24
 801eab8:	e7d7      	b.n	801ea6a <_dtoa_r+0x2c2>
 801eaba:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801eabc:	9301      	str	r3, [sp, #4]
 801eabe:	9304      	str	r3, [sp, #16]
 801eac0:	e7ba      	b.n	801ea38 <_dtoa_r+0x290>
 801eac2:	3101      	adds	r1, #1
 801eac4:	0052      	lsls	r2, r2, #1
 801eac6:	e7ba      	b.n	801ea3e <_dtoa_r+0x296>
 801eac8:	69e3      	ldr	r3, [r4, #28]
 801eaca:	9a00      	ldr	r2, [sp, #0]
 801eacc:	601a      	str	r2, [r3, #0]
 801eace:	9b04      	ldr	r3, [sp, #16]
 801ead0:	2b0e      	cmp	r3, #14
 801ead2:	f200 80a8 	bhi.w	801ec26 <_dtoa_r+0x47e>
 801ead6:	2d00      	cmp	r5, #0
 801ead8:	f000 80a5 	beq.w	801ec26 <_dtoa_r+0x47e>
 801eadc:	f1bb 0f00 	cmp.w	fp, #0
 801eae0:	dd38      	ble.n	801eb54 <_dtoa_r+0x3ac>
 801eae2:	4bc0      	ldr	r3, [pc, #768]	; (801ede4 <_dtoa_r+0x63c>)
 801eae4:	f00b 020f 	and.w	r2, fp, #15
 801eae8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801eaec:	f41b 7f80 	tst.w	fp, #256	; 0x100
 801eaf0:	e9d3 6700 	ldrd	r6, r7, [r3]
 801eaf4:	ea4f 182b 	mov.w	r8, fp, asr #4
 801eaf8:	d019      	beq.n	801eb2e <_dtoa_r+0x386>
 801eafa:	4bbb      	ldr	r3, [pc, #748]	; (801ede8 <_dtoa_r+0x640>)
 801eafc:	ec51 0b18 	vmov	r0, r1, d8
 801eb00:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 801eb04:	f7e1 feca 	bl	800089c <__aeabi_ddiv>
 801eb08:	e9cd 0102 	strd	r0, r1, [sp, #8]
 801eb0c:	f008 080f 	and.w	r8, r8, #15
 801eb10:	2503      	movs	r5, #3
 801eb12:	f8df 92d4 	ldr.w	r9, [pc, #724]	; 801ede8 <_dtoa_r+0x640>
 801eb16:	f1b8 0f00 	cmp.w	r8, #0
 801eb1a:	d10a      	bne.n	801eb32 <_dtoa_r+0x38a>
 801eb1c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 801eb20:	4632      	mov	r2, r6
 801eb22:	463b      	mov	r3, r7
 801eb24:	f7e1 feba 	bl	800089c <__aeabi_ddiv>
 801eb28:	e9cd 0102 	strd	r0, r1, [sp, #8]
 801eb2c:	e02b      	b.n	801eb86 <_dtoa_r+0x3de>
 801eb2e:	2502      	movs	r5, #2
 801eb30:	e7ef      	b.n	801eb12 <_dtoa_r+0x36a>
 801eb32:	f018 0f01 	tst.w	r8, #1
 801eb36:	d008      	beq.n	801eb4a <_dtoa_r+0x3a2>
 801eb38:	4630      	mov	r0, r6
 801eb3a:	4639      	mov	r1, r7
 801eb3c:	e9d9 2300 	ldrd	r2, r3, [r9]
 801eb40:	f7e1 fd82 	bl	8000648 <__aeabi_dmul>
 801eb44:	3501      	adds	r5, #1
 801eb46:	4606      	mov	r6, r0
 801eb48:	460f      	mov	r7, r1
 801eb4a:	ea4f 0868 	mov.w	r8, r8, asr #1
 801eb4e:	f109 0908 	add.w	r9, r9, #8
 801eb52:	e7e0      	b.n	801eb16 <_dtoa_r+0x36e>
 801eb54:	f000 809f 	beq.w	801ec96 <_dtoa_r+0x4ee>
 801eb58:	f1cb 0600 	rsb	r6, fp, #0
 801eb5c:	4ba1      	ldr	r3, [pc, #644]	; (801ede4 <_dtoa_r+0x63c>)
 801eb5e:	4fa2      	ldr	r7, [pc, #648]	; (801ede8 <_dtoa_r+0x640>)
 801eb60:	f006 020f 	and.w	r2, r6, #15
 801eb64:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801eb68:	e9d3 2300 	ldrd	r2, r3, [r3]
 801eb6c:	ec51 0b18 	vmov	r0, r1, d8
 801eb70:	f7e1 fd6a 	bl	8000648 <__aeabi_dmul>
 801eb74:	e9cd 0102 	strd	r0, r1, [sp, #8]
 801eb78:	1136      	asrs	r6, r6, #4
 801eb7a:	2300      	movs	r3, #0
 801eb7c:	2502      	movs	r5, #2
 801eb7e:	2e00      	cmp	r6, #0
 801eb80:	d17e      	bne.n	801ec80 <_dtoa_r+0x4d8>
 801eb82:	2b00      	cmp	r3, #0
 801eb84:	d1d0      	bne.n	801eb28 <_dtoa_r+0x380>
 801eb86:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801eb88:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
 801eb8c:	2b00      	cmp	r3, #0
 801eb8e:	f000 8084 	beq.w	801ec9a <_dtoa_r+0x4f2>
 801eb92:	4b96      	ldr	r3, [pc, #600]	; (801edec <_dtoa_r+0x644>)
 801eb94:	2200      	movs	r2, #0
 801eb96:	4640      	mov	r0, r8
 801eb98:	4649      	mov	r1, r9
 801eb9a:	f7e1 ffc7 	bl	8000b2c <__aeabi_dcmplt>
 801eb9e:	2800      	cmp	r0, #0
 801eba0:	d07b      	beq.n	801ec9a <_dtoa_r+0x4f2>
 801eba2:	9b04      	ldr	r3, [sp, #16]
 801eba4:	2b00      	cmp	r3, #0
 801eba6:	d078      	beq.n	801ec9a <_dtoa_r+0x4f2>
 801eba8:	9b01      	ldr	r3, [sp, #4]
 801ebaa:	2b00      	cmp	r3, #0
 801ebac:	dd39      	ble.n	801ec22 <_dtoa_r+0x47a>
 801ebae:	4b90      	ldr	r3, [pc, #576]	; (801edf0 <_dtoa_r+0x648>)
 801ebb0:	2200      	movs	r2, #0
 801ebb2:	4640      	mov	r0, r8
 801ebb4:	4649      	mov	r1, r9
 801ebb6:	f7e1 fd47 	bl	8000648 <__aeabi_dmul>
 801ebba:	e9cd 0102 	strd	r0, r1, [sp, #8]
 801ebbe:	9e01      	ldr	r6, [sp, #4]
 801ebc0:	f10b 37ff 	add.w	r7, fp, #4294967295
 801ebc4:	3501      	adds	r5, #1
 801ebc6:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
 801ebca:	4628      	mov	r0, r5
 801ebcc:	f7e1 fcd2 	bl	8000574 <__aeabi_i2d>
 801ebd0:	4642      	mov	r2, r8
 801ebd2:	464b      	mov	r3, r9
 801ebd4:	f7e1 fd38 	bl	8000648 <__aeabi_dmul>
 801ebd8:	4b86      	ldr	r3, [pc, #536]	; (801edf4 <_dtoa_r+0x64c>)
 801ebda:	2200      	movs	r2, #0
 801ebdc:	f7e1 fb7e 	bl	80002dc <__adddf3>
 801ebe0:	f1a1 7350 	sub.w	r3, r1, #54525952	; 0x3400000
 801ebe4:	e9cd 0102 	strd	r0, r1, [sp, #8]
 801ebe8:	9303      	str	r3, [sp, #12]
 801ebea:	2e00      	cmp	r6, #0
 801ebec:	d158      	bne.n	801eca0 <_dtoa_r+0x4f8>
 801ebee:	4b82      	ldr	r3, [pc, #520]	; (801edf8 <_dtoa_r+0x650>)
 801ebf0:	2200      	movs	r2, #0
 801ebf2:	4640      	mov	r0, r8
 801ebf4:	4649      	mov	r1, r9
 801ebf6:	f7e1 fb6f 	bl	80002d8 <__aeabi_dsub>
 801ebfa:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 801ebfe:	4680      	mov	r8, r0
 801ec00:	4689      	mov	r9, r1
 801ec02:	f7e1 ffb1 	bl	8000b68 <__aeabi_dcmpgt>
 801ec06:	2800      	cmp	r0, #0
 801ec08:	f040 8296 	bne.w	801f138 <_dtoa_r+0x990>
 801ec0c:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
 801ec10:	4640      	mov	r0, r8
 801ec12:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 801ec16:	4649      	mov	r1, r9
 801ec18:	f7e1 ff88 	bl	8000b2c <__aeabi_dcmplt>
 801ec1c:	2800      	cmp	r0, #0
 801ec1e:	f040 8289 	bne.w	801f134 <_dtoa_r+0x98c>
 801ec22:	ed8d 8b02 	vstr	d8, [sp, #8]
 801ec26:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801ec28:	2b00      	cmp	r3, #0
 801ec2a:	f2c0 814e 	blt.w	801eeca <_dtoa_r+0x722>
 801ec2e:	f1bb 0f0e 	cmp.w	fp, #14
 801ec32:	f300 814a 	bgt.w	801eeca <_dtoa_r+0x722>
 801ec36:	4b6b      	ldr	r3, [pc, #428]	; (801ede4 <_dtoa_r+0x63c>)
 801ec38:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 801ec3c:	e9d3 8900 	ldrd	r8, r9, [r3]
 801ec40:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801ec42:	2b00      	cmp	r3, #0
 801ec44:	f280 80dc 	bge.w	801ee00 <_dtoa_r+0x658>
 801ec48:	9b04      	ldr	r3, [sp, #16]
 801ec4a:	2b00      	cmp	r3, #0
 801ec4c:	f300 80d8 	bgt.w	801ee00 <_dtoa_r+0x658>
 801ec50:	f040 826f 	bne.w	801f132 <_dtoa_r+0x98a>
 801ec54:	4b68      	ldr	r3, [pc, #416]	; (801edf8 <_dtoa_r+0x650>)
 801ec56:	2200      	movs	r2, #0
 801ec58:	4640      	mov	r0, r8
 801ec5a:	4649      	mov	r1, r9
 801ec5c:	f7e1 fcf4 	bl	8000648 <__aeabi_dmul>
 801ec60:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 801ec64:	f7e1 ff76 	bl	8000b54 <__aeabi_dcmpge>
 801ec68:	9e04      	ldr	r6, [sp, #16]
 801ec6a:	4637      	mov	r7, r6
 801ec6c:	2800      	cmp	r0, #0
 801ec6e:	f040 8245 	bne.w	801f0fc <_dtoa_r+0x954>
 801ec72:	9d00      	ldr	r5, [sp, #0]
 801ec74:	2331      	movs	r3, #49	; 0x31
 801ec76:	f805 3b01 	strb.w	r3, [r5], #1
 801ec7a:	f10b 0b01 	add.w	fp, fp, #1
 801ec7e:	e241      	b.n	801f104 <_dtoa_r+0x95c>
 801ec80:	07f2      	lsls	r2, r6, #31
 801ec82:	d505      	bpl.n	801ec90 <_dtoa_r+0x4e8>
 801ec84:	e9d7 2300 	ldrd	r2, r3, [r7]
 801ec88:	f7e1 fcde 	bl	8000648 <__aeabi_dmul>
 801ec8c:	3501      	adds	r5, #1
 801ec8e:	2301      	movs	r3, #1
 801ec90:	1076      	asrs	r6, r6, #1
 801ec92:	3708      	adds	r7, #8
 801ec94:	e773      	b.n	801eb7e <_dtoa_r+0x3d6>
 801ec96:	2502      	movs	r5, #2
 801ec98:	e775      	b.n	801eb86 <_dtoa_r+0x3de>
 801ec9a:	9e04      	ldr	r6, [sp, #16]
 801ec9c:	465f      	mov	r7, fp
 801ec9e:	e792      	b.n	801ebc6 <_dtoa_r+0x41e>
 801eca0:	9900      	ldr	r1, [sp, #0]
 801eca2:	4b50      	ldr	r3, [pc, #320]	; (801ede4 <_dtoa_r+0x63c>)
 801eca4:	ed9d 7b02 	vldr	d7, [sp, #8]
 801eca8:	4431      	add	r1, r6
 801ecaa:	9102      	str	r1, [sp, #8]
 801ecac:	9909      	ldr	r1, [sp, #36]	; 0x24
 801ecae:	eeb0 9a47 	vmov.f32	s18, s14
 801ecb2:	eef0 9a67 	vmov.f32	s19, s15
 801ecb6:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
 801ecba:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 801ecbe:	2900      	cmp	r1, #0
 801ecc0:	d044      	beq.n	801ed4c <_dtoa_r+0x5a4>
 801ecc2:	494e      	ldr	r1, [pc, #312]	; (801edfc <_dtoa_r+0x654>)
 801ecc4:	2000      	movs	r0, #0
 801ecc6:	f7e1 fde9 	bl	800089c <__aeabi_ddiv>
 801ecca:	ec53 2b19 	vmov	r2, r3, d9
 801ecce:	f7e1 fb03 	bl	80002d8 <__aeabi_dsub>
 801ecd2:	9d00      	ldr	r5, [sp, #0]
 801ecd4:	ec41 0b19 	vmov	d9, r0, r1
 801ecd8:	4649      	mov	r1, r9
 801ecda:	4640      	mov	r0, r8
 801ecdc:	f7e1 ff64 	bl	8000ba8 <__aeabi_d2iz>
 801ece0:	4606      	mov	r6, r0
 801ece2:	f7e1 fc47 	bl	8000574 <__aeabi_i2d>
 801ece6:	4602      	mov	r2, r0
 801ece8:	460b      	mov	r3, r1
 801ecea:	4640      	mov	r0, r8
 801ecec:	4649      	mov	r1, r9
 801ecee:	f7e1 faf3 	bl	80002d8 <__aeabi_dsub>
 801ecf2:	3630      	adds	r6, #48	; 0x30
 801ecf4:	f805 6b01 	strb.w	r6, [r5], #1
 801ecf8:	ec53 2b19 	vmov	r2, r3, d9
 801ecfc:	4680      	mov	r8, r0
 801ecfe:	4689      	mov	r9, r1
 801ed00:	f7e1 ff14 	bl	8000b2c <__aeabi_dcmplt>
 801ed04:	2800      	cmp	r0, #0
 801ed06:	d164      	bne.n	801edd2 <_dtoa_r+0x62a>
 801ed08:	4642      	mov	r2, r8
 801ed0a:	464b      	mov	r3, r9
 801ed0c:	4937      	ldr	r1, [pc, #220]	; (801edec <_dtoa_r+0x644>)
 801ed0e:	2000      	movs	r0, #0
 801ed10:	f7e1 fae2 	bl	80002d8 <__aeabi_dsub>
 801ed14:	ec53 2b19 	vmov	r2, r3, d9
 801ed18:	f7e1 ff08 	bl	8000b2c <__aeabi_dcmplt>
 801ed1c:	2800      	cmp	r0, #0
 801ed1e:	f040 80b6 	bne.w	801ee8e <_dtoa_r+0x6e6>
 801ed22:	9b02      	ldr	r3, [sp, #8]
 801ed24:	429d      	cmp	r5, r3
 801ed26:	f43f af7c 	beq.w	801ec22 <_dtoa_r+0x47a>
 801ed2a:	4b31      	ldr	r3, [pc, #196]	; (801edf0 <_dtoa_r+0x648>)
 801ed2c:	ec51 0b19 	vmov	r0, r1, d9
 801ed30:	2200      	movs	r2, #0
 801ed32:	f7e1 fc89 	bl	8000648 <__aeabi_dmul>
 801ed36:	4b2e      	ldr	r3, [pc, #184]	; (801edf0 <_dtoa_r+0x648>)
 801ed38:	ec41 0b19 	vmov	d9, r0, r1
 801ed3c:	2200      	movs	r2, #0
 801ed3e:	4640      	mov	r0, r8
 801ed40:	4649      	mov	r1, r9
 801ed42:	f7e1 fc81 	bl	8000648 <__aeabi_dmul>
 801ed46:	4680      	mov	r8, r0
 801ed48:	4689      	mov	r9, r1
 801ed4a:	e7c5      	b.n	801ecd8 <_dtoa_r+0x530>
 801ed4c:	ec51 0b17 	vmov	r0, r1, d7
 801ed50:	f7e1 fc7a 	bl	8000648 <__aeabi_dmul>
 801ed54:	9b02      	ldr	r3, [sp, #8]
 801ed56:	9d00      	ldr	r5, [sp, #0]
 801ed58:	930f      	str	r3, [sp, #60]	; 0x3c
 801ed5a:	ec41 0b19 	vmov	d9, r0, r1
 801ed5e:	4649      	mov	r1, r9
 801ed60:	4640      	mov	r0, r8
 801ed62:	f7e1 ff21 	bl	8000ba8 <__aeabi_d2iz>
 801ed66:	4606      	mov	r6, r0
 801ed68:	f7e1 fc04 	bl	8000574 <__aeabi_i2d>
 801ed6c:	3630      	adds	r6, #48	; 0x30
 801ed6e:	4602      	mov	r2, r0
 801ed70:	460b      	mov	r3, r1
 801ed72:	4640      	mov	r0, r8
 801ed74:	4649      	mov	r1, r9
 801ed76:	f7e1 faaf 	bl	80002d8 <__aeabi_dsub>
 801ed7a:	f805 6b01 	strb.w	r6, [r5], #1
 801ed7e:	9b02      	ldr	r3, [sp, #8]
 801ed80:	429d      	cmp	r5, r3
 801ed82:	4680      	mov	r8, r0
 801ed84:	4689      	mov	r9, r1
 801ed86:	f04f 0200 	mov.w	r2, #0
 801ed8a:	d124      	bne.n	801edd6 <_dtoa_r+0x62e>
 801ed8c:	4b1b      	ldr	r3, [pc, #108]	; (801edfc <_dtoa_r+0x654>)
 801ed8e:	ec51 0b19 	vmov	r0, r1, d9
 801ed92:	f7e1 faa3 	bl	80002dc <__adddf3>
 801ed96:	4602      	mov	r2, r0
 801ed98:	460b      	mov	r3, r1
 801ed9a:	4640      	mov	r0, r8
 801ed9c:	4649      	mov	r1, r9
 801ed9e:	f7e1 fee3 	bl	8000b68 <__aeabi_dcmpgt>
 801eda2:	2800      	cmp	r0, #0
 801eda4:	d173      	bne.n	801ee8e <_dtoa_r+0x6e6>
 801eda6:	ec53 2b19 	vmov	r2, r3, d9
 801edaa:	4914      	ldr	r1, [pc, #80]	; (801edfc <_dtoa_r+0x654>)
 801edac:	2000      	movs	r0, #0
 801edae:	f7e1 fa93 	bl	80002d8 <__aeabi_dsub>
 801edb2:	4602      	mov	r2, r0
 801edb4:	460b      	mov	r3, r1
 801edb6:	4640      	mov	r0, r8
 801edb8:	4649      	mov	r1, r9
 801edba:	f7e1 feb7 	bl	8000b2c <__aeabi_dcmplt>
 801edbe:	2800      	cmp	r0, #0
 801edc0:	f43f af2f 	beq.w	801ec22 <_dtoa_r+0x47a>
 801edc4:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 801edc6:	1e6b      	subs	r3, r5, #1
 801edc8:	930f      	str	r3, [sp, #60]	; 0x3c
 801edca:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 801edce:	2b30      	cmp	r3, #48	; 0x30
 801edd0:	d0f8      	beq.n	801edc4 <_dtoa_r+0x61c>
 801edd2:	46bb      	mov	fp, r7
 801edd4:	e04a      	b.n	801ee6c <_dtoa_r+0x6c4>
 801edd6:	4b06      	ldr	r3, [pc, #24]	; (801edf0 <_dtoa_r+0x648>)
 801edd8:	f7e1 fc36 	bl	8000648 <__aeabi_dmul>
 801eddc:	4680      	mov	r8, r0
 801edde:	4689      	mov	r9, r1
 801ede0:	e7bd      	b.n	801ed5e <_dtoa_r+0x5b6>
 801ede2:	bf00      	nop
 801ede4:	08023a10 	.word	0x08023a10
 801ede8:	080239e8 	.word	0x080239e8
 801edec:	3ff00000 	.word	0x3ff00000
 801edf0:	40240000 	.word	0x40240000
 801edf4:	401c0000 	.word	0x401c0000
 801edf8:	40140000 	.word	0x40140000
 801edfc:	3fe00000 	.word	0x3fe00000
 801ee00:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 801ee04:	9d00      	ldr	r5, [sp, #0]
 801ee06:	4642      	mov	r2, r8
 801ee08:	464b      	mov	r3, r9
 801ee0a:	4630      	mov	r0, r6
 801ee0c:	4639      	mov	r1, r7
 801ee0e:	f7e1 fd45 	bl	800089c <__aeabi_ddiv>
 801ee12:	f7e1 fec9 	bl	8000ba8 <__aeabi_d2iz>
 801ee16:	9001      	str	r0, [sp, #4]
 801ee18:	f7e1 fbac 	bl	8000574 <__aeabi_i2d>
 801ee1c:	4642      	mov	r2, r8
 801ee1e:	464b      	mov	r3, r9
 801ee20:	f7e1 fc12 	bl	8000648 <__aeabi_dmul>
 801ee24:	4602      	mov	r2, r0
 801ee26:	460b      	mov	r3, r1
 801ee28:	4630      	mov	r0, r6
 801ee2a:	4639      	mov	r1, r7
 801ee2c:	f7e1 fa54 	bl	80002d8 <__aeabi_dsub>
 801ee30:	9e01      	ldr	r6, [sp, #4]
 801ee32:	9f04      	ldr	r7, [sp, #16]
 801ee34:	3630      	adds	r6, #48	; 0x30
 801ee36:	f805 6b01 	strb.w	r6, [r5], #1
 801ee3a:	9e00      	ldr	r6, [sp, #0]
 801ee3c:	1bae      	subs	r6, r5, r6
 801ee3e:	42b7      	cmp	r7, r6
 801ee40:	4602      	mov	r2, r0
 801ee42:	460b      	mov	r3, r1
 801ee44:	d134      	bne.n	801eeb0 <_dtoa_r+0x708>
 801ee46:	f7e1 fa49 	bl	80002dc <__adddf3>
 801ee4a:	4642      	mov	r2, r8
 801ee4c:	464b      	mov	r3, r9
 801ee4e:	4606      	mov	r6, r0
 801ee50:	460f      	mov	r7, r1
 801ee52:	f7e1 fe89 	bl	8000b68 <__aeabi_dcmpgt>
 801ee56:	b9c8      	cbnz	r0, 801ee8c <_dtoa_r+0x6e4>
 801ee58:	4642      	mov	r2, r8
 801ee5a:	464b      	mov	r3, r9
 801ee5c:	4630      	mov	r0, r6
 801ee5e:	4639      	mov	r1, r7
 801ee60:	f7e1 fe5a 	bl	8000b18 <__aeabi_dcmpeq>
 801ee64:	b110      	cbz	r0, 801ee6c <_dtoa_r+0x6c4>
 801ee66:	9b01      	ldr	r3, [sp, #4]
 801ee68:	07db      	lsls	r3, r3, #31
 801ee6a:	d40f      	bmi.n	801ee8c <_dtoa_r+0x6e4>
 801ee6c:	4651      	mov	r1, sl
 801ee6e:	4620      	mov	r0, r4
 801ee70:	f000 fbcc 	bl	801f60c <_Bfree>
 801ee74:	2300      	movs	r3, #0
 801ee76:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801ee78:	702b      	strb	r3, [r5, #0]
 801ee7a:	f10b 0301 	add.w	r3, fp, #1
 801ee7e:	6013      	str	r3, [r2, #0]
 801ee80:	9b21      	ldr	r3, [sp, #132]	; 0x84
 801ee82:	2b00      	cmp	r3, #0
 801ee84:	f43f ace2 	beq.w	801e84c <_dtoa_r+0xa4>
 801ee88:	601d      	str	r5, [r3, #0]
 801ee8a:	e4df      	b.n	801e84c <_dtoa_r+0xa4>
 801ee8c:	465f      	mov	r7, fp
 801ee8e:	462b      	mov	r3, r5
 801ee90:	461d      	mov	r5, r3
 801ee92:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 801ee96:	2a39      	cmp	r2, #57	; 0x39
 801ee98:	d106      	bne.n	801eea8 <_dtoa_r+0x700>
 801ee9a:	9a00      	ldr	r2, [sp, #0]
 801ee9c:	429a      	cmp	r2, r3
 801ee9e:	d1f7      	bne.n	801ee90 <_dtoa_r+0x6e8>
 801eea0:	9900      	ldr	r1, [sp, #0]
 801eea2:	2230      	movs	r2, #48	; 0x30
 801eea4:	3701      	adds	r7, #1
 801eea6:	700a      	strb	r2, [r1, #0]
 801eea8:	781a      	ldrb	r2, [r3, #0]
 801eeaa:	3201      	adds	r2, #1
 801eeac:	701a      	strb	r2, [r3, #0]
 801eeae:	e790      	b.n	801edd2 <_dtoa_r+0x62a>
 801eeb0:	4ba3      	ldr	r3, [pc, #652]	; (801f140 <_dtoa_r+0x998>)
 801eeb2:	2200      	movs	r2, #0
 801eeb4:	f7e1 fbc8 	bl	8000648 <__aeabi_dmul>
 801eeb8:	2200      	movs	r2, #0
 801eeba:	2300      	movs	r3, #0
 801eebc:	4606      	mov	r6, r0
 801eebe:	460f      	mov	r7, r1
 801eec0:	f7e1 fe2a 	bl	8000b18 <__aeabi_dcmpeq>
 801eec4:	2800      	cmp	r0, #0
 801eec6:	d09e      	beq.n	801ee06 <_dtoa_r+0x65e>
 801eec8:	e7d0      	b.n	801ee6c <_dtoa_r+0x6c4>
 801eeca:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801eecc:	2a00      	cmp	r2, #0
 801eece:	f000 80ca 	beq.w	801f066 <_dtoa_r+0x8be>
 801eed2:	9a07      	ldr	r2, [sp, #28]
 801eed4:	2a01      	cmp	r2, #1
 801eed6:	f300 80ad 	bgt.w	801f034 <_dtoa_r+0x88c>
 801eeda:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801eedc:	2a00      	cmp	r2, #0
 801eede:	f000 80a5 	beq.w	801f02c <_dtoa_r+0x884>
 801eee2:	f203 4333 	addw	r3, r3, #1075	; 0x433
 801eee6:	9e08      	ldr	r6, [sp, #32]
 801eee8:	9d05      	ldr	r5, [sp, #20]
 801eeea:	9a05      	ldr	r2, [sp, #20]
 801eeec:	441a      	add	r2, r3
 801eeee:	9205      	str	r2, [sp, #20]
 801eef0:	9a06      	ldr	r2, [sp, #24]
 801eef2:	2101      	movs	r1, #1
 801eef4:	441a      	add	r2, r3
 801eef6:	4620      	mov	r0, r4
 801eef8:	9206      	str	r2, [sp, #24]
 801eefa:	f000 fc3d 	bl	801f778 <__i2b>
 801eefe:	4607      	mov	r7, r0
 801ef00:	b165      	cbz	r5, 801ef1c <_dtoa_r+0x774>
 801ef02:	9b06      	ldr	r3, [sp, #24]
 801ef04:	2b00      	cmp	r3, #0
 801ef06:	dd09      	ble.n	801ef1c <_dtoa_r+0x774>
 801ef08:	42ab      	cmp	r3, r5
 801ef0a:	9a05      	ldr	r2, [sp, #20]
 801ef0c:	bfa8      	it	ge
 801ef0e:	462b      	movge	r3, r5
 801ef10:	1ad2      	subs	r2, r2, r3
 801ef12:	9205      	str	r2, [sp, #20]
 801ef14:	9a06      	ldr	r2, [sp, #24]
 801ef16:	1aed      	subs	r5, r5, r3
 801ef18:	1ad3      	subs	r3, r2, r3
 801ef1a:	9306      	str	r3, [sp, #24]
 801ef1c:	9b08      	ldr	r3, [sp, #32]
 801ef1e:	b1f3      	cbz	r3, 801ef5e <_dtoa_r+0x7b6>
 801ef20:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801ef22:	2b00      	cmp	r3, #0
 801ef24:	f000 80a3 	beq.w	801f06e <_dtoa_r+0x8c6>
 801ef28:	2e00      	cmp	r6, #0
 801ef2a:	dd10      	ble.n	801ef4e <_dtoa_r+0x7a6>
 801ef2c:	4639      	mov	r1, r7
 801ef2e:	4632      	mov	r2, r6
 801ef30:	4620      	mov	r0, r4
 801ef32:	f000 fce1 	bl	801f8f8 <__pow5mult>
 801ef36:	4652      	mov	r2, sl
 801ef38:	4601      	mov	r1, r0
 801ef3a:	4607      	mov	r7, r0
 801ef3c:	4620      	mov	r0, r4
 801ef3e:	f000 fc31 	bl	801f7a4 <__multiply>
 801ef42:	4651      	mov	r1, sl
 801ef44:	4680      	mov	r8, r0
 801ef46:	4620      	mov	r0, r4
 801ef48:	f000 fb60 	bl	801f60c <_Bfree>
 801ef4c:	46c2      	mov	sl, r8
 801ef4e:	9b08      	ldr	r3, [sp, #32]
 801ef50:	1b9a      	subs	r2, r3, r6
 801ef52:	d004      	beq.n	801ef5e <_dtoa_r+0x7b6>
 801ef54:	4651      	mov	r1, sl
 801ef56:	4620      	mov	r0, r4
 801ef58:	f000 fcce 	bl	801f8f8 <__pow5mult>
 801ef5c:	4682      	mov	sl, r0
 801ef5e:	2101      	movs	r1, #1
 801ef60:	4620      	mov	r0, r4
 801ef62:	f000 fc09 	bl	801f778 <__i2b>
 801ef66:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801ef68:	2b00      	cmp	r3, #0
 801ef6a:	4606      	mov	r6, r0
 801ef6c:	f340 8081 	ble.w	801f072 <_dtoa_r+0x8ca>
 801ef70:	461a      	mov	r2, r3
 801ef72:	4601      	mov	r1, r0
 801ef74:	4620      	mov	r0, r4
 801ef76:	f000 fcbf 	bl	801f8f8 <__pow5mult>
 801ef7a:	9b07      	ldr	r3, [sp, #28]
 801ef7c:	2b01      	cmp	r3, #1
 801ef7e:	4606      	mov	r6, r0
 801ef80:	dd7a      	ble.n	801f078 <_dtoa_r+0x8d0>
 801ef82:	f04f 0800 	mov.w	r8, #0
 801ef86:	6933      	ldr	r3, [r6, #16]
 801ef88:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 801ef8c:	6918      	ldr	r0, [r3, #16]
 801ef8e:	f000 fba5 	bl	801f6dc <__hi0bits>
 801ef92:	f1c0 0020 	rsb	r0, r0, #32
 801ef96:	9b06      	ldr	r3, [sp, #24]
 801ef98:	4418      	add	r0, r3
 801ef9a:	f010 001f 	ands.w	r0, r0, #31
 801ef9e:	f000 8094 	beq.w	801f0ca <_dtoa_r+0x922>
 801efa2:	f1c0 0320 	rsb	r3, r0, #32
 801efa6:	2b04      	cmp	r3, #4
 801efa8:	f340 8085 	ble.w	801f0b6 <_dtoa_r+0x90e>
 801efac:	9b05      	ldr	r3, [sp, #20]
 801efae:	f1c0 001c 	rsb	r0, r0, #28
 801efb2:	4403      	add	r3, r0
 801efb4:	9305      	str	r3, [sp, #20]
 801efb6:	9b06      	ldr	r3, [sp, #24]
 801efb8:	4403      	add	r3, r0
 801efba:	4405      	add	r5, r0
 801efbc:	9306      	str	r3, [sp, #24]
 801efbe:	9b05      	ldr	r3, [sp, #20]
 801efc0:	2b00      	cmp	r3, #0
 801efc2:	dd05      	ble.n	801efd0 <_dtoa_r+0x828>
 801efc4:	4651      	mov	r1, sl
 801efc6:	461a      	mov	r2, r3
 801efc8:	4620      	mov	r0, r4
 801efca:	f000 fcef 	bl	801f9ac <__lshift>
 801efce:	4682      	mov	sl, r0
 801efd0:	9b06      	ldr	r3, [sp, #24]
 801efd2:	2b00      	cmp	r3, #0
 801efd4:	dd05      	ble.n	801efe2 <_dtoa_r+0x83a>
 801efd6:	4631      	mov	r1, r6
 801efd8:	461a      	mov	r2, r3
 801efda:	4620      	mov	r0, r4
 801efdc:	f000 fce6 	bl	801f9ac <__lshift>
 801efe0:	4606      	mov	r6, r0
 801efe2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801efe4:	2b00      	cmp	r3, #0
 801efe6:	d072      	beq.n	801f0ce <_dtoa_r+0x926>
 801efe8:	4631      	mov	r1, r6
 801efea:	4650      	mov	r0, sl
 801efec:	f000 fd4a 	bl	801fa84 <__mcmp>
 801eff0:	2800      	cmp	r0, #0
 801eff2:	da6c      	bge.n	801f0ce <_dtoa_r+0x926>
 801eff4:	2300      	movs	r3, #0
 801eff6:	4651      	mov	r1, sl
 801eff8:	220a      	movs	r2, #10
 801effa:	4620      	mov	r0, r4
 801effc:	f000 fb28 	bl	801f650 <__multadd>
 801f000:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801f002:	f10b 3bff 	add.w	fp, fp, #4294967295
 801f006:	4682      	mov	sl, r0
 801f008:	2b00      	cmp	r3, #0
 801f00a:	f000 81b0 	beq.w	801f36e <_dtoa_r+0xbc6>
 801f00e:	2300      	movs	r3, #0
 801f010:	4639      	mov	r1, r7
 801f012:	220a      	movs	r2, #10
 801f014:	4620      	mov	r0, r4
 801f016:	f000 fb1b 	bl	801f650 <__multadd>
 801f01a:	9b01      	ldr	r3, [sp, #4]
 801f01c:	2b00      	cmp	r3, #0
 801f01e:	4607      	mov	r7, r0
 801f020:	f300 8096 	bgt.w	801f150 <_dtoa_r+0x9a8>
 801f024:	9b07      	ldr	r3, [sp, #28]
 801f026:	2b02      	cmp	r3, #2
 801f028:	dc59      	bgt.n	801f0de <_dtoa_r+0x936>
 801f02a:	e091      	b.n	801f150 <_dtoa_r+0x9a8>
 801f02c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801f02e:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 801f032:	e758      	b.n	801eee6 <_dtoa_r+0x73e>
 801f034:	9b04      	ldr	r3, [sp, #16]
 801f036:	1e5e      	subs	r6, r3, #1
 801f038:	9b08      	ldr	r3, [sp, #32]
 801f03a:	42b3      	cmp	r3, r6
 801f03c:	bfbf      	itttt	lt
 801f03e:	9b08      	ldrlt	r3, [sp, #32]
 801f040:	9a0b      	ldrlt	r2, [sp, #44]	; 0x2c
 801f042:	9608      	strlt	r6, [sp, #32]
 801f044:	1af3      	sublt	r3, r6, r3
 801f046:	bfb4      	ite	lt
 801f048:	18d2      	addlt	r2, r2, r3
 801f04a:	1b9e      	subge	r6, r3, r6
 801f04c:	9b04      	ldr	r3, [sp, #16]
 801f04e:	bfbc      	itt	lt
 801f050:	920b      	strlt	r2, [sp, #44]	; 0x2c
 801f052:	2600      	movlt	r6, #0
 801f054:	2b00      	cmp	r3, #0
 801f056:	bfb7      	itett	lt
 801f058:	e9dd 2304 	ldrdlt	r2, r3, [sp, #16]
 801f05c:	e9dd 3504 	ldrdge	r3, r5, [sp, #16]
 801f060:	1a9d      	sublt	r5, r3, r2
 801f062:	2300      	movlt	r3, #0
 801f064:	e741      	b.n	801eeea <_dtoa_r+0x742>
 801f066:	9e08      	ldr	r6, [sp, #32]
 801f068:	9d05      	ldr	r5, [sp, #20]
 801f06a:	9f09      	ldr	r7, [sp, #36]	; 0x24
 801f06c:	e748      	b.n	801ef00 <_dtoa_r+0x758>
 801f06e:	9a08      	ldr	r2, [sp, #32]
 801f070:	e770      	b.n	801ef54 <_dtoa_r+0x7ac>
 801f072:	9b07      	ldr	r3, [sp, #28]
 801f074:	2b01      	cmp	r3, #1
 801f076:	dc19      	bgt.n	801f0ac <_dtoa_r+0x904>
 801f078:	9b02      	ldr	r3, [sp, #8]
 801f07a:	b9bb      	cbnz	r3, 801f0ac <_dtoa_r+0x904>
 801f07c:	9b03      	ldr	r3, [sp, #12]
 801f07e:	f3c3 0313 	ubfx	r3, r3, #0, #20
 801f082:	b99b      	cbnz	r3, 801f0ac <_dtoa_r+0x904>
 801f084:	9b03      	ldr	r3, [sp, #12]
 801f086:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 801f08a:	0d1b      	lsrs	r3, r3, #20
 801f08c:	051b      	lsls	r3, r3, #20
 801f08e:	b183      	cbz	r3, 801f0b2 <_dtoa_r+0x90a>
 801f090:	9b05      	ldr	r3, [sp, #20]
 801f092:	3301      	adds	r3, #1
 801f094:	9305      	str	r3, [sp, #20]
 801f096:	9b06      	ldr	r3, [sp, #24]
 801f098:	3301      	adds	r3, #1
 801f09a:	9306      	str	r3, [sp, #24]
 801f09c:	f04f 0801 	mov.w	r8, #1
 801f0a0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801f0a2:	2b00      	cmp	r3, #0
 801f0a4:	f47f af6f 	bne.w	801ef86 <_dtoa_r+0x7de>
 801f0a8:	2001      	movs	r0, #1
 801f0aa:	e774      	b.n	801ef96 <_dtoa_r+0x7ee>
 801f0ac:	f04f 0800 	mov.w	r8, #0
 801f0b0:	e7f6      	b.n	801f0a0 <_dtoa_r+0x8f8>
 801f0b2:	4698      	mov	r8, r3
 801f0b4:	e7f4      	b.n	801f0a0 <_dtoa_r+0x8f8>
 801f0b6:	d082      	beq.n	801efbe <_dtoa_r+0x816>
 801f0b8:	9a05      	ldr	r2, [sp, #20]
 801f0ba:	331c      	adds	r3, #28
 801f0bc:	441a      	add	r2, r3
 801f0be:	9205      	str	r2, [sp, #20]
 801f0c0:	9a06      	ldr	r2, [sp, #24]
 801f0c2:	441a      	add	r2, r3
 801f0c4:	441d      	add	r5, r3
 801f0c6:	9206      	str	r2, [sp, #24]
 801f0c8:	e779      	b.n	801efbe <_dtoa_r+0x816>
 801f0ca:	4603      	mov	r3, r0
 801f0cc:	e7f4      	b.n	801f0b8 <_dtoa_r+0x910>
 801f0ce:	9b04      	ldr	r3, [sp, #16]
 801f0d0:	2b00      	cmp	r3, #0
 801f0d2:	dc37      	bgt.n	801f144 <_dtoa_r+0x99c>
 801f0d4:	9b07      	ldr	r3, [sp, #28]
 801f0d6:	2b02      	cmp	r3, #2
 801f0d8:	dd34      	ble.n	801f144 <_dtoa_r+0x99c>
 801f0da:	9b04      	ldr	r3, [sp, #16]
 801f0dc:	9301      	str	r3, [sp, #4]
 801f0de:	9b01      	ldr	r3, [sp, #4]
 801f0e0:	b963      	cbnz	r3, 801f0fc <_dtoa_r+0x954>
 801f0e2:	4631      	mov	r1, r6
 801f0e4:	2205      	movs	r2, #5
 801f0e6:	4620      	mov	r0, r4
 801f0e8:	f000 fab2 	bl	801f650 <__multadd>
 801f0ec:	4601      	mov	r1, r0
 801f0ee:	4606      	mov	r6, r0
 801f0f0:	4650      	mov	r0, sl
 801f0f2:	f000 fcc7 	bl	801fa84 <__mcmp>
 801f0f6:	2800      	cmp	r0, #0
 801f0f8:	f73f adbb 	bgt.w	801ec72 <_dtoa_r+0x4ca>
 801f0fc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801f0fe:	9d00      	ldr	r5, [sp, #0]
 801f100:	ea6f 0b03 	mvn.w	fp, r3
 801f104:	f04f 0800 	mov.w	r8, #0
 801f108:	4631      	mov	r1, r6
 801f10a:	4620      	mov	r0, r4
 801f10c:	f000 fa7e 	bl	801f60c <_Bfree>
 801f110:	2f00      	cmp	r7, #0
 801f112:	f43f aeab 	beq.w	801ee6c <_dtoa_r+0x6c4>
 801f116:	f1b8 0f00 	cmp.w	r8, #0
 801f11a:	d005      	beq.n	801f128 <_dtoa_r+0x980>
 801f11c:	45b8      	cmp	r8, r7
 801f11e:	d003      	beq.n	801f128 <_dtoa_r+0x980>
 801f120:	4641      	mov	r1, r8
 801f122:	4620      	mov	r0, r4
 801f124:	f000 fa72 	bl	801f60c <_Bfree>
 801f128:	4639      	mov	r1, r7
 801f12a:	4620      	mov	r0, r4
 801f12c:	f000 fa6e 	bl	801f60c <_Bfree>
 801f130:	e69c      	b.n	801ee6c <_dtoa_r+0x6c4>
 801f132:	2600      	movs	r6, #0
 801f134:	4637      	mov	r7, r6
 801f136:	e7e1      	b.n	801f0fc <_dtoa_r+0x954>
 801f138:	46bb      	mov	fp, r7
 801f13a:	4637      	mov	r7, r6
 801f13c:	e599      	b.n	801ec72 <_dtoa_r+0x4ca>
 801f13e:	bf00      	nop
 801f140:	40240000 	.word	0x40240000
 801f144:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801f146:	2b00      	cmp	r3, #0
 801f148:	f000 80c8 	beq.w	801f2dc <_dtoa_r+0xb34>
 801f14c:	9b04      	ldr	r3, [sp, #16]
 801f14e:	9301      	str	r3, [sp, #4]
 801f150:	2d00      	cmp	r5, #0
 801f152:	dd05      	ble.n	801f160 <_dtoa_r+0x9b8>
 801f154:	4639      	mov	r1, r7
 801f156:	462a      	mov	r2, r5
 801f158:	4620      	mov	r0, r4
 801f15a:	f000 fc27 	bl	801f9ac <__lshift>
 801f15e:	4607      	mov	r7, r0
 801f160:	f1b8 0f00 	cmp.w	r8, #0
 801f164:	d05b      	beq.n	801f21e <_dtoa_r+0xa76>
 801f166:	6879      	ldr	r1, [r7, #4]
 801f168:	4620      	mov	r0, r4
 801f16a:	f000 fa0f 	bl	801f58c <_Balloc>
 801f16e:	4605      	mov	r5, r0
 801f170:	b928      	cbnz	r0, 801f17e <_dtoa_r+0x9d6>
 801f172:	4b83      	ldr	r3, [pc, #524]	; (801f380 <_dtoa_r+0xbd8>)
 801f174:	4602      	mov	r2, r0
 801f176:	f240 21ef 	movw	r1, #751	; 0x2ef
 801f17a:	f7ff bb2e 	b.w	801e7da <_dtoa_r+0x32>
 801f17e:	693a      	ldr	r2, [r7, #16]
 801f180:	3202      	adds	r2, #2
 801f182:	0092      	lsls	r2, r2, #2
 801f184:	f107 010c 	add.w	r1, r7, #12
 801f188:	300c      	adds	r0, #12
 801f18a:	f7ff fa6d 	bl	801e668 <memcpy>
 801f18e:	2201      	movs	r2, #1
 801f190:	4629      	mov	r1, r5
 801f192:	4620      	mov	r0, r4
 801f194:	f000 fc0a 	bl	801f9ac <__lshift>
 801f198:	9b00      	ldr	r3, [sp, #0]
 801f19a:	3301      	adds	r3, #1
 801f19c:	9304      	str	r3, [sp, #16]
 801f19e:	e9dd 2300 	ldrd	r2, r3, [sp]
 801f1a2:	4413      	add	r3, r2
 801f1a4:	9308      	str	r3, [sp, #32]
 801f1a6:	9b02      	ldr	r3, [sp, #8]
 801f1a8:	f003 0301 	and.w	r3, r3, #1
 801f1ac:	46b8      	mov	r8, r7
 801f1ae:	9306      	str	r3, [sp, #24]
 801f1b0:	4607      	mov	r7, r0
 801f1b2:	9b04      	ldr	r3, [sp, #16]
 801f1b4:	4631      	mov	r1, r6
 801f1b6:	3b01      	subs	r3, #1
 801f1b8:	4650      	mov	r0, sl
 801f1ba:	9301      	str	r3, [sp, #4]
 801f1bc:	f7ff fa69 	bl	801e692 <quorem>
 801f1c0:	4641      	mov	r1, r8
 801f1c2:	9002      	str	r0, [sp, #8]
 801f1c4:	f100 0930 	add.w	r9, r0, #48	; 0x30
 801f1c8:	4650      	mov	r0, sl
 801f1ca:	f000 fc5b 	bl	801fa84 <__mcmp>
 801f1ce:	463a      	mov	r2, r7
 801f1d0:	9005      	str	r0, [sp, #20]
 801f1d2:	4631      	mov	r1, r6
 801f1d4:	4620      	mov	r0, r4
 801f1d6:	f000 fc71 	bl	801fabc <__mdiff>
 801f1da:	68c2      	ldr	r2, [r0, #12]
 801f1dc:	4605      	mov	r5, r0
 801f1de:	bb02      	cbnz	r2, 801f222 <_dtoa_r+0xa7a>
 801f1e0:	4601      	mov	r1, r0
 801f1e2:	4650      	mov	r0, sl
 801f1e4:	f000 fc4e 	bl	801fa84 <__mcmp>
 801f1e8:	4602      	mov	r2, r0
 801f1ea:	4629      	mov	r1, r5
 801f1ec:	4620      	mov	r0, r4
 801f1ee:	9209      	str	r2, [sp, #36]	; 0x24
 801f1f0:	f000 fa0c 	bl	801f60c <_Bfree>
 801f1f4:	9b07      	ldr	r3, [sp, #28]
 801f1f6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801f1f8:	9d04      	ldr	r5, [sp, #16]
 801f1fa:	ea43 0102 	orr.w	r1, r3, r2
 801f1fe:	9b06      	ldr	r3, [sp, #24]
 801f200:	4319      	orrs	r1, r3
 801f202:	d110      	bne.n	801f226 <_dtoa_r+0xa7e>
 801f204:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
 801f208:	d029      	beq.n	801f25e <_dtoa_r+0xab6>
 801f20a:	9b05      	ldr	r3, [sp, #20]
 801f20c:	2b00      	cmp	r3, #0
 801f20e:	dd02      	ble.n	801f216 <_dtoa_r+0xa6e>
 801f210:	9b02      	ldr	r3, [sp, #8]
 801f212:	f103 0931 	add.w	r9, r3, #49	; 0x31
 801f216:	9b01      	ldr	r3, [sp, #4]
 801f218:	f883 9000 	strb.w	r9, [r3]
 801f21c:	e774      	b.n	801f108 <_dtoa_r+0x960>
 801f21e:	4638      	mov	r0, r7
 801f220:	e7ba      	b.n	801f198 <_dtoa_r+0x9f0>
 801f222:	2201      	movs	r2, #1
 801f224:	e7e1      	b.n	801f1ea <_dtoa_r+0xa42>
 801f226:	9b05      	ldr	r3, [sp, #20]
 801f228:	2b00      	cmp	r3, #0
 801f22a:	db04      	blt.n	801f236 <_dtoa_r+0xa8e>
 801f22c:	9907      	ldr	r1, [sp, #28]
 801f22e:	430b      	orrs	r3, r1
 801f230:	9906      	ldr	r1, [sp, #24]
 801f232:	430b      	orrs	r3, r1
 801f234:	d120      	bne.n	801f278 <_dtoa_r+0xad0>
 801f236:	2a00      	cmp	r2, #0
 801f238:	dded      	ble.n	801f216 <_dtoa_r+0xa6e>
 801f23a:	4651      	mov	r1, sl
 801f23c:	2201      	movs	r2, #1
 801f23e:	4620      	mov	r0, r4
 801f240:	f000 fbb4 	bl	801f9ac <__lshift>
 801f244:	4631      	mov	r1, r6
 801f246:	4682      	mov	sl, r0
 801f248:	f000 fc1c 	bl	801fa84 <__mcmp>
 801f24c:	2800      	cmp	r0, #0
 801f24e:	dc03      	bgt.n	801f258 <_dtoa_r+0xab0>
 801f250:	d1e1      	bne.n	801f216 <_dtoa_r+0xa6e>
 801f252:	f019 0f01 	tst.w	r9, #1
 801f256:	d0de      	beq.n	801f216 <_dtoa_r+0xa6e>
 801f258:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
 801f25c:	d1d8      	bne.n	801f210 <_dtoa_r+0xa68>
 801f25e:	9a01      	ldr	r2, [sp, #4]
 801f260:	2339      	movs	r3, #57	; 0x39
 801f262:	7013      	strb	r3, [r2, #0]
 801f264:	462b      	mov	r3, r5
 801f266:	461d      	mov	r5, r3
 801f268:	3b01      	subs	r3, #1
 801f26a:	f815 2c01 	ldrb.w	r2, [r5, #-1]
 801f26e:	2a39      	cmp	r2, #57	; 0x39
 801f270:	d06c      	beq.n	801f34c <_dtoa_r+0xba4>
 801f272:	3201      	adds	r2, #1
 801f274:	701a      	strb	r2, [r3, #0]
 801f276:	e747      	b.n	801f108 <_dtoa_r+0x960>
 801f278:	2a00      	cmp	r2, #0
 801f27a:	dd07      	ble.n	801f28c <_dtoa_r+0xae4>
 801f27c:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
 801f280:	d0ed      	beq.n	801f25e <_dtoa_r+0xab6>
 801f282:	9a01      	ldr	r2, [sp, #4]
 801f284:	f109 0301 	add.w	r3, r9, #1
 801f288:	7013      	strb	r3, [r2, #0]
 801f28a:	e73d      	b.n	801f108 <_dtoa_r+0x960>
 801f28c:	9b04      	ldr	r3, [sp, #16]
 801f28e:	9a08      	ldr	r2, [sp, #32]
 801f290:	f803 9c01 	strb.w	r9, [r3, #-1]
 801f294:	4293      	cmp	r3, r2
 801f296:	d043      	beq.n	801f320 <_dtoa_r+0xb78>
 801f298:	4651      	mov	r1, sl
 801f29a:	2300      	movs	r3, #0
 801f29c:	220a      	movs	r2, #10
 801f29e:	4620      	mov	r0, r4
 801f2a0:	f000 f9d6 	bl	801f650 <__multadd>
 801f2a4:	45b8      	cmp	r8, r7
 801f2a6:	4682      	mov	sl, r0
 801f2a8:	f04f 0300 	mov.w	r3, #0
 801f2ac:	f04f 020a 	mov.w	r2, #10
 801f2b0:	4641      	mov	r1, r8
 801f2b2:	4620      	mov	r0, r4
 801f2b4:	d107      	bne.n	801f2c6 <_dtoa_r+0xb1e>
 801f2b6:	f000 f9cb 	bl	801f650 <__multadd>
 801f2ba:	4680      	mov	r8, r0
 801f2bc:	4607      	mov	r7, r0
 801f2be:	9b04      	ldr	r3, [sp, #16]
 801f2c0:	3301      	adds	r3, #1
 801f2c2:	9304      	str	r3, [sp, #16]
 801f2c4:	e775      	b.n	801f1b2 <_dtoa_r+0xa0a>
 801f2c6:	f000 f9c3 	bl	801f650 <__multadd>
 801f2ca:	4639      	mov	r1, r7
 801f2cc:	4680      	mov	r8, r0
 801f2ce:	2300      	movs	r3, #0
 801f2d0:	220a      	movs	r2, #10
 801f2d2:	4620      	mov	r0, r4
 801f2d4:	f000 f9bc 	bl	801f650 <__multadd>
 801f2d8:	4607      	mov	r7, r0
 801f2da:	e7f0      	b.n	801f2be <_dtoa_r+0xb16>
 801f2dc:	9b04      	ldr	r3, [sp, #16]
 801f2de:	9301      	str	r3, [sp, #4]
 801f2e0:	9d00      	ldr	r5, [sp, #0]
 801f2e2:	4631      	mov	r1, r6
 801f2e4:	4650      	mov	r0, sl
 801f2e6:	f7ff f9d4 	bl	801e692 <quorem>
 801f2ea:	f100 0930 	add.w	r9, r0, #48	; 0x30
 801f2ee:	9b00      	ldr	r3, [sp, #0]
 801f2f0:	f805 9b01 	strb.w	r9, [r5], #1
 801f2f4:	1aea      	subs	r2, r5, r3
 801f2f6:	9b01      	ldr	r3, [sp, #4]
 801f2f8:	4293      	cmp	r3, r2
 801f2fa:	dd07      	ble.n	801f30c <_dtoa_r+0xb64>
 801f2fc:	4651      	mov	r1, sl
 801f2fe:	2300      	movs	r3, #0
 801f300:	220a      	movs	r2, #10
 801f302:	4620      	mov	r0, r4
 801f304:	f000 f9a4 	bl	801f650 <__multadd>
 801f308:	4682      	mov	sl, r0
 801f30a:	e7ea      	b.n	801f2e2 <_dtoa_r+0xb3a>
 801f30c:	9b01      	ldr	r3, [sp, #4]
 801f30e:	2b00      	cmp	r3, #0
 801f310:	bfc8      	it	gt
 801f312:	461d      	movgt	r5, r3
 801f314:	9b00      	ldr	r3, [sp, #0]
 801f316:	bfd8      	it	le
 801f318:	2501      	movle	r5, #1
 801f31a:	441d      	add	r5, r3
 801f31c:	f04f 0800 	mov.w	r8, #0
 801f320:	4651      	mov	r1, sl
 801f322:	2201      	movs	r2, #1
 801f324:	4620      	mov	r0, r4
 801f326:	f000 fb41 	bl	801f9ac <__lshift>
 801f32a:	4631      	mov	r1, r6
 801f32c:	4682      	mov	sl, r0
 801f32e:	f000 fba9 	bl	801fa84 <__mcmp>
 801f332:	2800      	cmp	r0, #0
 801f334:	dc96      	bgt.n	801f264 <_dtoa_r+0xabc>
 801f336:	d102      	bne.n	801f33e <_dtoa_r+0xb96>
 801f338:	f019 0f01 	tst.w	r9, #1
 801f33c:	d192      	bne.n	801f264 <_dtoa_r+0xabc>
 801f33e:	462b      	mov	r3, r5
 801f340:	461d      	mov	r5, r3
 801f342:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 801f346:	2a30      	cmp	r2, #48	; 0x30
 801f348:	d0fa      	beq.n	801f340 <_dtoa_r+0xb98>
 801f34a:	e6dd      	b.n	801f108 <_dtoa_r+0x960>
 801f34c:	9a00      	ldr	r2, [sp, #0]
 801f34e:	429a      	cmp	r2, r3
 801f350:	d189      	bne.n	801f266 <_dtoa_r+0xabe>
 801f352:	f10b 0b01 	add.w	fp, fp, #1
 801f356:	2331      	movs	r3, #49	; 0x31
 801f358:	e796      	b.n	801f288 <_dtoa_r+0xae0>
 801f35a:	4b0a      	ldr	r3, [pc, #40]	; (801f384 <_dtoa_r+0xbdc>)
 801f35c:	f7ff ba99 	b.w	801e892 <_dtoa_r+0xea>
 801f360:	9b21      	ldr	r3, [sp, #132]	; 0x84
 801f362:	2b00      	cmp	r3, #0
 801f364:	f47f aa6d 	bne.w	801e842 <_dtoa_r+0x9a>
 801f368:	4b07      	ldr	r3, [pc, #28]	; (801f388 <_dtoa_r+0xbe0>)
 801f36a:	f7ff ba92 	b.w	801e892 <_dtoa_r+0xea>
 801f36e:	9b01      	ldr	r3, [sp, #4]
 801f370:	2b00      	cmp	r3, #0
 801f372:	dcb5      	bgt.n	801f2e0 <_dtoa_r+0xb38>
 801f374:	9b07      	ldr	r3, [sp, #28]
 801f376:	2b02      	cmp	r3, #2
 801f378:	f73f aeb1 	bgt.w	801f0de <_dtoa_r+0x936>
 801f37c:	e7b0      	b.n	801f2e0 <_dtoa_r+0xb38>
 801f37e:	bf00      	nop
 801f380:	08023977 	.word	0x08023977
 801f384:	080238d7 	.word	0x080238d7
 801f388:	080238fb 	.word	0x080238fb

0801f38c <_free_r>:
 801f38c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 801f38e:	2900      	cmp	r1, #0
 801f390:	d044      	beq.n	801f41c <_free_r+0x90>
 801f392:	f851 3c04 	ldr.w	r3, [r1, #-4]
 801f396:	9001      	str	r0, [sp, #4]
 801f398:	2b00      	cmp	r3, #0
 801f39a:	f1a1 0404 	sub.w	r4, r1, #4
 801f39e:	bfb8      	it	lt
 801f3a0:	18e4      	addlt	r4, r4, r3
 801f3a2:	f000 f8e7 	bl	801f574 <__malloc_lock>
 801f3a6:	4a1e      	ldr	r2, [pc, #120]	; (801f420 <_free_r+0x94>)
 801f3a8:	9801      	ldr	r0, [sp, #4]
 801f3aa:	6813      	ldr	r3, [r2, #0]
 801f3ac:	b933      	cbnz	r3, 801f3bc <_free_r+0x30>
 801f3ae:	6063      	str	r3, [r4, #4]
 801f3b0:	6014      	str	r4, [r2, #0]
 801f3b2:	b003      	add	sp, #12
 801f3b4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 801f3b8:	f000 b8e2 	b.w	801f580 <__malloc_unlock>
 801f3bc:	42a3      	cmp	r3, r4
 801f3be:	d908      	bls.n	801f3d2 <_free_r+0x46>
 801f3c0:	6825      	ldr	r5, [r4, #0]
 801f3c2:	1961      	adds	r1, r4, r5
 801f3c4:	428b      	cmp	r3, r1
 801f3c6:	bf01      	itttt	eq
 801f3c8:	6819      	ldreq	r1, [r3, #0]
 801f3ca:	685b      	ldreq	r3, [r3, #4]
 801f3cc:	1949      	addeq	r1, r1, r5
 801f3ce:	6021      	streq	r1, [r4, #0]
 801f3d0:	e7ed      	b.n	801f3ae <_free_r+0x22>
 801f3d2:	461a      	mov	r2, r3
 801f3d4:	685b      	ldr	r3, [r3, #4]
 801f3d6:	b10b      	cbz	r3, 801f3dc <_free_r+0x50>
 801f3d8:	42a3      	cmp	r3, r4
 801f3da:	d9fa      	bls.n	801f3d2 <_free_r+0x46>
 801f3dc:	6811      	ldr	r1, [r2, #0]
 801f3de:	1855      	adds	r5, r2, r1
 801f3e0:	42a5      	cmp	r5, r4
 801f3e2:	d10b      	bne.n	801f3fc <_free_r+0x70>
 801f3e4:	6824      	ldr	r4, [r4, #0]
 801f3e6:	4421      	add	r1, r4
 801f3e8:	1854      	adds	r4, r2, r1
 801f3ea:	42a3      	cmp	r3, r4
 801f3ec:	6011      	str	r1, [r2, #0]
 801f3ee:	d1e0      	bne.n	801f3b2 <_free_r+0x26>
 801f3f0:	681c      	ldr	r4, [r3, #0]
 801f3f2:	685b      	ldr	r3, [r3, #4]
 801f3f4:	6053      	str	r3, [r2, #4]
 801f3f6:	440c      	add	r4, r1
 801f3f8:	6014      	str	r4, [r2, #0]
 801f3fa:	e7da      	b.n	801f3b2 <_free_r+0x26>
 801f3fc:	d902      	bls.n	801f404 <_free_r+0x78>
 801f3fe:	230c      	movs	r3, #12
 801f400:	6003      	str	r3, [r0, #0]
 801f402:	e7d6      	b.n	801f3b2 <_free_r+0x26>
 801f404:	6825      	ldr	r5, [r4, #0]
 801f406:	1961      	adds	r1, r4, r5
 801f408:	428b      	cmp	r3, r1
 801f40a:	bf04      	itt	eq
 801f40c:	6819      	ldreq	r1, [r3, #0]
 801f40e:	685b      	ldreq	r3, [r3, #4]
 801f410:	6063      	str	r3, [r4, #4]
 801f412:	bf04      	itt	eq
 801f414:	1949      	addeq	r1, r1, r5
 801f416:	6021      	streq	r1, [r4, #0]
 801f418:	6054      	str	r4, [r2, #4]
 801f41a:	e7ca      	b.n	801f3b2 <_free_r+0x26>
 801f41c:	b003      	add	sp, #12
 801f41e:	bd30      	pop	{r4, r5, pc}
 801f420:	20016a70 	.word	0x20016a70

0801f424 <malloc>:
 801f424:	4b02      	ldr	r3, [pc, #8]	; (801f430 <malloc+0xc>)
 801f426:	4601      	mov	r1, r0
 801f428:	6818      	ldr	r0, [r3, #0]
 801f42a:	f000 b823 	b.w	801f474 <_malloc_r>
 801f42e:	bf00      	nop
 801f430:	200001e8 	.word	0x200001e8

0801f434 <sbrk_aligned>:
 801f434:	b570      	push	{r4, r5, r6, lr}
 801f436:	4e0e      	ldr	r6, [pc, #56]	; (801f470 <sbrk_aligned+0x3c>)
 801f438:	460c      	mov	r4, r1
 801f43a:	6831      	ldr	r1, [r6, #0]
 801f43c:	4605      	mov	r5, r0
 801f43e:	b911      	cbnz	r1, 801f446 <sbrk_aligned+0x12>
 801f440:	f001 f85e 	bl	8020500 <_sbrk_r>
 801f444:	6030      	str	r0, [r6, #0]
 801f446:	4621      	mov	r1, r4
 801f448:	4628      	mov	r0, r5
 801f44a:	f001 f859 	bl	8020500 <_sbrk_r>
 801f44e:	1c43      	adds	r3, r0, #1
 801f450:	d00a      	beq.n	801f468 <sbrk_aligned+0x34>
 801f452:	1cc4      	adds	r4, r0, #3
 801f454:	f024 0403 	bic.w	r4, r4, #3
 801f458:	42a0      	cmp	r0, r4
 801f45a:	d007      	beq.n	801f46c <sbrk_aligned+0x38>
 801f45c:	1a21      	subs	r1, r4, r0
 801f45e:	4628      	mov	r0, r5
 801f460:	f001 f84e 	bl	8020500 <_sbrk_r>
 801f464:	3001      	adds	r0, #1
 801f466:	d101      	bne.n	801f46c <sbrk_aligned+0x38>
 801f468:	f04f 34ff 	mov.w	r4, #4294967295
 801f46c:	4620      	mov	r0, r4
 801f46e:	bd70      	pop	{r4, r5, r6, pc}
 801f470:	20016a74 	.word	0x20016a74

0801f474 <_malloc_r>:
 801f474:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801f478:	1ccd      	adds	r5, r1, #3
 801f47a:	f025 0503 	bic.w	r5, r5, #3
 801f47e:	3508      	adds	r5, #8
 801f480:	2d0c      	cmp	r5, #12
 801f482:	bf38      	it	cc
 801f484:	250c      	movcc	r5, #12
 801f486:	2d00      	cmp	r5, #0
 801f488:	4607      	mov	r7, r0
 801f48a:	db01      	blt.n	801f490 <_malloc_r+0x1c>
 801f48c:	42a9      	cmp	r1, r5
 801f48e:	d905      	bls.n	801f49c <_malloc_r+0x28>
 801f490:	230c      	movs	r3, #12
 801f492:	603b      	str	r3, [r7, #0]
 801f494:	2600      	movs	r6, #0
 801f496:	4630      	mov	r0, r6
 801f498:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801f49c:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 801f570 <_malloc_r+0xfc>
 801f4a0:	f000 f868 	bl	801f574 <__malloc_lock>
 801f4a4:	f8d8 3000 	ldr.w	r3, [r8]
 801f4a8:	461c      	mov	r4, r3
 801f4aa:	bb5c      	cbnz	r4, 801f504 <_malloc_r+0x90>
 801f4ac:	4629      	mov	r1, r5
 801f4ae:	4638      	mov	r0, r7
 801f4b0:	f7ff ffc0 	bl	801f434 <sbrk_aligned>
 801f4b4:	1c43      	adds	r3, r0, #1
 801f4b6:	4604      	mov	r4, r0
 801f4b8:	d155      	bne.n	801f566 <_malloc_r+0xf2>
 801f4ba:	f8d8 4000 	ldr.w	r4, [r8]
 801f4be:	4626      	mov	r6, r4
 801f4c0:	2e00      	cmp	r6, #0
 801f4c2:	d145      	bne.n	801f550 <_malloc_r+0xdc>
 801f4c4:	2c00      	cmp	r4, #0
 801f4c6:	d048      	beq.n	801f55a <_malloc_r+0xe6>
 801f4c8:	6823      	ldr	r3, [r4, #0]
 801f4ca:	4631      	mov	r1, r6
 801f4cc:	4638      	mov	r0, r7
 801f4ce:	eb04 0903 	add.w	r9, r4, r3
 801f4d2:	f001 f815 	bl	8020500 <_sbrk_r>
 801f4d6:	4581      	cmp	r9, r0
 801f4d8:	d13f      	bne.n	801f55a <_malloc_r+0xe6>
 801f4da:	6821      	ldr	r1, [r4, #0]
 801f4dc:	1a6d      	subs	r5, r5, r1
 801f4de:	4629      	mov	r1, r5
 801f4e0:	4638      	mov	r0, r7
 801f4e2:	f7ff ffa7 	bl	801f434 <sbrk_aligned>
 801f4e6:	3001      	adds	r0, #1
 801f4e8:	d037      	beq.n	801f55a <_malloc_r+0xe6>
 801f4ea:	6823      	ldr	r3, [r4, #0]
 801f4ec:	442b      	add	r3, r5
 801f4ee:	6023      	str	r3, [r4, #0]
 801f4f0:	f8d8 3000 	ldr.w	r3, [r8]
 801f4f4:	2b00      	cmp	r3, #0
 801f4f6:	d038      	beq.n	801f56a <_malloc_r+0xf6>
 801f4f8:	685a      	ldr	r2, [r3, #4]
 801f4fa:	42a2      	cmp	r2, r4
 801f4fc:	d12b      	bne.n	801f556 <_malloc_r+0xe2>
 801f4fe:	2200      	movs	r2, #0
 801f500:	605a      	str	r2, [r3, #4]
 801f502:	e00f      	b.n	801f524 <_malloc_r+0xb0>
 801f504:	6822      	ldr	r2, [r4, #0]
 801f506:	1b52      	subs	r2, r2, r5
 801f508:	d41f      	bmi.n	801f54a <_malloc_r+0xd6>
 801f50a:	2a0b      	cmp	r2, #11
 801f50c:	d917      	bls.n	801f53e <_malloc_r+0xca>
 801f50e:	1961      	adds	r1, r4, r5
 801f510:	42a3      	cmp	r3, r4
 801f512:	6025      	str	r5, [r4, #0]
 801f514:	bf18      	it	ne
 801f516:	6059      	strne	r1, [r3, #4]
 801f518:	6863      	ldr	r3, [r4, #4]
 801f51a:	bf08      	it	eq
 801f51c:	f8c8 1000 	streq.w	r1, [r8]
 801f520:	5162      	str	r2, [r4, r5]
 801f522:	604b      	str	r3, [r1, #4]
 801f524:	4638      	mov	r0, r7
 801f526:	f104 060b 	add.w	r6, r4, #11
 801f52a:	f000 f829 	bl	801f580 <__malloc_unlock>
 801f52e:	f026 0607 	bic.w	r6, r6, #7
 801f532:	1d23      	adds	r3, r4, #4
 801f534:	1af2      	subs	r2, r6, r3
 801f536:	d0ae      	beq.n	801f496 <_malloc_r+0x22>
 801f538:	1b9b      	subs	r3, r3, r6
 801f53a:	50a3      	str	r3, [r4, r2]
 801f53c:	e7ab      	b.n	801f496 <_malloc_r+0x22>
 801f53e:	42a3      	cmp	r3, r4
 801f540:	6862      	ldr	r2, [r4, #4]
 801f542:	d1dd      	bne.n	801f500 <_malloc_r+0x8c>
 801f544:	f8c8 2000 	str.w	r2, [r8]
 801f548:	e7ec      	b.n	801f524 <_malloc_r+0xb0>
 801f54a:	4623      	mov	r3, r4
 801f54c:	6864      	ldr	r4, [r4, #4]
 801f54e:	e7ac      	b.n	801f4aa <_malloc_r+0x36>
 801f550:	4634      	mov	r4, r6
 801f552:	6876      	ldr	r6, [r6, #4]
 801f554:	e7b4      	b.n	801f4c0 <_malloc_r+0x4c>
 801f556:	4613      	mov	r3, r2
 801f558:	e7cc      	b.n	801f4f4 <_malloc_r+0x80>
 801f55a:	230c      	movs	r3, #12
 801f55c:	603b      	str	r3, [r7, #0]
 801f55e:	4638      	mov	r0, r7
 801f560:	f000 f80e 	bl	801f580 <__malloc_unlock>
 801f564:	e797      	b.n	801f496 <_malloc_r+0x22>
 801f566:	6025      	str	r5, [r4, #0]
 801f568:	e7dc      	b.n	801f524 <_malloc_r+0xb0>
 801f56a:	605b      	str	r3, [r3, #4]
 801f56c:	deff      	udf	#255	; 0xff
 801f56e:	bf00      	nop
 801f570:	20016a70 	.word	0x20016a70

0801f574 <__malloc_lock>:
 801f574:	4801      	ldr	r0, [pc, #4]	; (801f57c <__malloc_lock+0x8>)
 801f576:	f7ff b875 	b.w	801e664 <__retarget_lock_acquire_recursive>
 801f57a:	bf00      	nop
 801f57c:	20016a6c 	.word	0x20016a6c

0801f580 <__malloc_unlock>:
 801f580:	4801      	ldr	r0, [pc, #4]	; (801f588 <__malloc_unlock+0x8>)
 801f582:	f7ff b870 	b.w	801e666 <__retarget_lock_release_recursive>
 801f586:	bf00      	nop
 801f588:	20016a6c 	.word	0x20016a6c

0801f58c <_Balloc>:
 801f58c:	b570      	push	{r4, r5, r6, lr}
 801f58e:	69c6      	ldr	r6, [r0, #28]
 801f590:	4604      	mov	r4, r0
 801f592:	460d      	mov	r5, r1
 801f594:	b976      	cbnz	r6, 801f5b4 <_Balloc+0x28>
 801f596:	2010      	movs	r0, #16
 801f598:	f7ff ff44 	bl	801f424 <malloc>
 801f59c:	4602      	mov	r2, r0
 801f59e:	61e0      	str	r0, [r4, #28]
 801f5a0:	b920      	cbnz	r0, 801f5ac <_Balloc+0x20>
 801f5a2:	4b18      	ldr	r3, [pc, #96]	; (801f604 <_Balloc+0x78>)
 801f5a4:	4818      	ldr	r0, [pc, #96]	; (801f608 <_Balloc+0x7c>)
 801f5a6:	216b      	movs	r1, #107	; 0x6b
 801f5a8:	f7fe fa36 	bl	801da18 <__assert_func>
 801f5ac:	e9c0 6601 	strd	r6, r6, [r0, #4]
 801f5b0:	6006      	str	r6, [r0, #0]
 801f5b2:	60c6      	str	r6, [r0, #12]
 801f5b4:	69e6      	ldr	r6, [r4, #28]
 801f5b6:	68f3      	ldr	r3, [r6, #12]
 801f5b8:	b183      	cbz	r3, 801f5dc <_Balloc+0x50>
 801f5ba:	69e3      	ldr	r3, [r4, #28]
 801f5bc:	68db      	ldr	r3, [r3, #12]
 801f5be:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 801f5c2:	b9b8      	cbnz	r0, 801f5f4 <_Balloc+0x68>
 801f5c4:	2101      	movs	r1, #1
 801f5c6:	fa01 f605 	lsl.w	r6, r1, r5
 801f5ca:	1d72      	adds	r2, r6, #5
 801f5cc:	0092      	lsls	r2, r2, #2
 801f5ce:	4620      	mov	r0, r4
 801f5d0:	f000 ffa6 	bl	8020520 <_calloc_r>
 801f5d4:	b160      	cbz	r0, 801f5f0 <_Balloc+0x64>
 801f5d6:	e9c0 5601 	strd	r5, r6, [r0, #4]
 801f5da:	e00e      	b.n	801f5fa <_Balloc+0x6e>
 801f5dc:	2221      	movs	r2, #33	; 0x21
 801f5de:	2104      	movs	r1, #4
 801f5e0:	4620      	mov	r0, r4
 801f5e2:	f000 ff9d 	bl	8020520 <_calloc_r>
 801f5e6:	69e3      	ldr	r3, [r4, #28]
 801f5e8:	60f0      	str	r0, [r6, #12]
 801f5ea:	68db      	ldr	r3, [r3, #12]
 801f5ec:	2b00      	cmp	r3, #0
 801f5ee:	d1e4      	bne.n	801f5ba <_Balloc+0x2e>
 801f5f0:	2000      	movs	r0, #0
 801f5f2:	bd70      	pop	{r4, r5, r6, pc}
 801f5f4:	6802      	ldr	r2, [r0, #0]
 801f5f6:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
 801f5fa:	2300      	movs	r3, #0
 801f5fc:	e9c0 3303 	strd	r3, r3, [r0, #12]
 801f600:	e7f7      	b.n	801f5f2 <_Balloc+0x66>
 801f602:	bf00      	nop
 801f604:	08023908 	.word	0x08023908
 801f608:	08023988 	.word	0x08023988

0801f60c <_Bfree>:
 801f60c:	b570      	push	{r4, r5, r6, lr}
 801f60e:	69c6      	ldr	r6, [r0, #28]
 801f610:	4605      	mov	r5, r0
 801f612:	460c      	mov	r4, r1
 801f614:	b976      	cbnz	r6, 801f634 <_Bfree+0x28>
 801f616:	2010      	movs	r0, #16
 801f618:	f7ff ff04 	bl	801f424 <malloc>
 801f61c:	4602      	mov	r2, r0
 801f61e:	61e8      	str	r0, [r5, #28]
 801f620:	b920      	cbnz	r0, 801f62c <_Bfree+0x20>
 801f622:	4b09      	ldr	r3, [pc, #36]	; (801f648 <_Bfree+0x3c>)
 801f624:	4809      	ldr	r0, [pc, #36]	; (801f64c <_Bfree+0x40>)
 801f626:	218f      	movs	r1, #143	; 0x8f
 801f628:	f7fe f9f6 	bl	801da18 <__assert_func>
 801f62c:	e9c0 6601 	strd	r6, r6, [r0, #4]
 801f630:	6006      	str	r6, [r0, #0]
 801f632:	60c6      	str	r6, [r0, #12]
 801f634:	b13c      	cbz	r4, 801f646 <_Bfree+0x3a>
 801f636:	69eb      	ldr	r3, [r5, #28]
 801f638:	6862      	ldr	r2, [r4, #4]
 801f63a:	68db      	ldr	r3, [r3, #12]
 801f63c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 801f640:	6021      	str	r1, [r4, #0]
 801f642:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
 801f646:	bd70      	pop	{r4, r5, r6, pc}
 801f648:	08023908 	.word	0x08023908
 801f64c:	08023988 	.word	0x08023988

0801f650 <__multadd>:
 801f650:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801f654:	690d      	ldr	r5, [r1, #16]
 801f656:	4607      	mov	r7, r0
 801f658:	460c      	mov	r4, r1
 801f65a:	461e      	mov	r6, r3
 801f65c:	f101 0c14 	add.w	ip, r1, #20
 801f660:	2000      	movs	r0, #0
 801f662:	f8dc 3000 	ldr.w	r3, [ip]
 801f666:	b299      	uxth	r1, r3
 801f668:	fb02 6101 	mla	r1, r2, r1, r6
 801f66c:	0c1e      	lsrs	r6, r3, #16
 801f66e:	0c0b      	lsrs	r3, r1, #16
 801f670:	fb02 3306 	mla	r3, r2, r6, r3
 801f674:	b289      	uxth	r1, r1
 801f676:	3001      	adds	r0, #1
 801f678:	eb01 4103 	add.w	r1, r1, r3, lsl #16
 801f67c:	4285      	cmp	r5, r0
 801f67e:	f84c 1b04 	str.w	r1, [ip], #4
 801f682:	ea4f 4613 	mov.w	r6, r3, lsr #16
 801f686:	dcec      	bgt.n	801f662 <__multadd+0x12>
 801f688:	b30e      	cbz	r6, 801f6ce <__multadd+0x7e>
 801f68a:	68a3      	ldr	r3, [r4, #8]
 801f68c:	42ab      	cmp	r3, r5
 801f68e:	dc19      	bgt.n	801f6c4 <__multadd+0x74>
 801f690:	6861      	ldr	r1, [r4, #4]
 801f692:	4638      	mov	r0, r7
 801f694:	3101      	adds	r1, #1
 801f696:	f7ff ff79 	bl	801f58c <_Balloc>
 801f69a:	4680      	mov	r8, r0
 801f69c:	b928      	cbnz	r0, 801f6aa <__multadd+0x5a>
 801f69e:	4602      	mov	r2, r0
 801f6a0:	4b0c      	ldr	r3, [pc, #48]	; (801f6d4 <__multadd+0x84>)
 801f6a2:	480d      	ldr	r0, [pc, #52]	; (801f6d8 <__multadd+0x88>)
 801f6a4:	21ba      	movs	r1, #186	; 0xba
 801f6a6:	f7fe f9b7 	bl	801da18 <__assert_func>
 801f6aa:	6922      	ldr	r2, [r4, #16]
 801f6ac:	3202      	adds	r2, #2
 801f6ae:	f104 010c 	add.w	r1, r4, #12
 801f6b2:	0092      	lsls	r2, r2, #2
 801f6b4:	300c      	adds	r0, #12
 801f6b6:	f7fe ffd7 	bl	801e668 <memcpy>
 801f6ba:	4621      	mov	r1, r4
 801f6bc:	4638      	mov	r0, r7
 801f6be:	f7ff ffa5 	bl	801f60c <_Bfree>
 801f6c2:	4644      	mov	r4, r8
 801f6c4:	eb04 0385 	add.w	r3, r4, r5, lsl #2
 801f6c8:	3501      	adds	r5, #1
 801f6ca:	615e      	str	r6, [r3, #20]
 801f6cc:	6125      	str	r5, [r4, #16]
 801f6ce:	4620      	mov	r0, r4
 801f6d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801f6d4:	08023977 	.word	0x08023977
 801f6d8:	08023988 	.word	0x08023988

0801f6dc <__hi0bits>:
 801f6dc:	0c03      	lsrs	r3, r0, #16
 801f6de:	041b      	lsls	r3, r3, #16
 801f6e0:	b9d3      	cbnz	r3, 801f718 <__hi0bits+0x3c>
 801f6e2:	0400      	lsls	r0, r0, #16
 801f6e4:	2310      	movs	r3, #16
 801f6e6:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 801f6ea:	bf04      	itt	eq
 801f6ec:	0200      	lsleq	r0, r0, #8
 801f6ee:	3308      	addeq	r3, #8
 801f6f0:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 801f6f4:	bf04      	itt	eq
 801f6f6:	0100      	lsleq	r0, r0, #4
 801f6f8:	3304      	addeq	r3, #4
 801f6fa:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
 801f6fe:	bf04      	itt	eq
 801f700:	0080      	lsleq	r0, r0, #2
 801f702:	3302      	addeq	r3, #2
 801f704:	2800      	cmp	r0, #0
 801f706:	db05      	blt.n	801f714 <__hi0bits+0x38>
 801f708:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
 801f70c:	f103 0301 	add.w	r3, r3, #1
 801f710:	bf08      	it	eq
 801f712:	2320      	moveq	r3, #32
 801f714:	4618      	mov	r0, r3
 801f716:	4770      	bx	lr
 801f718:	2300      	movs	r3, #0
 801f71a:	e7e4      	b.n	801f6e6 <__hi0bits+0xa>

0801f71c <__lo0bits>:
 801f71c:	6803      	ldr	r3, [r0, #0]
 801f71e:	f013 0207 	ands.w	r2, r3, #7
 801f722:	d00c      	beq.n	801f73e <__lo0bits+0x22>
 801f724:	07d9      	lsls	r1, r3, #31
 801f726:	d422      	bmi.n	801f76e <__lo0bits+0x52>
 801f728:	079a      	lsls	r2, r3, #30
 801f72a:	bf49      	itett	mi
 801f72c:	085b      	lsrmi	r3, r3, #1
 801f72e:	089b      	lsrpl	r3, r3, #2
 801f730:	6003      	strmi	r3, [r0, #0]
 801f732:	2201      	movmi	r2, #1
 801f734:	bf5c      	itt	pl
 801f736:	6003      	strpl	r3, [r0, #0]
 801f738:	2202      	movpl	r2, #2
 801f73a:	4610      	mov	r0, r2
 801f73c:	4770      	bx	lr
 801f73e:	b299      	uxth	r1, r3
 801f740:	b909      	cbnz	r1, 801f746 <__lo0bits+0x2a>
 801f742:	0c1b      	lsrs	r3, r3, #16
 801f744:	2210      	movs	r2, #16
 801f746:	b2d9      	uxtb	r1, r3
 801f748:	b909      	cbnz	r1, 801f74e <__lo0bits+0x32>
 801f74a:	3208      	adds	r2, #8
 801f74c:	0a1b      	lsrs	r3, r3, #8
 801f74e:	0719      	lsls	r1, r3, #28
 801f750:	bf04      	itt	eq
 801f752:	091b      	lsreq	r3, r3, #4
 801f754:	3204      	addeq	r2, #4
 801f756:	0799      	lsls	r1, r3, #30
 801f758:	bf04      	itt	eq
 801f75a:	089b      	lsreq	r3, r3, #2
 801f75c:	3202      	addeq	r2, #2
 801f75e:	07d9      	lsls	r1, r3, #31
 801f760:	d403      	bmi.n	801f76a <__lo0bits+0x4e>
 801f762:	085b      	lsrs	r3, r3, #1
 801f764:	f102 0201 	add.w	r2, r2, #1
 801f768:	d003      	beq.n	801f772 <__lo0bits+0x56>
 801f76a:	6003      	str	r3, [r0, #0]
 801f76c:	e7e5      	b.n	801f73a <__lo0bits+0x1e>
 801f76e:	2200      	movs	r2, #0
 801f770:	e7e3      	b.n	801f73a <__lo0bits+0x1e>
 801f772:	2220      	movs	r2, #32
 801f774:	e7e1      	b.n	801f73a <__lo0bits+0x1e>
	...

0801f778 <__i2b>:
 801f778:	b510      	push	{r4, lr}
 801f77a:	460c      	mov	r4, r1
 801f77c:	2101      	movs	r1, #1
 801f77e:	f7ff ff05 	bl	801f58c <_Balloc>
 801f782:	4602      	mov	r2, r0
 801f784:	b928      	cbnz	r0, 801f792 <__i2b+0x1a>
 801f786:	4b05      	ldr	r3, [pc, #20]	; (801f79c <__i2b+0x24>)
 801f788:	4805      	ldr	r0, [pc, #20]	; (801f7a0 <__i2b+0x28>)
 801f78a:	f240 1145 	movw	r1, #325	; 0x145
 801f78e:	f7fe f943 	bl	801da18 <__assert_func>
 801f792:	2301      	movs	r3, #1
 801f794:	6144      	str	r4, [r0, #20]
 801f796:	6103      	str	r3, [r0, #16]
 801f798:	bd10      	pop	{r4, pc}
 801f79a:	bf00      	nop
 801f79c:	08023977 	.word	0x08023977
 801f7a0:	08023988 	.word	0x08023988

0801f7a4 <__multiply>:
 801f7a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801f7a8:	4691      	mov	r9, r2
 801f7aa:	690a      	ldr	r2, [r1, #16]
 801f7ac:	f8d9 3010 	ldr.w	r3, [r9, #16]
 801f7b0:	429a      	cmp	r2, r3
 801f7b2:	bfb8      	it	lt
 801f7b4:	460b      	movlt	r3, r1
 801f7b6:	460c      	mov	r4, r1
 801f7b8:	bfbc      	itt	lt
 801f7ba:	464c      	movlt	r4, r9
 801f7bc:	4699      	movlt	r9, r3
 801f7be:	6927      	ldr	r7, [r4, #16]
 801f7c0:	f8d9 a010 	ldr.w	sl, [r9, #16]
 801f7c4:	68a3      	ldr	r3, [r4, #8]
 801f7c6:	6861      	ldr	r1, [r4, #4]
 801f7c8:	eb07 060a 	add.w	r6, r7, sl
 801f7cc:	42b3      	cmp	r3, r6
 801f7ce:	b085      	sub	sp, #20
 801f7d0:	bfb8      	it	lt
 801f7d2:	3101      	addlt	r1, #1
 801f7d4:	f7ff feda 	bl	801f58c <_Balloc>
 801f7d8:	b930      	cbnz	r0, 801f7e8 <__multiply+0x44>
 801f7da:	4602      	mov	r2, r0
 801f7dc:	4b44      	ldr	r3, [pc, #272]	; (801f8f0 <__multiply+0x14c>)
 801f7de:	4845      	ldr	r0, [pc, #276]	; (801f8f4 <__multiply+0x150>)
 801f7e0:	f44f 71b1 	mov.w	r1, #354	; 0x162
 801f7e4:	f7fe f918 	bl	801da18 <__assert_func>
 801f7e8:	f100 0514 	add.w	r5, r0, #20
 801f7ec:	eb05 0886 	add.w	r8, r5, r6, lsl #2
 801f7f0:	462b      	mov	r3, r5
 801f7f2:	2200      	movs	r2, #0
 801f7f4:	4543      	cmp	r3, r8
 801f7f6:	d321      	bcc.n	801f83c <__multiply+0x98>
 801f7f8:	f104 0314 	add.w	r3, r4, #20
 801f7fc:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 801f800:	f109 0314 	add.w	r3, r9, #20
 801f804:	eb03 028a 	add.w	r2, r3, sl, lsl #2
 801f808:	9202      	str	r2, [sp, #8]
 801f80a:	1b3a      	subs	r2, r7, r4
 801f80c:	3a15      	subs	r2, #21
 801f80e:	f022 0203 	bic.w	r2, r2, #3
 801f812:	3204      	adds	r2, #4
 801f814:	f104 0115 	add.w	r1, r4, #21
 801f818:	428f      	cmp	r7, r1
 801f81a:	bf38      	it	cc
 801f81c:	2204      	movcc	r2, #4
 801f81e:	9201      	str	r2, [sp, #4]
 801f820:	9a02      	ldr	r2, [sp, #8]
 801f822:	9303      	str	r3, [sp, #12]
 801f824:	429a      	cmp	r2, r3
 801f826:	d80c      	bhi.n	801f842 <__multiply+0x9e>
 801f828:	2e00      	cmp	r6, #0
 801f82a:	dd03      	ble.n	801f834 <__multiply+0x90>
 801f82c:	f858 3d04 	ldr.w	r3, [r8, #-4]!
 801f830:	2b00      	cmp	r3, #0
 801f832:	d05b      	beq.n	801f8ec <__multiply+0x148>
 801f834:	6106      	str	r6, [r0, #16]
 801f836:	b005      	add	sp, #20
 801f838:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801f83c:	f843 2b04 	str.w	r2, [r3], #4
 801f840:	e7d8      	b.n	801f7f4 <__multiply+0x50>
 801f842:	f8b3 a000 	ldrh.w	sl, [r3]
 801f846:	f1ba 0f00 	cmp.w	sl, #0
 801f84a:	d024      	beq.n	801f896 <__multiply+0xf2>
 801f84c:	f104 0e14 	add.w	lr, r4, #20
 801f850:	46a9      	mov	r9, r5
 801f852:	f04f 0c00 	mov.w	ip, #0
 801f856:	f85e 2b04 	ldr.w	r2, [lr], #4
 801f85a:	f8d9 1000 	ldr.w	r1, [r9]
 801f85e:	fa1f fb82 	uxth.w	fp, r2
 801f862:	b289      	uxth	r1, r1
 801f864:	fb0a 110b 	mla	r1, sl, fp, r1
 801f868:	ea4f 4b12 	mov.w	fp, r2, lsr #16
 801f86c:	f8d9 2000 	ldr.w	r2, [r9]
 801f870:	4461      	add	r1, ip
 801f872:	ea4f 4c12 	mov.w	ip, r2, lsr #16
 801f876:	fb0a c20b 	mla	r2, sl, fp, ip
 801f87a:	eb02 4211 	add.w	r2, r2, r1, lsr #16
 801f87e:	b289      	uxth	r1, r1
 801f880:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 801f884:	4577      	cmp	r7, lr
 801f886:	f849 1b04 	str.w	r1, [r9], #4
 801f88a:	ea4f 4c12 	mov.w	ip, r2, lsr #16
 801f88e:	d8e2      	bhi.n	801f856 <__multiply+0xb2>
 801f890:	9a01      	ldr	r2, [sp, #4]
 801f892:	f845 c002 	str.w	ip, [r5, r2]
 801f896:	9a03      	ldr	r2, [sp, #12]
 801f898:	f8b2 9002 	ldrh.w	r9, [r2, #2]
 801f89c:	3304      	adds	r3, #4
 801f89e:	f1b9 0f00 	cmp.w	r9, #0
 801f8a2:	d021      	beq.n	801f8e8 <__multiply+0x144>
 801f8a4:	6829      	ldr	r1, [r5, #0]
 801f8a6:	f104 0c14 	add.w	ip, r4, #20
 801f8aa:	46ae      	mov	lr, r5
 801f8ac:	f04f 0a00 	mov.w	sl, #0
 801f8b0:	f8bc b000 	ldrh.w	fp, [ip]
 801f8b4:	f8be 2002 	ldrh.w	r2, [lr, #2]
 801f8b8:	fb09 220b 	mla	r2, r9, fp, r2
 801f8bc:	4452      	add	r2, sl
 801f8be:	b289      	uxth	r1, r1
 801f8c0:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 801f8c4:	f84e 1b04 	str.w	r1, [lr], #4
 801f8c8:	f85c 1b04 	ldr.w	r1, [ip], #4
 801f8cc:	ea4f 4a11 	mov.w	sl, r1, lsr #16
 801f8d0:	f8be 1000 	ldrh.w	r1, [lr]
 801f8d4:	fb09 110a 	mla	r1, r9, sl, r1
 801f8d8:	eb01 4112 	add.w	r1, r1, r2, lsr #16
 801f8dc:	4567      	cmp	r7, ip
 801f8de:	ea4f 4a11 	mov.w	sl, r1, lsr #16
 801f8e2:	d8e5      	bhi.n	801f8b0 <__multiply+0x10c>
 801f8e4:	9a01      	ldr	r2, [sp, #4]
 801f8e6:	50a9      	str	r1, [r5, r2]
 801f8e8:	3504      	adds	r5, #4
 801f8ea:	e799      	b.n	801f820 <__multiply+0x7c>
 801f8ec:	3e01      	subs	r6, #1
 801f8ee:	e79b      	b.n	801f828 <__multiply+0x84>
 801f8f0:	08023977 	.word	0x08023977
 801f8f4:	08023988 	.word	0x08023988

0801f8f8 <__pow5mult>:
 801f8f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801f8fc:	4615      	mov	r5, r2
 801f8fe:	f012 0203 	ands.w	r2, r2, #3
 801f902:	4606      	mov	r6, r0
 801f904:	460f      	mov	r7, r1
 801f906:	d007      	beq.n	801f918 <__pow5mult+0x20>
 801f908:	4c25      	ldr	r4, [pc, #148]	; (801f9a0 <__pow5mult+0xa8>)
 801f90a:	3a01      	subs	r2, #1
 801f90c:	2300      	movs	r3, #0
 801f90e:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 801f912:	f7ff fe9d 	bl	801f650 <__multadd>
 801f916:	4607      	mov	r7, r0
 801f918:	10ad      	asrs	r5, r5, #2
 801f91a:	d03d      	beq.n	801f998 <__pow5mult+0xa0>
 801f91c:	69f4      	ldr	r4, [r6, #28]
 801f91e:	b97c      	cbnz	r4, 801f940 <__pow5mult+0x48>
 801f920:	2010      	movs	r0, #16
 801f922:	f7ff fd7f 	bl	801f424 <malloc>
 801f926:	4602      	mov	r2, r0
 801f928:	61f0      	str	r0, [r6, #28]
 801f92a:	b928      	cbnz	r0, 801f938 <__pow5mult+0x40>
 801f92c:	4b1d      	ldr	r3, [pc, #116]	; (801f9a4 <__pow5mult+0xac>)
 801f92e:	481e      	ldr	r0, [pc, #120]	; (801f9a8 <__pow5mult+0xb0>)
 801f930:	f240 11b3 	movw	r1, #435	; 0x1b3
 801f934:	f7fe f870 	bl	801da18 <__assert_func>
 801f938:	e9c0 4401 	strd	r4, r4, [r0, #4]
 801f93c:	6004      	str	r4, [r0, #0]
 801f93e:	60c4      	str	r4, [r0, #12]
 801f940:	f8d6 801c 	ldr.w	r8, [r6, #28]
 801f944:	f8d8 4008 	ldr.w	r4, [r8, #8]
 801f948:	b94c      	cbnz	r4, 801f95e <__pow5mult+0x66>
 801f94a:	f240 2171 	movw	r1, #625	; 0x271
 801f94e:	4630      	mov	r0, r6
 801f950:	f7ff ff12 	bl	801f778 <__i2b>
 801f954:	2300      	movs	r3, #0
 801f956:	f8c8 0008 	str.w	r0, [r8, #8]
 801f95a:	4604      	mov	r4, r0
 801f95c:	6003      	str	r3, [r0, #0]
 801f95e:	f04f 0900 	mov.w	r9, #0
 801f962:	07eb      	lsls	r3, r5, #31
 801f964:	d50a      	bpl.n	801f97c <__pow5mult+0x84>
 801f966:	4639      	mov	r1, r7
 801f968:	4622      	mov	r2, r4
 801f96a:	4630      	mov	r0, r6
 801f96c:	f7ff ff1a 	bl	801f7a4 <__multiply>
 801f970:	4639      	mov	r1, r7
 801f972:	4680      	mov	r8, r0
 801f974:	4630      	mov	r0, r6
 801f976:	f7ff fe49 	bl	801f60c <_Bfree>
 801f97a:	4647      	mov	r7, r8
 801f97c:	106d      	asrs	r5, r5, #1
 801f97e:	d00b      	beq.n	801f998 <__pow5mult+0xa0>
 801f980:	6820      	ldr	r0, [r4, #0]
 801f982:	b938      	cbnz	r0, 801f994 <__pow5mult+0x9c>
 801f984:	4622      	mov	r2, r4
 801f986:	4621      	mov	r1, r4
 801f988:	4630      	mov	r0, r6
 801f98a:	f7ff ff0b 	bl	801f7a4 <__multiply>
 801f98e:	6020      	str	r0, [r4, #0]
 801f990:	f8c0 9000 	str.w	r9, [r0]
 801f994:	4604      	mov	r4, r0
 801f996:	e7e4      	b.n	801f962 <__pow5mult+0x6a>
 801f998:	4638      	mov	r0, r7
 801f99a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801f99e:	bf00      	nop
 801f9a0:	08023ad8 	.word	0x08023ad8
 801f9a4:	08023908 	.word	0x08023908
 801f9a8:	08023988 	.word	0x08023988

0801f9ac <__lshift>:
 801f9ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801f9b0:	460c      	mov	r4, r1
 801f9b2:	6849      	ldr	r1, [r1, #4]
 801f9b4:	6923      	ldr	r3, [r4, #16]
 801f9b6:	eb03 1862 	add.w	r8, r3, r2, asr #5
 801f9ba:	68a3      	ldr	r3, [r4, #8]
 801f9bc:	4607      	mov	r7, r0
 801f9be:	4691      	mov	r9, r2
 801f9c0:	ea4f 1a62 	mov.w	sl, r2, asr #5
 801f9c4:	f108 0601 	add.w	r6, r8, #1
 801f9c8:	42b3      	cmp	r3, r6
 801f9ca:	db0b      	blt.n	801f9e4 <__lshift+0x38>
 801f9cc:	4638      	mov	r0, r7
 801f9ce:	f7ff fddd 	bl	801f58c <_Balloc>
 801f9d2:	4605      	mov	r5, r0
 801f9d4:	b948      	cbnz	r0, 801f9ea <__lshift+0x3e>
 801f9d6:	4602      	mov	r2, r0
 801f9d8:	4b28      	ldr	r3, [pc, #160]	; (801fa7c <__lshift+0xd0>)
 801f9da:	4829      	ldr	r0, [pc, #164]	; (801fa80 <__lshift+0xd4>)
 801f9dc:	f44f 71ef 	mov.w	r1, #478	; 0x1de
 801f9e0:	f7fe f81a 	bl	801da18 <__assert_func>
 801f9e4:	3101      	adds	r1, #1
 801f9e6:	005b      	lsls	r3, r3, #1
 801f9e8:	e7ee      	b.n	801f9c8 <__lshift+0x1c>
 801f9ea:	2300      	movs	r3, #0
 801f9ec:	f100 0114 	add.w	r1, r0, #20
 801f9f0:	f100 0210 	add.w	r2, r0, #16
 801f9f4:	4618      	mov	r0, r3
 801f9f6:	4553      	cmp	r3, sl
 801f9f8:	db33      	blt.n	801fa62 <__lshift+0xb6>
 801f9fa:	6920      	ldr	r0, [r4, #16]
 801f9fc:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
 801fa00:	f104 0314 	add.w	r3, r4, #20
 801fa04:	f019 091f 	ands.w	r9, r9, #31
 801fa08:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 801fa0c:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
 801fa10:	d02b      	beq.n	801fa6a <__lshift+0xbe>
 801fa12:	f1c9 0e20 	rsb	lr, r9, #32
 801fa16:	468a      	mov	sl, r1
 801fa18:	2200      	movs	r2, #0
 801fa1a:	6818      	ldr	r0, [r3, #0]
 801fa1c:	fa00 f009 	lsl.w	r0, r0, r9
 801fa20:	4310      	orrs	r0, r2
 801fa22:	f84a 0b04 	str.w	r0, [sl], #4
 801fa26:	f853 2b04 	ldr.w	r2, [r3], #4
 801fa2a:	459c      	cmp	ip, r3
 801fa2c:	fa22 f20e 	lsr.w	r2, r2, lr
 801fa30:	d8f3      	bhi.n	801fa1a <__lshift+0x6e>
 801fa32:	ebac 0304 	sub.w	r3, ip, r4
 801fa36:	3b15      	subs	r3, #21
 801fa38:	f023 0303 	bic.w	r3, r3, #3
 801fa3c:	3304      	adds	r3, #4
 801fa3e:	f104 0015 	add.w	r0, r4, #21
 801fa42:	4584      	cmp	ip, r0
 801fa44:	bf38      	it	cc
 801fa46:	2304      	movcc	r3, #4
 801fa48:	50ca      	str	r2, [r1, r3]
 801fa4a:	b10a      	cbz	r2, 801fa50 <__lshift+0xa4>
 801fa4c:	f108 0602 	add.w	r6, r8, #2
 801fa50:	3e01      	subs	r6, #1
 801fa52:	4638      	mov	r0, r7
 801fa54:	612e      	str	r6, [r5, #16]
 801fa56:	4621      	mov	r1, r4
 801fa58:	f7ff fdd8 	bl	801f60c <_Bfree>
 801fa5c:	4628      	mov	r0, r5
 801fa5e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801fa62:	f842 0f04 	str.w	r0, [r2, #4]!
 801fa66:	3301      	adds	r3, #1
 801fa68:	e7c5      	b.n	801f9f6 <__lshift+0x4a>
 801fa6a:	3904      	subs	r1, #4
 801fa6c:	f853 2b04 	ldr.w	r2, [r3], #4
 801fa70:	f841 2f04 	str.w	r2, [r1, #4]!
 801fa74:	459c      	cmp	ip, r3
 801fa76:	d8f9      	bhi.n	801fa6c <__lshift+0xc0>
 801fa78:	e7ea      	b.n	801fa50 <__lshift+0xa4>
 801fa7a:	bf00      	nop
 801fa7c:	08023977 	.word	0x08023977
 801fa80:	08023988 	.word	0x08023988

0801fa84 <__mcmp>:
 801fa84:	b530      	push	{r4, r5, lr}
 801fa86:	6902      	ldr	r2, [r0, #16]
 801fa88:	690c      	ldr	r4, [r1, #16]
 801fa8a:	1b12      	subs	r2, r2, r4
 801fa8c:	d10e      	bne.n	801faac <__mcmp+0x28>
 801fa8e:	f100 0314 	add.w	r3, r0, #20
 801fa92:	3114      	adds	r1, #20
 801fa94:	eb03 0084 	add.w	r0, r3, r4, lsl #2
 801fa98:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 801fa9c:	f850 5d04 	ldr.w	r5, [r0, #-4]!
 801faa0:	f851 4d04 	ldr.w	r4, [r1, #-4]!
 801faa4:	42a5      	cmp	r5, r4
 801faa6:	d003      	beq.n	801fab0 <__mcmp+0x2c>
 801faa8:	d305      	bcc.n	801fab6 <__mcmp+0x32>
 801faaa:	2201      	movs	r2, #1
 801faac:	4610      	mov	r0, r2
 801faae:	bd30      	pop	{r4, r5, pc}
 801fab0:	4283      	cmp	r3, r0
 801fab2:	d3f3      	bcc.n	801fa9c <__mcmp+0x18>
 801fab4:	e7fa      	b.n	801faac <__mcmp+0x28>
 801fab6:	f04f 32ff 	mov.w	r2, #4294967295
 801faba:	e7f7      	b.n	801faac <__mcmp+0x28>

0801fabc <__mdiff>:
 801fabc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801fac0:	460c      	mov	r4, r1
 801fac2:	4606      	mov	r6, r0
 801fac4:	4611      	mov	r1, r2
 801fac6:	4620      	mov	r0, r4
 801fac8:	4690      	mov	r8, r2
 801faca:	f7ff ffdb 	bl	801fa84 <__mcmp>
 801face:	1e05      	subs	r5, r0, #0
 801fad0:	d110      	bne.n	801faf4 <__mdiff+0x38>
 801fad2:	4629      	mov	r1, r5
 801fad4:	4630      	mov	r0, r6
 801fad6:	f7ff fd59 	bl	801f58c <_Balloc>
 801fada:	b930      	cbnz	r0, 801faea <__mdiff+0x2e>
 801fadc:	4b3a      	ldr	r3, [pc, #232]	; (801fbc8 <__mdiff+0x10c>)
 801fade:	4602      	mov	r2, r0
 801fae0:	f240 2137 	movw	r1, #567	; 0x237
 801fae4:	4839      	ldr	r0, [pc, #228]	; (801fbcc <__mdiff+0x110>)
 801fae6:	f7fd ff97 	bl	801da18 <__assert_func>
 801faea:	2301      	movs	r3, #1
 801faec:	e9c0 3504 	strd	r3, r5, [r0, #16]
 801faf0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801faf4:	bfa4      	itt	ge
 801faf6:	4643      	movge	r3, r8
 801faf8:	46a0      	movge	r8, r4
 801fafa:	4630      	mov	r0, r6
 801fafc:	f8d8 1004 	ldr.w	r1, [r8, #4]
 801fb00:	bfa6      	itte	ge
 801fb02:	461c      	movge	r4, r3
 801fb04:	2500      	movge	r5, #0
 801fb06:	2501      	movlt	r5, #1
 801fb08:	f7ff fd40 	bl	801f58c <_Balloc>
 801fb0c:	b920      	cbnz	r0, 801fb18 <__mdiff+0x5c>
 801fb0e:	4b2e      	ldr	r3, [pc, #184]	; (801fbc8 <__mdiff+0x10c>)
 801fb10:	4602      	mov	r2, r0
 801fb12:	f240 2145 	movw	r1, #581	; 0x245
 801fb16:	e7e5      	b.n	801fae4 <__mdiff+0x28>
 801fb18:	f8d8 7010 	ldr.w	r7, [r8, #16]
 801fb1c:	6926      	ldr	r6, [r4, #16]
 801fb1e:	60c5      	str	r5, [r0, #12]
 801fb20:	f104 0914 	add.w	r9, r4, #20
 801fb24:	f108 0514 	add.w	r5, r8, #20
 801fb28:	f100 0e14 	add.w	lr, r0, #20
 801fb2c:	eb05 0c87 	add.w	ip, r5, r7, lsl #2
 801fb30:	eb09 0686 	add.w	r6, r9, r6, lsl #2
 801fb34:	f108 0210 	add.w	r2, r8, #16
 801fb38:	46f2      	mov	sl, lr
 801fb3a:	2100      	movs	r1, #0
 801fb3c:	f859 3b04 	ldr.w	r3, [r9], #4
 801fb40:	f852 bf04 	ldr.w	fp, [r2, #4]!
 801fb44:	fa11 f88b 	uxtah	r8, r1, fp
 801fb48:	b299      	uxth	r1, r3
 801fb4a:	0c1b      	lsrs	r3, r3, #16
 801fb4c:	eba8 0801 	sub.w	r8, r8, r1
 801fb50:	ebc3 431b 	rsb	r3, r3, fp, lsr #16
 801fb54:	eb03 4328 	add.w	r3, r3, r8, asr #16
 801fb58:	fa1f f888 	uxth.w	r8, r8
 801fb5c:	1419      	asrs	r1, r3, #16
 801fb5e:	454e      	cmp	r6, r9
 801fb60:	ea48 4303 	orr.w	r3, r8, r3, lsl #16
 801fb64:	f84a 3b04 	str.w	r3, [sl], #4
 801fb68:	d8e8      	bhi.n	801fb3c <__mdiff+0x80>
 801fb6a:	1b33      	subs	r3, r6, r4
 801fb6c:	3b15      	subs	r3, #21
 801fb6e:	f023 0303 	bic.w	r3, r3, #3
 801fb72:	3304      	adds	r3, #4
 801fb74:	3415      	adds	r4, #21
 801fb76:	42a6      	cmp	r6, r4
 801fb78:	bf38      	it	cc
 801fb7a:	2304      	movcc	r3, #4
 801fb7c:	441d      	add	r5, r3
 801fb7e:	4473      	add	r3, lr
 801fb80:	469e      	mov	lr, r3
 801fb82:	462e      	mov	r6, r5
 801fb84:	4566      	cmp	r6, ip
 801fb86:	d30e      	bcc.n	801fba6 <__mdiff+0xea>
 801fb88:	f10c 0203 	add.w	r2, ip, #3
 801fb8c:	1b52      	subs	r2, r2, r5
 801fb8e:	f022 0203 	bic.w	r2, r2, #3
 801fb92:	3d03      	subs	r5, #3
 801fb94:	45ac      	cmp	ip, r5
 801fb96:	bf38      	it	cc
 801fb98:	2200      	movcc	r2, #0
 801fb9a:	4413      	add	r3, r2
 801fb9c:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 801fba0:	b17a      	cbz	r2, 801fbc2 <__mdiff+0x106>
 801fba2:	6107      	str	r7, [r0, #16]
 801fba4:	e7a4      	b.n	801faf0 <__mdiff+0x34>
 801fba6:	f856 8b04 	ldr.w	r8, [r6], #4
 801fbaa:	fa11 f288 	uxtah	r2, r1, r8
 801fbae:	1414      	asrs	r4, r2, #16
 801fbb0:	eb04 4418 	add.w	r4, r4, r8, lsr #16
 801fbb4:	b292      	uxth	r2, r2
 801fbb6:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
 801fbba:	f84e 2b04 	str.w	r2, [lr], #4
 801fbbe:	1421      	asrs	r1, r4, #16
 801fbc0:	e7e0      	b.n	801fb84 <__mdiff+0xc8>
 801fbc2:	3f01      	subs	r7, #1
 801fbc4:	e7ea      	b.n	801fb9c <__mdiff+0xe0>
 801fbc6:	bf00      	nop
 801fbc8:	08023977 	.word	0x08023977
 801fbcc:	08023988 	.word	0x08023988

0801fbd0 <__d2b>:
 801fbd0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 801fbd4:	460f      	mov	r7, r1
 801fbd6:	2101      	movs	r1, #1
 801fbd8:	ec59 8b10 	vmov	r8, r9, d0
 801fbdc:	4616      	mov	r6, r2
 801fbde:	f7ff fcd5 	bl	801f58c <_Balloc>
 801fbe2:	4604      	mov	r4, r0
 801fbe4:	b930      	cbnz	r0, 801fbf4 <__d2b+0x24>
 801fbe6:	4602      	mov	r2, r0
 801fbe8:	4b24      	ldr	r3, [pc, #144]	; (801fc7c <__d2b+0xac>)
 801fbea:	4825      	ldr	r0, [pc, #148]	; (801fc80 <__d2b+0xb0>)
 801fbec:	f240 310f 	movw	r1, #783	; 0x30f
 801fbf0:	f7fd ff12 	bl	801da18 <__assert_func>
 801fbf4:	f3c9 550a 	ubfx	r5, r9, #20, #11
 801fbf8:	f3c9 0313 	ubfx	r3, r9, #0, #20
 801fbfc:	bb2d      	cbnz	r5, 801fc4a <__d2b+0x7a>
 801fbfe:	9301      	str	r3, [sp, #4]
 801fc00:	f1b8 0300 	subs.w	r3, r8, #0
 801fc04:	d026      	beq.n	801fc54 <__d2b+0x84>
 801fc06:	4668      	mov	r0, sp
 801fc08:	9300      	str	r3, [sp, #0]
 801fc0a:	f7ff fd87 	bl	801f71c <__lo0bits>
 801fc0e:	e9dd 1200 	ldrd	r1, r2, [sp]
 801fc12:	b1e8      	cbz	r0, 801fc50 <__d2b+0x80>
 801fc14:	f1c0 0320 	rsb	r3, r0, #32
 801fc18:	fa02 f303 	lsl.w	r3, r2, r3
 801fc1c:	430b      	orrs	r3, r1
 801fc1e:	40c2      	lsrs	r2, r0
 801fc20:	6163      	str	r3, [r4, #20]
 801fc22:	9201      	str	r2, [sp, #4]
 801fc24:	9b01      	ldr	r3, [sp, #4]
 801fc26:	61a3      	str	r3, [r4, #24]
 801fc28:	2b00      	cmp	r3, #0
 801fc2a:	bf14      	ite	ne
 801fc2c:	2202      	movne	r2, #2
 801fc2e:	2201      	moveq	r2, #1
 801fc30:	6122      	str	r2, [r4, #16]
 801fc32:	b1bd      	cbz	r5, 801fc64 <__d2b+0x94>
 801fc34:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
 801fc38:	4405      	add	r5, r0
 801fc3a:	603d      	str	r5, [r7, #0]
 801fc3c:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 801fc40:	6030      	str	r0, [r6, #0]
 801fc42:	4620      	mov	r0, r4
 801fc44:	b003      	add	sp, #12
 801fc46:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801fc4a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 801fc4e:	e7d6      	b.n	801fbfe <__d2b+0x2e>
 801fc50:	6161      	str	r1, [r4, #20]
 801fc52:	e7e7      	b.n	801fc24 <__d2b+0x54>
 801fc54:	a801      	add	r0, sp, #4
 801fc56:	f7ff fd61 	bl	801f71c <__lo0bits>
 801fc5a:	9b01      	ldr	r3, [sp, #4]
 801fc5c:	6163      	str	r3, [r4, #20]
 801fc5e:	3020      	adds	r0, #32
 801fc60:	2201      	movs	r2, #1
 801fc62:	e7e5      	b.n	801fc30 <__d2b+0x60>
 801fc64:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 801fc68:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 801fc6c:	6038      	str	r0, [r7, #0]
 801fc6e:	6918      	ldr	r0, [r3, #16]
 801fc70:	f7ff fd34 	bl	801f6dc <__hi0bits>
 801fc74:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
 801fc78:	e7e2      	b.n	801fc40 <__d2b+0x70>
 801fc7a:	bf00      	nop
 801fc7c:	08023977 	.word	0x08023977
 801fc80:	08023988 	.word	0x08023988

0801fc84 <__ssputs_r>:
 801fc84:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801fc88:	688e      	ldr	r6, [r1, #8]
 801fc8a:	461f      	mov	r7, r3
 801fc8c:	42be      	cmp	r6, r7
 801fc8e:	680b      	ldr	r3, [r1, #0]
 801fc90:	4682      	mov	sl, r0
 801fc92:	460c      	mov	r4, r1
 801fc94:	4690      	mov	r8, r2
 801fc96:	d82c      	bhi.n	801fcf2 <__ssputs_r+0x6e>
 801fc98:	898a      	ldrh	r2, [r1, #12]
 801fc9a:	f412 6f90 	tst.w	r2, #1152	; 0x480
 801fc9e:	d026      	beq.n	801fcee <__ssputs_r+0x6a>
 801fca0:	6965      	ldr	r5, [r4, #20]
 801fca2:	6909      	ldr	r1, [r1, #16]
 801fca4:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 801fca8:	eba3 0901 	sub.w	r9, r3, r1
 801fcac:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 801fcb0:	1c7b      	adds	r3, r7, #1
 801fcb2:	444b      	add	r3, r9
 801fcb4:	106d      	asrs	r5, r5, #1
 801fcb6:	429d      	cmp	r5, r3
 801fcb8:	bf38      	it	cc
 801fcba:	461d      	movcc	r5, r3
 801fcbc:	0553      	lsls	r3, r2, #21
 801fcbe:	d527      	bpl.n	801fd10 <__ssputs_r+0x8c>
 801fcc0:	4629      	mov	r1, r5
 801fcc2:	f7ff fbd7 	bl	801f474 <_malloc_r>
 801fcc6:	4606      	mov	r6, r0
 801fcc8:	b360      	cbz	r0, 801fd24 <__ssputs_r+0xa0>
 801fcca:	6921      	ldr	r1, [r4, #16]
 801fccc:	464a      	mov	r2, r9
 801fcce:	f7fe fccb 	bl	801e668 <memcpy>
 801fcd2:	89a3      	ldrh	r3, [r4, #12]
 801fcd4:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 801fcd8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 801fcdc:	81a3      	strh	r3, [r4, #12]
 801fcde:	6126      	str	r6, [r4, #16]
 801fce0:	6165      	str	r5, [r4, #20]
 801fce2:	444e      	add	r6, r9
 801fce4:	eba5 0509 	sub.w	r5, r5, r9
 801fce8:	6026      	str	r6, [r4, #0]
 801fcea:	60a5      	str	r5, [r4, #8]
 801fcec:	463e      	mov	r6, r7
 801fcee:	42be      	cmp	r6, r7
 801fcf0:	d900      	bls.n	801fcf4 <__ssputs_r+0x70>
 801fcf2:	463e      	mov	r6, r7
 801fcf4:	6820      	ldr	r0, [r4, #0]
 801fcf6:	4632      	mov	r2, r6
 801fcf8:	4641      	mov	r1, r8
 801fcfa:	f000 fba3 	bl	8020444 <memmove>
 801fcfe:	68a3      	ldr	r3, [r4, #8]
 801fd00:	1b9b      	subs	r3, r3, r6
 801fd02:	60a3      	str	r3, [r4, #8]
 801fd04:	6823      	ldr	r3, [r4, #0]
 801fd06:	4433      	add	r3, r6
 801fd08:	6023      	str	r3, [r4, #0]
 801fd0a:	2000      	movs	r0, #0
 801fd0c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801fd10:	462a      	mov	r2, r5
 801fd12:	f000 fc2d 	bl	8020570 <_realloc_r>
 801fd16:	4606      	mov	r6, r0
 801fd18:	2800      	cmp	r0, #0
 801fd1a:	d1e0      	bne.n	801fcde <__ssputs_r+0x5a>
 801fd1c:	6921      	ldr	r1, [r4, #16]
 801fd1e:	4650      	mov	r0, sl
 801fd20:	f7ff fb34 	bl	801f38c <_free_r>
 801fd24:	230c      	movs	r3, #12
 801fd26:	f8ca 3000 	str.w	r3, [sl]
 801fd2a:	89a3      	ldrh	r3, [r4, #12]
 801fd2c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801fd30:	81a3      	strh	r3, [r4, #12]
 801fd32:	f04f 30ff 	mov.w	r0, #4294967295
 801fd36:	e7e9      	b.n	801fd0c <__ssputs_r+0x88>

0801fd38 <_svfiprintf_r>:
 801fd38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801fd3c:	4698      	mov	r8, r3
 801fd3e:	898b      	ldrh	r3, [r1, #12]
 801fd40:	061b      	lsls	r3, r3, #24
 801fd42:	b09d      	sub	sp, #116	; 0x74
 801fd44:	4607      	mov	r7, r0
 801fd46:	460d      	mov	r5, r1
 801fd48:	4614      	mov	r4, r2
 801fd4a:	d50e      	bpl.n	801fd6a <_svfiprintf_r+0x32>
 801fd4c:	690b      	ldr	r3, [r1, #16]
 801fd4e:	b963      	cbnz	r3, 801fd6a <_svfiprintf_r+0x32>
 801fd50:	2140      	movs	r1, #64	; 0x40
 801fd52:	f7ff fb8f 	bl	801f474 <_malloc_r>
 801fd56:	6028      	str	r0, [r5, #0]
 801fd58:	6128      	str	r0, [r5, #16]
 801fd5a:	b920      	cbnz	r0, 801fd66 <_svfiprintf_r+0x2e>
 801fd5c:	230c      	movs	r3, #12
 801fd5e:	603b      	str	r3, [r7, #0]
 801fd60:	f04f 30ff 	mov.w	r0, #4294967295
 801fd64:	e0d0      	b.n	801ff08 <_svfiprintf_r+0x1d0>
 801fd66:	2340      	movs	r3, #64	; 0x40
 801fd68:	616b      	str	r3, [r5, #20]
 801fd6a:	2300      	movs	r3, #0
 801fd6c:	9309      	str	r3, [sp, #36]	; 0x24
 801fd6e:	2320      	movs	r3, #32
 801fd70:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 801fd74:	f8cd 800c 	str.w	r8, [sp, #12]
 801fd78:	2330      	movs	r3, #48	; 0x30
 801fd7a:	f8df 81a4 	ldr.w	r8, [pc, #420]	; 801ff20 <_svfiprintf_r+0x1e8>
 801fd7e:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 801fd82:	f04f 0901 	mov.w	r9, #1
 801fd86:	4623      	mov	r3, r4
 801fd88:	469a      	mov	sl, r3
 801fd8a:	f813 2b01 	ldrb.w	r2, [r3], #1
 801fd8e:	b10a      	cbz	r2, 801fd94 <_svfiprintf_r+0x5c>
 801fd90:	2a25      	cmp	r2, #37	; 0x25
 801fd92:	d1f9      	bne.n	801fd88 <_svfiprintf_r+0x50>
 801fd94:	ebba 0b04 	subs.w	fp, sl, r4
 801fd98:	d00b      	beq.n	801fdb2 <_svfiprintf_r+0x7a>
 801fd9a:	465b      	mov	r3, fp
 801fd9c:	4622      	mov	r2, r4
 801fd9e:	4629      	mov	r1, r5
 801fda0:	4638      	mov	r0, r7
 801fda2:	f7ff ff6f 	bl	801fc84 <__ssputs_r>
 801fda6:	3001      	adds	r0, #1
 801fda8:	f000 80a9 	beq.w	801fefe <_svfiprintf_r+0x1c6>
 801fdac:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801fdae:	445a      	add	r2, fp
 801fdb0:	9209      	str	r2, [sp, #36]	; 0x24
 801fdb2:	f89a 3000 	ldrb.w	r3, [sl]
 801fdb6:	2b00      	cmp	r3, #0
 801fdb8:	f000 80a1 	beq.w	801fefe <_svfiprintf_r+0x1c6>
 801fdbc:	2300      	movs	r3, #0
 801fdbe:	f04f 32ff 	mov.w	r2, #4294967295
 801fdc2:	e9cd 2305 	strd	r2, r3, [sp, #20]
 801fdc6:	f10a 0a01 	add.w	sl, sl, #1
 801fdca:	9304      	str	r3, [sp, #16]
 801fdcc:	9307      	str	r3, [sp, #28]
 801fdce:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 801fdd2:	931a      	str	r3, [sp, #104]	; 0x68
 801fdd4:	4654      	mov	r4, sl
 801fdd6:	2205      	movs	r2, #5
 801fdd8:	f814 1b01 	ldrb.w	r1, [r4], #1
 801fddc:	4850      	ldr	r0, [pc, #320]	; (801ff20 <_svfiprintf_r+0x1e8>)
 801fdde:	f7e0 fa1f 	bl	8000220 <memchr>
 801fde2:	9a04      	ldr	r2, [sp, #16]
 801fde4:	b9d8      	cbnz	r0, 801fe1e <_svfiprintf_r+0xe6>
 801fde6:	06d0      	lsls	r0, r2, #27
 801fde8:	bf44      	itt	mi
 801fdea:	2320      	movmi	r3, #32
 801fdec:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 801fdf0:	0711      	lsls	r1, r2, #28
 801fdf2:	bf44      	itt	mi
 801fdf4:	232b      	movmi	r3, #43	; 0x2b
 801fdf6:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 801fdfa:	f89a 3000 	ldrb.w	r3, [sl]
 801fdfe:	2b2a      	cmp	r3, #42	; 0x2a
 801fe00:	d015      	beq.n	801fe2e <_svfiprintf_r+0xf6>
 801fe02:	9a07      	ldr	r2, [sp, #28]
 801fe04:	4654      	mov	r4, sl
 801fe06:	2000      	movs	r0, #0
 801fe08:	f04f 0c0a 	mov.w	ip, #10
 801fe0c:	4621      	mov	r1, r4
 801fe0e:	f811 3b01 	ldrb.w	r3, [r1], #1
 801fe12:	3b30      	subs	r3, #48	; 0x30
 801fe14:	2b09      	cmp	r3, #9
 801fe16:	d94d      	bls.n	801feb4 <_svfiprintf_r+0x17c>
 801fe18:	b1b0      	cbz	r0, 801fe48 <_svfiprintf_r+0x110>
 801fe1a:	9207      	str	r2, [sp, #28]
 801fe1c:	e014      	b.n	801fe48 <_svfiprintf_r+0x110>
 801fe1e:	eba0 0308 	sub.w	r3, r0, r8
 801fe22:	fa09 f303 	lsl.w	r3, r9, r3
 801fe26:	4313      	orrs	r3, r2
 801fe28:	9304      	str	r3, [sp, #16]
 801fe2a:	46a2      	mov	sl, r4
 801fe2c:	e7d2      	b.n	801fdd4 <_svfiprintf_r+0x9c>
 801fe2e:	9b03      	ldr	r3, [sp, #12]
 801fe30:	1d19      	adds	r1, r3, #4
 801fe32:	681b      	ldr	r3, [r3, #0]
 801fe34:	9103      	str	r1, [sp, #12]
 801fe36:	2b00      	cmp	r3, #0
 801fe38:	bfbb      	ittet	lt
 801fe3a:	425b      	neglt	r3, r3
 801fe3c:	f042 0202 	orrlt.w	r2, r2, #2
 801fe40:	9307      	strge	r3, [sp, #28]
 801fe42:	9307      	strlt	r3, [sp, #28]
 801fe44:	bfb8      	it	lt
 801fe46:	9204      	strlt	r2, [sp, #16]
 801fe48:	7823      	ldrb	r3, [r4, #0]
 801fe4a:	2b2e      	cmp	r3, #46	; 0x2e
 801fe4c:	d10c      	bne.n	801fe68 <_svfiprintf_r+0x130>
 801fe4e:	7863      	ldrb	r3, [r4, #1]
 801fe50:	2b2a      	cmp	r3, #42	; 0x2a
 801fe52:	d134      	bne.n	801febe <_svfiprintf_r+0x186>
 801fe54:	9b03      	ldr	r3, [sp, #12]
 801fe56:	1d1a      	adds	r2, r3, #4
 801fe58:	681b      	ldr	r3, [r3, #0]
 801fe5a:	9203      	str	r2, [sp, #12]
 801fe5c:	2b00      	cmp	r3, #0
 801fe5e:	bfb8      	it	lt
 801fe60:	f04f 33ff 	movlt.w	r3, #4294967295
 801fe64:	3402      	adds	r4, #2
 801fe66:	9305      	str	r3, [sp, #20]
 801fe68:	f8df a0c4 	ldr.w	sl, [pc, #196]	; 801ff30 <_svfiprintf_r+0x1f8>
 801fe6c:	7821      	ldrb	r1, [r4, #0]
 801fe6e:	2203      	movs	r2, #3
 801fe70:	4650      	mov	r0, sl
 801fe72:	f7e0 f9d5 	bl	8000220 <memchr>
 801fe76:	b138      	cbz	r0, 801fe88 <_svfiprintf_r+0x150>
 801fe78:	9b04      	ldr	r3, [sp, #16]
 801fe7a:	eba0 000a 	sub.w	r0, r0, sl
 801fe7e:	2240      	movs	r2, #64	; 0x40
 801fe80:	4082      	lsls	r2, r0
 801fe82:	4313      	orrs	r3, r2
 801fe84:	3401      	adds	r4, #1
 801fe86:	9304      	str	r3, [sp, #16]
 801fe88:	f814 1b01 	ldrb.w	r1, [r4], #1
 801fe8c:	4825      	ldr	r0, [pc, #148]	; (801ff24 <_svfiprintf_r+0x1ec>)
 801fe8e:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 801fe92:	2206      	movs	r2, #6
 801fe94:	f7e0 f9c4 	bl	8000220 <memchr>
 801fe98:	2800      	cmp	r0, #0
 801fe9a:	d038      	beq.n	801ff0e <_svfiprintf_r+0x1d6>
 801fe9c:	4b22      	ldr	r3, [pc, #136]	; (801ff28 <_svfiprintf_r+0x1f0>)
 801fe9e:	bb1b      	cbnz	r3, 801fee8 <_svfiprintf_r+0x1b0>
 801fea0:	9b03      	ldr	r3, [sp, #12]
 801fea2:	3307      	adds	r3, #7
 801fea4:	f023 0307 	bic.w	r3, r3, #7
 801fea8:	3308      	adds	r3, #8
 801feaa:	9303      	str	r3, [sp, #12]
 801feac:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801feae:	4433      	add	r3, r6
 801feb0:	9309      	str	r3, [sp, #36]	; 0x24
 801feb2:	e768      	b.n	801fd86 <_svfiprintf_r+0x4e>
 801feb4:	fb0c 3202 	mla	r2, ip, r2, r3
 801feb8:	460c      	mov	r4, r1
 801feba:	2001      	movs	r0, #1
 801febc:	e7a6      	b.n	801fe0c <_svfiprintf_r+0xd4>
 801febe:	2300      	movs	r3, #0
 801fec0:	3401      	adds	r4, #1
 801fec2:	9305      	str	r3, [sp, #20]
 801fec4:	4619      	mov	r1, r3
 801fec6:	f04f 0c0a 	mov.w	ip, #10
 801feca:	4620      	mov	r0, r4
 801fecc:	f810 2b01 	ldrb.w	r2, [r0], #1
 801fed0:	3a30      	subs	r2, #48	; 0x30
 801fed2:	2a09      	cmp	r2, #9
 801fed4:	d903      	bls.n	801fede <_svfiprintf_r+0x1a6>
 801fed6:	2b00      	cmp	r3, #0
 801fed8:	d0c6      	beq.n	801fe68 <_svfiprintf_r+0x130>
 801feda:	9105      	str	r1, [sp, #20]
 801fedc:	e7c4      	b.n	801fe68 <_svfiprintf_r+0x130>
 801fede:	fb0c 2101 	mla	r1, ip, r1, r2
 801fee2:	4604      	mov	r4, r0
 801fee4:	2301      	movs	r3, #1
 801fee6:	e7f0      	b.n	801feca <_svfiprintf_r+0x192>
 801fee8:	ab03      	add	r3, sp, #12
 801feea:	9300      	str	r3, [sp, #0]
 801feec:	462a      	mov	r2, r5
 801feee:	4b0f      	ldr	r3, [pc, #60]	; (801ff2c <_svfiprintf_r+0x1f4>)
 801fef0:	a904      	add	r1, sp, #16
 801fef2:	4638      	mov	r0, r7
 801fef4:	f7fd fe4e 	bl	801db94 <_printf_float>
 801fef8:	1c42      	adds	r2, r0, #1
 801fefa:	4606      	mov	r6, r0
 801fefc:	d1d6      	bne.n	801feac <_svfiprintf_r+0x174>
 801fefe:	89ab      	ldrh	r3, [r5, #12]
 801ff00:	065b      	lsls	r3, r3, #25
 801ff02:	f53f af2d 	bmi.w	801fd60 <_svfiprintf_r+0x28>
 801ff06:	9809      	ldr	r0, [sp, #36]	; 0x24
 801ff08:	b01d      	add	sp, #116	; 0x74
 801ff0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801ff0e:	ab03      	add	r3, sp, #12
 801ff10:	9300      	str	r3, [sp, #0]
 801ff12:	462a      	mov	r2, r5
 801ff14:	4b05      	ldr	r3, [pc, #20]	; (801ff2c <_svfiprintf_r+0x1f4>)
 801ff16:	a904      	add	r1, sp, #16
 801ff18:	4638      	mov	r0, r7
 801ff1a:	f7fe f8df 	bl	801e0dc <_printf_i>
 801ff1e:	e7eb      	b.n	801fef8 <_svfiprintf_r+0x1c0>
 801ff20:	08023ae4 	.word	0x08023ae4
 801ff24:	08023aee 	.word	0x08023aee
 801ff28:	0801db95 	.word	0x0801db95
 801ff2c:	0801fc85 	.word	0x0801fc85
 801ff30:	08023aea 	.word	0x08023aea

0801ff34 <__sfputc_r>:
 801ff34:	6893      	ldr	r3, [r2, #8]
 801ff36:	3b01      	subs	r3, #1
 801ff38:	2b00      	cmp	r3, #0
 801ff3a:	b410      	push	{r4}
 801ff3c:	6093      	str	r3, [r2, #8]
 801ff3e:	da08      	bge.n	801ff52 <__sfputc_r+0x1e>
 801ff40:	6994      	ldr	r4, [r2, #24]
 801ff42:	42a3      	cmp	r3, r4
 801ff44:	db01      	blt.n	801ff4a <__sfputc_r+0x16>
 801ff46:	290a      	cmp	r1, #10
 801ff48:	d103      	bne.n	801ff52 <__sfputc_r+0x1e>
 801ff4a:	f85d 4b04 	ldr.w	r4, [sp], #4
 801ff4e:	f000 b9e3 	b.w	8020318 <__swbuf_r>
 801ff52:	6813      	ldr	r3, [r2, #0]
 801ff54:	1c58      	adds	r0, r3, #1
 801ff56:	6010      	str	r0, [r2, #0]
 801ff58:	7019      	strb	r1, [r3, #0]
 801ff5a:	4608      	mov	r0, r1
 801ff5c:	f85d 4b04 	ldr.w	r4, [sp], #4
 801ff60:	4770      	bx	lr

0801ff62 <__sfputs_r>:
 801ff62:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801ff64:	4606      	mov	r6, r0
 801ff66:	460f      	mov	r7, r1
 801ff68:	4614      	mov	r4, r2
 801ff6a:	18d5      	adds	r5, r2, r3
 801ff6c:	42ac      	cmp	r4, r5
 801ff6e:	d101      	bne.n	801ff74 <__sfputs_r+0x12>
 801ff70:	2000      	movs	r0, #0
 801ff72:	e007      	b.n	801ff84 <__sfputs_r+0x22>
 801ff74:	f814 1b01 	ldrb.w	r1, [r4], #1
 801ff78:	463a      	mov	r2, r7
 801ff7a:	4630      	mov	r0, r6
 801ff7c:	f7ff ffda 	bl	801ff34 <__sfputc_r>
 801ff80:	1c43      	adds	r3, r0, #1
 801ff82:	d1f3      	bne.n	801ff6c <__sfputs_r+0xa>
 801ff84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0801ff88 <_vfiprintf_r>:
 801ff88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ff8c:	460d      	mov	r5, r1
 801ff8e:	b09d      	sub	sp, #116	; 0x74
 801ff90:	4614      	mov	r4, r2
 801ff92:	4698      	mov	r8, r3
 801ff94:	4606      	mov	r6, r0
 801ff96:	b118      	cbz	r0, 801ffa0 <_vfiprintf_r+0x18>
 801ff98:	6a03      	ldr	r3, [r0, #32]
 801ff9a:	b90b      	cbnz	r3, 801ffa0 <_vfiprintf_r+0x18>
 801ff9c:	f7fe fa3a 	bl	801e414 <__sinit>
 801ffa0:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 801ffa2:	07d9      	lsls	r1, r3, #31
 801ffa4:	d405      	bmi.n	801ffb2 <_vfiprintf_r+0x2a>
 801ffa6:	89ab      	ldrh	r3, [r5, #12]
 801ffa8:	059a      	lsls	r2, r3, #22
 801ffaa:	d402      	bmi.n	801ffb2 <_vfiprintf_r+0x2a>
 801ffac:	6da8      	ldr	r0, [r5, #88]	; 0x58
 801ffae:	f7fe fb59 	bl	801e664 <__retarget_lock_acquire_recursive>
 801ffb2:	89ab      	ldrh	r3, [r5, #12]
 801ffb4:	071b      	lsls	r3, r3, #28
 801ffb6:	d501      	bpl.n	801ffbc <_vfiprintf_r+0x34>
 801ffb8:	692b      	ldr	r3, [r5, #16]
 801ffba:	b99b      	cbnz	r3, 801ffe4 <_vfiprintf_r+0x5c>
 801ffbc:	4629      	mov	r1, r5
 801ffbe:	4630      	mov	r0, r6
 801ffc0:	f000 f9e8 	bl	8020394 <__swsetup_r>
 801ffc4:	b170      	cbz	r0, 801ffe4 <_vfiprintf_r+0x5c>
 801ffc6:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 801ffc8:	07dc      	lsls	r4, r3, #31
 801ffca:	d504      	bpl.n	801ffd6 <_vfiprintf_r+0x4e>
 801ffcc:	f04f 30ff 	mov.w	r0, #4294967295
 801ffd0:	b01d      	add	sp, #116	; 0x74
 801ffd2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801ffd6:	89ab      	ldrh	r3, [r5, #12]
 801ffd8:	0598      	lsls	r0, r3, #22
 801ffda:	d4f7      	bmi.n	801ffcc <_vfiprintf_r+0x44>
 801ffdc:	6da8      	ldr	r0, [r5, #88]	; 0x58
 801ffde:	f7fe fb42 	bl	801e666 <__retarget_lock_release_recursive>
 801ffe2:	e7f3      	b.n	801ffcc <_vfiprintf_r+0x44>
 801ffe4:	2300      	movs	r3, #0
 801ffe6:	9309      	str	r3, [sp, #36]	; 0x24
 801ffe8:	2320      	movs	r3, #32
 801ffea:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 801ffee:	f8cd 800c 	str.w	r8, [sp, #12]
 801fff2:	2330      	movs	r3, #48	; 0x30
 801fff4:	f8df 81b0 	ldr.w	r8, [pc, #432]	; 80201a8 <_vfiprintf_r+0x220>
 801fff8:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 801fffc:	f04f 0901 	mov.w	r9, #1
 8020000:	4623      	mov	r3, r4
 8020002:	469a      	mov	sl, r3
 8020004:	f813 2b01 	ldrb.w	r2, [r3], #1
 8020008:	b10a      	cbz	r2, 802000e <_vfiprintf_r+0x86>
 802000a:	2a25      	cmp	r2, #37	; 0x25
 802000c:	d1f9      	bne.n	8020002 <_vfiprintf_r+0x7a>
 802000e:	ebba 0b04 	subs.w	fp, sl, r4
 8020012:	d00b      	beq.n	802002c <_vfiprintf_r+0xa4>
 8020014:	465b      	mov	r3, fp
 8020016:	4622      	mov	r2, r4
 8020018:	4629      	mov	r1, r5
 802001a:	4630      	mov	r0, r6
 802001c:	f7ff ffa1 	bl	801ff62 <__sfputs_r>
 8020020:	3001      	adds	r0, #1
 8020022:	f000 80a9 	beq.w	8020178 <_vfiprintf_r+0x1f0>
 8020026:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8020028:	445a      	add	r2, fp
 802002a:	9209      	str	r2, [sp, #36]	; 0x24
 802002c:	f89a 3000 	ldrb.w	r3, [sl]
 8020030:	2b00      	cmp	r3, #0
 8020032:	f000 80a1 	beq.w	8020178 <_vfiprintf_r+0x1f0>
 8020036:	2300      	movs	r3, #0
 8020038:	f04f 32ff 	mov.w	r2, #4294967295
 802003c:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8020040:	f10a 0a01 	add.w	sl, sl, #1
 8020044:	9304      	str	r3, [sp, #16]
 8020046:	9307      	str	r3, [sp, #28]
 8020048:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 802004c:	931a      	str	r3, [sp, #104]	; 0x68
 802004e:	4654      	mov	r4, sl
 8020050:	2205      	movs	r2, #5
 8020052:	f814 1b01 	ldrb.w	r1, [r4], #1
 8020056:	4854      	ldr	r0, [pc, #336]	; (80201a8 <_vfiprintf_r+0x220>)
 8020058:	f7e0 f8e2 	bl	8000220 <memchr>
 802005c:	9a04      	ldr	r2, [sp, #16]
 802005e:	b9d8      	cbnz	r0, 8020098 <_vfiprintf_r+0x110>
 8020060:	06d1      	lsls	r1, r2, #27
 8020062:	bf44      	itt	mi
 8020064:	2320      	movmi	r3, #32
 8020066:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 802006a:	0713      	lsls	r3, r2, #28
 802006c:	bf44      	itt	mi
 802006e:	232b      	movmi	r3, #43	; 0x2b
 8020070:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8020074:	f89a 3000 	ldrb.w	r3, [sl]
 8020078:	2b2a      	cmp	r3, #42	; 0x2a
 802007a:	d015      	beq.n	80200a8 <_vfiprintf_r+0x120>
 802007c:	9a07      	ldr	r2, [sp, #28]
 802007e:	4654      	mov	r4, sl
 8020080:	2000      	movs	r0, #0
 8020082:	f04f 0c0a 	mov.w	ip, #10
 8020086:	4621      	mov	r1, r4
 8020088:	f811 3b01 	ldrb.w	r3, [r1], #1
 802008c:	3b30      	subs	r3, #48	; 0x30
 802008e:	2b09      	cmp	r3, #9
 8020090:	d94d      	bls.n	802012e <_vfiprintf_r+0x1a6>
 8020092:	b1b0      	cbz	r0, 80200c2 <_vfiprintf_r+0x13a>
 8020094:	9207      	str	r2, [sp, #28]
 8020096:	e014      	b.n	80200c2 <_vfiprintf_r+0x13a>
 8020098:	eba0 0308 	sub.w	r3, r0, r8
 802009c:	fa09 f303 	lsl.w	r3, r9, r3
 80200a0:	4313      	orrs	r3, r2
 80200a2:	9304      	str	r3, [sp, #16]
 80200a4:	46a2      	mov	sl, r4
 80200a6:	e7d2      	b.n	802004e <_vfiprintf_r+0xc6>
 80200a8:	9b03      	ldr	r3, [sp, #12]
 80200aa:	1d19      	adds	r1, r3, #4
 80200ac:	681b      	ldr	r3, [r3, #0]
 80200ae:	9103      	str	r1, [sp, #12]
 80200b0:	2b00      	cmp	r3, #0
 80200b2:	bfbb      	ittet	lt
 80200b4:	425b      	neglt	r3, r3
 80200b6:	f042 0202 	orrlt.w	r2, r2, #2
 80200ba:	9307      	strge	r3, [sp, #28]
 80200bc:	9307      	strlt	r3, [sp, #28]
 80200be:	bfb8      	it	lt
 80200c0:	9204      	strlt	r2, [sp, #16]
 80200c2:	7823      	ldrb	r3, [r4, #0]
 80200c4:	2b2e      	cmp	r3, #46	; 0x2e
 80200c6:	d10c      	bne.n	80200e2 <_vfiprintf_r+0x15a>
 80200c8:	7863      	ldrb	r3, [r4, #1]
 80200ca:	2b2a      	cmp	r3, #42	; 0x2a
 80200cc:	d134      	bne.n	8020138 <_vfiprintf_r+0x1b0>
 80200ce:	9b03      	ldr	r3, [sp, #12]
 80200d0:	1d1a      	adds	r2, r3, #4
 80200d2:	681b      	ldr	r3, [r3, #0]
 80200d4:	9203      	str	r2, [sp, #12]
 80200d6:	2b00      	cmp	r3, #0
 80200d8:	bfb8      	it	lt
 80200da:	f04f 33ff 	movlt.w	r3, #4294967295
 80200de:	3402      	adds	r4, #2
 80200e0:	9305      	str	r3, [sp, #20]
 80200e2:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 80201b8 <_vfiprintf_r+0x230>
 80200e6:	7821      	ldrb	r1, [r4, #0]
 80200e8:	2203      	movs	r2, #3
 80200ea:	4650      	mov	r0, sl
 80200ec:	f7e0 f898 	bl	8000220 <memchr>
 80200f0:	b138      	cbz	r0, 8020102 <_vfiprintf_r+0x17a>
 80200f2:	9b04      	ldr	r3, [sp, #16]
 80200f4:	eba0 000a 	sub.w	r0, r0, sl
 80200f8:	2240      	movs	r2, #64	; 0x40
 80200fa:	4082      	lsls	r2, r0
 80200fc:	4313      	orrs	r3, r2
 80200fe:	3401      	adds	r4, #1
 8020100:	9304      	str	r3, [sp, #16]
 8020102:	f814 1b01 	ldrb.w	r1, [r4], #1
 8020106:	4829      	ldr	r0, [pc, #164]	; (80201ac <_vfiprintf_r+0x224>)
 8020108:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 802010c:	2206      	movs	r2, #6
 802010e:	f7e0 f887 	bl	8000220 <memchr>
 8020112:	2800      	cmp	r0, #0
 8020114:	d03f      	beq.n	8020196 <_vfiprintf_r+0x20e>
 8020116:	4b26      	ldr	r3, [pc, #152]	; (80201b0 <_vfiprintf_r+0x228>)
 8020118:	bb1b      	cbnz	r3, 8020162 <_vfiprintf_r+0x1da>
 802011a:	9b03      	ldr	r3, [sp, #12]
 802011c:	3307      	adds	r3, #7
 802011e:	f023 0307 	bic.w	r3, r3, #7
 8020122:	3308      	adds	r3, #8
 8020124:	9303      	str	r3, [sp, #12]
 8020126:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020128:	443b      	add	r3, r7
 802012a:	9309      	str	r3, [sp, #36]	; 0x24
 802012c:	e768      	b.n	8020000 <_vfiprintf_r+0x78>
 802012e:	fb0c 3202 	mla	r2, ip, r2, r3
 8020132:	460c      	mov	r4, r1
 8020134:	2001      	movs	r0, #1
 8020136:	e7a6      	b.n	8020086 <_vfiprintf_r+0xfe>
 8020138:	2300      	movs	r3, #0
 802013a:	3401      	adds	r4, #1
 802013c:	9305      	str	r3, [sp, #20]
 802013e:	4619      	mov	r1, r3
 8020140:	f04f 0c0a 	mov.w	ip, #10
 8020144:	4620      	mov	r0, r4
 8020146:	f810 2b01 	ldrb.w	r2, [r0], #1
 802014a:	3a30      	subs	r2, #48	; 0x30
 802014c:	2a09      	cmp	r2, #9
 802014e:	d903      	bls.n	8020158 <_vfiprintf_r+0x1d0>
 8020150:	2b00      	cmp	r3, #0
 8020152:	d0c6      	beq.n	80200e2 <_vfiprintf_r+0x15a>
 8020154:	9105      	str	r1, [sp, #20]
 8020156:	e7c4      	b.n	80200e2 <_vfiprintf_r+0x15a>
 8020158:	fb0c 2101 	mla	r1, ip, r1, r2
 802015c:	4604      	mov	r4, r0
 802015e:	2301      	movs	r3, #1
 8020160:	e7f0      	b.n	8020144 <_vfiprintf_r+0x1bc>
 8020162:	ab03      	add	r3, sp, #12
 8020164:	9300      	str	r3, [sp, #0]
 8020166:	462a      	mov	r2, r5
 8020168:	4b12      	ldr	r3, [pc, #72]	; (80201b4 <_vfiprintf_r+0x22c>)
 802016a:	a904      	add	r1, sp, #16
 802016c:	4630      	mov	r0, r6
 802016e:	f7fd fd11 	bl	801db94 <_printf_float>
 8020172:	4607      	mov	r7, r0
 8020174:	1c78      	adds	r0, r7, #1
 8020176:	d1d6      	bne.n	8020126 <_vfiprintf_r+0x19e>
 8020178:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 802017a:	07d9      	lsls	r1, r3, #31
 802017c:	d405      	bmi.n	802018a <_vfiprintf_r+0x202>
 802017e:	89ab      	ldrh	r3, [r5, #12]
 8020180:	059a      	lsls	r2, r3, #22
 8020182:	d402      	bmi.n	802018a <_vfiprintf_r+0x202>
 8020184:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8020186:	f7fe fa6e 	bl	801e666 <__retarget_lock_release_recursive>
 802018a:	89ab      	ldrh	r3, [r5, #12]
 802018c:	065b      	lsls	r3, r3, #25
 802018e:	f53f af1d 	bmi.w	801ffcc <_vfiprintf_r+0x44>
 8020192:	9809      	ldr	r0, [sp, #36]	; 0x24
 8020194:	e71c      	b.n	801ffd0 <_vfiprintf_r+0x48>
 8020196:	ab03      	add	r3, sp, #12
 8020198:	9300      	str	r3, [sp, #0]
 802019a:	462a      	mov	r2, r5
 802019c:	4b05      	ldr	r3, [pc, #20]	; (80201b4 <_vfiprintf_r+0x22c>)
 802019e:	a904      	add	r1, sp, #16
 80201a0:	4630      	mov	r0, r6
 80201a2:	f7fd ff9b 	bl	801e0dc <_printf_i>
 80201a6:	e7e4      	b.n	8020172 <_vfiprintf_r+0x1ea>
 80201a8:	08023ae4 	.word	0x08023ae4
 80201ac:	08023aee 	.word	0x08023aee
 80201b0:	0801db95 	.word	0x0801db95
 80201b4:	0801ff63 	.word	0x0801ff63
 80201b8:	08023aea 	.word	0x08023aea

080201bc <__sflush_r>:
 80201bc:	898a      	ldrh	r2, [r1, #12]
 80201be:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80201c2:	4605      	mov	r5, r0
 80201c4:	0710      	lsls	r0, r2, #28
 80201c6:	460c      	mov	r4, r1
 80201c8:	d458      	bmi.n	802027c <__sflush_r+0xc0>
 80201ca:	684b      	ldr	r3, [r1, #4]
 80201cc:	2b00      	cmp	r3, #0
 80201ce:	dc05      	bgt.n	80201dc <__sflush_r+0x20>
 80201d0:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 80201d2:	2b00      	cmp	r3, #0
 80201d4:	dc02      	bgt.n	80201dc <__sflush_r+0x20>
 80201d6:	2000      	movs	r0, #0
 80201d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80201dc:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 80201de:	2e00      	cmp	r6, #0
 80201e0:	d0f9      	beq.n	80201d6 <__sflush_r+0x1a>
 80201e2:	2300      	movs	r3, #0
 80201e4:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 80201e8:	682f      	ldr	r7, [r5, #0]
 80201ea:	6a21      	ldr	r1, [r4, #32]
 80201ec:	602b      	str	r3, [r5, #0]
 80201ee:	d032      	beq.n	8020256 <__sflush_r+0x9a>
 80201f0:	6d60      	ldr	r0, [r4, #84]	; 0x54
 80201f2:	89a3      	ldrh	r3, [r4, #12]
 80201f4:	075a      	lsls	r2, r3, #29
 80201f6:	d505      	bpl.n	8020204 <__sflush_r+0x48>
 80201f8:	6863      	ldr	r3, [r4, #4]
 80201fa:	1ac0      	subs	r0, r0, r3
 80201fc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80201fe:	b10b      	cbz	r3, 8020204 <__sflush_r+0x48>
 8020200:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8020202:	1ac0      	subs	r0, r0, r3
 8020204:	2300      	movs	r3, #0
 8020206:	4602      	mov	r2, r0
 8020208:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 802020a:	6a21      	ldr	r1, [r4, #32]
 802020c:	4628      	mov	r0, r5
 802020e:	47b0      	blx	r6
 8020210:	1c43      	adds	r3, r0, #1
 8020212:	89a3      	ldrh	r3, [r4, #12]
 8020214:	d106      	bne.n	8020224 <__sflush_r+0x68>
 8020216:	6829      	ldr	r1, [r5, #0]
 8020218:	291d      	cmp	r1, #29
 802021a:	d82b      	bhi.n	8020274 <__sflush_r+0xb8>
 802021c:	4a29      	ldr	r2, [pc, #164]	; (80202c4 <__sflush_r+0x108>)
 802021e:	410a      	asrs	r2, r1
 8020220:	07d6      	lsls	r6, r2, #31
 8020222:	d427      	bmi.n	8020274 <__sflush_r+0xb8>
 8020224:	2200      	movs	r2, #0
 8020226:	6062      	str	r2, [r4, #4]
 8020228:	04d9      	lsls	r1, r3, #19
 802022a:	6922      	ldr	r2, [r4, #16]
 802022c:	6022      	str	r2, [r4, #0]
 802022e:	d504      	bpl.n	802023a <__sflush_r+0x7e>
 8020230:	1c42      	adds	r2, r0, #1
 8020232:	d101      	bne.n	8020238 <__sflush_r+0x7c>
 8020234:	682b      	ldr	r3, [r5, #0]
 8020236:	b903      	cbnz	r3, 802023a <__sflush_r+0x7e>
 8020238:	6560      	str	r0, [r4, #84]	; 0x54
 802023a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802023c:	602f      	str	r7, [r5, #0]
 802023e:	2900      	cmp	r1, #0
 8020240:	d0c9      	beq.n	80201d6 <__sflush_r+0x1a>
 8020242:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8020246:	4299      	cmp	r1, r3
 8020248:	d002      	beq.n	8020250 <__sflush_r+0x94>
 802024a:	4628      	mov	r0, r5
 802024c:	f7ff f89e 	bl	801f38c <_free_r>
 8020250:	2000      	movs	r0, #0
 8020252:	6360      	str	r0, [r4, #52]	; 0x34
 8020254:	e7c0      	b.n	80201d8 <__sflush_r+0x1c>
 8020256:	2301      	movs	r3, #1
 8020258:	4628      	mov	r0, r5
 802025a:	47b0      	blx	r6
 802025c:	1c41      	adds	r1, r0, #1
 802025e:	d1c8      	bne.n	80201f2 <__sflush_r+0x36>
 8020260:	682b      	ldr	r3, [r5, #0]
 8020262:	2b00      	cmp	r3, #0
 8020264:	d0c5      	beq.n	80201f2 <__sflush_r+0x36>
 8020266:	2b1d      	cmp	r3, #29
 8020268:	d001      	beq.n	802026e <__sflush_r+0xb2>
 802026a:	2b16      	cmp	r3, #22
 802026c:	d101      	bne.n	8020272 <__sflush_r+0xb6>
 802026e:	602f      	str	r7, [r5, #0]
 8020270:	e7b1      	b.n	80201d6 <__sflush_r+0x1a>
 8020272:	89a3      	ldrh	r3, [r4, #12]
 8020274:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8020278:	81a3      	strh	r3, [r4, #12]
 802027a:	e7ad      	b.n	80201d8 <__sflush_r+0x1c>
 802027c:	690f      	ldr	r7, [r1, #16]
 802027e:	2f00      	cmp	r7, #0
 8020280:	d0a9      	beq.n	80201d6 <__sflush_r+0x1a>
 8020282:	0793      	lsls	r3, r2, #30
 8020284:	680e      	ldr	r6, [r1, #0]
 8020286:	bf08      	it	eq
 8020288:	694b      	ldreq	r3, [r1, #20]
 802028a:	600f      	str	r7, [r1, #0]
 802028c:	bf18      	it	ne
 802028e:	2300      	movne	r3, #0
 8020290:	eba6 0807 	sub.w	r8, r6, r7
 8020294:	608b      	str	r3, [r1, #8]
 8020296:	f1b8 0f00 	cmp.w	r8, #0
 802029a:	dd9c      	ble.n	80201d6 <__sflush_r+0x1a>
 802029c:	6a21      	ldr	r1, [r4, #32]
 802029e:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 80202a0:	4643      	mov	r3, r8
 80202a2:	463a      	mov	r2, r7
 80202a4:	4628      	mov	r0, r5
 80202a6:	47b0      	blx	r6
 80202a8:	2800      	cmp	r0, #0
 80202aa:	dc06      	bgt.n	80202ba <__sflush_r+0xfe>
 80202ac:	89a3      	ldrh	r3, [r4, #12]
 80202ae:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80202b2:	81a3      	strh	r3, [r4, #12]
 80202b4:	f04f 30ff 	mov.w	r0, #4294967295
 80202b8:	e78e      	b.n	80201d8 <__sflush_r+0x1c>
 80202ba:	4407      	add	r7, r0
 80202bc:	eba8 0800 	sub.w	r8, r8, r0
 80202c0:	e7e9      	b.n	8020296 <__sflush_r+0xda>
 80202c2:	bf00      	nop
 80202c4:	dfbffffe 	.word	0xdfbffffe

080202c8 <_fflush_r>:
 80202c8:	b538      	push	{r3, r4, r5, lr}
 80202ca:	690b      	ldr	r3, [r1, #16]
 80202cc:	4605      	mov	r5, r0
 80202ce:	460c      	mov	r4, r1
 80202d0:	b913      	cbnz	r3, 80202d8 <_fflush_r+0x10>
 80202d2:	2500      	movs	r5, #0
 80202d4:	4628      	mov	r0, r5
 80202d6:	bd38      	pop	{r3, r4, r5, pc}
 80202d8:	b118      	cbz	r0, 80202e2 <_fflush_r+0x1a>
 80202da:	6a03      	ldr	r3, [r0, #32]
 80202dc:	b90b      	cbnz	r3, 80202e2 <_fflush_r+0x1a>
 80202de:	f7fe f899 	bl	801e414 <__sinit>
 80202e2:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80202e6:	2b00      	cmp	r3, #0
 80202e8:	d0f3      	beq.n	80202d2 <_fflush_r+0xa>
 80202ea:	6e62      	ldr	r2, [r4, #100]	; 0x64
 80202ec:	07d0      	lsls	r0, r2, #31
 80202ee:	d404      	bmi.n	80202fa <_fflush_r+0x32>
 80202f0:	0599      	lsls	r1, r3, #22
 80202f2:	d402      	bmi.n	80202fa <_fflush_r+0x32>
 80202f4:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80202f6:	f7fe f9b5 	bl	801e664 <__retarget_lock_acquire_recursive>
 80202fa:	4628      	mov	r0, r5
 80202fc:	4621      	mov	r1, r4
 80202fe:	f7ff ff5d 	bl	80201bc <__sflush_r>
 8020302:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8020304:	07da      	lsls	r2, r3, #31
 8020306:	4605      	mov	r5, r0
 8020308:	d4e4      	bmi.n	80202d4 <_fflush_r+0xc>
 802030a:	89a3      	ldrh	r3, [r4, #12]
 802030c:	059b      	lsls	r3, r3, #22
 802030e:	d4e1      	bmi.n	80202d4 <_fflush_r+0xc>
 8020310:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8020312:	f7fe f9a8 	bl	801e666 <__retarget_lock_release_recursive>
 8020316:	e7dd      	b.n	80202d4 <_fflush_r+0xc>

08020318 <__swbuf_r>:
 8020318:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802031a:	460e      	mov	r6, r1
 802031c:	4614      	mov	r4, r2
 802031e:	4605      	mov	r5, r0
 8020320:	b118      	cbz	r0, 802032a <__swbuf_r+0x12>
 8020322:	6a03      	ldr	r3, [r0, #32]
 8020324:	b90b      	cbnz	r3, 802032a <__swbuf_r+0x12>
 8020326:	f7fe f875 	bl	801e414 <__sinit>
 802032a:	69a3      	ldr	r3, [r4, #24]
 802032c:	60a3      	str	r3, [r4, #8]
 802032e:	89a3      	ldrh	r3, [r4, #12]
 8020330:	071a      	lsls	r2, r3, #28
 8020332:	d525      	bpl.n	8020380 <__swbuf_r+0x68>
 8020334:	6923      	ldr	r3, [r4, #16]
 8020336:	b31b      	cbz	r3, 8020380 <__swbuf_r+0x68>
 8020338:	6823      	ldr	r3, [r4, #0]
 802033a:	6922      	ldr	r2, [r4, #16]
 802033c:	1a98      	subs	r0, r3, r2
 802033e:	6963      	ldr	r3, [r4, #20]
 8020340:	b2f6      	uxtb	r6, r6
 8020342:	4283      	cmp	r3, r0
 8020344:	4637      	mov	r7, r6
 8020346:	dc04      	bgt.n	8020352 <__swbuf_r+0x3a>
 8020348:	4621      	mov	r1, r4
 802034a:	4628      	mov	r0, r5
 802034c:	f7ff ffbc 	bl	80202c8 <_fflush_r>
 8020350:	b9e0      	cbnz	r0, 802038c <__swbuf_r+0x74>
 8020352:	68a3      	ldr	r3, [r4, #8]
 8020354:	3b01      	subs	r3, #1
 8020356:	60a3      	str	r3, [r4, #8]
 8020358:	6823      	ldr	r3, [r4, #0]
 802035a:	1c5a      	adds	r2, r3, #1
 802035c:	6022      	str	r2, [r4, #0]
 802035e:	701e      	strb	r6, [r3, #0]
 8020360:	6962      	ldr	r2, [r4, #20]
 8020362:	1c43      	adds	r3, r0, #1
 8020364:	429a      	cmp	r2, r3
 8020366:	d004      	beq.n	8020372 <__swbuf_r+0x5a>
 8020368:	89a3      	ldrh	r3, [r4, #12]
 802036a:	07db      	lsls	r3, r3, #31
 802036c:	d506      	bpl.n	802037c <__swbuf_r+0x64>
 802036e:	2e0a      	cmp	r6, #10
 8020370:	d104      	bne.n	802037c <__swbuf_r+0x64>
 8020372:	4621      	mov	r1, r4
 8020374:	4628      	mov	r0, r5
 8020376:	f7ff ffa7 	bl	80202c8 <_fflush_r>
 802037a:	b938      	cbnz	r0, 802038c <__swbuf_r+0x74>
 802037c:	4638      	mov	r0, r7
 802037e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8020380:	4621      	mov	r1, r4
 8020382:	4628      	mov	r0, r5
 8020384:	f000 f806 	bl	8020394 <__swsetup_r>
 8020388:	2800      	cmp	r0, #0
 802038a:	d0d5      	beq.n	8020338 <__swbuf_r+0x20>
 802038c:	f04f 37ff 	mov.w	r7, #4294967295
 8020390:	e7f4      	b.n	802037c <__swbuf_r+0x64>
	...

08020394 <__swsetup_r>:
 8020394:	b538      	push	{r3, r4, r5, lr}
 8020396:	4b2a      	ldr	r3, [pc, #168]	; (8020440 <__swsetup_r+0xac>)
 8020398:	4605      	mov	r5, r0
 802039a:	6818      	ldr	r0, [r3, #0]
 802039c:	460c      	mov	r4, r1
 802039e:	b118      	cbz	r0, 80203a8 <__swsetup_r+0x14>
 80203a0:	6a03      	ldr	r3, [r0, #32]
 80203a2:	b90b      	cbnz	r3, 80203a8 <__swsetup_r+0x14>
 80203a4:	f7fe f836 	bl	801e414 <__sinit>
 80203a8:	89a3      	ldrh	r3, [r4, #12]
 80203aa:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 80203ae:	0718      	lsls	r0, r3, #28
 80203b0:	d422      	bmi.n	80203f8 <__swsetup_r+0x64>
 80203b2:	06d9      	lsls	r1, r3, #27
 80203b4:	d407      	bmi.n	80203c6 <__swsetup_r+0x32>
 80203b6:	2309      	movs	r3, #9
 80203b8:	602b      	str	r3, [r5, #0]
 80203ba:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 80203be:	81a3      	strh	r3, [r4, #12]
 80203c0:	f04f 30ff 	mov.w	r0, #4294967295
 80203c4:	e034      	b.n	8020430 <__swsetup_r+0x9c>
 80203c6:	0758      	lsls	r0, r3, #29
 80203c8:	d512      	bpl.n	80203f0 <__swsetup_r+0x5c>
 80203ca:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80203cc:	b141      	cbz	r1, 80203e0 <__swsetup_r+0x4c>
 80203ce:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80203d2:	4299      	cmp	r1, r3
 80203d4:	d002      	beq.n	80203dc <__swsetup_r+0x48>
 80203d6:	4628      	mov	r0, r5
 80203d8:	f7fe ffd8 	bl	801f38c <_free_r>
 80203dc:	2300      	movs	r3, #0
 80203de:	6363      	str	r3, [r4, #52]	; 0x34
 80203e0:	89a3      	ldrh	r3, [r4, #12]
 80203e2:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 80203e6:	81a3      	strh	r3, [r4, #12]
 80203e8:	2300      	movs	r3, #0
 80203ea:	6063      	str	r3, [r4, #4]
 80203ec:	6923      	ldr	r3, [r4, #16]
 80203ee:	6023      	str	r3, [r4, #0]
 80203f0:	89a3      	ldrh	r3, [r4, #12]
 80203f2:	f043 0308 	orr.w	r3, r3, #8
 80203f6:	81a3      	strh	r3, [r4, #12]
 80203f8:	6923      	ldr	r3, [r4, #16]
 80203fa:	b94b      	cbnz	r3, 8020410 <__swsetup_r+0x7c>
 80203fc:	89a3      	ldrh	r3, [r4, #12]
 80203fe:	f403 7320 	and.w	r3, r3, #640	; 0x280
 8020402:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8020406:	d003      	beq.n	8020410 <__swsetup_r+0x7c>
 8020408:	4621      	mov	r1, r4
 802040a:	4628      	mov	r0, r5
 802040c:	f000 f912 	bl	8020634 <__smakebuf_r>
 8020410:	89a0      	ldrh	r0, [r4, #12]
 8020412:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8020416:	f010 0301 	ands.w	r3, r0, #1
 802041a:	d00a      	beq.n	8020432 <__swsetup_r+0x9e>
 802041c:	2300      	movs	r3, #0
 802041e:	60a3      	str	r3, [r4, #8]
 8020420:	6963      	ldr	r3, [r4, #20]
 8020422:	425b      	negs	r3, r3
 8020424:	61a3      	str	r3, [r4, #24]
 8020426:	6923      	ldr	r3, [r4, #16]
 8020428:	b943      	cbnz	r3, 802043c <__swsetup_r+0xa8>
 802042a:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 802042e:	d1c4      	bne.n	80203ba <__swsetup_r+0x26>
 8020430:	bd38      	pop	{r3, r4, r5, pc}
 8020432:	0781      	lsls	r1, r0, #30
 8020434:	bf58      	it	pl
 8020436:	6963      	ldrpl	r3, [r4, #20]
 8020438:	60a3      	str	r3, [r4, #8]
 802043a:	e7f4      	b.n	8020426 <__swsetup_r+0x92>
 802043c:	2000      	movs	r0, #0
 802043e:	e7f7      	b.n	8020430 <__swsetup_r+0x9c>
 8020440:	200001e8 	.word	0x200001e8

08020444 <memmove>:
 8020444:	4288      	cmp	r0, r1
 8020446:	b510      	push	{r4, lr}
 8020448:	eb01 0402 	add.w	r4, r1, r2
 802044c:	d902      	bls.n	8020454 <memmove+0x10>
 802044e:	4284      	cmp	r4, r0
 8020450:	4623      	mov	r3, r4
 8020452:	d807      	bhi.n	8020464 <memmove+0x20>
 8020454:	1e43      	subs	r3, r0, #1
 8020456:	42a1      	cmp	r1, r4
 8020458:	d008      	beq.n	802046c <memmove+0x28>
 802045a:	f811 2b01 	ldrb.w	r2, [r1], #1
 802045e:	f803 2f01 	strb.w	r2, [r3, #1]!
 8020462:	e7f8      	b.n	8020456 <memmove+0x12>
 8020464:	4402      	add	r2, r0
 8020466:	4601      	mov	r1, r0
 8020468:	428a      	cmp	r2, r1
 802046a:	d100      	bne.n	802046e <memmove+0x2a>
 802046c:	bd10      	pop	{r4, pc}
 802046e:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8020472:	f802 4d01 	strb.w	r4, [r2, #-1]!
 8020476:	e7f7      	b.n	8020468 <memmove+0x24>

08020478 <_raise_r>:
 8020478:	291f      	cmp	r1, #31
 802047a:	b538      	push	{r3, r4, r5, lr}
 802047c:	4604      	mov	r4, r0
 802047e:	460d      	mov	r5, r1
 8020480:	d904      	bls.n	802048c <_raise_r+0x14>
 8020482:	2316      	movs	r3, #22
 8020484:	6003      	str	r3, [r0, #0]
 8020486:	f04f 30ff 	mov.w	r0, #4294967295
 802048a:	bd38      	pop	{r3, r4, r5, pc}
 802048c:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 802048e:	b112      	cbz	r2, 8020496 <_raise_r+0x1e>
 8020490:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8020494:	b94b      	cbnz	r3, 80204aa <_raise_r+0x32>
 8020496:	4620      	mov	r0, r4
 8020498:	f000 f830 	bl	80204fc <_getpid_r>
 802049c:	462a      	mov	r2, r5
 802049e:	4601      	mov	r1, r0
 80204a0:	4620      	mov	r0, r4
 80204a2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80204a6:	f000 b817 	b.w	80204d8 <_kill_r>
 80204aa:	2b01      	cmp	r3, #1
 80204ac:	d00a      	beq.n	80204c4 <_raise_r+0x4c>
 80204ae:	1c59      	adds	r1, r3, #1
 80204b0:	d103      	bne.n	80204ba <_raise_r+0x42>
 80204b2:	2316      	movs	r3, #22
 80204b4:	6003      	str	r3, [r0, #0]
 80204b6:	2001      	movs	r0, #1
 80204b8:	e7e7      	b.n	802048a <_raise_r+0x12>
 80204ba:	2400      	movs	r4, #0
 80204bc:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 80204c0:	4628      	mov	r0, r5
 80204c2:	4798      	blx	r3
 80204c4:	2000      	movs	r0, #0
 80204c6:	e7e0      	b.n	802048a <_raise_r+0x12>

080204c8 <raise>:
 80204c8:	4b02      	ldr	r3, [pc, #8]	; (80204d4 <raise+0xc>)
 80204ca:	4601      	mov	r1, r0
 80204cc:	6818      	ldr	r0, [r3, #0]
 80204ce:	f7ff bfd3 	b.w	8020478 <_raise_r>
 80204d2:	bf00      	nop
 80204d4:	200001e8 	.word	0x200001e8

080204d8 <_kill_r>:
 80204d8:	b538      	push	{r3, r4, r5, lr}
 80204da:	4d07      	ldr	r5, [pc, #28]	; (80204f8 <_kill_r+0x20>)
 80204dc:	2300      	movs	r3, #0
 80204de:	4604      	mov	r4, r0
 80204e0:	4608      	mov	r0, r1
 80204e2:	4611      	mov	r1, r2
 80204e4:	602b      	str	r3, [r5, #0]
 80204e6:	f7e5 f993 	bl	8005810 <_kill>
 80204ea:	1c43      	adds	r3, r0, #1
 80204ec:	d102      	bne.n	80204f4 <_kill_r+0x1c>
 80204ee:	682b      	ldr	r3, [r5, #0]
 80204f0:	b103      	cbz	r3, 80204f4 <_kill_r+0x1c>
 80204f2:	6023      	str	r3, [r4, #0]
 80204f4:	bd38      	pop	{r3, r4, r5, pc}
 80204f6:	bf00      	nop
 80204f8:	20016a68 	.word	0x20016a68

080204fc <_getpid_r>:
 80204fc:	f7e5 b980 	b.w	8005800 <_getpid>

08020500 <_sbrk_r>:
 8020500:	b538      	push	{r3, r4, r5, lr}
 8020502:	4d06      	ldr	r5, [pc, #24]	; (802051c <_sbrk_r+0x1c>)
 8020504:	2300      	movs	r3, #0
 8020506:	4604      	mov	r4, r0
 8020508:	4608      	mov	r0, r1
 802050a:	602b      	str	r3, [r5, #0]
 802050c:	f7e5 f9ec 	bl	80058e8 <_sbrk>
 8020510:	1c43      	adds	r3, r0, #1
 8020512:	d102      	bne.n	802051a <_sbrk_r+0x1a>
 8020514:	682b      	ldr	r3, [r5, #0]
 8020516:	b103      	cbz	r3, 802051a <_sbrk_r+0x1a>
 8020518:	6023      	str	r3, [r4, #0]
 802051a:	bd38      	pop	{r3, r4, r5, pc}
 802051c:	20016a68 	.word	0x20016a68

08020520 <_calloc_r>:
 8020520:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8020522:	fba1 2402 	umull	r2, r4, r1, r2
 8020526:	b94c      	cbnz	r4, 802053c <_calloc_r+0x1c>
 8020528:	4611      	mov	r1, r2
 802052a:	9201      	str	r2, [sp, #4]
 802052c:	f7fe ffa2 	bl	801f474 <_malloc_r>
 8020530:	9a01      	ldr	r2, [sp, #4]
 8020532:	4605      	mov	r5, r0
 8020534:	b930      	cbnz	r0, 8020544 <_calloc_r+0x24>
 8020536:	4628      	mov	r0, r5
 8020538:	b003      	add	sp, #12
 802053a:	bd30      	pop	{r4, r5, pc}
 802053c:	220c      	movs	r2, #12
 802053e:	6002      	str	r2, [r0, #0]
 8020540:	2500      	movs	r5, #0
 8020542:	e7f8      	b.n	8020536 <_calloc_r+0x16>
 8020544:	4621      	mov	r1, r4
 8020546:	f7fe f810 	bl	801e56a <memset>
 802054a:	e7f4      	b.n	8020536 <_calloc_r+0x16>

0802054c <__ascii_mbtowc>:
 802054c:	b082      	sub	sp, #8
 802054e:	b901      	cbnz	r1, 8020552 <__ascii_mbtowc+0x6>
 8020550:	a901      	add	r1, sp, #4
 8020552:	b142      	cbz	r2, 8020566 <__ascii_mbtowc+0x1a>
 8020554:	b14b      	cbz	r3, 802056a <__ascii_mbtowc+0x1e>
 8020556:	7813      	ldrb	r3, [r2, #0]
 8020558:	600b      	str	r3, [r1, #0]
 802055a:	7812      	ldrb	r2, [r2, #0]
 802055c:	1e10      	subs	r0, r2, #0
 802055e:	bf18      	it	ne
 8020560:	2001      	movne	r0, #1
 8020562:	b002      	add	sp, #8
 8020564:	4770      	bx	lr
 8020566:	4610      	mov	r0, r2
 8020568:	e7fb      	b.n	8020562 <__ascii_mbtowc+0x16>
 802056a:	f06f 0001 	mvn.w	r0, #1
 802056e:	e7f8      	b.n	8020562 <__ascii_mbtowc+0x16>

08020570 <_realloc_r>:
 8020570:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8020574:	4680      	mov	r8, r0
 8020576:	4614      	mov	r4, r2
 8020578:	460e      	mov	r6, r1
 802057a:	b921      	cbnz	r1, 8020586 <_realloc_r+0x16>
 802057c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8020580:	4611      	mov	r1, r2
 8020582:	f7fe bf77 	b.w	801f474 <_malloc_r>
 8020586:	b92a      	cbnz	r2, 8020594 <_realloc_r+0x24>
 8020588:	f7fe ff00 	bl	801f38c <_free_r>
 802058c:	4625      	mov	r5, r4
 802058e:	4628      	mov	r0, r5
 8020590:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8020594:	f000 f8ac 	bl	80206f0 <_malloc_usable_size_r>
 8020598:	4284      	cmp	r4, r0
 802059a:	4607      	mov	r7, r0
 802059c:	d802      	bhi.n	80205a4 <_realloc_r+0x34>
 802059e:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
 80205a2:	d812      	bhi.n	80205ca <_realloc_r+0x5a>
 80205a4:	4621      	mov	r1, r4
 80205a6:	4640      	mov	r0, r8
 80205a8:	f7fe ff64 	bl	801f474 <_malloc_r>
 80205ac:	4605      	mov	r5, r0
 80205ae:	2800      	cmp	r0, #0
 80205b0:	d0ed      	beq.n	802058e <_realloc_r+0x1e>
 80205b2:	42bc      	cmp	r4, r7
 80205b4:	4622      	mov	r2, r4
 80205b6:	4631      	mov	r1, r6
 80205b8:	bf28      	it	cs
 80205ba:	463a      	movcs	r2, r7
 80205bc:	f7fe f854 	bl	801e668 <memcpy>
 80205c0:	4631      	mov	r1, r6
 80205c2:	4640      	mov	r0, r8
 80205c4:	f7fe fee2 	bl	801f38c <_free_r>
 80205c8:	e7e1      	b.n	802058e <_realloc_r+0x1e>
 80205ca:	4635      	mov	r5, r6
 80205cc:	e7df      	b.n	802058e <_realloc_r+0x1e>

080205ce <__ascii_wctomb>:
 80205ce:	b149      	cbz	r1, 80205e4 <__ascii_wctomb+0x16>
 80205d0:	2aff      	cmp	r2, #255	; 0xff
 80205d2:	bf85      	ittet	hi
 80205d4:	238a      	movhi	r3, #138	; 0x8a
 80205d6:	6003      	strhi	r3, [r0, #0]
 80205d8:	700a      	strbls	r2, [r1, #0]
 80205da:	f04f 30ff 	movhi.w	r0, #4294967295
 80205de:	bf98      	it	ls
 80205e0:	2001      	movls	r0, #1
 80205e2:	4770      	bx	lr
 80205e4:	4608      	mov	r0, r1
 80205e6:	4770      	bx	lr

080205e8 <__swhatbuf_r>:
 80205e8:	b570      	push	{r4, r5, r6, lr}
 80205ea:	460c      	mov	r4, r1
 80205ec:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80205f0:	2900      	cmp	r1, #0
 80205f2:	b096      	sub	sp, #88	; 0x58
 80205f4:	4615      	mov	r5, r2
 80205f6:	461e      	mov	r6, r3
 80205f8:	da0d      	bge.n	8020616 <__swhatbuf_r+0x2e>
 80205fa:	89a3      	ldrh	r3, [r4, #12]
 80205fc:	f013 0f80 	tst.w	r3, #128	; 0x80
 8020600:	f04f 0100 	mov.w	r1, #0
 8020604:	bf0c      	ite	eq
 8020606:	f44f 6380 	moveq.w	r3, #1024	; 0x400
 802060a:	2340      	movne	r3, #64	; 0x40
 802060c:	2000      	movs	r0, #0
 802060e:	6031      	str	r1, [r6, #0]
 8020610:	602b      	str	r3, [r5, #0]
 8020612:	b016      	add	sp, #88	; 0x58
 8020614:	bd70      	pop	{r4, r5, r6, pc}
 8020616:	466a      	mov	r2, sp
 8020618:	f000 f848 	bl	80206ac <_fstat_r>
 802061c:	2800      	cmp	r0, #0
 802061e:	dbec      	blt.n	80205fa <__swhatbuf_r+0x12>
 8020620:	9901      	ldr	r1, [sp, #4]
 8020622:	f401 4170 	and.w	r1, r1, #61440	; 0xf000
 8020626:	f5a1 5300 	sub.w	r3, r1, #8192	; 0x2000
 802062a:	4259      	negs	r1, r3
 802062c:	4159      	adcs	r1, r3
 802062e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8020632:	e7eb      	b.n	802060c <__swhatbuf_r+0x24>

08020634 <__smakebuf_r>:
 8020634:	898b      	ldrh	r3, [r1, #12]
 8020636:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8020638:	079d      	lsls	r5, r3, #30
 802063a:	4606      	mov	r6, r0
 802063c:	460c      	mov	r4, r1
 802063e:	d507      	bpl.n	8020650 <__smakebuf_r+0x1c>
 8020640:	f104 0347 	add.w	r3, r4, #71	; 0x47
 8020644:	6023      	str	r3, [r4, #0]
 8020646:	6123      	str	r3, [r4, #16]
 8020648:	2301      	movs	r3, #1
 802064a:	6163      	str	r3, [r4, #20]
 802064c:	b002      	add	sp, #8
 802064e:	bd70      	pop	{r4, r5, r6, pc}
 8020650:	ab01      	add	r3, sp, #4
 8020652:	466a      	mov	r2, sp
 8020654:	f7ff ffc8 	bl	80205e8 <__swhatbuf_r>
 8020658:	9900      	ldr	r1, [sp, #0]
 802065a:	4605      	mov	r5, r0
 802065c:	4630      	mov	r0, r6
 802065e:	f7fe ff09 	bl	801f474 <_malloc_r>
 8020662:	b948      	cbnz	r0, 8020678 <__smakebuf_r+0x44>
 8020664:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8020668:	059a      	lsls	r2, r3, #22
 802066a:	d4ef      	bmi.n	802064c <__smakebuf_r+0x18>
 802066c:	f023 0303 	bic.w	r3, r3, #3
 8020670:	f043 0302 	orr.w	r3, r3, #2
 8020674:	81a3      	strh	r3, [r4, #12]
 8020676:	e7e3      	b.n	8020640 <__smakebuf_r+0xc>
 8020678:	89a3      	ldrh	r3, [r4, #12]
 802067a:	6020      	str	r0, [r4, #0]
 802067c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8020680:	81a3      	strh	r3, [r4, #12]
 8020682:	9b00      	ldr	r3, [sp, #0]
 8020684:	6163      	str	r3, [r4, #20]
 8020686:	9b01      	ldr	r3, [sp, #4]
 8020688:	6120      	str	r0, [r4, #16]
 802068a:	b15b      	cbz	r3, 80206a4 <__smakebuf_r+0x70>
 802068c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8020690:	4630      	mov	r0, r6
 8020692:	f000 f81d 	bl	80206d0 <_isatty_r>
 8020696:	b128      	cbz	r0, 80206a4 <__smakebuf_r+0x70>
 8020698:	89a3      	ldrh	r3, [r4, #12]
 802069a:	f023 0303 	bic.w	r3, r3, #3
 802069e:	f043 0301 	orr.w	r3, r3, #1
 80206a2:	81a3      	strh	r3, [r4, #12]
 80206a4:	89a3      	ldrh	r3, [r4, #12]
 80206a6:	431d      	orrs	r5, r3
 80206a8:	81a5      	strh	r5, [r4, #12]
 80206aa:	e7cf      	b.n	802064c <__smakebuf_r+0x18>

080206ac <_fstat_r>:
 80206ac:	b538      	push	{r3, r4, r5, lr}
 80206ae:	4d07      	ldr	r5, [pc, #28]	; (80206cc <_fstat_r+0x20>)
 80206b0:	2300      	movs	r3, #0
 80206b2:	4604      	mov	r4, r0
 80206b4:	4608      	mov	r0, r1
 80206b6:	4611      	mov	r1, r2
 80206b8:	602b      	str	r3, [r5, #0]
 80206ba:	f7e5 f8ec 	bl	8005896 <_fstat>
 80206be:	1c43      	adds	r3, r0, #1
 80206c0:	d102      	bne.n	80206c8 <_fstat_r+0x1c>
 80206c2:	682b      	ldr	r3, [r5, #0]
 80206c4:	b103      	cbz	r3, 80206c8 <_fstat_r+0x1c>
 80206c6:	6023      	str	r3, [r4, #0]
 80206c8:	bd38      	pop	{r3, r4, r5, pc}
 80206ca:	bf00      	nop
 80206cc:	20016a68 	.word	0x20016a68

080206d0 <_isatty_r>:
 80206d0:	b538      	push	{r3, r4, r5, lr}
 80206d2:	4d06      	ldr	r5, [pc, #24]	; (80206ec <_isatty_r+0x1c>)
 80206d4:	2300      	movs	r3, #0
 80206d6:	4604      	mov	r4, r0
 80206d8:	4608      	mov	r0, r1
 80206da:	602b      	str	r3, [r5, #0]
 80206dc:	f7e5 f8eb 	bl	80058b6 <_isatty>
 80206e0:	1c43      	adds	r3, r0, #1
 80206e2:	d102      	bne.n	80206ea <_isatty_r+0x1a>
 80206e4:	682b      	ldr	r3, [r5, #0]
 80206e6:	b103      	cbz	r3, 80206ea <_isatty_r+0x1a>
 80206e8:	6023      	str	r3, [r4, #0]
 80206ea:	bd38      	pop	{r3, r4, r5, pc}
 80206ec:	20016a68 	.word	0x20016a68

080206f0 <_malloc_usable_size_r>:
 80206f0:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80206f4:	1f18      	subs	r0, r3, #4
 80206f6:	2b00      	cmp	r3, #0
 80206f8:	bfbc      	itt	lt
 80206fa:	580b      	ldrlt	r3, [r1, r0]
 80206fc:	18c0      	addlt	r0, r0, r3
 80206fe:	4770      	bx	lr

08020700 <sinf>:
 8020700:	ee10 3a10 	vmov	r3, s0
 8020704:	b507      	push	{r0, r1, r2, lr}
 8020706:	4a1f      	ldr	r2, [pc, #124]	; (8020784 <sinf+0x84>)
 8020708:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802070c:	4293      	cmp	r3, r2
 802070e:	dc07      	bgt.n	8020720 <sinf+0x20>
 8020710:	eddf 0a1d 	vldr	s1, [pc, #116]	; 8020788 <sinf+0x88>
 8020714:	2000      	movs	r0, #0
 8020716:	b003      	add	sp, #12
 8020718:	f85d eb04 	ldr.w	lr, [sp], #4
 802071c:	f000 b894 	b.w	8020848 <__kernel_sinf>
 8020720:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8020724:	db04      	blt.n	8020730 <sinf+0x30>
 8020726:	ee30 0a40 	vsub.f32	s0, s0, s0
 802072a:	b003      	add	sp, #12
 802072c:	f85d fb04 	ldr.w	pc, [sp], #4
 8020730:	4668      	mov	r0, sp
 8020732:	f000 f8d1 	bl	80208d8 <__ieee754_rem_pio2f>
 8020736:	f000 0003 	and.w	r0, r0, #3
 802073a:	2801      	cmp	r0, #1
 802073c:	d00a      	beq.n	8020754 <sinf+0x54>
 802073e:	2802      	cmp	r0, #2
 8020740:	d00f      	beq.n	8020762 <sinf+0x62>
 8020742:	b9c0      	cbnz	r0, 8020776 <sinf+0x76>
 8020744:	eddd 0a01 	vldr	s1, [sp, #4]
 8020748:	ed9d 0a00 	vldr	s0, [sp]
 802074c:	2001      	movs	r0, #1
 802074e:	f000 f87b 	bl	8020848 <__kernel_sinf>
 8020752:	e7ea      	b.n	802072a <sinf+0x2a>
 8020754:	eddd 0a01 	vldr	s1, [sp, #4]
 8020758:	ed9d 0a00 	vldr	s0, [sp]
 802075c:	f000 f816 	bl	802078c <__kernel_cosf>
 8020760:	e7e3      	b.n	802072a <sinf+0x2a>
 8020762:	eddd 0a01 	vldr	s1, [sp, #4]
 8020766:	ed9d 0a00 	vldr	s0, [sp]
 802076a:	2001      	movs	r0, #1
 802076c:	f000 f86c 	bl	8020848 <__kernel_sinf>
 8020770:	eeb1 0a40 	vneg.f32	s0, s0
 8020774:	e7d9      	b.n	802072a <sinf+0x2a>
 8020776:	eddd 0a01 	vldr	s1, [sp, #4]
 802077a:	ed9d 0a00 	vldr	s0, [sp]
 802077e:	f000 f805 	bl	802078c <__kernel_cosf>
 8020782:	e7f5      	b.n	8020770 <sinf+0x70>
 8020784:	3f490fd8 	.word	0x3f490fd8
 8020788:	00000000 	.word	0x00000000

0802078c <__kernel_cosf>:
 802078c:	ee10 3a10 	vmov	r3, s0
 8020790:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8020794:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 8020798:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 802079c:	da05      	bge.n	80207aa <__kernel_cosf+0x1e>
 802079e:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 80207a2:	ee17 2a90 	vmov	r2, s15
 80207a6:	2a00      	cmp	r2, #0
 80207a8:	d03b      	beq.n	8020822 <__kernel_cosf+0x96>
 80207aa:	ee20 7a00 	vmul.f32	s14, s0, s0
 80207ae:	eddf 7a1e 	vldr	s15, [pc, #120]	; 8020828 <__kernel_cosf+0x9c>
 80207b2:	ed9f 6a1e 	vldr	s12, [pc, #120]	; 802082c <__kernel_cosf+0xa0>
 80207b6:	4a1e      	ldr	r2, [pc, #120]	; (8020830 <__kernel_cosf+0xa4>)
 80207b8:	eea7 6a27 	vfma.f32	s12, s14, s15
 80207bc:	4293      	cmp	r3, r2
 80207be:	eddf 7a1d 	vldr	s15, [pc, #116]	; 8020834 <__kernel_cosf+0xa8>
 80207c2:	eee6 7a07 	vfma.f32	s15, s12, s14
 80207c6:	ed9f 6a1c 	vldr	s12, [pc, #112]	; 8020838 <__kernel_cosf+0xac>
 80207ca:	eea7 6a87 	vfma.f32	s12, s15, s14
 80207ce:	eddf 7a1b 	vldr	s15, [pc, #108]	; 802083c <__kernel_cosf+0xb0>
 80207d2:	eee6 7a07 	vfma.f32	s15, s12, s14
 80207d6:	ed9f 6a1a 	vldr	s12, [pc, #104]	; 8020840 <__kernel_cosf+0xb4>
 80207da:	eea7 6a87 	vfma.f32	s12, s15, s14
 80207de:	ee60 0ac0 	vnmul.f32	s1, s1, s0
 80207e2:	ee26 6a07 	vmul.f32	s12, s12, s14
 80207e6:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 80207ea:	eee7 0a06 	vfma.f32	s1, s14, s12
 80207ee:	ee67 7a27 	vmul.f32	s15, s14, s15
 80207f2:	dc04      	bgt.n	80207fe <__kernel_cosf+0x72>
 80207f4:	ee77 7ae0 	vsub.f32	s15, s15, s1
 80207f8:	ee36 0ae7 	vsub.f32	s0, s13, s15
 80207fc:	4770      	bx	lr
 80207fe:	4a11      	ldr	r2, [pc, #68]	; (8020844 <__kernel_cosf+0xb8>)
 8020800:	4293      	cmp	r3, r2
 8020802:	bfda      	itte	le
 8020804:	f103 437f 	addle.w	r3, r3, #4278190080	; 0xff000000
 8020808:	ee07 3a10 	vmovle	s14, r3
 802080c:	eeb5 7a02 	vmovgt.f32	s14, #82	; 0x3e900000  0.2812500
 8020810:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8020814:	ee36 0ac7 	vsub.f32	s0, s13, s14
 8020818:	ee77 7ae0 	vsub.f32	s15, s15, s1
 802081c:	ee30 0a67 	vsub.f32	s0, s0, s15
 8020820:	4770      	bx	lr
 8020822:	eeb0 0a66 	vmov.f32	s0, s13
 8020826:	4770      	bx	lr
 8020828:	ad47d74e 	.word	0xad47d74e
 802082c:	310f74f6 	.word	0x310f74f6
 8020830:	3e999999 	.word	0x3e999999
 8020834:	b493f27c 	.word	0xb493f27c
 8020838:	37d00d01 	.word	0x37d00d01
 802083c:	bab60b61 	.word	0xbab60b61
 8020840:	3d2aaaab 	.word	0x3d2aaaab
 8020844:	3f480000 	.word	0x3f480000

08020848 <__kernel_sinf>:
 8020848:	ee10 3a10 	vmov	r3, s0
 802084c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8020850:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 8020854:	da04      	bge.n	8020860 <__kernel_sinf+0x18>
 8020856:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 802085a:	ee17 3a90 	vmov	r3, s15
 802085e:	b35b      	cbz	r3, 80208b8 <__kernel_sinf+0x70>
 8020860:	ee20 7a00 	vmul.f32	s14, s0, s0
 8020864:	eddf 7a15 	vldr	s15, [pc, #84]	; 80208bc <__kernel_sinf+0x74>
 8020868:	ed9f 6a15 	vldr	s12, [pc, #84]	; 80208c0 <__kernel_sinf+0x78>
 802086c:	eea7 6a27 	vfma.f32	s12, s14, s15
 8020870:	eddf 7a14 	vldr	s15, [pc, #80]	; 80208c4 <__kernel_sinf+0x7c>
 8020874:	eee6 7a07 	vfma.f32	s15, s12, s14
 8020878:	ed9f 6a13 	vldr	s12, [pc, #76]	; 80208c8 <__kernel_sinf+0x80>
 802087c:	eea7 6a87 	vfma.f32	s12, s15, s14
 8020880:	eddf 7a12 	vldr	s15, [pc, #72]	; 80208cc <__kernel_sinf+0x84>
 8020884:	ee60 6a07 	vmul.f32	s13, s0, s14
 8020888:	eee6 7a07 	vfma.f32	s15, s12, s14
 802088c:	b930      	cbnz	r0, 802089c <__kernel_sinf+0x54>
 802088e:	ed9f 6a10 	vldr	s12, [pc, #64]	; 80208d0 <__kernel_sinf+0x88>
 8020892:	eea7 6a27 	vfma.f32	s12, s14, s15
 8020896:	eea6 0a26 	vfma.f32	s0, s12, s13
 802089a:	4770      	bx	lr
 802089c:	ee67 7ae6 	vnmul.f32	s15, s15, s13
 80208a0:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
 80208a4:	eee0 7a86 	vfma.f32	s15, s1, s12
 80208a8:	eed7 0a87 	vfnms.f32	s1, s15, s14
 80208ac:	eddf 7a09 	vldr	s15, [pc, #36]	; 80208d4 <__kernel_sinf+0x8c>
 80208b0:	eee6 0aa7 	vfma.f32	s1, s13, s15
 80208b4:	ee30 0a60 	vsub.f32	s0, s0, s1
 80208b8:	4770      	bx	lr
 80208ba:	bf00      	nop
 80208bc:	2f2ec9d3 	.word	0x2f2ec9d3
 80208c0:	b2d72f34 	.word	0xb2d72f34
 80208c4:	3638ef1b 	.word	0x3638ef1b
 80208c8:	b9500d01 	.word	0xb9500d01
 80208cc:	3c088889 	.word	0x3c088889
 80208d0:	be2aaaab 	.word	0xbe2aaaab
 80208d4:	3e2aaaab 	.word	0x3e2aaaab

080208d8 <__ieee754_rem_pio2f>:
 80208d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80208da:	ee10 6a10 	vmov	r6, s0
 80208de:	4b86      	ldr	r3, [pc, #536]	; (8020af8 <__ieee754_rem_pio2f+0x220>)
 80208e0:	f026 4500 	bic.w	r5, r6, #2147483648	; 0x80000000
 80208e4:	429d      	cmp	r5, r3
 80208e6:	b087      	sub	sp, #28
 80208e8:	4604      	mov	r4, r0
 80208ea:	dc05      	bgt.n	80208f8 <__ieee754_rem_pio2f+0x20>
 80208ec:	2300      	movs	r3, #0
 80208ee:	ed80 0a00 	vstr	s0, [r0]
 80208f2:	6043      	str	r3, [r0, #4]
 80208f4:	2000      	movs	r0, #0
 80208f6:	e020      	b.n	802093a <__ieee754_rem_pio2f+0x62>
 80208f8:	4b80      	ldr	r3, [pc, #512]	; (8020afc <__ieee754_rem_pio2f+0x224>)
 80208fa:	429d      	cmp	r5, r3
 80208fc:	dc38      	bgt.n	8020970 <__ieee754_rem_pio2f+0x98>
 80208fe:	2e00      	cmp	r6, #0
 8020900:	ed9f 7a7f 	vldr	s14, [pc, #508]	; 8020b00 <__ieee754_rem_pio2f+0x228>
 8020904:	4b7f      	ldr	r3, [pc, #508]	; (8020b04 <__ieee754_rem_pio2f+0x22c>)
 8020906:	f025 050f 	bic.w	r5, r5, #15
 802090a:	dd18      	ble.n	802093e <__ieee754_rem_pio2f+0x66>
 802090c:	429d      	cmp	r5, r3
 802090e:	ee70 7a47 	vsub.f32	s15, s0, s14
 8020912:	bf09      	itett	eq
 8020914:	ed9f 7a7c 	vldreq	s14, [pc, #496]	; 8020b08 <__ieee754_rem_pio2f+0x230>
 8020918:	ed9f 7a7c 	vldrne	s14, [pc, #496]	; 8020b0c <__ieee754_rem_pio2f+0x234>
 802091c:	ee77 7ac7 	vsubeq.f32	s15, s15, s14
 8020920:	ed9f 7a7b 	vldreq	s14, [pc, #492]	; 8020b10 <__ieee754_rem_pio2f+0x238>
 8020924:	ee77 6ac7 	vsub.f32	s13, s15, s14
 8020928:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802092c:	edc0 6a00 	vstr	s13, [r0]
 8020930:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8020934:	edc0 7a01 	vstr	s15, [r0, #4]
 8020938:	2001      	movs	r0, #1
 802093a:	b007      	add	sp, #28
 802093c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802093e:	429d      	cmp	r5, r3
 8020940:	ee70 7a07 	vadd.f32	s15, s0, s14
 8020944:	bf09      	itett	eq
 8020946:	ed9f 7a70 	vldreq	s14, [pc, #448]	; 8020b08 <__ieee754_rem_pio2f+0x230>
 802094a:	ed9f 7a70 	vldrne	s14, [pc, #448]	; 8020b0c <__ieee754_rem_pio2f+0x234>
 802094e:	ee77 7a87 	vaddeq.f32	s15, s15, s14
 8020952:	ed9f 7a6f 	vldreq	s14, [pc, #444]	; 8020b10 <__ieee754_rem_pio2f+0x238>
 8020956:	ee77 6a87 	vadd.f32	s13, s15, s14
 802095a:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802095e:	edc0 6a00 	vstr	s13, [r0]
 8020962:	ee77 7a87 	vadd.f32	s15, s15, s14
 8020966:	edc0 7a01 	vstr	s15, [r0, #4]
 802096a:	f04f 30ff 	mov.w	r0, #4294967295
 802096e:	e7e4      	b.n	802093a <__ieee754_rem_pio2f+0x62>
 8020970:	4b68      	ldr	r3, [pc, #416]	; (8020b14 <__ieee754_rem_pio2f+0x23c>)
 8020972:	429d      	cmp	r5, r3
 8020974:	dc71      	bgt.n	8020a5a <__ieee754_rem_pio2f+0x182>
 8020976:	f000 f8db 	bl	8020b30 <fabsf>
 802097a:	ed9f 7a67 	vldr	s14, [pc, #412]	; 8020b18 <__ieee754_rem_pio2f+0x240>
 802097e:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8020982:	eee0 7a07 	vfma.f32	s15, s0, s14
 8020986:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802098a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 802098e:	ee17 0a90 	vmov	r0, s15
 8020992:	eddf 7a5b 	vldr	s15, [pc, #364]	; 8020b00 <__ieee754_rem_pio2f+0x228>
 8020996:	eea7 0a67 	vfms.f32	s0, s14, s15
 802099a:	281f      	cmp	r0, #31
 802099c:	eddf 7a5b 	vldr	s15, [pc, #364]	; 8020b0c <__ieee754_rem_pio2f+0x234>
 80209a0:	ee67 7a27 	vmul.f32	s15, s14, s15
 80209a4:	eeb1 6a47 	vneg.f32	s12, s14
 80209a8:	ee70 6a67 	vsub.f32	s13, s0, s15
 80209ac:	ee16 2a90 	vmov	r2, s13
 80209b0:	dc1c      	bgt.n	80209ec <__ieee754_rem_pio2f+0x114>
 80209b2:	495a      	ldr	r1, [pc, #360]	; (8020b1c <__ieee754_rem_pio2f+0x244>)
 80209b4:	1e47      	subs	r7, r0, #1
 80209b6:	f025 03ff 	bic.w	r3, r5, #255	; 0xff
 80209ba:	f851 1027 	ldr.w	r1, [r1, r7, lsl #2]
 80209be:	428b      	cmp	r3, r1
 80209c0:	d014      	beq.n	80209ec <__ieee754_rem_pio2f+0x114>
 80209c2:	6022      	str	r2, [r4, #0]
 80209c4:	ed94 7a00 	vldr	s14, [r4]
 80209c8:	ee30 0a47 	vsub.f32	s0, s0, s14
 80209cc:	2e00      	cmp	r6, #0
 80209ce:	ee30 0a67 	vsub.f32	s0, s0, s15
 80209d2:	ed84 0a01 	vstr	s0, [r4, #4]
 80209d6:	dab0      	bge.n	802093a <__ieee754_rem_pio2f+0x62>
 80209d8:	eeb1 7a47 	vneg.f32	s14, s14
 80209dc:	eeb1 0a40 	vneg.f32	s0, s0
 80209e0:	ed84 7a00 	vstr	s14, [r4]
 80209e4:	ed84 0a01 	vstr	s0, [r4, #4]
 80209e8:	4240      	negs	r0, r0
 80209ea:	e7a6      	b.n	802093a <__ieee754_rem_pio2f+0x62>
 80209ec:	f3c2 51c7 	ubfx	r1, r2, #23, #8
 80209f0:	ebc1 51d5 	rsb	r1, r1, r5, lsr #23
 80209f4:	2908      	cmp	r1, #8
 80209f6:	ea4f 53e5 	mov.w	r3, r5, asr #23
 80209fa:	dde2      	ble.n	80209c2 <__ieee754_rem_pio2f+0xea>
 80209fc:	eddf 5a42 	vldr	s11, [pc, #264]	; 8020b08 <__ieee754_rem_pio2f+0x230>
 8020a00:	eef0 6a40 	vmov.f32	s13, s0
 8020a04:	eee6 6a25 	vfma.f32	s13, s12, s11
 8020a08:	ee70 7a66 	vsub.f32	s15, s0, s13
 8020a0c:	eee6 7a25 	vfma.f32	s15, s12, s11
 8020a10:	eddf 5a3f 	vldr	s11, [pc, #252]	; 8020b10 <__ieee754_rem_pio2f+0x238>
 8020a14:	eed7 7a25 	vfnms.f32	s15, s14, s11
 8020a18:	ee76 5ae7 	vsub.f32	s11, s13, s15
 8020a1c:	ee15 2a90 	vmov	r2, s11
 8020a20:	f3c2 51c7 	ubfx	r1, r2, #23, #8
 8020a24:	1a5b      	subs	r3, r3, r1
 8020a26:	2b19      	cmp	r3, #25
 8020a28:	dc04      	bgt.n	8020a34 <__ieee754_rem_pio2f+0x15c>
 8020a2a:	edc4 5a00 	vstr	s11, [r4]
 8020a2e:	eeb0 0a66 	vmov.f32	s0, s13
 8020a32:	e7c7      	b.n	80209c4 <__ieee754_rem_pio2f+0xec>
 8020a34:	eddf 5a3a 	vldr	s11, [pc, #232]	; 8020b20 <__ieee754_rem_pio2f+0x248>
 8020a38:	eeb0 0a66 	vmov.f32	s0, s13
 8020a3c:	eea6 0a25 	vfma.f32	s0, s12, s11
 8020a40:	ee76 7ac0 	vsub.f32	s15, s13, s0
 8020a44:	eddf 6a37 	vldr	s13, [pc, #220]	; 8020b24 <__ieee754_rem_pio2f+0x24c>
 8020a48:	eee6 7a25 	vfma.f32	s15, s12, s11
 8020a4c:	eed7 7a26 	vfnms.f32	s15, s14, s13
 8020a50:	ee30 7a67 	vsub.f32	s14, s0, s15
 8020a54:	ed84 7a00 	vstr	s14, [r4]
 8020a58:	e7b4      	b.n	80209c4 <__ieee754_rem_pio2f+0xec>
 8020a5a:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
 8020a5e:	db06      	blt.n	8020a6e <__ieee754_rem_pio2f+0x196>
 8020a60:	ee70 7a40 	vsub.f32	s15, s0, s0
 8020a64:	edc0 7a01 	vstr	s15, [r0, #4]
 8020a68:	edc0 7a00 	vstr	s15, [r0]
 8020a6c:	e742      	b.n	80208f4 <__ieee754_rem_pio2f+0x1c>
 8020a6e:	15ea      	asrs	r2, r5, #23
 8020a70:	3a86      	subs	r2, #134	; 0x86
 8020a72:	eba5 53c2 	sub.w	r3, r5, r2, lsl #23
 8020a76:	ee07 3a90 	vmov	s15, r3
 8020a7a:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 8020a7e:	eddf 6a2a 	vldr	s13, [pc, #168]	; 8020b28 <__ieee754_rem_pio2f+0x250>
 8020a82:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8020a86:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8020a8a:	ed8d 7a03 	vstr	s14, [sp, #12]
 8020a8e:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8020a92:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 8020a96:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8020a9a:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8020a9e:	ed8d 7a04 	vstr	s14, [sp, #16]
 8020aa2:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8020aa6:	eef5 7a40 	vcmp.f32	s15, #0.0
 8020aaa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020aae:	edcd 7a05 	vstr	s15, [sp, #20]
 8020ab2:	d11e      	bne.n	8020af2 <__ieee754_rem_pio2f+0x21a>
 8020ab4:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8020ab8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020abc:	bf14      	ite	ne
 8020abe:	2302      	movne	r3, #2
 8020ac0:	2301      	moveq	r3, #1
 8020ac2:	491a      	ldr	r1, [pc, #104]	; (8020b2c <__ieee754_rem_pio2f+0x254>)
 8020ac4:	9101      	str	r1, [sp, #4]
 8020ac6:	2102      	movs	r1, #2
 8020ac8:	9100      	str	r1, [sp, #0]
 8020aca:	a803      	add	r0, sp, #12
 8020acc:	4621      	mov	r1, r4
 8020ace:	f000 f837 	bl	8020b40 <__kernel_rem_pio2f>
 8020ad2:	2e00      	cmp	r6, #0
 8020ad4:	f6bf af31 	bge.w	802093a <__ieee754_rem_pio2f+0x62>
 8020ad8:	edd4 7a00 	vldr	s15, [r4]
 8020adc:	eef1 7a67 	vneg.f32	s15, s15
 8020ae0:	edc4 7a00 	vstr	s15, [r4]
 8020ae4:	edd4 7a01 	vldr	s15, [r4, #4]
 8020ae8:	eef1 7a67 	vneg.f32	s15, s15
 8020aec:	edc4 7a01 	vstr	s15, [r4, #4]
 8020af0:	e77a      	b.n	80209e8 <__ieee754_rem_pio2f+0x110>
 8020af2:	2303      	movs	r3, #3
 8020af4:	e7e5      	b.n	8020ac2 <__ieee754_rem_pio2f+0x1ea>
 8020af6:	bf00      	nop
 8020af8:	3f490fd8 	.word	0x3f490fd8
 8020afc:	4016cbe3 	.word	0x4016cbe3
 8020b00:	3fc90f80 	.word	0x3fc90f80
 8020b04:	3fc90fd0 	.word	0x3fc90fd0
 8020b08:	37354400 	.word	0x37354400
 8020b0c:	37354443 	.word	0x37354443
 8020b10:	2e85a308 	.word	0x2e85a308
 8020b14:	43490f80 	.word	0x43490f80
 8020b18:	3f22f984 	.word	0x3f22f984
 8020b1c:	08023c00 	.word	0x08023c00
 8020b20:	2e85a300 	.word	0x2e85a300
 8020b24:	248d3132 	.word	0x248d3132
 8020b28:	43800000 	.word	0x43800000
 8020b2c:	08023c80 	.word	0x08023c80

08020b30 <fabsf>:
 8020b30:	ee10 3a10 	vmov	r3, s0
 8020b34:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8020b38:	ee00 3a10 	vmov	s0, r3
 8020b3c:	4770      	bx	lr
	...

08020b40 <__kernel_rem_pio2f>:
 8020b40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020b44:	ed2d 8b04 	vpush	{d8-d9}
 8020b48:	b0d9      	sub	sp, #356	; 0x164
 8020b4a:	4688      	mov	r8, r1
 8020b4c:	9002      	str	r0, [sp, #8]
 8020b4e:	49b8      	ldr	r1, [pc, #736]	; (8020e30 <__kernel_rem_pio2f+0x2f0>)
 8020b50:	9866      	ldr	r0, [sp, #408]	; 0x198
 8020b52:	9301      	str	r3, [sp, #4]
 8020b54:	f851 a020 	ldr.w	sl, [r1, r0, lsl #2]
 8020b58:	9901      	ldr	r1, [sp, #4]
 8020b5a:	9b67      	ldr	r3, [sp, #412]	; 0x19c
 8020b5c:	f101 3bff 	add.w	fp, r1, #4294967295
 8020b60:	1d11      	adds	r1, r2, #4
 8020b62:	db25      	blt.n	8020bb0 <__kernel_rem_pio2f+0x70>
 8020b64:	1ed0      	subs	r0, r2, #3
 8020b66:	bf48      	it	mi
 8020b68:	1d10      	addmi	r0, r2, #4
 8020b6a:	10c0      	asrs	r0, r0, #3
 8020b6c:	1c45      	adds	r5, r0, #1
 8020b6e:	00e9      	lsls	r1, r5, #3
 8020b70:	eba0 070b 	sub.w	r7, r0, fp
 8020b74:	ed9f 7ab2 	vldr	s14, [pc, #712]	; 8020e40 <__kernel_rem_pio2f+0x300>
 8020b78:	9103      	str	r1, [sp, #12]
 8020b7a:	eba2 05c5 	sub.w	r5, r2, r5, lsl #3
 8020b7e:	eb0a 0c0b 	add.w	ip, sl, fp
 8020b82:	ae1c      	add	r6, sp, #112	; 0x70
 8020b84:	eb03 0e87 	add.w	lr, r3, r7, lsl #2
 8020b88:	2400      	movs	r4, #0
 8020b8a:	4564      	cmp	r4, ip
 8020b8c:	dd12      	ble.n	8020bb4 <__kernel_rem_pio2f+0x74>
 8020b8e:	9901      	ldr	r1, [sp, #4]
 8020b90:	ac1c      	add	r4, sp, #112	; 0x70
 8020b92:	eb04 0481 	add.w	r4, r4, r1, lsl #2
 8020b96:	f50d 7988 	add.w	r9, sp, #272	; 0x110
 8020b9a:	f04f 0c00 	mov.w	ip, #0
 8020b9e:	45d4      	cmp	ip, sl
 8020ba0:	dc27      	bgt.n	8020bf2 <__kernel_rem_pio2f+0xb2>
 8020ba2:	f8dd e008 	ldr.w	lr, [sp, #8]
 8020ba6:	eddf 7aa6 	vldr	s15, [pc, #664]	; 8020e40 <__kernel_rem_pio2f+0x300>
 8020baa:	4627      	mov	r7, r4
 8020bac:	2600      	movs	r6, #0
 8020bae:	e016      	b.n	8020bde <__kernel_rem_pio2f+0x9e>
 8020bb0:	2000      	movs	r0, #0
 8020bb2:	e7db      	b.n	8020b6c <__kernel_rem_pio2f+0x2c>
 8020bb4:	42e7      	cmn	r7, r4
 8020bb6:	bf5d      	ittte	pl
 8020bb8:	f85e 1024 	ldrpl.w	r1, [lr, r4, lsl #2]
 8020bbc:	ee07 1a90 	vmovpl	s15, r1
 8020bc0:	eef8 7ae7 	vcvtpl.f32.s32	s15, s15
 8020bc4:	eef0 7a47 	vmovmi.f32	s15, s14
 8020bc8:	ece6 7a01 	vstmia	r6!, {s15}
 8020bcc:	3401      	adds	r4, #1
 8020bce:	e7dc      	b.n	8020b8a <__kernel_rem_pio2f+0x4a>
 8020bd0:	ecfe 6a01 	vldmia	lr!, {s13}
 8020bd4:	ed97 7a00 	vldr	s14, [r7]
 8020bd8:	eee6 7a87 	vfma.f32	s15, s13, s14
 8020bdc:	3601      	adds	r6, #1
 8020bde:	455e      	cmp	r6, fp
 8020be0:	f1a7 0704 	sub.w	r7, r7, #4
 8020be4:	ddf4      	ble.n	8020bd0 <__kernel_rem_pio2f+0x90>
 8020be6:	ece9 7a01 	vstmia	r9!, {s15}
 8020bea:	f10c 0c01 	add.w	ip, ip, #1
 8020bee:	3404      	adds	r4, #4
 8020bf0:	e7d5      	b.n	8020b9e <__kernel_rem_pio2f+0x5e>
 8020bf2:	a908      	add	r1, sp, #32
 8020bf4:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 8020bf8:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8020bfc:	eddf 8a8f 	vldr	s17, [pc, #572]	; 8020e3c <__kernel_rem_pio2f+0x2fc>
 8020c00:	ed9f 9a8d 	vldr	s18, [pc, #564]	; 8020e38 <__kernel_rem_pio2f+0x2f8>
 8020c04:	9105      	str	r1, [sp, #20]
 8020c06:	9304      	str	r3, [sp, #16]
 8020c08:	4656      	mov	r6, sl
 8020c0a:	00b3      	lsls	r3, r6, #2
 8020c0c:	9306      	str	r3, [sp, #24]
 8020c0e:	ab58      	add	r3, sp, #352	; 0x160
 8020c10:	eb03 0086 	add.w	r0, r3, r6, lsl #2
 8020c14:	ac08      	add	r4, sp, #32
 8020c16:	ab44      	add	r3, sp, #272	; 0x110
 8020c18:	ed10 0a14 	vldr	s0, [r0, #-80]	; 0xffffffb0
 8020c1c:	46a4      	mov	ip, r4
 8020c1e:	eb03 0086 	add.w	r0, r3, r6, lsl #2
 8020c22:	4637      	mov	r7, r6
 8020c24:	2f00      	cmp	r7, #0
 8020c26:	f1a0 0004 	sub.w	r0, r0, #4
 8020c2a:	dc4a      	bgt.n	8020cc2 <__kernel_rem_pio2f+0x182>
 8020c2c:	4628      	mov	r0, r5
 8020c2e:	9207      	str	r2, [sp, #28]
 8020c30:	f000 f9f8 	bl	8021024 <scalbnf>
 8020c34:	eeb0 8a40 	vmov.f32	s16, s0
 8020c38:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
 8020c3c:	ee28 0a00 	vmul.f32	s0, s16, s0
 8020c40:	f000 fa56 	bl	80210f0 <floorf>
 8020c44:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
 8020c48:	eea0 8a67 	vfms.f32	s16, s0, s15
 8020c4c:	2d00      	cmp	r5, #0
 8020c4e:	9a07      	ldr	r2, [sp, #28]
 8020c50:	eefd 7ac8 	vcvt.s32.f32	s15, s16
 8020c54:	ee17 9a90 	vmov	r9, s15
 8020c58:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8020c5c:	ee38 8a67 	vsub.f32	s16, s16, s15
 8020c60:	dd41      	ble.n	8020ce6 <__kernel_rem_pio2f+0x1a6>
 8020c62:	f106 3cff 	add.w	ip, r6, #4294967295
 8020c66:	ab08      	add	r3, sp, #32
 8020c68:	f1c5 0e08 	rsb	lr, r5, #8
 8020c6c:	f853 702c 	ldr.w	r7, [r3, ip, lsl #2]
 8020c70:	fa47 f00e 	asr.w	r0, r7, lr
 8020c74:	4481      	add	r9, r0
 8020c76:	fa00 f00e 	lsl.w	r0, r0, lr
 8020c7a:	1a3f      	subs	r7, r7, r0
 8020c7c:	f1c5 0007 	rsb	r0, r5, #7
 8020c80:	f843 702c 	str.w	r7, [r3, ip, lsl #2]
 8020c84:	4107      	asrs	r7, r0
 8020c86:	2f00      	cmp	r7, #0
 8020c88:	dd3c      	ble.n	8020d04 <__kernel_rem_pio2f+0x1c4>
 8020c8a:	f04f 0e00 	mov.w	lr, #0
 8020c8e:	f109 0901 	add.w	r9, r9, #1
 8020c92:	4671      	mov	r1, lr
 8020c94:	4576      	cmp	r6, lr
 8020c96:	dc67      	bgt.n	8020d68 <__kernel_rem_pio2f+0x228>
 8020c98:	2d00      	cmp	r5, #0
 8020c9a:	dd03      	ble.n	8020ca4 <__kernel_rem_pio2f+0x164>
 8020c9c:	2d01      	cmp	r5, #1
 8020c9e:	d074      	beq.n	8020d8a <__kernel_rem_pio2f+0x24a>
 8020ca0:	2d02      	cmp	r5, #2
 8020ca2:	d07b      	beq.n	8020d9c <__kernel_rem_pio2f+0x25c>
 8020ca4:	2f02      	cmp	r7, #2
 8020ca6:	d12d      	bne.n	8020d04 <__kernel_rem_pio2f+0x1c4>
 8020ca8:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8020cac:	ee30 8a48 	vsub.f32	s16, s0, s16
 8020cb0:	b341      	cbz	r1, 8020d04 <__kernel_rem_pio2f+0x1c4>
 8020cb2:	4628      	mov	r0, r5
 8020cb4:	9207      	str	r2, [sp, #28]
 8020cb6:	f000 f9b5 	bl	8021024 <scalbnf>
 8020cba:	9a07      	ldr	r2, [sp, #28]
 8020cbc:	ee38 8a40 	vsub.f32	s16, s16, s0
 8020cc0:	e020      	b.n	8020d04 <__kernel_rem_pio2f+0x1c4>
 8020cc2:	ee60 7a28 	vmul.f32	s15, s0, s17
 8020cc6:	3f01      	subs	r7, #1
 8020cc8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8020ccc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8020cd0:	eea7 0ac9 	vfms.f32	s0, s15, s18
 8020cd4:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 8020cd8:	ecac 0a01 	vstmia	ip!, {s0}
 8020cdc:	ed90 0a00 	vldr	s0, [r0]
 8020ce0:	ee37 0a80 	vadd.f32	s0, s15, s0
 8020ce4:	e79e      	b.n	8020c24 <__kernel_rem_pio2f+0xe4>
 8020ce6:	d105      	bne.n	8020cf4 <__kernel_rem_pio2f+0x1b4>
 8020ce8:	1e70      	subs	r0, r6, #1
 8020cea:	ab08      	add	r3, sp, #32
 8020cec:	f853 7020 	ldr.w	r7, [r3, r0, lsl #2]
 8020cf0:	11ff      	asrs	r7, r7, #7
 8020cf2:	e7c8      	b.n	8020c86 <__kernel_rem_pio2f+0x146>
 8020cf4:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8020cf8:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8020cfc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020d00:	da30      	bge.n	8020d64 <__kernel_rem_pio2f+0x224>
 8020d02:	2700      	movs	r7, #0
 8020d04:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8020d08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020d0c:	f040 809a 	bne.w	8020e44 <__kernel_rem_pio2f+0x304>
 8020d10:	1e74      	subs	r4, r6, #1
 8020d12:	46a4      	mov	ip, r4
 8020d14:	2100      	movs	r1, #0
 8020d16:	45d4      	cmp	ip, sl
 8020d18:	da47      	bge.n	8020daa <__kernel_rem_pio2f+0x26a>
 8020d1a:	2900      	cmp	r1, #0
 8020d1c:	d063      	beq.n	8020de6 <__kernel_rem_pio2f+0x2a6>
 8020d1e:	ab08      	add	r3, sp, #32
 8020d20:	3d08      	subs	r5, #8
 8020d22:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8020d26:	2b00      	cmp	r3, #0
 8020d28:	d07f      	beq.n	8020e2a <__kernel_rem_pio2f+0x2ea>
 8020d2a:	4628      	mov	r0, r5
 8020d2c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8020d30:	f000 f978 	bl	8021024 <scalbnf>
 8020d34:	1c63      	adds	r3, r4, #1
 8020d36:	aa44      	add	r2, sp, #272	; 0x110
 8020d38:	ed9f 7a40 	vldr	s14, [pc, #256]	; 8020e3c <__kernel_rem_pio2f+0x2fc>
 8020d3c:	0099      	lsls	r1, r3, #2
 8020d3e:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8020d42:	4623      	mov	r3, r4
 8020d44:	2b00      	cmp	r3, #0
 8020d46:	f280 80ad 	bge.w	8020ea4 <__kernel_rem_pio2f+0x364>
 8020d4a:	4623      	mov	r3, r4
 8020d4c:	2b00      	cmp	r3, #0
 8020d4e:	f2c0 80cb 	blt.w	8020ee8 <__kernel_rem_pio2f+0x3a8>
 8020d52:	aa44      	add	r2, sp, #272	; 0x110
 8020d54:	eb02 0583 	add.w	r5, r2, r3, lsl #2
 8020d58:	4e36      	ldr	r6, [pc, #216]	; (8020e34 <__kernel_rem_pio2f+0x2f4>)
 8020d5a:	eddf 7a39 	vldr	s15, [pc, #228]	; 8020e40 <__kernel_rem_pio2f+0x300>
 8020d5e:	2000      	movs	r0, #0
 8020d60:	1ae2      	subs	r2, r4, r3
 8020d62:	e0b6      	b.n	8020ed2 <__kernel_rem_pio2f+0x392>
 8020d64:	2702      	movs	r7, #2
 8020d66:	e790      	b.n	8020c8a <__kernel_rem_pio2f+0x14a>
 8020d68:	6820      	ldr	r0, [r4, #0]
 8020d6a:	b949      	cbnz	r1, 8020d80 <__kernel_rem_pio2f+0x240>
 8020d6c:	b118      	cbz	r0, 8020d76 <__kernel_rem_pio2f+0x236>
 8020d6e:	f5c0 7080 	rsb	r0, r0, #256	; 0x100
 8020d72:	6020      	str	r0, [r4, #0]
 8020d74:	2001      	movs	r0, #1
 8020d76:	f10e 0e01 	add.w	lr, lr, #1
 8020d7a:	3404      	adds	r4, #4
 8020d7c:	4601      	mov	r1, r0
 8020d7e:	e789      	b.n	8020c94 <__kernel_rem_pio2f+0x154>
 8020d80:	f1c0 00ff 	rsb	r0, r0, #255	; 0xff
 8020d84:	6020      	str	r0, [r4, #0]
 8020d86:	4608      	mov	r0, r1
 8020d88:	e7f5      	b.n	8020d76 <__kernel_rem_pio2f+0x236>
 8020d8a:	1e74      	subs	r4, r6, #1
 8020d8c:	ab08      	add	r3, sp, #32
 8020d8e:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 8020d92:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 8020d96:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
 8020d9a:	e783      	b.n	8020ca4 <__kernel_rem_pio2f+0x164>
 8020d9c:	1e74      	subs	r4, r6, #1
 8020d9e:	ab08      	add	r3, sp, #32
 8020da0:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 8020da4:	f000 003f 	and.w	r0, r0, #63	; 0x3f
 8020da8:	e7f5      	b.n	8020d96 <__kernel_rem_pio2f+0x256>
 8020daa:	ab08      	add	r3, sp, #32
 8020dac:	f853 002c 	ldr.w	r0, [r3, ip, lsl #2]
 8020db0:	f10c 3cff 	add.w	ip, ip, #4294967295
 8020db4:	4301      	orrs	r1, r0
 8020db6:	e7ae      	b.n	8020d16 <__kernel_rem_pio2f+0x1d6>
 8020db8:	3001      	adds	r0, #1
 8020dba:	f854 7d04 	ldr.w	r7, [r4, #-4]!
 8020dbe:	2f00      	cmp	r7, #0
 8020dc0:	d0fa      	beq.n	8020db8 <__kernel_rem_pio2f+0x278>
 8020dc2:	9b06      	ldr	r3, [sp, #24]
 8020dc4:	f503 73b0 	add.w	r3, r3, #352	; 0x160
 8020dc8:	eb0d 0403 	add.w	r4, sp, r3
 8020dcc:	9b01      	ldr	r3, [sp, #4]
 8020dce:	18f7      	adds	r7, r6, r3
 8020dd0:	ab1c      	add	r3, sp, #112	; 0x70
 8020dd2:	f106 0c01 	add.w	ip, r6, #1
 8020dd6:	3c4c      	subs	r4, #76	; 0x4c
 8020dd8:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8020ddc:	4430      	add	r0, r6
 8020dde:	4560      	cmp	r0, ip
 8020de0:	da04      	bge.n	8020dec <__kernel_rem_pio2f+0x2ac>
 8020de2:	4606      	mov	r6, r0
 8020de4:	e711      	b.n	8020c0a <__kernel_rem_pio2f+0xca>
 8020de6:	9c05      	ldr	r4, [sp, #20]
 8020de8:	2001      	movs	r0, #1
 8020dea:	e7e6      	b.n	8020dba <__kernel_rem_pio2f+0x27a>
 8020dec:	9b04      	ldr	r3, [sp, #16]
 8020dee:	f8dd e008 	ldr.w	lr, [sp, #8]
 8020df2:	f853 302c 	ldr.w	r3, [r3, ip, lsl #2]
 8020df6:	9306      	str	r3, [sp, #24]
 8020df8:	ee07 3a90 	vmov	s15, r3
 8020dfc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8020e00:	2600      	movs	r6, #0
 8020e02:	ece7 7a01 	vstmia	r7!, {s15}
 8020e06:	eddf 7a0e 	vldr	s15, [pc, #56]	; 8020e40 <__kernel_rem_pio2f+0x300>
 8020e0a:	46b9      	mov	r9, r7
 8020e0c:	455e      	cmp	r6, fp
 8020e0e:	dd04      	ble.n	8020e1a <__kernel_rem_pio2f+0x2da>
 8020e10:	ece4 7a01 	vstmia	r4!, {s15}
 8020e14:	f10c 0c01 	add.w	ip, ip, #1
 8020e18:	e7e1      	b.n	8020dde <__kernel_rem_pio2f+0x29e>
 8020e1a:	ecfe 6a01 	vldmia	lr!, {s13}
 8020e1e:	ed39 7a01 	vldmdb	r9!, {s14}
 8020e22:	3601      	adds	r6, #1
 8020e24:	eee6 7a87 	vfma.f32	s15, s13, s14
 8020e28:	e7f0      	b.n	8020e0c <__kernel_rem_pio2f+0x2cc>
 8020e2a:	3c01      	subs	r4, #1
 8020e2c:	e777      	b.n	8020d1e <__kernel_rem_pio2f+0x1de>
 8020e2e:	bf00      	nop
 8020e30:	08023fc4 	.word	0x08023fc4
 8020e34:	08023f98 	.word	0x08023f98
 8020e38:	43800000 	.word	0x43800000
 8020e3c:	3b800000 	.word	0x3b800000
 8020e40:	00000000 	.word	0x00000000
 8020e44:	9b03      	ldr	r3, [sp, #12]
 8020e46:	eeb0 0a48 	vmov.f32	s0, s16
 8020e4a:	1a98      	subs	r0, r3, r2
 8020e4c:	f000 f8ea 	bl	8021024 <scalbnf>
 8020e50:	ed1f 7a07 	vldr	s14, [pc, #-28]	; 8020e38 <__kernel_rem_pio2f+0x2f8>
 8020e54:	eeb4 0ac7 	vcmpe.f32	s0, s14
 8020e58:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020e5c:	db19      	blt.n	8020e92 <__kernel_rem_pio2f+0x352>
 8020e5e:	ed5f 7a09 	vldr	s15, [pc, #-36]	; 8020e3c <__kernel_rem_pio2f+0x2fc>
 8020e62:	ee60 7a27 	vmul.f32	s15, s0, s15
 8020e66:	aa08      	add	r2, sp, #32
 8020e68:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8020e6c:	1c74      	adds	r4, r6, #1
 8020e6e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8020e72:	3508      	adds	r5, #8
 8020e74:	eea7 0ac7 	vfms.f32	s0, s15, s14
 8020e78:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8020e7c:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 8020e80:	ee10 3a10 	vmov	r3, s0
 8020e84:	f842 3026 	str.w	r3, [r2, r6, lsl #2]
 8020e88:	ee17 3a90 	vmov	r3, s15
 8020e8c:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
 8020e90:	e74b      	b.n	8020d2a <__kernel_rem_pio2f+0x1ea>
 8020e92:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 8020e96:	aa08      	add	r2, sp, #32
 8020e98:	ee10 3a10 	vmov	r3, s0
 8020e9c:	4634      	mov	r4, r6
 8020e9e:	f842 3026 	str.w	r3, [r2, r6, lsl #2]
 8020ea2:	e742      	b.n	8020d2a <__kernel_rem_pio2f+0x1ea>
 8020ea4:	a808      	add	r0, sp, #32
 8020ea6:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 8020eaa:	9001      	str	r0, [sp, #4]
 8020eac:	ee07 0a90 	vmov	s15, r0
 8020eb0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8020eb4:	3b01      	subs	r3, #1
 8020eb6:	ee67 7a80 	vmul.f32	s15, s15, s0
 8020eba:	ee20 0a07 	vmul.f32	s0, s0, s14
 8020ebe:	ed62 7a01 	vstmdb	r2!, {s15}
 8020ec2:	e73f      	b.n	8020d44 <__kernel_rem_pio2f+0x204>
 8020ec4:	ecf6 6a01 	vldmia	r6!, {s13}
 8020ec8:	ecb5 7a01 	vldmia	r5!, {s14}
 8020ecc:	eee6 7a87 	vfma.f32	s15, s13, s14
 8020ed0:	3001      	adds	r0, #1
 8020ed2:	4550      	cmp	r0, sl
 8020ed4:	dc01      	bgt.n	8020eda <__kernel_rem_pio2f+0x39a>
 8020ed6:	4290      	cmp	r0, r2
 8020ed8:	ddf4      	ble.n	8020ec4 <__kernel_rem_pio2f+0x384>
 8020eda:	a858      	add	r0, sp, #352	; 0x160
 8020edc:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8020ee0:	ed42 7a28 	vstr	s15, [r2, #-160]	; 0xffffff60
 8020ee4:	3b01      	subs	r3, #1
 8020ee6:	e731      	b.n	8020d4c <__kernel_rem_pio2f+0x20c>
 8020ee8:	9b66      	ldr	r3, [sp, #408]	; 0x198
 8020eea:	2b02      	cmp	r3, #2
 8020eec:	dc09      	bgt.n	8020f02 <__kernel_rem_pio2f+0x3c2>
 8020eee:	2b00      	cmp	r3, #0
 8020ef0:	dc2b      	bgt.n	8020f4a <__kernel_rem_pio2f+0x40a>
 8020ef2:	d044      	beq.n	8020f7e <__kernel_rem_pio2f+0x43e>
 8020ef4:	f009 0007 	and.w	r0, r9, #7
 8020ef8:	b059      	add	sp, #356	; 0x164
 8020efa:	ecbd 8b04 	vpop	{d8-d9}
 8020efe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020f02:	9b66      	ldr	r3, [sp, #408]	; 0x198
 8020f04:	2b03      	cmp	r3, #3
 8020f06:	d1f5      	bne.n	8020ef4 <__kernel_rem_pio2f+0x3b4>
 8020f08:	aa30      	add	r2, sp, #192	; 0xc0
 8020f0a:	1f0b      	subs	r3, r1, #4
 8020f0c:	4413      	add	r3, r2
 8020f0e:	461a      	mov	r2, r3
 8020f10:	4620      	mov	r0, r4
 8020f12:	2800      	cmp	r0, #0
 8020f14:	f1a2 0204 	sub.w	r2, r2, #4
 8020f18:	dc52      	bgt.n	8020fc0 <__kernel_rem_pio2f+0x480>
 8020f1a:	4622      	mov	r2, r4
 8020f1c:	2a01      	cmp	r2, #1
 8020f1e:	f1a3 0304 	sub.w	r3, r3, #4
 8020f22:	dc5d      	bgt.n	8020fe0 <__kernel_rem_pio2f+0x4a0>
 8020f24:	ab30      	add	r3, sp, #192	; 0xc0
 8020f26:	ed5f 7a3a 	vldr	s15, [pc, #-232]	; 8020e40 <__kernel_rem_pio2f+0x300>
 8020f2a:	440b      	add	r3, r1
 8020f2c:	2c01      	cmp	r4, #1
 8020f2e:	dc67      	bgt.n	8021000 <__kernel_rem_pio2f+0x4c0>
 8020f30:	eddd 6a30 	vldr	s13, [sp, #192]	; 0xc0
 8020f34:	ed9d 7a31 	vldr	s14, [sp, #196]	; 0xc4
 8020f38:	2f00      	cmp	r7, #0
 8020f3a:	d167      	bne.n	802100c <__kernel_rem_pio2f+0x4cc>
 8020f3c:	edc8 6a00 	vstr	s13, [r8]
 8020f40:	ed88 7a01 	vstr	s14, [r8, #4]
 8020f44:	edc8 7a02 	vstr	s15, [r8, #8]
 8020f48:	e7d4      	b.n	8020ef4 <__kernel_rem_pio2f+0x3b4>
 8020f4a:	ab30      	add	r3, sp, #192	; 0xc0
 8020f4c:	ed1f 7a44 	vldr	s14, [pc, #-272]	; 8020e40 <__kernel_rem_pio2f+0x300>
 8020f50:	440b      	add	r3, r1
 8020f52:	4622      	mov	r2, r4
 8020f54:	2a00      	cmp	r2, #0
 8020f56:	da24      	bge.n	8020fa2 <__kernel_rem_pio2f+0x462>
 8020f58:	b34f      	cbz	r7, 8020fae <__kernel_rem_pio2f+0x46e>
 8020f5a:	eef1 7a47 	vneg.f32	s15, s14
 8020f5e:	edc8 7a00 	vstr	s15, [r8]
 8020f62:	eddd 7a30 	vldr	s15, [sp, #192]	; 0xc0
 8020f66:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8020f6a:	aa31      	add	r2, sp, #196	; 0xc4
 8020f6c:	2301      	movs	r3, #1
 8020f6e:	429c      	cmp	r4, r3
 8020f70:	da20      	bge.n	8020fb4 <__kernel_rem_pio2f+0x474>
 8020f72:	b10f      	cbz	r7, 8020f78 <__kernel_rem_pio2f+0x438>
 8020f74:	eef1 7a67 	vneg.f32	s15, s15
 8020f78:	edc8 7a01 	vstr	s15, [r8, #4]
 8020f7c:	e7ba      	b.n	8020ef4 <__kernel_rem_pio2f+0x3b4>
 8020f7e:	ab30      	add	r3, sp, #192	; 0xc0
 8020f80:	ed5f 7a51 	vldr	s15, [pc, #-324]	; 8020e40 <__kernel_rem_pio2f+0x300>
 8020f84:	440b      	add	r3, r1
 8020f86:	2c00      	cmp	r4, #0
 8020f88:	da05      	bge.n	8020f96 <__kernel_rem_pio2f+0x456>
 8020f8a:	b10f      	cbz	r7, 8020f90 <__kernel_rem_pio2f+0x450>
 8020f8c:	eef1 7a67 	vneg.f32	s15, s15
 8020f90:	edc8 7a00 	vstr	s15, [r8]
 8020f94:	e7ae      	b.n	8020ef4 <__kernel_rem_pio2f+0x3b4>
 8020f96:	ed33 7a01 	vldmdb	r3!, {s14}
 8020f9a:	3c01      	subs	r4, #1
 8020f9c:	ee77 7a87 	vadd.f32	s15, s15, s14
 8020fa0:	e7f1      	b.n	8020f86 <__kernel_rem_pio2f+0x446>
 8020fa2:	ed73 7a01 	vldmdb	r3!, {s15}
 8020fa6:	3a01      	subs	r2, #1
 8020fa8:	ee37 7a27 	vadd.f32	s14, s14, s15
 8020fac:	e7d2      	b.n	8020f54 <__kernel_rem_pio2f+0x414>
 8020fae:	eef0 7a47 	vmov.f32	s15, s14
 8020fb2:	e7d4      	b.n	8020f5e <__kernel_rem_pio2f+0x41e>
 8020fb4:	ecb2 7a01 	vldmia	r2!, {s14}
 8020fb8:	3301      	adds	r3, #1
 8020fba:	ee77 7a87 	vadd.f32	s15, s15, s14
 8020fbe:	e7d6      	b.n	8020f6e <__kernel_rem_pio2f+0x42e>
 8020fc0:	edd2 7a00 	vldr	s15, [r2]
 8020fc4:	edd2 6a01 	vldr	s13, [r2, #4]
 8020fc8:	ee37 7aa6 	vadd.f32	s14, s15, s13
 8020fcc:	3801      	subs	r0, #1
 8020fce:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8020fd2:	ed82 7a00 	vstr	s14, [r2]
 8020fd6:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8020fda:	edc2 7a01 	vstr	s15, [r2, #4]
 8020fde:	e798      	b.n	8020f12 <__kernel_rem_pio2f+0x3d2>
 8020fe0:	edd3 7a00 	vldr	s15, [r3]
 8020fe4:	edd3 6a01 	vldr	s13, [r3, #4]
 8020fe8:	ee37 7aa6 	vadd.f32	s14, s15, s13
 8020fec:	3a01      	subs	r2, #1
 8020fee:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8020ff2:	ed83 7a00 	vstr	s14, [r3]
 8020ff6:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8020ffa:	edc3 7a01 	vstr	s15, [r3, #4]
 8020ffe:	e78d      	b.n	8020f1c <__kernel_rem_pio2f+0x3dc>
 8021000:	ed33 7a01 	vldmdb	r3!, {s14}
 8021004:	3c01      	subs	r4, #1
 8021006:	ee77 7a87 	vadd.f32	s15, s15, s14
 802100a:	e78f      	b.n	8020f2c <__kernel_rem_pio2f+0x3ec>
 802100c:	eef1 6a66 	vneg.f32	s13, s13
 8021010:	eeb1 7a47 	vneg.f32	s14, s14
 8021014:	edc8 6a00 	vstr	s13, [r8]
 8021018:	ed88 7a01 	vstr	s14, [r8, #4]
 802101c:	eef1 7a67 	vneg.f32	s15, s15
 8021020:	e790      	b.n	8020f44 <__kernel_rem_pio2f+0x404>
 8021022:	bf00      	nop

08021024 <scalbnf>:
 8021024:	ee10 3a10 	vmov	r3, s0
 8021028:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
 802102c:	d02b      	beq.n	8021086 <scalbnf+0x62>
 802102e:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8021032:	d302      	bcc.n	802103a <scalbnf+0x16>
 8021034:	ee30 0a00 	vadd.f32	s0, s0, s0
 8021038:	4770      	bx	lr
 802103a:	f013 4fff 	tst.w	r3, #2139095040	; 0x7f800000
 802103e:	d123      	bne.n	8021088 <scalbnf+0x64>
 8021040:	4b24      	ldr	r3, [pc, #144]	; (80210d4 <scalbnf+0xb0>)
 8021042:	eddf 7a25 	vldr	s15, [pc, #148]	; 80210d8 <scalbnf+0xb4>
 8021046:	4298      	cmp	r0, r3
 8021048:	ee20 0a27 	vmul.f32	s0, s0, s15
 802104c:	db17      	blt.n	802107e <scalbnf+0x5a>
 802104e:	ee10 3a10 	vmov	r3, s0
 8021052:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 8021056:	3a19      	subs	r2, #25
 8021058:	f24c 3150 	movw	r1, #50000	; 0xc350
 802105c:	4288      	cmp	r0, r1
 802105e:	dd15      	ble.n	802108c <scalbnf+0x68>
 8021060:	eddf 7a1e 	vldr	s15, [pc, #120]	; 80210dc <scalbnf+0xb8>
 8021064:	eddf 6a1e 	vldr	s13, [pc, #120]	; 80210e0 <scalbnf+0xbc>
 8021068:	ee10 3a10 	vmov	r3, s0
 802106c:	eeb0 7a67 	vmov.f32	s14, s15
 8021070:	2b00      	cmp	r3, #0
 8021072:	bfb8      	it	lt
 8021074:	eef0 7a66 	vmovlt.f32	s15, s13
 8021078:	ee27 0a87 	vmul.f32	s0, s15, s14
 802107c:	4770      	bx	lr
 802107e:	eddf 7a19 	vldr	s15, [pc, #100]	; 80210e4 <scalbnf+0xc0>
 8021082:	ee27 0a80 	vmul.f32	s0, s15, s0
 8021086:	4770      	bx	lr
 8021088:	0dd2      	lsrs	r2, r2, #23
 802108a:	e7e5      	b.n	8021058 <scalbnf+0x34>
 802108c:	4410      	add	r0, r2
 802108e:	28fe      	cmp	r0, #254	; 0xfe
 8021090:	dce6      	bgt.n	8021060 <scalbnf+0x3c>
 8021092:	2800      	cmp	r0, #0
 8021094:	dd06      	ble.n	80210a4 <scalbnf+0x80>
 8021096:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 802109a:	ea43 53c0 	orr.w	r3, r3, r0, lsl #23
 802109e:	ee00 3a10 	vmov	s0, r3
 80210a2:	4770      	bx	lr
 80210a4:	f110 0f16 	cmn.w	r0, #22
 80210a8:	da09      	bge.n	80210be <scalbnf+0x9a>
 80210aa:	eddf 7a0e 	vldr	s15, [pc, #56]	; 80210e4 <scalbnf+0xc0>
 80210ae:	eddf 6a0e 	vldr	s13, [pc, #56]	; 80210e8 <scalbnf+0xc4>
 80210b2:	ee10 3a10 	vmov	r3, s0
 80210b6:	eeb0 7a67 	vmov.f32	s14, s15
 80210ba:	2b00      	cmp	r3, #0
 80210bc:	e7d9      	b.n	8021072 <scalbnf+0x4e>
 80210be:	3019      	adds	r0, #25
 80210c0:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 80210c4:	ea43 53c0 	orr.w	r3, r3, r0, lsl #23
 80210c8:	ed9f 0a08 	vldr	s0, [pc, #32]	; 80210ec <scalbnf+0xc8>
 80210cc:	ee07 3a90 	vmov	s15, r3
 80210d0:	e7d7      	b.n	8021082 <scalbnf+0x5e>
 80210d2:	bf00      	nop
 80210d4:	ffff3cb0 	.word	0xffff3cb0
 80210d8:	4c000000 	.word	0x4c000000
 80210dc:	7149f2ca 	.word	0x7149f2ca
 80210e0:	f149f2ca 	.word	0xf149f2ca
 80210e4:	0da24260 	.word	0x0da24260
 80210e8:	8da24260 	.word	0x8da24260
 80210ec:	33000000 	.word	0x33000000

080210f0 <floorf>:
 80210f0:	ee10 3a10 	vmov	r3, s0
 80210f4:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 80210f8:	3a7f      	subs	r2, #127	; 0x7f
 80210fa:	2a16      	cmp	r2, #22
 80210fc:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 8021100:	dc2a      	bgt.n	8021158 <floorf+0x68>
 8021102:	2a00      	cmp	r2, #0
 8021104:	da11      	bge.n	802112a <floorf+0x3a>
 8021106:	eddf 7a18 	vldr	s15, [pc, #96]	; 8021168 <floorf+0x78>
 802110a:	ee30 0a27 	vadd.f32	s0, s0, s15
 802110e:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8021112:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021116:	dd05      	ble.n	8021124 <floorf+0x34>
 8021118:	2b00      	cmp	r3, #0
 802111a:	da23      	bge.n	8021164 <floorf+0x74>
 802111c:	4a13      	ldr	r2, [pc, #76]	; (802116c <floorf+0x7c>)
 802111e:	2900      	cmp	r1, #0
 8021120:	bf18      	it	ne
 8021122:	4613      	movne	r3, r2
 8021124:	ee00 3a10 	vmov	s0, r3
 8021128:	4770      	bx	lr
 802112a:	4911      	ldr	r1, [pc, #68]	; (8021170 <floorf+0x80>)
 802112c:	4111      	asrs	r1, r2
 802112e:	420b      	tst	r3, r1
 8021130:	d0fa      	beq.n	8021128 <floorf+0x38>
 8021132:	eddf 7a0d 	vldr	s15, [pc, #52]	; 8021168 <floorf+0x78>
 8021136:	ee30 0a27 	vadd.f32	s0, s0, s15
 802113a:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 802113e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021142:	ddef      	ble.n	8021124 <floorf+0x34>
 8021144:	2b00      	cmp	r3, #0
 8021146:	bfbe      	ittt	lt
 8021148:	f44f 0000 	movlt.w	r0, #8388608	; 0x800000
 802114c:	fa40 f202 	asrlt.w	r2, r0, r2
 8021150:	189b      	addlt	r3, r3, r2
 8021152:	ea23 0301 	bic.w	r3, r3, r1
 8021156:	e7e5      	b.n	8021124 <floorf+0x34>
 8021158:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 802115c:	d3e4      	bcc.n	8021128 <floorf+0x38>
 802115e:	ee30 0a00 	vadd.f32	s0, s0, s0
 8021162:	4770      	bx	lr
 8021164:	2300      	movs	r3, #0
 8021166:	e7dd      	b.n	8021124 <floorf+0x34>
 8021168:	7149f2ca 	.word	0x7149f2ca
 802116c:	bf800000 	.word	0xbf800000
 8021170:	007fffff 	.word	0x007fffff

08021174 <_init>:
 8021174:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8021176:	bf00      	nop
 8021178:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802117a:	bc08      	pop	{r3}
 802117c:	469e      	mov	lr, r3
 802117e:	4770      	bx	lr

08021180 <_fini>:
 8021180:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8021182:	bf00      	nop
 8021184:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8021186:	bc08      	pop	{r3}
 8021188:	469e      	mov	lr, r3
 802118a:	4770      	bx	lr
